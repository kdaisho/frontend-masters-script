[
  {
    "name": "complete-intro-to-computer-science",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to the complete intro to computer science data structure and algorithms. So the first thing you'll see here on my screen is I had this nice little course website. This is all of my notes, so literally, you can see here I have two computers, one of them I just have this website off and I'm just kind of going through point by point."
          },
          {
            "time": "[00:00:19]",
            "text": "So this is something that you can keep after you're done with the course and refer back to you can share it with your friends. One of the really nice things in front of masters allows me to do is to open source all the course material. So if there's spelling mistakes, please go in and fix them, these courses get better as people help, and it's all open source on Git Hub."
          },
          {
            "time": "[00:00:40]",
            "text": "Okay, so let's kind of just orient you a little bit with this site. Here you can see we have various different sections here. Most of these are pretty self-contained so if you go do trees and you want to do that, you don't necessarily have to take binary search first, which is a nice feature that the only thing I'll say is that the trees and applying tree algorithms, as you might guess, are kind of based on each other, everything else is pretty self-contained."
          },
          {
            "time": "[00:01:07]",
            "text": "You can see here that these are links so if I click into one of these Here in the top right, you'll see that the name of the section and the name of the lesson that we're on. So if I'm in the middle of the lesson, you can kind of see which part of the website I'm on, so you can hop back into wherever I am cool."
          },
          {
            "time": "[00:01:24]",
            "text": "Cool, so let's talk a little bit about why you might wanna take this course. You might want to take this course because you're interested in computer science and you wanna be a better programmer, that's kind of where I started learning about these sorts of things. These things are also very useful for interviews because big tech companies love to ask these kind of questions, for reasons unknown to me, because most of them don't necessarily apply on your day to day but they think it's a measure of intelligence which I would very vehement say that it's not a measure of intelligence."
          },
          {
            "time": "[00:01:56]",
            "text": "But in any case, it is the way it is, so I'm gonna help you cheat at those interviews by knowing all of the things, is that cheating by just knowing the thing? I guess, no, kind of, anyway, don't care, I want you to pass all of your interviews and get paid lots of somebody that's my goal here."
          },
          {
            "time": "[00:02:16]",
            "text": "Okay, here you'll see I have these like blue boxes on here, these are just like points of emphasis, so whenever you see a blue box, be sure to pay attention to those on the site. The first one here is just kind of giving you permission to feel like this is hard."
          },
          {
            "time": "[00:02:28]",
            "text": "[LAUGH] We're about to go learn a lot of kind of like, concepts require a lot of brainpower to just process through, which is exhausting. So expecting you to do all of these, right in a row is very, very difficult. And I'm gonna say for those of you that are watching this later and recorded, just give yourself space to do it, right?"
          },
          {
            "time": "[00:02:50]",
            "text": "Take this over a couple of days, walk away from the computer, think about it Come back, there's a reason why the colleges spread this out over like two years, it's because it's kind of hard to do this all at once. So just be aware you have this just like tidal wave of knowledge coming your way, and if it feels like you're drowning you might be a little bit and that's okay."
          },
          {
            "time": "[00:03:11]",
            "text": "Right, like that's kind of how this is supposed to work. But at the same time, it's just really good to be exposed to these things and kind of let them sink in overtime. Like maybe take this class a couple of times and you'll get a little bit more each time."
          },
          {
            "time": "[00:03:24]",
            "text": "But in any case, the number one thing here I'm saying is do not get down on yourself, right? That's really easy to do when these things seem really hard and it feels like everyone else is getting it and Brian is breezing through this, why is this so hard for me?"
          },
          {
            "time": "[00:03:38]",
            "text": "Don't go to that place, there's nothing useful there for you. Just be okay, having a hard time, that's really what I wanna get here is like it's okay to feel like this is hard. But by the way, I have to like look these up every single time that I use them."
          },
          {
            "time": "[00:03:55]",
            "text": "I don't just have this like tucked away in the back of my head, I prepared for this course and spent a bunch of time doing this, so I don't even have this all in my head all the ones. All right, that's enough of that. So who's this course for?"
          },
          {
            "time": "[00:04:09]",
            "text": "Hopefully, this course is for you that's who I wrote it for. [LAUGH] There is a base level expectation that you know JavaScript. In that I'm not going to be teaching your JavaScript today, hopefully, you are okay with JavaScript. If you don't know JavaScript, front of masters has a lot of great and even free resources."
          },
          {
            "time": "[00:04:29]",
            "text": "I link to down here to the boot camp, which I taught with along with Jen Kramer and that's totally free for everybody, definitely share that with your friends as well, and that'll get you up to speed where you could probably take this class. I'm not gonna be doing any sort of advanced JavaScript stuff, I even took most of the functional programming stuff out of this class, so it's actually fairly straightforward."
          },
          {
            "time": "[00:04:49]",
            "text": "Or I hope it's straightforward, that's what I designed it to be that you can be the judge of that. Okay, who's this lovely bastard on the screen? That's me. [LAUGH] My name is Brian, I work at Microsoft, I live in Seattle at the moment, I've lived there for, I don't know, four or five years now."
          },
          {
            "time": "[00:05:11]",
            "text": "I did attend college, I did go to a university where I learned computer science, I actually ended up dropping out of college. But I had taken three years of computer science so I did take these classes in college. But I really was always kind of annoyed that I felt that people felt like that this knowledge of computer science is locked up in these $50,000 degrees a semester."
          },
          {
            "time": "[00:05:34]",
            "text": "Those kind of things and that this was inaccessible to them because in reality, most of these concepts, as you'll see, I can teach you in a couple of hours, and you'll just know them and you'll have them for the rest of your life and you didn't need a four-year degree to get it."
          },
          {
            "time": "[00:05:46]",
            "text": "The other thing I wanna make sure, I'm not disparaging computer science degrees either, they are useful and for people that have them, high five, I wish I had one. [LAUGH] So that's also useful as well but I wanna make sure that we're not safekeeping either way, we're not making people that have CSVS to that, but we also wanna bring people that don't have CS degrees with us, right, and share all this knowledge."
          },
          {
            "time": "[00:06:11]",
            "text": "So, that's why I wrote this course because I really wanted to make sure that you didn't feel like that knowledge was locked behind some dollar figure. So, yeah, as I started working at larger and larger companies, thee funny thing is I used to think that these concepts were totally worthless, right?"
          },
          {
            "time": "[00:06:27]",
            "text": "I learned all these things in a vacuum and I thought like why would my ever gonna need to know how to do 17 different ways of sorting numbers. It turns out after working at Netflix and Reddit and LinkedIn and Microsoft and all these big companies, these actually do get used, and they are useful to know."
          },
          {
            "time": "[00:06:47]",
            "text": "But more than anything, it's actually like the mindset of trading-off, what am I gonna do this thing and I'm going to sacrifice this other thing. That sort of mindset is really what computer science is to me, it's just a science of making trade-offs. I'm gonna use in the word trade-off today, I don't know if you've ever watched me in front and happy hour, if we had a key word today, and it was trade-off we'd all be drunk by the end of the class."
          },
          {
            "time": "[00:07:11]",
            "text": "If not, you can go listen front and happy hour that joke will make more sense of do. All right, yeah, I wanna help you learn methodologies of structured thinking that's kind of like my goal here today. What else? When I'm not teaching here for a Masters when I'm not working, I like to exercise, I hopped on my peloton too much, I really like the scotches, I like very happy beer."
          },
          {
            "time": "[00:07:42]",
            "text": "I have an amazing wife Nikki, I like getting my ass kicked Dota and Overwatch, as most of the Frontend Masters team can attest to. And of traveling as well, I haven't done that in a little while but that's also something I have loved to do. I have an adorable dog I put a picture of Luna in literally every course that I teach, so there she is."
          },
          {
            "time": "[00:08:08]",
            "text": "Here's I just dropped some links to my favorite charities in here. These are the ones that I support, there's certainly awesome. So if you're interested in finding some cool charity support, there's a couple on there as well. As always special things to Frontend Masters, really appreciate them giving me the opportunity to get up here to share this knowledge with you."
          },
          {
            "time": "[00:08:28]",
            "text": "Yeah, it's, they're awesome people to work with, thanks for the Masters. As always, I put my socials on here, you can find me on Twitter, LinkedIn, GitHub, and peloton. I do have open DMS on both of them, I am terrible at answering them, so just be aware, feel free to send them I might not respond cuz I get a lot of them."
          }
        ]
      },
      {
        "name": "1-code-setup",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This course we're gonna be doing inside of code sandbox. So, I put a box in here you can click and say edit on code sandbox. Let's just get you oriented a little bit. It might say that to you, it's fine to say some of the main branch."
          },
          {
            "time": "[00:00:24]",
            "text": "As you may notice this looks a lot like Visual Studio code. It's cuz it is very similar to Visual Studio code cuz it's embedding VS code in the browser. What you'll see here is you'll see, we have this project that is a GitHub repo. You can see here it's bt holds slash out of the algorithms exercises."
          },
          {
            "time": "[00:00:44]",
            "text": "So, if you find any mistakes, feel free to open a PR there. And we have these source documents. This is gonna be helpful for us when we're doing sorts and trees, they're kind of like little visuals. Visualizer helpers but for the most part, you can ignore the source directory."
          },
          {
            "time": "[00:01:00]",
            "text": "The stuff that you're most curious about here are gonna be here in the specs. These are gonna be unit tests that you and I are going to make passed together. So, if we look at the first one here, which is going to be bubble sort right there, you can see a bubble sort dot test dot j s."
          },
          {
            "time": "[00:01:18]",
            "text": "If I click on that one, I have a little exercise here. It's got a little unit test here that we're gonna make pass and then the code goes here inside of bubblesort. So, that's what you and I are gonna be doing all day today is just writing code that hopefully makes these unit tests pass."
          },
          {
            "time": "[00:01:41]",
            "text": "Now there's also here, the bubblesort solution. So, if I clicked on this, it would show me the actual solution to whatever I was looking for. This isn't a test, no one's grading you on this, if it's helpful for you, feel free to go ahead and peek over in the solution anytime that you need to like I'm not up here judging you for looking at the solution."
          },
          {
            "time": "[00:02:03]",
            "text": "Our number one shared goal together as you are just to learn what about these algorithms right? Please Google everything, please look at the solutions, please ask your friends. Ask your rubber ducky or dog or something like that. I don't care, whatever it takes for you to learn. That is the thing that you should be doing and if you're not doing the thing that's gonna help you learn, then you're doing the wrong thing."
          },
          {
            "time": "[00:02:27]",
            "text": "And again, the wrong thing to do is just to sit there and stress. If you're doing that, let's reevaluate or re approach the problem do something different. Now, the one thing I'm gonna say, is there's a lot of value in struggle. And when I say that I mean sitting there and just trying to reason through it, just using all of your brainpower to kind of power through reasoning through that."
          },
          {
            "time": "[00:02:48]",
            "text": "And it's hard and it's exhausting and this may not be what you want to do. But that moment of struggle is really where I think you can learn a lot. So, I'm just going to invite you to embrace the struggle a little bit. But don't embrace it so much that you get stressed out or too stressed out."
          },
          {
            "time": "[00:03:05]",
            "text": "It's a little stressful and we kind of have to deal with that. But you know yourself better than anyone else just listen to yourself and follow your dreams. This is really what I wanna say. Anyway, let's, go ahead and get started. It is possible to run this locally as well."
          },
          {
            "time": "[00:03:27]",
            "text": "So, this is actually all just running with jest. Yeah, sorry one more thing. Let's go back here. Back here in code sandbox before I forget. She just leaves us open all right, so here in code sandbox, you can see I have this browser. And then I have tests here."
          },
          {
            "time": "[00:03:55]",
            "text": "So if I click on tests, again here on the right side, this is actually running just for me and I can see all of my specs that are running. When I say a spec, I just mean a test file. I don't know why I'm stuck in that term spec."
          },
          {
            "time": "[00:04:09]",
            "text": "But like, I used to write ruby tests, which is our spec, and that term just stuck in my brain and I'm sorry, it's just not coming out I tried. Tried to shake the Ruby out of me and it just didn't come out. So, that's what that's why they're called specs."
          },
          {
            "time": "[00:04:25]",
            "text": "I think it's a Ruby term, or maybe it came from before that's why I know it, anyway, tests. So, this will show you all the tests here. This is where you can actually see where the tests are passing and where they're failing and why they're failing and things like that."
          },
          {
            "time": "[00:04:40]",
            "text": "You can see here there's 53 tests currently passing and there's 97 tests total that we're gonna try and make pass. Don't worry, you don't have to write 97 things some things have multiple tests on them. And then the last thing here is down here in console. This is actually like the console."
          },
          {
            "time": "[00:04:58]",
            "text": "So, if you want to do a console log here, it will show up here in the dev tools. Yeah, so it'll show up here in the dev tools as well. You can see here, this is actually logging out from the code here, but this gets pretty noisy because code sandbox puts a lot of stuff in here."
          },
          {
            "time": "[00:05:19]",
            "text": "So, I would say just use this one down here where it says console down here. If you're looking at this and say like, where all these numbers coming from, there's actually a, maze path finding lesson that we're gonna do. And it actually has like a little helper logger tool and that's where that's coming from."
          },
          {
            "time": "[00:05:41]",
            "text": "And we'll comment that out in just a second. So, that we can ignore it a little bit. Okay.that's good to know. You can actually clone this repo and run all the code locally and you can run it the Jest, that's all what these tests are run by is Jest digest."
          },
          {
            "time": "[00:05:55]",
            "text": "So, feel free to go say git clone, this repo and you can do NPM run test and it'll run everything. Last thing here on all of the tests. So, you can see here it says test dot skip. That means it's not gonna try and run this unit test."
          },
          {
            "time": "[00:06:14]",
            "text": "I do this so that just like it's not, you can see as soon as I do this, it's gonna say hey bubblesort is failing. Let's get rid of that for a second. That's because this test now it's trying to run a test on bubblesort it's not working. So, I would just say take this test by test and do it that way."
          },
          {
            "time": "[00:06:39]",
            "text": "One more thing here. I would go ahead and just fork this repo to your own repo. That's gonna help you as well because then you can save your work. And if you don't have a code sandbox account, probably makes sense to sign up for that as well."
          }
        ]
      },
      {
        "name": "2-big-o-time-complexity",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So for this first part, this is just going to be lecture, so you can kind of chill out for a second before we get into the big stuff. But I wanna introduce you to some tools that we're gonna use to look at algorithms. And again, if you're gonna be doing interviews anytime soon, this is gonna be something that you should really kind of get in depth on, probably more in depth than even that I'm gonna get on it."
          },
          {
            "time": "[00:00:23]",
            "text": "But knowing how to talk about Big O is, I don't know I put that in air quotes, it's actually called Big O, anyway, let's talk about Big O is very important. So Big O is a way of talking about how efficient an algorithm is. And when I say algorithm, I'm actually meaning more in the mathematical sense."
          },
          {
            "time": "[00:00:47]",
            "text": "We like to talk about algorithms in the sense of computer science, but algorithm is, I think, originally a mathematics term that we kind of just applied to computer science. You'll find that mathematics and computer science end up having a lot of crossover. That's also not to say that you need to be very good at math to be able to do this."
          },
          {
            "time": "[00:01:05]",
            "text": "So if you don't have a math background, do not worry, this stuff can still make a lot of sense to you. A lot of people will say, I don't do computer science because I don't know math that well. Nothing I'm gonna do here today is going to be any worse than algebra."
          },
          {
            "time": "[00:01:22]",
            "text": "Is that true? Yeah, we're not doing any calculus or anything like that, no algebra too, this is just college are not college algebra, but high school algebra level. So anyway, going back to Big O, Big O was this concept of taking a algorithm kind of zooming out and saying, just on a very broad stroke how efficient is this."
          },
          {
            "time": "[00:01:44]",
            "text": "And that's useful because then we can kind of compare algorithms and broad strokes, and not get to mired in the details. So I like to describe the O part cuz it's a big open O, that is a vacuum that sucks out all the unimportant details and you're kind of left with the heavy, very important details."
          },
          {
            "time": "[00:02:07]",
            "text": "So, allow me to get mathematical for just one second, 3x squared + x + 1. Just zoom in a second. So we have 3x squared + x + 1, that's a formula that maybe that describes how much time it takes for an algorithm to run. Where x is how long the array is, right?"
          },
          {
            "time": "[00:02:33]",
            "text": "So if I have an array of one, it's gonna be 3 times 1 squared, which is 1, + 1 plus, so it'd be 5, right? Now, if we try and plug in something like 5, the first term would be 75, and when I say term, I just mean the first thing between the plus signs, right?"
          },
          {
            "time": "[00:02:57]",
            "text": "That's the mathematics, which just means like 3x squared is one term, x is one term, and 1 is one term. So if we plug in 5 to the first term, we'd get 75, we get 5, and we get 1. So you can see this first term, it carries most of the weight of the algorithm, right?"
          },
          {
            "time": "[00:03:14]",
            "text": "So if I plug in, again, if I do 5 million, this ends up being the first term was that 75 trillion, the second term is 5 million, and the last one is one, right? So 75 trillion is so much bigger than 5 million and one, for the sake of Big O analysis, we can just ignore the plus x+1 because they don't really affect the final product so much."
          },
          {
            "time": "[00:03:40]",
            "text": "I'm not worried about the difference between 300 and 303, I'm worried about the difference between 300 and 300 million. Does that make sense? I'm trying to just focus on the very broad strokes of this. So that's what Big O does, instead of saying that we have this complexity of 3x squared +x+1, we're just gonna say that we have the complexity of x squared."
          },
          {
            "time": "[00:04:05]",
            "text": "Or they like to use n instead of x squared, so we're gonna say n squared. So the complexity, the Big O of this 3x squared+x+1, is gonna be n squared. So basically, the life hack here is this, you just look for the biggest term, right? So 3x squared would be the biggest term here."
          },
          {
            "time": "[00:04:26]",
            "text": "And we even ignore the coefficient, the number next to it, so we just look at x squared, right? So the Big O of 3x squared +x+1 is just n squared, because that's gonna carry most of the weight of this particular algorithm. Now, why do we care? Why am I talking about math in this Frontend Masters Course?"
          },
          {
            "time": "[00:04:48]",
            "text": "You didn't sign up for a math class, and you certainly don't wanna take it from me. Well, we're gonna use the same methodology, we just applied it to math, but we're gonna now apply it to a computer science problem. So in particular, what we're gonna be concerned about the x that we're worried here about is this input."
          },
          {
            "time": "[00:05:13]",
            "text": "This input is gonna be an array, right? And we're worried about what the difference is if I have one item in the array or if I have 100 items in the array or if I have a million items in the array. So this function here, crossAdd, all it does is it takes the beginning and the end and adds it together."
          },
          {
            "time": "[00:05:33]",
            "text": "Then the second item and the second last item adds them together, the third, the last, and the third item and adds them together, right? So it kind of crosses each other to kind of make this crossAdd array. So here, I have this for loop that goes over the array and it just adds all the numbers together."
          },
          {
            "time": "[00:05:58]",
            "text": "So the question you wanna be asking yourself is, how many instructions am I gonna give the CPU based on how long this array is? Well, the thing that you really wanna be looking at here is this for loop, right? Cuz this var answer equals array and this return answer here, those execute once no matter how long input is, right?"
          },
          {
            "time": "[00:06:22]",
            "text": "This would be like the plus two part of our equation up here, right? The +1, which is to say we can ignore it. But this here, this four loop, this is gonna happen more and more and more, depending on how long input is, right? So if this is 1, input is of length 1, right?"
          },
          {
            "time": "[00:06:42]",
            "text": "We give it the array of 0 inside of square brackets, that's only gonna take one four loop, right? It's only gonna go through this one iteration. But if this is of length 1 million, this four loop, this body here is gonna happen 1 million times, right? So you can see here this is getting stretched out, depending on how it's gonna be happen more and more."
          },
          {
            "time": "[00:07:05]",
            "text": "So it's gonna take longer and more computational power to execute, depending on how long input is. So this is gonna be our most significant term in this function, right? So how many times is this for loop gonna happen? Well, it's gonna happen however long input is, right? That's how long this for loop is gonna go for, it goes for through input.length."
          },
          {
            "time": "[00:07:30]",
            "text": "So this is gonna be of n, right? Or x, but we're gonna stick with n from now on. So the complexity of this is gonna be o of n, right? Does that make sense? Where n is just the length of the array. Here's the life hack here, here's where I'm burying the lead a little bit."
          },
          {
            "time": "[00:07:51]",
            "text": "Just look for for loops, not just loops in general, right? So val loops would count as well. Just look for loops, right? So if you have a loop, that's gonna be n, if you don't have any loops, it's gonna be what we call constant, right? So that's gonna be Big O of 1, which means no matter how long the input is, it's not gonna take that much longer."
          },
          {
            "time": "[00:08:13]",
            "text": "Now, you might ask, what if I'm doing a lot of things inside of this for loop? Does that affect it? Well, that would be like the three here and the x squared. It's a coefficient, Big O just ignores all of that stuff, right? We're just looking really for the loops."
          },
          {
            "time": "[00:08:31]",
            "text": "Okay? How about this one here? You can cheat by looking down the page, but maybe just bear with me for a second and don't cheat. [LAUGH] Just find one here. So I have a needle, which will be like I'm looking for 5, and I have an array of 15 and I'm looking for wherever 5 is, right?"
          },
          {
            "time": "[00:08:52]",
            "text": "It's like a typical linear search in an array. So, I'm gonna loop through this and I'm going to look for the needle, and if I find that in the haystack, then I'm gonna return true. What's the Big O of this? Well, it might not go through the entire loop, right?"
          },
          {
            "time": "[00:09:10]",
            "text": "It actually might find it on the first thing. So if 5 is the first item in the array, and I'm looking at an array of 1 billion, it doesn't matter, it just takes 1 second, or one second, it definitely doesn't take, it takes a millisecond. What's that? Well, that's gonna be still Big O of n, because this short circuiting here, right?"
          },
          {
            "time": "[00:09:30]",
            "text": "Where we could just return true, that's still just a coefficient, right? So we're still gonna say n, keep in mind that it actually could be the last thing in the array, which means that we would look at literally either every item in the array to find it, right?"
          },
          {
            "time": "[00:09:45]",
            "text": "So if it was of length 1 billion, we will look at a billion things. So we're still gonna call this Big O of n. And what I'm trying to demonstrate to you here is there's a difference between best case scenario, worst case scenario, and average case scenario, right?"
          },
          {
            "time": "[00:10:00]",
            "text": "Best case scenario, first item in the array just finds the returns and you're done, that's called the best case scenario. The worst case scenario is, it is the last item in the array, and we'll take the entire array looking for it. So what's the average case scenario in this array?"
          },
          {
            "time": "[00:10:19]",
            "text": "Somewhere in the middle, like it'd be, like a half n, right? But again, Big O doesn't care, so we're still gonna say this is Big O of n, despite the fact that it could exit sooner. Does that make sense? Okay, I promise I'm gonna let you write code here in a second, you're not gonna be stuck listening to me lecture this entire time."
          },
          {
            "time": "[00:10:41]",
            "text": "All right, so let's talk about this one here, I love asking people, how do you say this word? Is it tuples? Is it tuples? There is a correct answer and I don't like it. [LAUGH] I've always said tuples my entire life and I will probably continue to say tuples because it's just buried in my brain."
          },
          {
            "time": "[00:11:00]",
            "text": "I don't know how to fix that. I believe the correct way to say that is tuples. It's not really a JavaScript concept, it's more of a Python concept in general, but the idea is, it's a pair, right? You have an array of length 2, right? And you have one first item and one second item, and that's a pair of values, and we call those tuples, tuples, whatever."
          },
          {
            "time": "[00:11:26]",
            "text": "So what if I wanted to take an array and I wanted to make a tuple out of every single possibility in the array, right? So if I had an item that was or had an array here, an input of length three, then I would end up, I think, with nine items in the array, right?"
          },
          {
            "time": "[00:11:41]",
            "text": "Because I'd make every pair possible, right? Again, not something that you would typically do, but what is the Big O of this? And so, how did we get to this n squared kinda solution here? Well, we have this outer loop that's gonna run over every item in the array, and then for every item in the array, we're going to run through every item in the array again, right?"
          },
          {
            "time": "[00:12:09]",
            "text": "So if I have something of length 3, then it's gonna run 9 times, Ii I have length 4, it's gonna run 16 times, right? And you can see here, that number just keeps going up and up and up. If I have something of length 10, it's gonna run 100 times, right?"
          },
          {
            "time": "[00:12:23]",
            "text": "And it gets kind of out of control really quickly. So if input here was like, 500, right? This is gonna take a really long time. Which is bad, we don't wanna do that, right? So that's n squared. So how did we get n squared? Well, we have an outer loop and then we have an inner loop."
          },
          {
            "time": "[00:12:43]",
            "text": "And when you see nested loops, then you can kind of assume n squared, right? And if you saw another one inside of here, another for loop inside of that, that would be n cubed, right? Or n to the third. There's not really any n cubed algorithms, and please don't write any [LAUGH]."
          },
          {
            "time": "[00:13:05]",
            "text": "That's kind of like a bridge too far. There are n squared, there's reasons to write n squared, but it's a, you wanna be pretty careful with that, cuz those n squared ones get out of control pretty quickly. But that being said, you and I are gonna write some n squared algorithms today."
          },
          {
            "time": "[00:13:22]",
            "text": ">> It's best practice to avoid the n squared just to go for constant time complexity? And I guess, how are we gonna make that trade off? If this is further down the line then answer it then answer it then."
          },
          {
            "time": "[00:13:22]",
            "text": ">> It's a good question and we're basically gonna be answering that question for the rest of the damn class [LAUGH]."
          },
          {
            "time": "[00:13:44]",
            "text": "But it's a super valid question and I'm glad you asked it. There's no right answer to it, right? The reason why there's no just one sorting algorithm in one data structure, that'd be a much shorter and better class is these algorithms are so fit for different problems that you're gonna have to choose."
          },
          {
            "time": "[00:14:08]",
            "text": "They're definitely gonna be time to n squared algorithm is gonna be way better than a log(n) algorithm or n log(n). But anyway, things that are judged to be better algorithms are not always better algorithms, right? And I'm gonna show you that kinda, again, throughout the rest of the course."
          },
          {
            "time": "[00:14:25]",
            "text": "Frequently, you're not gonna have a choice as well, right? Sometimes you just kinda have to do something in a really inefficient way because you wanna do inefficient things. And that's really what I want you to learn today is how to make that trade off in your head. And we'll yeah, we'll be making lots of examples, but I want you to continue to ask yourself that question throughout the rest of the course."
          },
          {
            "time": "[00:14:47]",
            "text": "Cool, good question. All right, so let's talk about this one here, function get middle of array. What do you think the time complexity of that one's gonna be?"
          },
          {
            "time": "[00:14:47]",
            "text": ">> O(1)."
          },
          {
            "time": "[00:14:47]",
            "text": ">> There you go. So this is gonna be O(1), you can see it's written like that here. So array, this can be a very large array."
          },
          {
            "time": "[00:15:17]",
            "text": "It could be of length a million, it can be of length a billion, but there's no loop here in the middle, we're just gonna go find the middle item in the array and then return that. So that's said to be O(1), or the way that you say that out loud is its constant time, right?"
          },
          {
            "time": "[00:15:32]",
            "text": "And I guess I should tell you how to say the rest of these, so O(n) squared, you would say this is quadratic time. You can also just say, O(n) squared, but people will call that quadratic time. And then here Big O of n, again, feel free to just say Big O of n, that's accurate and people say that, but you can also call this linear time."
          },
          {
            "time": "[00:15:57]",
            "text": "I don't hardly ever say the word quadratic time out loud, I don't know why, but I will say linear time, and then I always say constant time. Basically, the question you need to ask yourself to find out something's constant time or not is, does this take more time if the array is longer?"
          },
          {
            "time": "[00:16:17]",
            "text": "And in this case, no, it doesn't, so we're just gonna say this is constant time. Okay, so let's zoom out here just a second. I kinda tried to give you a little bit of a graph of how this looks in terms of how many items in the array."
          },
          {
            "time": "[00:16:36]",
            "text": "And I swear, I think there's only one more graph left in this course, there's not a lot more graphs. So if you have some PTSD from school from graphs, like I do, I swear there's not too many of them. But you can see here, this red line here, this is gonna be what it represents."
          },
          {
            "time": "[00:16:57]",
            "text": "If I have eight items in the array, is still gonna only take me, let's just say that it's one millisecond to run this particular item, right? So no matter how many items in the array, it's a constant amount of time it'll take to run the algorithm. This blue line, we could say this is linear time, this is why it's called linear, right?"
          },
          {
            "time": "[00:17:14]",
            "text": "Cuz it's literally just a straight line that goes up. If I have six items in the array, it takes a constant amount of time. So we're adding just a constant amount over time depending on how many items are in the array. And this green one here, that's going up and you can see it's going up faster and faster, that would be quadratic time or Big O of n squared."
          },
          {
            "time": "[00:17:38]",
            "text": "Because the more items we add to the array, it's gonna just take off and go, we add an exponential amount of time. Does that kinda make sense? As you might imagine, if I put Big O of n cubed, that's just gonna be basically a straight line up, right?"
          },
          {
            "time": "[00:18:12]",
            "text": "All right, so there's one I haven't talked about yet. We're gonna talk about it when we get to recursion, and merge sort, and quick sort, it's this purple line here, which is logarithmic time. And you can see here, it does go up if we add more and more items into the array, but it goes up at a very slow pace, right?"
          },
          {
            "time": "[00:18:33]",
            "text": "So the difference between doing it with 10 items versus 100 items versus 1,000 items, it does take longer to do 1,000 items versus 100 items, but not a lot more. And basically, we can use algorithms as kind of shortcuts to cut out pieces of the work. And by doing that, we kinda get an economy of scale, right?"
          },
          {
            "time": "[00:18:52]",
            "text": "So if we add like 10,000 things, it still is able to go fairly fast because we can do things in logarithmic time. And again, I just wanted to get that kind of in front of you before we got to recursion, so you can kind of see where that fit."
          },
          {
            "time": "[00:19:09]",
            "text": "But I'll explain logarithmic Big O later in two sections, so just buckle up and wait for that. Okay, so that is really a summary of what Big O is. I'm sure mathematicians would have about two more hours that they'd like to talk to you about Big O, and I am not that."
          },
          {
            "time": "[00:19:29]",
            "text": "This is in as much as I ever use Big O, which is, I'm trying to say here. I just gave you kind of a very surface level overview of what I think is useful for a computer science, like a web developer, to know about Big O, but there's a lot more there."
          },
          {
            "time": "[00:19:45]",
            "text": "So I'm not gonna claim that I've taught you everything about Big O."
          }
        ]
      },
      {
        "name": "3-why-use-big-o",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, why is this useful to one? Again, this is gonna be really useful when you go interview at tech companies because they love to ask you, what's the Big O of the algorithm you just wrote? And I kinda gave you some tricks, which is like look for four loops, but also you need to have a bit more critical eye in terms of just think about in general, the more items I add to this array, how much longer is it gonna take, right?"
          },
          {
            "time": "[00:00:25]",
            "text": "The more inputs I give it does it take longer? So, that four loop trick doesn't always work in the sense that there can be other things that can contribute to it, but just be aware of that. Let's talk about why you would use this actually in a day job."
          },
          {
            "time": "[00:00:41]",
            "text": "So I gave an example here, which is like let's say you're writing a comment system for a website, and that comment system had a sorting and filtering ability. What's the appropriate Big O for assorting and filtering algorithm for a comment system? Now, the response I want you to have to that question is, you didn't give me enough information, it depends, right."
          },
          {
            "time": "[00:01:11]",
            "text": "That's why whenever you ask a computer scientist a question, their answer is like 99 times out of 100, it depends, I need more information. So, I know it annoys people to say it depends, give me more information, but it's actually the correct answer to that question. Because, if you're sorting and filtering for comments on a, like a small colleges or site any given article there's only three or four different comments, the answer is it doesn't matter, [LAUGH] right."
          },
          {
            "time": "[00:01:44]",
            "text": "It doesn't matter if you have complexity of Big O of n cubed. Because if you're only sorting and filtering three or four comments at a time, it really just profoundly doesn't matter how fast that algorithm takes, because the difference between three milliseconds and 15 milliseconds is basically negligible to an end user, mostly."
          },
          {
            "time": "[00:02:09]",
            "text": "But if you can write better code, more understandable, more maintainable code, so that people can come back and maintain your code later and better, that's what you wanna do, right. That's the correct answer of that question. It's not write the fastest sorting and filtering algorithm because it just doesn't make any difference."
          },
          {
            "time": "[00:02:26]",
            "text": "My point here is, don't spend time on things that don't matter, right. But I used to work at Reddit, right, and if Reddit had a sort and filtering algorithm of n cubed, you would never see reddit.com ever again because it gets so many comments, right. So the Big O of that sorting algorithm makes a massive difference."
          },
          {
            "time": "[00:02:55]",
            "text": "It's something that was unscrapable probably crashed the site consistently. So this is why Big O is necessary in the sense of like, it's a tool, right. I didn't give you the way to judge this algorithm is better than this algorithm, that was not my intention, right. That's like saying that like if I gave you a 12 inch ruler, you would never need a tape measure, right."
          },
          {
            "time": "[00:03:17]",
            "text": "It's just one tool in your toolbox for measuring algorithms, but you need to compare things across multiple axes, right. This is where I'm getting back to, this is the science of trade offs, right. And I'm giving you one of the measurement sticks here to measure your algorithms. Yeah, the question is always got to be, it depends give me more information, what do you need me to do?"
          },
          {
            "time": "[00:03:43]",
            "text": "And like again, this is kind of a pro tip for interviewing as well. Pull as much information out of the interviewer that you possibly can, right. If they just say, Hey, we're writing a sorting for these comments, don't just pop in there and start writing a sorting algorithm right away, that's the incorrect answer."
          },
          {
            "time": "[00:03:59]",
            "text": "You wanna say, what am I doing? Who's the end user? What's my constraints? What devices am I running on? Am I running on 5G? Am I running on 2G, right? These are the kinda questions that you need to be thinking about. You need to paint a complete picture of what the actual requirements are."
          }
        ]
      },
      {
        "name": "4-spatial-complexity",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> No, it's always talking about time for the most part, right? Or computational complexity. I think, for the most part I call it, in this class, computational complexity. But I think, it's actually probably referred to more, as time complexity, but you can kind of more or less tie those things together."
          },
          {
            "time": "[00:00:17]",
            "text": "They're not totally the same, but for the sake of this course, they are totally same. And it's the idea of, if I give this more inputs, how many more CPU cycles is this gonna take, how much longer is this gonna take, right? And when I talk about Big O, and when people talk about Big O, without referring to what they're talking about, they're almost always talking about time complexity."
          },
          {
            "time": "[00:00:43]",
            "text": "There is another type of complexity that's called space complexity or spatial complexity. And that's, basically, how much RAM are you gonna take, RAM or hard disk space, how much stuff do you need to store, for an algorithm? And sometimes this ends up being really important, this used to be extremely important to me in my job at Netflix."
          },
          {
            "time": "[00:01:06]",
            "text": "Because I was working on things like Roku sticks, and PS3s, and things like that, that had very, very precious little bit of memory."
          },
          {
            "time": "[00:01:06]",
            "text": ">> Will complexity be the same for network transfers, as well? Like the size of the transfer you're making, would that be evaluated as spatial complexity, as well?"
          },
          {
            "time": "[00:01:26]",
            "text": ">> So the question is would you have considered network transfer to be the same sort of thing as space complexity? I don't think so, I think I would consider that in a different vein. You totally could consider that in a Big O way, I just haven't. But no, this was much more like, how much stuff am I storing, locally?"
          },
          {
            "time": "[00:01:52]",
            "text": "And then you could probably consider network traffic, and in a yet different thing. That's a good question, I'll have to think more about that, cuz I haven't really thought about it. But, anyway, for the sake of this class, we're just talking about how much RAM you're taking, right?"
          },
          {
            "time": "[00:02:08]",
            "text": "How much stuff you're creating. So yeah, when I was working at Netflix and working on the Roku stick, the PS3, all that kind of stuff, those devices actually have plenty of CPU, right? So they're not hampered in that particular sense, but they just have no memory. They don't give any of the programs that are running on them no memory."
          },
          {
            "time": "[00:02:31]",
            "text": "And so from when we were signing people up on Netflix, that's what I used to work on. We had to be extremely careful of how much RAM we were taking because, that could really hamper user's viewing experience, or sign up experience, in this particular case. So that's why, you don't always have to consider spatial complexity, but when it's important it tends to be very important."
          },
          {
            "time": "[00:02:52]",
            "text": "So let's talk about that. So if we're gonna do something that's linear, right? If you remember linear is Big O of N, if it has linear spatial complexity that would be say, like if we had an array of ten items, our algorithm would probably create ten arrays, right?"
          },
          {
            "time": "[00:03:13]",
            "text": "So you can see here, when we take an array, and we make more arrays out of that array, that just tends to churn up RAM space. And for something like a PS3, which is very, very memory limited, that can be a bit of a problem. Because if you're churning through a lot of memory, that ends up being a really bad user experience, right?"
          },
          {
            "time": "[00:03:34]",
            "text": "So we were always talking about the spatial complexity, and we never wanted to do anything that had linear spatial complexity. But typically, the thing that you're doing, is you're creating additional arrays, that's what causes spatial complexity, it's not always true, right? You can be creating other temporary variables but normally, at least in the terms of sorting algorithms, it's gonna be arrays that are gonna cause that spatial complexity."
          },
          {
            "time": "[00:04:01]",
            "text": "Logarithmic, as you might imagine, you create less overtime, right? So if I have 10 arrays, maybe create 7 arrays, by 100 it'll create 12 arrays, you can see this kind of like this diminishing return. That would be considered logarithmic. Constant would, basically, what you'd say, either if I have an array, I'll create five arrays."
          },
          {
            "time": "[00:04:21]",
            "text": "But if it's of length 1 million or length 10, I always create five arrays, right? That would be considered constant, right? Because it's the same amount no matter what. And let's talk about quadratic, this is actually kind of an interesting one, cuz this is something that I actually did at one of my former companies."
          },
          {
            "time": "[00:04:40]",
            "text": "Let's say we had to evaluate the distance between two zip codes. And a zip code is a, they more or less exists all over the world on the sense of, it's a number that refers to a parcel of land in the United States, right? So for example, I live in 9103, and let's say, which is a zip code in Seattle."
          },
          {
            "time": "[00:05:02]",
            "text": "Let's say I wanna calculate the distance between that and 10001, which is I think is in New York. You can see that I have these two zip codes, and I wanna calculate the distance between those. Now, let's say that computation is really expensive, so we wanna pre-compute, all of those various different distances between each other."
          },
          {
            "time": "[00:05:26]",
            "text": "Well, that says for every item that I add to that database, I have to now create an additional item in the database, or sorry, an additional item for every other item in the database, right? So if I have 10,000 zip codes in my database and they add a new zip code to the database, that means I need to create 10,000 new items and store them."
          },
          {
            "time": "[00:05:50]",
            "text": "This would be quadratic, right? Because every item that you add to the database, that means they have to add even more the next time, right? And it just grows kind of out of control at that point. Now, we actually did this that one of the companies that I worked at, we only did it for zip codes in the state of Utah."
          },
          {
            "time": "[00:06:07]",
            "text": "But the reason we did that is because, it was so expensive for us to call an API to get that information of the distance between two zip codes. That it was cheaper for us to just buy a really big database and put it all in there, right? But that to me was kinda funny, cuz it was an example of a quadratic spatial complexity."
          },
          {
            "time": "[00:06:26]",
            "text": "Typically, you never wanna have quadratic spatial complexities, that's really the only time I've ever seen it be appropriate. So there's a great question on here, how does this apply to functional programming, because functional programming, churns through a lot of stuff, right? There's a lot of arrays being created and destroyed."
          },
          {
            "time": "[00:06:44]",
            "text": "The first thing I wanna say to you, is that, normally it doesn't matter, right? Normally, it doesn't matter that if you're looping through 100 things or 10 things, or probably even 1,000 things, you are creating and destroying a lot of stuff, but modern computers are pretty fast, right?"
          },
          {
            "time": "[00:07:04]",
            "text": "Even an old Android phone should be able to handle that fairly well. So normally, it doesn't matter. But the second thing I wanna say, is that, when it does matter, functional programming is usually the first thing you kinda have to refactor out, because it does unnecessarily frequently churn through a lot of memory."
          },
          {
            "time": "[00:07:24]",
            "text": "For example, we had to basically ban functional programming in that Netflix TV code repo, because of that reason, we just could not afford to churn through all of those arrays. So yeah, rule number one, if it doesn't matter, it doesn't matter, and ignore it, right? Rule number two is, yeah, frequently you have to refactor out functional programming style, code when space is a concern."
          },
          {
            "time": "[00:07:51]",
            "text": "Does that answer your question?"
          },
          {
            "time": "[00:07:51]",
            "text": ">> So basically, we can combine different [INAUDIBLE], yeah, so?"
          },
          {
            "time": "[00:07:51]",
            "text": ">> Yep."
          },
          {
            "time": "[00:07:51]",
            "text": ">> Use other style of programming, yeah, okay, thank you."
          },
          {
            "time": "[00:07:51]",
            "text": ">> Yep, for sure. And we'll get into, I think, my next section here is actually on trade offs, it is. But typically, you just wanna wait for it to become a problem, before you solve it, right?"
          },
          {
            "time": "[00:08:16]",
            "text": "People like to solve problems before they have them, and that's a really bad idea, right? So wait for it to become a problem, and then when it's the problem then go refactor it out."
          },
          {
            "time": "[00:08:16]",
            "text": ">> Premature optimization."
          },
          {
            "time": "[00:08:16]",
            "text": ">> Yeah, premature optimization, it's a mouthful. [LAUGH] Yeah, so the question is what's driving these constraints, right?"
          },
          {
            "time": "[00:08:37]",
            "text": "And I mean, most frequently your boss isn't gonna know where those constraints are gonna be. So that's why it's on you to ask a lot of these questions like, hey, am I running on a low-end Android device in rural America? Or am I running on a super computing cluster that has basically infinite space and computational power?"
          },
          {
            "time": "[00:09:01]",
            "text": "Cuz those are gonna be very wildly different answers, right? Or in this particular case, I think the PS3 is a great example of, you know that you're extremely memory constrained, but that PS3 processors was very, very powerful, right? So that means that anything that we could shove towards this time complexity side, I mean we could do really inefficient things with the CPU because those cycles were very cheap to us."
          },
          {
            "time": "[00:09:24]",
            "text": "Whereas we had to be super conservative with our memory usage, right? Whereas, normally, like when I'm coding for the cloud, right? I mean, I work on Azure at the moment. I can just throw more RAM at it, RAM's cheap, right? So I can use really inefficient spatial complexity things."
          },
          {
            "time": "[00:09:40]",
            "text": "The question you should be asking yourself is, where is this running? What kind of devices is this going to be running on? And how important is it to the user? And how big of inputs am I expecting, right? Cuz if the answer is you're only gonna be evaluating two or three items at a time, it just doesn't matter, right?"
          },
          {
            "time": "[00:10:00]",
            "text": "In which case, write the simplest code possible. So yeah, just to wrap up here on spatial complexity. Again, this is just another ruler that I'm giving you to measure your approaches to problems. So that you can decide, based on whatever the the task is at hand, to choose what kind of algorithm you're gonna use."
          },
          {
            "time": "[00:10:19]",
            "text": "And it's never gonna be like, well, we're gonna use Quicksort, and we're gonna do that. Normally all this stuff that I'm about to teach you in this course is actually built into the language, and you don't actually really need to know how to do it. It's gonna be much more like, hey, we're creating type ahead for our search bar."
          },
          {
            "time": "[00:10:40]",
            "text": "And we can either pre-compute that with trees, or we can do it on the fly and just rely on the CPU to do that on the fly, which is the correct thing to do. And again, I hope your answer to that question is, it depends, right? Where's this gonna run?"
          },
          {
            "time": "[00:10:55]",
            "text": "What kind of devices,? What are my users doing? How big is that dataset, right? Those are the kind of questions that I'm hoping that I'm just gonna ram into your head, so that you know to ask that question continually is like, give me more information."
          }
        ]
      },
      {
        "name": "5-big-o-trade-offs",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we just talked about spatial complexity. Let's go ahead and pop into a whole section just on tradeoffs. And again, I actually think this is the most important part of this course. I'm gonna show you a bunch of novel techniques for sorting things and storing information, all that kind of stuff."
          },
          {
            "time": "[00:00:21]",
            "text": "But the point here is, I wanted to show you can do things multiple different ways. And you can decide which one's better or worse depending on what the problem constraints are. And I think, again, when you're getting into interviews and talking to an interviewer at a tech company, if you can discuss the tradeoffs with them, you're gonna be a leg up on everyone else, right?"
          },
          {
            "time": "[00:00:49]",
            "text": "So you can get in there and it's like, okay, well, we could do it this way, but we're trading off time. Or we can do it this way, and it's gonna cost more on our servers, blah, blah, blah. And you can discuss money versus customer experience or things like that, right?"
          },
          {
            "time": "[00:01:04]",
            "text": "To me, I have, at this point, done way too many interviews. I find that as an interviewer very, very impressive when a developer is able to kind of discuss these kind of, I guess business logic kind of things based on the constraints that they have. So I'm just giving you a big hint there that I think that's a really good idea."
          },
          {
            "time": "[00:01:33]",
            "text": "And then just like when you're writing code, looking at something and just kinda getting these, people call them code smells. But the idea of just these intuitions of hey, I have a for loop here, and I'm putting another for loop inside of it. That's what n square looks like, this might be a bad idea, right?"
          },
          {
            "time": "[00:01:51]",
            "text": "That's another thing that I'm kinda trying to help you understand here. Yeah, and just thinking about something in terms of, could this be done better? And, again, better is a very subjective term, and I'm trying to help you understand the trade offs so that you can decide what better means in any particular case."
          },
          {
            "time": "[00:02:14]",
            "text": "So my first rule here that I put, and I'll just zoom in here a little bit on this is, there are no rules here, right? There is no always do blink, right? That's one of the very, very big keys here. We talked about best and worst case scenarios, right?"
          },
          {
            "time": "[00:02:31]",
            "text": "Sometimes you wanna lean into those best case scenarios, and sometimes a less effective algorithm in terms of average case might have a better best case. And you might always have a best case scenario in front of you and you know that, in which case, you wanna lean into the best case."
          },
          {
            "time": "[00:02:47]",
            "text": "But sometimes, you don't know what you're gonna get, in which case, you really wanna lean into the worst and average case scenarios, right? So that's one thing here is, just learn that there are no rules and you have to reevaluate every problem in a unique light. There are frequently multiple right choices."
          },
          {
            "time": "[00:03:09]",
            "text": "It's not like someone's up there grading you saying you should have chosen quick sort instead of merge sort this time. Frequently, those are both very effective answers to the same question. Remember how I told you Big O says ignore the 3 and the 3x squared? Sometimes you can't ignore the 3, right?"
          },
          {
            "time": "[00:03:31]",
            "text": "So even though I taught you Big O and Big O ignores all of the coefficients, the incidentals, right? If you have a for loop that does has 10,000 lines in it, sometimes that coefficient ends up being enormous and you can't ignore it, right? So, again, Big O is just one tool, it's a very blunt instruments in terms of that it ignores a lot of the incidental details, and sometimes the incidental details are actually critical."
          },
          {
            "time": "[00:04:05]",
            "text": "So be aware of that. Yeah, Sometimes Big O can even be a bad tool to use in the sense of, let's imagine, and this is actually a real story from my career. I had a job that ingested a bunch of data from a partner once a day and ran and did a bunch of processing and then stored a bunch of stuff in our database."
          },
          {
            "time": "[00:04:36]",
            "text": "And I spent just tons of time trying to optimize that cuz it was a lot of data, right? But here's the thing, that job happened once a day, and it didn't matter if it took 30 minutes. No one was waiting on it, right? It was just updating our database with the freshest data, right?"
          },
          {
            "time": "[00:04:53]",
            "text": "So this was really early in my career. I spent just hours, and days, and weeks, trying to optimize this to get this down from, I think I had it 45 seconds I was trying to get it done. I was like, this should run in under a second. It was a massive waste of time, it didn't matter that it took 45 seconds, right?"
          },
          {
            "time": "[00:05:11]",
            "text": "So in this particular case, I was doing myself and my company a big disservice by focusing on something not important. So those things are only important when a user's being affected or it's causing downtime or things like that. If you're just making a computer wait a little bit longer, who cares, right?"
          },
          {
            "time": "[00:05:32]",
            "text": "Who cares that that job took 45 seconds? No one. I guess, except me, right? I cared [LAUGH]."
          },
          {
            "time": "[00:05:32]",
            "text": "This is probably the most important thing in here. Readability and maintainability are actually the most important things in code. I think I heard Kyle Simpson say this, I don't know if he invented it."
          },
          {
            "time": "[00:05:55]",
            "text": "He's a smart guy, but it might have been someone else. But he said that code is communication and that it's more important that a human can read it than a computer can read it. And that really challenged my worldview, the first time I heard it. And then I realized further and further it's like, if the only thing was important was computer time, we would just be writing assembly, right?"
          },
          {
            "time": "[00:06:16]",
            "text": "You and I both could learn assembly and I think everyone that's watching this course is capable of learning assembly. Why don't we write assembly? Or why don't we all write C? You can write web servers in C, I've done that before, why don't we all write C? Well, JavaScript is a lot easier to read, right?"
          },
          {
            "time": "[00:06:34]",
            "text": "It's a lot easier to write as well, but it's a lot easier to read and it's a lot easier to maintain. Why do we like TypeScript? TypeScript is even easier to maintain. I maintain that this is at all kind of derived from the fact that code is communication."
          },
          {
            "time": "[00:06:50]",
            "text": "Code is communication to your future self, it's communication to future developers that have to maintain your code. So always, always optimize for readability and maintainability. If you have something that's very simple and it's n squared and you have something that's hyper optimized and it's n, the n squared one might still be the better answer, if it's a lot easier for you to maintain later."
          },
          {
            "time": "[00:07:13]",
            "text": "Only go for that n code, if the constraints actually call for it, right? So that's what I'm saying here, readability and maintainability should be number 1 on your list, and only optimize when you actually need to optimize. Always err on the side of simple. If you can choose from complex and simple, simple code tends to just have less bugs because you can understand it more holistically."
          },
          {
            "time": "[00:07:43]",
            "text": "So where you can, try and write simple code. Human time is almost always more valuable than computer time. In the sense of what I'm saying is, if you can throw an additional server at the problem and it solves your problem, as opposed to making you write a lot more code, usually, it's cheaper to run a server than to pay you to write that code."
          },
          {
            "time": "[00:08:04]",
            "text": "So usually it's the right choice for you to spend your time doing something else. Talked about this already, but don't prematurely optimize. Try to have a perf problem before you solve a perf problem. Again, these are high level principles. I refer you back to rule number 1 here is that there are no rules."
          },
          {
            "time": "[00:08:21]",
            "text": "Sometimes you can look at something as, I know this is gonna be a problem and I'm going to fix it right now. But just know that you rarely know your problems you're about to have. None of us are code psychics, or if you are, I would like to hire you [LAUGH]."
          },
          {
            "time": "[00:08:43]",
            "text": "And then 99%, and this actually should probably be like 99.9999% of the time. You wanna use the built in features to the language and not write the code yourself. So for example, JavaScript has a .sort method, and it is faster than any sort that you're gonna write. Is that really true?"
          },
          {
            "time": "[00:09:02]",
            "text": "It's actually probably not true, you probably could write a faster one. But the thing is V8 gets to cheat. V8 or SpiderMonkey or any of the JavaScript engines, JavaScriptCore would be the other big one. They get to cheat because they get to use C and you don't get to use C when you're writing JavaScript, right?"
          },
          {
            "time": "[00:09:20]",
            "text": "So they can drop into the internals of the engine, sort your code and hand it back to you frequently faster than you can do it yourself. But the other thing I'm gonna say is that .sort has been so tested that it's pretty much guaranteed to be bug free."
          },
          {
            "time": "[00:09:37]",
            "text": "If you hit a bug on .sort, you are doing some just wild stuff and one, I congratulate you [LAUGH]. And two, it would actually be really cool thing for you to go fix. But suffice to say, .sort has been called on just about every website out there on the Internet right now, which means that you're probably not gonna hit the edge case on it."
          },
          {
            "time": "[00:09:59]",
            "text": "Whereas, if you write your own sorting algorithm, I guarantee you're gonna have some bugs that you just don't think about. So where you can, try and lean into what other people have done. Install that module off of NPM, call the .sort method, whatever you need to do, but you'll have less surface area for bugs."
          },
          {
            "time": "[00:10:18]",
            "text": "And again, I'd rather spend my time writing new and novel cool stuff for my company, rather than solving bugs. I don't know, maybe I'm strange in that capacity, but I don't think so. So the question is, you go out there you do what I just tell you, which is, do the unoptimized thing, do the simple thing, and then you hit hockey stick growth."
          },
          {
            "time": "[00:10:41]",
            "text": "And now instead of having 10 users, you now have 100,000 users and you find that you're gonna run into a lot of performance problems. So one, congratulations, [LAUGH] you're living the dream right there, which is that you hit scaling problems. And that's kind of the advice that I give startups, it's the advice that I give developers, try and have good problems."
          },
          {
            "time": "[00:11:10]",
            "text": "And having scaling problems are good problems. Now they're terrifying and they're very difficult to solve, right? But it's why people say never write Ruby on Rails. It's this unoptimized things and look, Twitter had to rewrite and GitHub had to rewrite and blah, blah, blah, and all that kind of stuff."
          },
          {
            "time": "[00:11:27]",
            "text": "Well, one, they're billion dollar companies, and they can now pay people to solve those problems. And if you hit hockey stick growth and go from 10 to 100,000 users, I hope that you're making enough money now that you can hire someone to go back and solve those scaling problems."
          },
          {
            "time": "[00:11:42]",
            "text": "I think the YC thing, the Y Combinator, which is the name of a VC firm is, do unscalable things. I quite agree with that in the sense of, again, normally you're not gonna, when you have 10 users, you typically don't know what problems you're actually gonna have when you have 100,000 users."
          },
          {
            "time": "[00:12:03]",
            "text": "You only know that you're gonna have those problems when you hit 100,000 users. Which means you're probably not gonna solve the right problems. You think, okay, this is a bottleneck, this for loop is definitely gonna get bugged down, and frequently it's actually over here and it's a different problem and it's way bigger, right?"
          },
          {
            "time": "[00:12:21]",
            "text": "So yes, that's gonna happen and you should feel very happy when those things happen. Does that answer your question? Cool, other questions?"
          },
          {
            "time": "[00:12:21]",
            "text": ">> I have one follow up question. So should we wait for that situation when there is an increase for user audience in our app, or we need to do some performance testing and fix code?"
          },
          {
            "time": "[00:12:49]",
            "text": "And when should we do that performance testing?"
          },
          {
            "time": "[00:12:49]",
            "text": ">> Yes, I think that the crux of that question is, when should we do that user tests, load testing and how much should we do in those kinda things? It depends, [LAUGH] I think the answer to that question is, how many users do you anticipate in the very near term are gonna be using your application, right?"
          },
          {
            "time": "[00:13:21]",
            "text": "So let's say I work at a startup and that startup has 10,000 users daily. I would probably try and load tests for up to 30,000 users or something like that, or 50,000 or 100,000 or something like that. Something that's within an order of magnitude difference, so that I'm not gonna just fall over my next, kinda scale up next little growth area."
          },
          {
            "time": "[00:13:44]",
            "text": "But I'm not gonna use or test, or I'm not gonna load test for a million. I'm not gonna load test for a billion, right? Really only Facebook gets to do that. [LAUGH] So, yeah, try and keep it within, Growing distance, within sight. But it's gonna really depend on what you anticipate growth and then I guess it also depends on what else is pressing, right?"
          },
          {
            "time": "[00:14:09]",
            "text": "If you're doing that instead of shipping new critical features, then you probably wanna minimize that and go work on the critical features. So it's really a pretty delicate balance depending on where you are in your startup's growth pattern."
          },
          {
            "time": "[00:14:09]",
            "text": ">> So what you're saying mean that we need to be prepared for the most nearest future."
          },
          {
            "time": "[00:14:37]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:14:37]",
            "text": ">> Not far away, but in a way for reasonable future, yeah, okay."
          },
          {
            "time": "[00:14:37]",
            "text": ">> Yeah, I think that's a good summation is be prepared for the visible future. Cuz it's possible to spend just infinite cycles on optimization, and that's not useful to anybody, right? What's useful is providing value for your users."
          },
          {
            "time": "[00:15:00]",
            "text": "Let's go with unnamed company, one that many of you have probably heard of. I had one particular problem, their search bar was incredibly slow, just while the inappropriately slow. And I was so upset, and I still use the products I liked the product, but the search bar drove me just bananas."
          },
          {
            "time": "[00:15:20]",
            "text": "And I asked one of the engineers, I was like, why is it so slow? I'm so upset all the time. [LAUGH] And basically what they said is, we looked at that and is just the gnarliest problem of how we did this when we first started it. They were loading just this huge amount of data set into a device that has no business loading that much data."
          },
          {
            "time": "[00:15:39]",
            "text": "And they basically said, it's gonna require a huge rewrite of this, and we have to ship a bunch of stuff before we can get back to this performance problem. And I was upset on one hand as a user, on the other hand, I totally agree with that approach of it did work, and those features that they were shipping, they did need."
          },
          {
            "time": "[00:15:57]",
            "text": "So in that case, ignoring the performance problem temporarily was actually the correct call. And it's fixed now, right? I still give them endless crap about it, and they deserve it, yeah. Anyway, it's a balance. Okay, let's get into writing some code. You're all probably sick of listening to me talk at you."
          },
          {
            "time": "[00:16:24]",
            "text": "We are gonna get into Bubble Sort."
          }
        ]
      },
      {
        "name": "6-bubble-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so for the first code that we're gonna write today, we're gonna be writing bubble sort. Now bubble sort is actually not a algorithm that you're ever going to use directly in production. Because there are algorithms that are just strictly better than bubble sort, but it really fits super well with the mental model that humans would think of how to sort numbers."
          },
          {
            "time": "[00:00:25]",
            "text": "So the first thing I'll tell you today, a lot of algorithms is about sorting. We're gonna be doing, I think, six different sorts today. And the reason for that is it's demonstrative of the ability to write algorithms in the sense of we're trying to show how you can take a large set of numbers and do a holistic action with them."
          },
          {
            "time": "[00:00:49]",
            "text": "And the various different strategies that you can do to minimize the work that that you're doing, and which is to say that you may not ever write quicksort or merge sort, insertion sort directly. In fact, I imagine you never will because the language is actually better at doing it than you are."
          },
          {
            "time": "[00:01:08]",
            "text": "But you will be able to take apart these algorithms and use them kind of piecemeal here and there. I remember I've interviewed at Facebook years and years ago to be on the React core team. And the algorithm that I used to solve the question that they asked was actually merge sort, just kind of dissected and reput back together."
          },
          {
            "time": "[00:01:32]",
            "text": "So that's kind of the mindset I want you to have here is you're probably not gonna sort too many numbers directly by hand, by code, but you will use these algorithms kind of pieced apart and reapplied. Okay, so I'm just giving you some justification of why I'm gonna have you sort so many damn numbers."
          },
          {
            "time": "[00:01:53]",
            "text": "So this is kind of a fun little graphic. It's from Wikipedia of how bubble sort actually looks over time. And the way that works, you can see that the biggest numbers bubble up to the top, right? That's why it's called bubble sort is cuz the biggest numbers over time end up being bubbling up to the top, and then it sorts the smaller part of the array over time."
          },
          {
            "time": "[00:02:18]",
            "text": "And the way it works is this, is you're just gonna go over the array, and if the item at index one is bigger than the item at index two, then you're gonna swap index one and index two, right? And then you're just gonna keep doing that. You're gonna say, is this one bigger than this one?"
          },
          {
            "time": "[00:02:38]",
            "text": "No, okay, next item, is this one bigger than this one? Yes, swap them, right? And then you just kinda swap them. So let's look at kind of a drawn out version. So let's say we're gonna sort this one here, 1, 5, 4, 3, 2. The first question you ask starting at the beginning, is 1 and 5 out of order, right?"
          },
          {
            "time": "[00:03:00]",
            "text": "Is 1 larger than 5? It's not, right? Next thing, is 5 larger than 4? Yes, then you swap. And then you end up with an array that looks like this 1, 4, 5, 2, 3. Now, notice here that 5 is the largest item in the array. So is it larger than those things?"
          },
          {
            "time": "[00:03:22]",
            "text": "The answer is always going to be yes, right? So that's why 5 is going to bubble to the top. So are 5 and 2 out of order? Yes, swap, are 5 and 3 out of order? Yes, swap, and now we've gone through the entire iteration once, right? We've gone through the entire array."
          },
          {
            "time": "[00:03:43]",
            "text": "Is it sorted yet? No, right, 4 is still here out of order. So that's kind of the inner, or sorry, yeah, what we did here, this is the inner loop, which is asking, are the two numbers out of order? And then there's an outer loop that says, hey, during my last iteration, did anything swap?"
          },
          {
            "time": "[00:04:06]",
            "text": "If the answer to that question is yes, then you do it again. If you go through it and nothing swaps, that means the array is sorted and you're done, right? So end of the array, did anything swap? The answer is yes. So then we start all over again."
          },
          {
            "time": "[00:04:24]",
            "text": "1 and 4 out of order? No, 4 and 2 out of order? Yes, so you swap those. Are 4 and 3 out of order? Yes, swap, and we've reached the end of the array again. Now notice we don't have to ask, are 4 and 5 out of order?"
          },
          {
            "time": "[00:04:39]",
            "text": "This is a bit of an optimization. You don't actually have to do this. But after the first iteration, you can guarantee that the last item in the array is definitely the largest item, right, because it'll bubble to the top. Which means we can progressively look at less than the rest of the array."
          },
          {
            "time": "[00:04:56]",
            "text": "So after two iterations, we can guarantee that the last two items are definitely the largest two items in the array, right, due to the method of how bubble sort works. Okay, so are 4 and 5 out of order? No, in fact, so this question here was technically unnecessary."
          },
          {
            "time": "[00:05:17]",
            "text": "You hit the end of the array, did anything swap? The answer's yes, we had a couple swaps here. And now notice it actually is sorted, right 1, 2, 3, 4, 5. But because something swapped in the last iteration, we have to go through it again, right? [COUGH] So are 1 and 2 out of order, 2 and 3, 3 and 4, 4 and 5?"
          },
          {
            "time": "[00:05:37]",
            "text": "And then here, we hit the end of the array and nothing swapped. So now we know this is in order. So since nothing swapped, we break the outer loop, and we're done, right? So that is the end of that particular sorting algorithm. So I talked about this a little bit, which is after the first run through, the largest item's at the end."
          },
          {
            "time": "[00:06:05]",
            "text": "After the second iteration, the second largest item's at the end, so on and so forth. Cool, so that's optimization right there. It would make a difference in the coefficient. It wouldn't actually make the big O any better. But it does guarantee that it'd run a little bit faster."
          },
          {
            "time": "[00:06:29]",
            "text": "So what's the time complexity? What's the computational complexity of this algorithm?"
          },
          {
            "time": "[00:06:29]",
            "text": ">> Someone online is saying, the best case scenario is four of n."
          },
          {
            "time": "[00:06:29]",
            "text": ">> Yep, so let's talk about the average case first, and then we'll loop back to the best case."
          },
          {
            "time": "[00:06:29]",
            "text": ">> And they're saying the average case is O of n squared."
          },
          {
            "time": "[00:06:51]",
            "text": ">> Yeah, so there's gonna be an outer while loop, right? That's gonna say while something swapped, then continue doing the inner part of that loop, right? And then the inner loop is gonna be a for loop, which is going to loop over the array every single time, right?"
          },
          {
            "time": "[00:07:12]",
            "text": "So we have a outer while loop and an inner for loop. What does that look like? It's gonna be n squared, right? So that's gonna be the average case and it's also gonna be, well, we'll talk about worst case here in just a second. But the average case here is that we have an outer loop and an inner loop, which means we're gonna end up with n squared."
          },
          {
            "time": "[00:07:37]",
            "text": "Because every item in a bubble sort more or less has to be compared to every other item in the array. That's kinda the question that you're gonna ask yourself is, does every item in the array, at some point say, is this larger than this? And the answer for a bubble sort is yeah, every item will see every other item in the array."
          },
          {
            "time": "[00:07:57]",
            "text": "So that's gonna make the average case of this n squared. The worst case scenario for a bubble sort is a reverse sorted list. So if this came in as 5, 4, 3, 2, 1, that means that we're gonna have to do a lot of swapping, right? And we're gonna have to ask, is this greater than this?"
          },
          {
            "time": "[00:08:19]",
            "text": "So that's gonna be the worst case scenario is a reverse sorted list. The best case scenario is going to be n, which is going to be a sorted list, right? Cuz if this was 1, 2, 3, 4, 5, it would go through the array once and say, hey, we did no swaps, I'm done."
          },
          {
            "time": "[00:08:44]",
            "text": "What's the spatial complexity of this? It's just, sorry, go ahead."
          },
          {
            "time": "[00:08:44]",
            "text": ">> [INAUDIBLE]"
          },
          {
            "time": "[00:08:44]",
            "text": ">> It's constant, that's correct. We're not creating any additional arrays. We're not doing anything like that. We're just operating on the array itself, which means that no new memory is being called into use here, which means it's gonna be constant time."
          },
          {
            "time": "[00:09:14]",
            "text": "Okay? So the next question, which we haven't talked about yet, is this sort stable? And again, we haven't talked about that yet. A stable sort that says if two items are considered equal in this sort, are they guaranteed to be in the same order when they come back?"
          },
          {
            "time": "[00:09:40]",
            "text": "So here, I have a little array that says state, which has Sarah Dresner, Shirley Wu, and Scott Moss. Scott and Shirley both live in California. And let's say we were sorting by state. For this to be a stable sort, we'd have to guarantee because Shirley came first in the array that she would come before Scott."
          },
          {
            "time": "[00:10:05]",
            "text": "Some sorting algorithms do not guarantee that, right, that if one of them comes first, it may not come first when it comes back, and that would be an unstable sort. Sometimes that's important to you. Sometimes that's not important to you. So in this particular case, Yes, bubble sort is considered a stable sort, right?"
          },
          {
            "time": "[00:10:35]",
            "text": "Because you just would never swap them, which means that in this particular case, Shirley would be guaranteed to be ahead of Scott if we did this sort based on speed. And the last one that we didn't talk about is this sort is what's called destructive. That means that it's actually operating on the array itself."
          },
          {
            "time": "[00:10:57]",
            "text": "So if I pass an input into bubble sort, it's going to operate on bubble sort or the array itself, which means that if I wanted to keep a copy of the original unsorted array, I would have to make a copy beforehand, right? Some sorts will return brand new arrays and do not operate on the original array, which those would not be destructive."
          },
          {
            "time": "[00:11:24]",
            "text": "But in this case, bubble sort is destructive cuz it's actually modifying the original input. Which if any of you are functional programmers, that feels really gross, right? But sometimes that's a good thing, right? Because we're not increasing some of the spatial complexity. So again, it's a trade-off. In this particular case, it's okay to operate on the original input."
          },
          {
            "time": "[00:11:48]",
            "text": "And you should in this particular case. So again, functional programmers love rules. Never operate on the input. And I want to refer you back to our trade-off's number one rule, there are no rules, right? So in this particular case, we want to modify our inputs."
          }
        ]
      },
      {
        "name": "7-bubble-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> I'm gonna give you some time to try and implement bubble sort yourself. So, should be able to click on here if, I think mine I actually have it open here. So Come back here to our code sandbox. And I want you to work on bubble sort.test. And you can go ahead and delete the .skip here."
          },
          {
            "time": "[00:00:40]",
            "text": "And you can go ahead and get started on that. You can look here at the test. You can call it right here, or you can write all the code here. As you can see here, I now have one failed test. Now, and actually I'll show you how to do this when we get back after you try this, but there's a cool little thing I added here that you can visualize your sorting happening as well as it goes on."
          },
          {
            "time": "[00:01:07]",
            "text": "And I'll show you how to do this when you get back but if you wannna give it a shot right now, you'll put your bubble sort code here in sort. And then anytime that you wanna take a snapshot of the array, which basically means that the beginning of every 4 loop."
          },
          {
            "time": "[00:01:22]",
            "text": "It'll actually visualize you over time of how your bubble sort's working, which is kinda cool. But I would say do it here, for us to do it here in the bubble sort here. Again, let's actually do that first as well. In fact, I might just commit that. Well, stay on page."
          },
          {
            "time": "[00:01:48]",
            "text": "If you wanna get rid of all the console stuff here, it's under pathfinding and under the solution and you just need to log out or remove the log maze parts. But I'll do that here in just a second. So just another kind of pro tip here as you're doing your code sandboxes."
          },
          {
            "time": "[00:02:23]",
            "text": "I tend to leave these skips on here. Let's do the test out skip until I'm fairly certain that I have at least a good first shot. It's really easy to get infinite loops, if you're just letting it run. In fact, I think code sandbox lets you yeah, actually, let me show you that as well, that's probably a useful thing here as well."
          },
          {
            "time": "[00:02:46]",
            "text": "This little blue circle up here, this toggle file watching, it'll actually just run your code as you're typing which is kinda slow. So if you just click on that. It won't try and run it every single time that you type, which is probably a good thing, especially when you get into recursion, you can actually crash your browser."
          },
          {
            "time": "[00:03:07]",
            "text": "Another kinda pro tip here is if you've created your own code sandbox account, you can just save the file before you try running it, so that if it does crash, you don't lose all your work. Also, don't refresh the page. I probably should have told you all this maybe a bit sooner but now you know, coz if you refresh the page, it's gonna drop all of your changes as well."
          },
          {
            "time": "[00:03:30]",
            "text": "Okay. So first thing here, is we wanna do create a variable called swapped. We'll set that equal to false. This is just gonna be the, I think the term for is the sentinel variable. That as soon as we swap anything in the array, that means we have to do another loop, okay?"
          },
          {
            "time": "[00:03:51]",
            "text": "Here you can do a while loop, but I never get to use do loops and whenever I get to use a do loop, I feel like I must because I never otherwise use them. So I'm gonna say do which is very similar to a while loop. What's the difference between a do loop and a while loop?"
          },
          {
            "time": "[00:04:09]",
            "text": "Well, a do loop always happens at least once, which in this case, you always wanna least check if it's sorted or not, okay? So I have this do loop here. And I'm going to say, on the first thing, swapped equals false. That's the first thing at the beginning of every single array, we're going to assume that nothing has been swapped, and then we're going to, if something does get swapped, then we will set swap to true which will cause it to loop again."
          },
          {
            "time": "[00:04:40]",
            "text": "When I say 4, let i equals zero. I as less than num style length i++, okay? And then in here, we're going to say if numbs of i is greater than nums of i + 1 Then we're gonna swap the numbers const temp equals nums i, you could write some function that does this as well, it's up to you."
          },
          {
            "time": "[00:05:21]",
            "text": "Nums i equals nums of i + 1. Nums of i plus 1 = temp, and swapped = true. It's basically it right there. There are a number of things here that I could do that could speed this up. For sure, I tried to write just the simplest code possible for you all to understand this."
          },
          {
            "time": "[00:06:04]",
            "text": "But a really good exercise for you to do later is to go and actually, like, for example, I could track how many iterations I've been through, right? And I could have like const iterations and are actually have to be alette. And that could do a ++ at the end of every loop here and then I could say minus iterations right?"
          },
          {
            "time": "[00:06:24]",
            "text": "And that would Allow me to do less than less loop throughs, I think that could actually make this even minus one. I think that actually does work. But let's actually try and see if this actually works as it Is, And we'll click play. Yeah, I got to return this at the end."
          },
          {
            "time": "[00:06:50]",
            "text": "Yeah, thank you. All right, so let's try that again. Sometimes it gets unhappy of That should be working. But let's go ahead and go take a look at the solution just to make sure here. Yeah, and you can see here I mean, that's basically the code that I wrote right there."
          },
          {
            "time": "[00:07:22]",
            "text": "If you are seeing that where it doesn't do that, what I would do is I would just save, refresh the entire thing cuz again, code sandbox can find itself in a bad state. So, the next thing I kinda wanna show you here, Is, let's just go ahead and refresh this."
          },
          {
            "time": "[00:08:00]",
            "text": "Bubble sort, you running now? Yeah, there we go. Now it is running. Cool. All right, so let's do some fun little visualization here. I'm just gonna copy the body of bubble sort here, and then I can have this thing under source called sort.js. You can actually just come in here and paste this."
          },
          {
            "time": "[00:08:26]",
            "text": "And I'm gonna uncomment these snapshots right here. And let's just call this nums. All right, so now if I go over here and browser, Okay? And then they come in here into sort, you can actually visualize what's going on here. So the one thing this will do for you is actually do duplicates for you, so as long as you just, so if I call snapshot multiple times in a row with the same array, it'll cut it out so you can only see what happens when it swaps."
          },
          {
            "time": "[00:08:59]",
            "text": "So you can see I took 71 snapshots by putting a snapshot here and then one of the ends just to get the final product. And it actually only got 22 unique snapshots. But you can see here, the nine bubbles up, the eight bubbles up the seven bubbles up, right?"
          },
          {
            "time": "[00:09:18]",
            "text": "And you can kind of see that bubble sort kinda working over time. Or I mean, we can do make this even bigger. This will be pretty ineffective. You can see I kinda made it unhappy cuz this is what happens when you use n squared algorithms. I've actually locked up my browser."
          },
          {
            "time": "[00:09:46]",
            "text": "That's how inefficient this this sword is. There we go. It's also a lot of react rendering. You can see here this took almost 9000 snapshots. And it has to have 2555 unique snapshots. You can see here the 97 bubbles up until it finds 100, then it finds 99, that's gonna bubble up until it finds 100 99 actually is the biggest cuz it's going from that to 100."
          },
          {
            "time": "[00:10:20]",
            "text": "You can look how long this this rendering is. But it's kinda pretty to watch all the colors kinda come together, right? Anyway, I think it's cool."
          },
          {
            "time": "[00:10:20]",
            "text": ">> In the f check there, are you intentionally going out of bounds and relying on a number greater than undefined will be false?"
          },
          {
            "time": "[00:10:41]",
            "text": ">> Yeah, so the question is here on line 13. This obviously at some point is going to go out of bounds and it just ends up working okay, so I just never bothered fixing it coz really only pops to go outside the array once and it doesn't. But you totally could say and no, this is gonna try and re render again."
          },
          {
            "time": "[00:11:08]",
            "text": ">> You could just start the for loop from i = 1 and do the check with i and i- 1."
          },
          {
            "time": "[00:11:08]",
            "text": ">> Yep, there's a lot of ways you could handle that and that would totally be fine as well. So anyway, I found this kinda fun. Feel free to to play around with this."
          },
          {
            "time": "[00:11:24]",
            "text": "This will work for all of the basically non recursive sorts. So this will work with like the radix sort. This will work with selection or insertion, all those sorts."
          }
        ]
      },
      {
        "name": "8-insertion-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, we just talked about bubble sort and I said bubble sorts, probably not one you're ever going to use. And the reason why you're probably never gonna use bubble sort and actually me rephrase, you'll never actually use bubble sort in any sort of real setting, it's strictly a teaching tool."
          },
          {
            "time": "[00:00:19]",
            "text": "And that's because insertion sort is just strictly better. There's no situation that you're gonna find that bubble sort, outperforms selections or, sorry, Insertion Sort. There's another sort called selection sort that we're not doing today that is occasionally useful. But we're gonna go with insertion Sort because one, I think it's a bit easier to conceptualize, and two, I think it's more useful in general algorithm."
          },
          {
            "time": "[00:00:45]",
            "text": "So insertion sort, again, works kinda in a way that the human brain maps sorting in its head. So you can see here in this little GIF, what is doing is it's starting at an array of length one, so zero right? And it's saying okay the very from array previous to index one is a sorted array, right?"
          },
          {
            "time": "[00:01:12]",
            "text": "So you have a basically a sub array of length one and an array of length one is always sorted, right? So if I have an array and it's just one number in there, that's a sorted array because you can't do anything else to that, it's just sorted because there's only one number in there, right?"
          },
          {
            "time": "[00:01:31]",
            "text": "So we're gonna take advantage of that concept and say, okay, what we're gonna do is we're gonna take the next number that this case, index 1, and we're going to insert that in a sorted way. So I have a list down here. We're basically gonna say everything before index 1 so basically just index 0 in this particular way is sorted, right."
          },
          {
            "time": "[00:01:51]",
            "text": "So 3, this part of the array is sorted and this part of the array is unsorted. Then we're gonna take 2 here and we're going to insert that into the sorted place for it, right? So you're gonna say is 2 larger than 3? No. Move 3 to the right beginning of the list and insert 2 at index 0, right?"
          },
          {
            "time": "[00:02:13]",
            "text": "So basically we're just going to be shifting those numbers over as we iterate over it. Once we get to the beginning of the list, then we know that 2 was at the beginning of the list, okay? Now we're gonna take index 5 here, so we're gonna say, is index 5 larger than 3?"
          },
          {
            "time": "[00:02:31]",
            "text": "And then we're gonna say insert after 3, in which case, it is already after 3, so we don't have to do anything. So this just stays where it is, okay? Then we're gonna start at index 4 here. We're gonna say is index 4 larger than 5? No, move to the right."
          },
          {
            "time": "[00:02:51]",
            "text": "So basically, 5 is going to end up here. And then we're gonna say is 4 larger than 3, is we're gonna say yes, so basically 4 gets inserted where 5 was. 10? And then after that we have 2, 3, 4, 5. And again, we're gonna ask is 1 larger than 5?"
          },
          {
            "time": "[00:03:11]",
            "text": "Move 5 to the right. Is 1 larger than 4? Move 4 to the right. Is 1 larger than 3? Move 3 to the right. Is 1 larger than 2? No, move 2 to the right. And eventually we reached the beginning of the list and we're going to insert it at index 0 which is gonna be 1, 2, 3, 4, 5."
          },
          {
            "time": "[00:03:29]",
            "text": "So basically we just continually shift all the numbers over until eventually it finds like okay, this is where it goes and then we put it there and then we start the loop over again. Make sense?"
          },
          {
            "time": "[00:03:29]",
            "text": ">> Looks like reverse bubble so."
          },
          {
            "time": "[00:03:29]",
            "text": ">> It kind of does, doesn't it?"
          },
          {
            "time": "[00:03:46]",
            "text": "Yeah, I could definitely see that logic. Yeah, this, I thought this graph was actually pretty helpful coz you can see them, shifting the numbers over until eventually they find where it's supposed to go. Is cuz you can see this number continually shift over. All right, so what's the big O of this?"
          },
          {
            "time": "[00:04:14]",
            "text": "What's the worst case scenario for this particular algorithm. Well, it's gonna be a reverse sorted list again, right? Because that means we're gonna continually have to shift everything over as much as possible, right? Every single time that we can shift something over, we're gonna have to do that until everything has to arrive at the beginning of the list from the end of the list."
          },
          {
            "time": "[00:04:39]",
            "text": "So reverse sorted list, worst case scenario, best case scenario is you get a sorted list and nothing ever has to shift, right? We get one iteration through, nothing moves and everything works great. So what's the average case scenario? Well, the average case scenario is that more or less, you're gonna have some sort of shuffled array."
          },
          {
            "time": "[00:05:03]",
            "text": "And most items gonna be compared against most other items and you end up with basically n squared. Now it is better than bubble sort coz it actually will do substantially left less work than bubble sort does. But it's still n squared, right? It's n squared with better coefficients."
          },
          {
            "time": "[00:05:25]",
            "text": "Now, why is this still a useful algorithm? Let's say that you had an array that you were getting back from your database and it was mostly sorted. Let's say you knew ahead of time that is a list of length 100, and you know for a fact 98 of those are gonna be in a sorted order."
          },
          {
            "time": "[00:05:46]",
            "text": "Insertion sort is really good for that, right? When you know that you have mostly sorted lists or totally sorted lists, insertion sort is really really good at handling those kinda situations and so that's when you would use an insertion sort over something like click sort and merge sort which have better average case but worst best case, if that makes sense."
          },
          {
            "time": "[00:06:13]",
            "text": "Spatial complexity we're still at constant time because we're not creating any additional stuff on the fly. I mean, I guess we have some swapping and moving to do but for the most part, we're doing that like we're doing what's in place, right? So we're having destructive sort. So that's not too bad."
          },
          {
            "time": "[00:06:35]",
            "text": "And I believe it is stable. Yeah. And yeah, insertion sort can be stable as long as you implement it as such. Okay. Does anyone have any questions about insertion sort?"
          },
          {
            "time": "[00:06:35]",
            "text": ">> I'm thinking it's like one of the interesting cases would be something like an event log from a server, where you think that it would be mostly sorted by time for example, but sometimes some events just don't follow the the order because the server received them a bit late and you have to fix those."
          },
          {
            "time": "[00:07:20]",
            "text": "Is that a good case for using something like this?"
          },
          {
            "time": "[00:07:20]",
            "text": ">> Yeah, I can see that something like where you're maybe getting network traffic from a server and maybe it's like a UDP so it can come out of order or something like that. I could see insertion sort being useful in that case, typically network traffic is a priority queue, right?"
          },
          {
            "time": "[00:07:43]",
            "text": "So some network traffic is more important than other pieces of traffic in which case, priority queues always go together with heaps. We'll be talking about heaps later. But in the strict case of like you're getting a mostly sorted list of traffic back and you wanna make sure that it's in the correct order or messages or something like that."
          },
          {
            "time": "[00:08:06]",
            "text": "Yeah, totally. I mean anything that's gonna be mostly sorted and you need it to be totally sorted cuz this is the perfect use case for that. And actually, sometimes we'll actually combine these sorts together. So you'll start maybe with an insertion sort, and if it goes for too many cycles, then you'll actually fall back into a like a quick sort."
          },
          {
            "time": "[00:08:30]",
            "text": "So, you'll see like, hey, maybe this is already sorted, we'll check. We'll do like three iterations. And if we get beyond that, it's like, okay, this is too unsorted. We'll break down into quick sort or something like that. So you can actually kinda combine these together to get the the best case scenario of an insertion sort, but also cover the average case with something like a merge sort of quick sort."
          },
          {
            "time": "[00:08:50]",
            "text": "So, we won't be doing that today but it actually might be a fun exercise for you to try as well."
          }
        ]
      },
      {
        "name": "9-insertion-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go ahead and give insertion sort of shot, you're gonna hear edit on code sandbox. We're gonna pop over to Insertion-sort. Can you ignore that part? So you'll have the test.skip here again, make sure you delete that and write your code. And your code is gonna go here into insertion sort, and yeah, go ahead and get started."
          },
          {
            "time": "[00:00:32]",
            "text": "So we're gonna pop into here, this is InsertionSort.test.js. And we're gonna have two for loops here. We have an outer one that's gonna loop over the array, starting with the first element in the array, right? Cuz the zeroeth element will be the sorted part of the array. [COUGH] And then we're gonna go inner loop that's going to go over backwards to find out where it should go."
          },
          {
            "time": "[00:01:05]",
            "text": "So we're gonna say for, let i = 1, i is less than nums.length, i++. And I'm gonna turn this off autorun, soft tab, okay? Then I will say let numberToInsert, so this gonna be like the number that we're gonna be comparing, = numbs(i). Then we're gonna say let j, cuz we're gonna keep track of that number as well."
          },
          {
            "time": "[00:01:52]",
            "text": "Here, we're gonna say for let j= or let's put just j, j = i- 1, nums(j) is greater than numberToInsert and j is greater than or equal to 0. And then at the end of every loop, we're gonna do j- -. Now again, there are multiple ways you can totally write this, this is just the way that I chose to do it."
          },
          {
            "time": "[00:02:26]",
            "text": "But here we're starting with j being 1 below the number that we're trying to insert. And then we're asking, is the number at that point, is that greater than number to insert? And is it greater than 0? And if not, then we're gonna just move the number to the side, right?"
          },
          {
            "time": "[00:02:53]",
            "text": "So we're gonna say nums(j + 1), Is gonna be equal to nums j, so this is actually moving the numbers backwards in the array. As soon as that's true, then we've arrived at the point that the number is ready to be inserted. So we're gonna say nums(j + 1) = numberToInsert."
          },
          {
            "time": "[00:03:25]",
            "text": "And again, if you arrive on the number where it's already in its correct place, this is just going to assign a number to itself, which is totally fine, no problems whatsoever. And then at the bottom, we just say return nums. That's it. So the outer loop which is going forward from assuming everything behind it, everything underneath i is going to be the sorted part of the array."
          },
          {
            "time": "[00:03:54]",
            "text": "And then we're gonna have j, which is going to work backwards through the sort of part of the array to us insert the next thing. So in theory, we should be able to put remove test.skip down there and run our tests. And hopefully, if we get into insertion sort, it looks like we are passing there."
          },
          {
            "time": "[00:04:14]",
            "text": "Pretty cool. So let's just go visualize that for funsies. Insert that, we're gonna pop over to sort here. And where are we gonna snapshot? We wanna snapshot, Probably every time at the end of this, right? Now this isn't truly ten comparisons going on. But you can kinda see here that you have here at the beginning of this, we can also snapshot beginning as well, just so we can see where we start."
          },
          {
            "time": "[00:05:10]",
            "text": "Snapshot numbs, So you can see here this three right now represents kind of the sorted part list. 2 gets inserted before the 0 at the beginning, and then A gets inserted the right place, then 5, right? And so you can kind of see that insertion going on until eventually down here, we end up with something that's sorted."
          },
          {
            "time": "[00:05:33]",
            "text": "Or we can do this for 50 or something like that to see something a little bigger. But you can kind of see this blue demarcate the sorted part of the list from the unsorted part, right? So everything before this 49 right here in this particular row, that's all sorted, 3, 4, 6, 7, 8, 16, and then everything after that is the unsorted part."
          },
          {
            "time": "[00:06:06]",
            "text": "Pretty cool, right? And then down here at the bottom, you can see we end up with a fully sorted list. The idea is that you are moving numbers forward in the array, so 40 gets moved to 8. Let's just make this bigger and let's make it smaller. So here, let's look at this line down here, the 0, 3, 4, 6, 7, 8, 9, right?"
          },
          {
            "time": "[00:06:41]",
            "text": "So, we have 2's that's gonna be the next number inserted into the unsorted part of the array. Everything 9 to 0 here, this is sorted. What it's gonna do on these iterations, in fact, let's just visualize that, I think this would work. We just say this is gonna get a lot bigger but snapshot(nums)."
          },
          {
            "time": "[00:07:14]",
            "text": "So you can kind of see here now we start having these redundant numbers, right, like 8 here. It's moving piece by piece the array forward until eventually we create the correct space. The down here after this for loop, kind of get rid of this, and move this over a little bit."
          },
          {
            "time": "[00:07:33]",
            "text": "So that this is moving everything forward 1, right, so 8 moves to here, then it moves to here, then here, then here, right? Until eventually, we arrive to this part of the code right here, line 18, which is actually just going to insert that number into the exact correct place."
          },
          {
            "time": "[00:07:51]",
            "text": "Does that make sense? So that's the actual part of the code that's moving numbers forward until you create the space where we're going to insert our new number. Hopefully, that makes sense. It's kind of abstract. It's better if I put it here. Yeah, again, you can see these numbers kind of where they're duplicated and they're moving, right?"
          },
          {
            "time": "[00:08:25]",
            "text": "So here, we've moved 5, 4, the number we're trying to insert right now is what? 9? Or something like that? We've kind of pulled that number out of the array and we're waiting to insert that. That number is being held here in number to insert and it's actually not being reflected in the array."
          },
          {
            "time": "[00:08:46]",
            "text": "That's why you see the duplication, until eventually we rereinserts that number here on line 18. Cool. I feel good about that explanation. [LAUGH]"
          }
        ]
      },
      {
        "name": "10-recursion",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, let's talk about our old friend recursion. I imagine many of you, whether you've gotten to a CS program or not have had to deal with recursion. Just by virtue like, it shows up somewhat frequently when coding. When I say somewhat frequently, I mean it rarely shows up but it does show."
          },
          {
            "time": "[00:00:17]",
            "text": "Let's go with that. So the idea with recursion is, what happens if you have a problem that's just really too big to solve, right? You're asked to sorta an array with a million numbers in it. Well, what you can do is, you can break that problem down into two problems, right?"
          },
          {
            "time": "[00:00:35]",
            "text": "So you can solve one for 500,000 and one for 500,000. Then you can continue splitting that down until eventually, you will end at a problem that you do know how to solve. And then you can re-stitch the solutions back together again. That's kinda the idea of recursion is like, break a big problem into two smaller problems, until eventually you have a small enough problem that you know how to solve."
          },
          {
            "time": "[00:00:57]",
            "text": "The entire gist of it. So, in English, if you recursively define something in English. Like here's my example here, what is a seafarer? It's one who fares the sea. Which is the most pointless definition of the word seafarer ever, right? But notice that I'm using the word seafare in the definition of seafarer, right?"
          },
          {
            "time": "[00:01:23]",
            "text": "It's something that's defined in terms of itself. Which in English doesn't really serve you too much, but in computer science it actually ends up being fairly useful. So, let's look at like the dumbest most pointless version of a recursive function encoding. I have this function here that all does is it logs out."
          },
          {
            "time": "[00:01:47]",
            "text": "This actually should be current, doesn't matter. In any case Notice that count To calls count To in and of itself, right? So, this function count To, is defined in terms of itself. So let's actually, I can even just copy and paste this, I'm gonna bring up my console here."
          },
          {
            "time": "[00:02:14]",
            "text": "And I'm gonna say function and I'm actually gonna modify this to say current, cuz that's actually what I meant. And I say count To (10). What do you expect this to do? I wanna think I have to give it a 0 or 1, something like that. What do you expect us to do?"
          },
          {
            "time": "[00:02:39]",
            "text": ">> [INAUDIBLE]"
          },
          {
            "time": "[00:02:39]",
            "text": ">> Yep, it's going to go count 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, right? There's no for loop in here though, how did that work? Well calls count To, and then eventually, it calls count To again. And it goes through this over and over again until I realize that this case right here if, and then it stops calling count To."
          },
          {
            "time": "[00:03:06]",
            "text": "So again, this is not a useful recursive function, but this is a recursive function in that, it's a function that calls itself. Now, I imagine most of you can imagine a better way of writing this, right. A simple for loop, a forereach, a map, any one of those things would have been clearer than this, abomination of code right here."
          },
          {
            "time": "[00:03:31]",
            "text": "But I wanted to demonstrate to you just basically that, you can make basically anything recursive if you really try hard enough. And, if you've ever written code or in languages like racket, or scheme, or Lisp. Or basically any Lisp, sort of oriented language, this is actually the only way of doing a for loop."
          },
          {
            "time": "[00:03:54]",
            "text": "Which is with recursion. Definitely not a scheme class. Though, I'll just toss out a recommendation. Not that I'm gonna teach you how to write scheme, but it made me a better programmer to go and learn a little bit of how to write scheme. So, and it's a fun weekend project."
          },
          {
            "time": "[00:04:13]",
            "text": "It's because it's a pretty simple language"
          },
          {
            "time": "[00:04:13]",
            "text": ">> Isn't map. You had a map function usually recursive by definition."
          },
          {
            "time": "[00:04:13]",
            "text": ">> The map function is recursive by definition. I don't think so, am I missing something?"
          },
          {
            "time": "[00:04:13]",
            "text": ">> I mean I've been dabbling with functional languages a lot recently, so I might be stuck in that space but"
          },
          {
            "time": "[00:04:40]",
            "text": ">> I mean it's more iterative, right? Cuz with a map function, you provided mapping which is then call on every single item the array. and function isn't calling itself, right? So that map is undefined in terms of itself. Which is what a recursive function is."
          },
          {
            "time": "[00:04:40]",
            "text": ">> I think since in functional languages, you don't have iteration."
          },
          {
            "time": "[00:05:04]",
            "text": "I mean, maybe that's the only way to make a map function in a functional language."
          },
          {
            "time": "[00:05:04]",
            "text": ">> Yeah, I guess if you're gonna implement map in something like Lua. Or not Lua, but Lisp, inherently because those languages model loops as recursion, then I guess it would have to be."
          },
          {
            "time": "[00:05:25]",
            "text": "So the question is, there's a couple of questions there. That's unpack it just a little bit. The first thing is, if I put in max as infinity. Yeah cuz it's never gonna stop counting, right. So, with normal recursion, this says this actually would just get tail called optimize it probably would, okay?"
          },
          {
            "time": "[00:05:50]",
            "text": "So you'd actually get an infinite loop and not a stack overflow, right? Because if it's tail call optimized, you'd be modeled as a loop and not a recursive function. So you'd actually end up in an infinite loop, which is maybe mildly better than a stack overflow. But, let's actually define both of those things."
          },
          {
            "time": "[00:06:08]",
            "text": "Infinite iteration, is when you have a loop that never ends, right? So, if I do a while loop like while true, right, that's an infinite loop. Something like this, while true, something like that, this would be an infinite loop cuz this would never end. Whereas if I count to here a max of positive infinity."
          },
          {
            "time": "[00:06:32]",
            "text": "That would also never finish, right? And that would be a stack overflow. Because eventually JavaScript engine just kinda gives up, like hey, you've taken all of my stack memory. I'm just gonna go puke in the corner basically. Now, let's talk about tail call optimization for just a second."
          },
          {
            "time": "[00:06:53]",
            "text": "One, it's still kind of a murky proposition in JavaScript, that it is part of ES 5 or ES 2015. But I don't think every engine implements tail call optimization yet. So in other words, don't rely on tail call optimization. And what tail call optimization is, if you make the last line of your recursive function, a return of your recursive call."
          },
          {
            "time": "[00:07:21]",
            "text": "Then technically a programming language can automatically turn that into a loop. Which is inherently faster and more memory efficient than a recursive call. So, I don't know if this does because it lacks return. That, if it would happen, I think it would. But it also depends on the engine, right?"
          },
          {
            "time": "[00:07:45]",
            "text": "I don't know if spider monkey does it, I don't know if he does it. Because there was always controversy of how to implement that. Anyway, that whole last part about tail call optimization, not something you really need to care about for the sake of this course. But it's something interesting, you can go read up on yourself on how to do it and what it is."
          },
          {
            "time": "[00:08:04]",
            "text": ">> What is the purpose of the list parameter, looks unused in this case?"
          },
          {
            "time": "[00:08:04]",
            "text": ">> It is, yeah. I was gonna have to populate that array there with the counted numbers and I did not take it out. So yeah, the list thing here is, pointless for the moment. When is recursion useful?"
          },
          {
            "time": "[00:08:25]",
            "text": "Well, when you find yourself in the definition of your problem. Modeling it in terms of smaller versions of the same problem, that's a good indication that your problem could be solved recursively. So one of the classic examples that people like to talk about with recursion, is something called the Fibonacci sequence."
          },
          {
            "time": "[00:08:47]",
            "text": "Now, again, I don't wanna veer too mathy here. But the idea of the Fibonacci sequences is, the Fibonacci(3) is the Fibonacci(2) + the Fibonacci(1). All right. And the definition of the Fibonacci (100) is, Fibonacci + 99 + the Fibonacci(98) + the Fibonacci(97)+ the Fibonacci(98). So on and so forth."
          },
          {
            "time": "[00:09:12]",
            "text": "That you can generalize as the Fibonacci(n), is the Fibonacci(n-1) + Fibonacci(n-2), right. And what is the Fibonacci(n-1)? Well, that's the Fibonacci(n-2) + Fibonacci(n-3), right? And you can kind of expand that out, to eventually you arrive at what the Fibonacci(2) is defined to be 1 and the Fibonacci(1) is defined to be 1 and the Fibonacci(0) is defined to be 0."
          },
          {
            "time": "[00:09:41]",
            "text": "Those are like kind of like the givens. So, as you might imagine the Fibonacci(3)= Fibonacci(2)+ Fibonacci(1). So the Fibonacci(3) = 2. The Fibonacci(4) would be the Fibonacci(3), which we just found out as 2+ Fibonacci(2)=1. What I just say, 3, 4. Anyway, it's kinda hard to keep all this in your head, right [LAUGH]."
          },
          {
            "time": "[00:10:18]",
            "text": "So, there are negative Fibonacci numbers, we're ignoring them. Please for the sake of this course, we're just talking about positive Fibonacci numbers. So, the first thing is, when you're talking about recursion is, always, always, always just define your base case first. The base case is when your your recursion stops, right?"
          },
          {
            "time": "[00:10:43]",
            "text": "Cuz if you don't ever stop your recursion, then you get stack overflows. So, for example up here in our count To, this if statement right here, is your base case. So, if current is greater than max, then return, right. That's when we've decided like, okay, we've satisfied all the conditions, we're now done, we're not recursing anymore."
          },
          {
            "time": "[00:11:07]",
            "text": "So, this is our base case that if n=2, look at this one, equal to 2 or equal to 1, then return 1, otherwise return 0. So we have the n=2 or the n=1. Don't click on it. So the base case here is that we return 1 and if we somehow end up on 0, we shouldn't end up on 0."
          },
          {
            "time": "[00:11:28]",
            "text": "But if we did, then you return 0. Okay? And then we just define the Fibonacci in terms of what our definition was. So the Fibonacci(5) is the return the Fibonacci(5-1), which is 4, and (5-2), which is 3, right. Which then calls this, until eventually those arrive to their base cases."
          },
          {
            "time": "[00:11:48]",
            "text": "And then, those return until eventually we kind of add all those numbers up and we end up with the correct answer."
          },
          {
            "time": "[00:11:48]",
            "text": ">> So, Fibonacci(2), right. That makes sense. So on and so forth. So you can see here, 2+3= 5, 3+ 5= 8, 5+ 8= 13, 8+13=21. Okay? Let's break this down into what the calls actually break down into, you'll often see recursion modeled as like a tree."
          },
          {
            "time": "[00:12:35]",
            "text": "Because essentially that's what it's kind of breaking itself down into. So, here if I call Fibonacci(5). This is gonna call this and it's gonna call Fibonacci(4), which is this call. And Fibonacci(3), which is gonna be this call. And that's gonna break down into these various different calls. Fibonacci(4) is gonna call 3 and it's gonna call Fibonacci(2) which is 1, right?"
          },
          {
            "time": "[00:12:59]",
            "text": "And then Fibonacci(3) will break down into 2 and 1, these are both 1. So this is gonna be 1+1, which is gonna return 2+1, which is gonna be 3. So, Fibonacci(4)=3 and then Fibonacci(3) over here, is gonna be 1+1, which is 2. And then these two are gonna add together, which is 3+2, which is gonna be 5."
          },
          {
            "time": "[00:13:20]",
            "text": "Now, at the end of the day, what did I end up doing? I ended up adding 1 to itself a whole lot, right? This is a whole lot of adding 1 together. So, if I end up doing something like, Fibonacci(15), which is a fairly large number. 610, how many times did I add 1 to itself?"
          },
          {
            "time": "[00:13:42]",
            "text": "610 times, right. 16, right 987. If start getting into really big numbers of Fibonacci, it gets kinda ugly. Notice how long that took, it's not instant. I did 35 there and it took a good worth. 2 seconds of my very good MacBook to compute that, right. So, as you can see here, this is actually super inefficient."
          },
          {
            "time": "[00:14:18]",
            "text": "But the code here is really quite nice, right? In the sense of like, it's kinda elegant in the sense of like, it's fairly easy to read that the Fibonacci(5) is gonna be the Fibonacci(4) + Fibonacci(3). So, you'll find this is frequently the case with recursive calls is. It might not be the most efficient way of doing things, but you can often end up with fairly elegant looking code."
          },
          {
            "time": "[00:14:46]",
            "text": "Now, what's the shame about this? We have Fibonacci(3), how many times do we call Fibonacci(3), instead of the Fibonacci(5)? At least twice, right? Well, exactly twice. But imagine when we call Fibonacci (15), how many times do you think we call Fibonacci (3)? A lot. Does the Fibonacci(3) change over time?"
          },
          {
            "time": "[00:15:13]",
            "text": "No, the Fibonacci(3) is always defined to be 2. So, this would actually be pretty effective if we did something called memorialization. Where we could actually say, hey, once you've completed the Fibonacci(4) to be, whatever it is 3, don't compute that anymore, right? It's always gonna be that, so if you ever see that again, just return the same answer that I got last time."
          },
          {
            "time": "[00:15:36]",
            "text": "So, not necessary the point of this course but I just wanted to call out that this would be a perfect case for a memorization. You can rewrite Fibonacci as in a for loop instead of as a recursion, right. And you end up with code that looks like this, which is just numbers adding itself together, right?"
          },
          {
            "time": "[00:16:05]",
            "text": "It's a little less clear, I might argue that this code might be easier to read, right? But this is, 500 times faster and probably even more than 500 times. So if I call here, let's see, Fibonacci(16) or Fibonacci(35). Notice how much faster this is going, let's do 100."
          },
          {
            "time": "[00:16:33]",
            "text": "Notice that this is just kicking out huge numbers really quickly. If you did Fibonacci(100), with the previous way that we had defined the Fibonacci sequence, it probably would have crashed my browser. So, it's another one of those things where in this case, the iterative approach is so much better."
          },
          {
            "time": "[00:16:50]",
            "text": "It's probably almost always going to be the correct answer. And this isn't terrible code. I might read some comments in there, but in general this is gonna be better. But, yeah this is to say that, frequently recursive problems can be rewritten as iterative solutions but not always."
          }
        ]
      },
      {
        "name": "11-recursion-practice-nested-addition",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So another really good use case for and this would work iteratively as well the recursive this would be a really cool solution. Let's say you had all of these numbers here and they were arbitrarily nested, right, like you can see here, this 14 here is pretty nested."
          },
          {
            "time": "[00:00:15]",
            "text": "You can write this as iterative and you can unwrap arrays and things like that. You could also just call a recursive add call on all of these, and these would work really well. So let's actually give you a shot at doing this. So I'm gonna go edit here on SandBox."
          },
          {
            "time": "[00:00:37]",
            "text": "And we're gonna pop over to code sandbox here. And we're gonna go to files. And we're gonna go to nested edition. So it's in recursion. There's one here called nested arrays.test.js. And what I want you to do is I want you to go and write code in a recursive fashion that takes all the numbers in the array and adds them together, right."
          },
          {
            "time": "[00:01:11]",
            "text": "So this should be 10 + 12 + 14 +1 + 16 + 20 + 10 + 11. And I want you to use recursion. So one you can definitely use flat and that's cheating. Do not use flatten for this, or flat or smush depending on when you started writing JavaScript, but I don't want you to do that."
          },
          {
            "time": "[00:01:41]",
            "text": "I want you to write this with recursion, so we're gonna give you just a bit of time for this. But just think about first what's your base case? In this case your base cases if you're adding a number right and not adding an array of arrays when you recurse more, right?"
          },
          {
            "time": "[00:01:58]",
            "text": "And then yeah, then you can just go into return a number at the end. I remember the first time I learned recursion and I was a buddy young lad young strapping lad in Bountiful, Utah. My brother would make me write code before I could play video games. And just the moment that it clicked for me is wait, I call the function inside of itself, the call is coming from inside the function."
          },
          {
            "time": "[00:02:30]",
            "text": "That's funnier than I thought it'd be. Anyway, I don't know. It just melts my mind. It made me feel like I had superpowers. So it was cool experience for me. Hopefully it's a cool experience for you. Imagine some of you probably have written recursive functions before but for some of you might be a really cool experience."
          },
          {
            "time": "[00:02:48]",
            "text": "All right, so I'm gonna have ,let some function, equals 0, and I'm gonna say 4 let i equals zero, i is less than array.length. I plus, plus And I'm going to say const current = array[i]. And then I'm going to say if array.isarray. This is just a nice little helper function that lets you check if something's an array."
          },
          {
            "time": "[00:03:35]",
            "text": "Then we need to recurse, right? So when I say sum, plus equals, whatever comes back from nested add of current, right? Else otherwise it's the number you can assume it's always a number. Sum plus equals current and we keep on our merry way with our for loop. Then down here we're gonna say return sum."
          },
          {
            "time": "[00:04:07]",
            "text": "So our base case, interestingly enough is not at the top. I would say frequently is at the top. I would say usually is at the top. But in this particular case, it wasn't, okay, but the base case is here, which is to say that it's not an array."
          },
          {
            "time": "[00:04:23]",
            "text": "Right and then we keep going. And then here you can see it's gonna come down with the nested data and it's gonna call this again and again until we eventually get our answer. So let's try this, make sure that it works the way that we think it should."
          },
          {
            "time": "[00:04:44]",
            "text": "And recursion, nested arrays, and it works. Now you absolutely totally could do this with iteration and just on unpacking arrays that way, but this is actually a nice elegant solution that we use this nested add function and I would say this is totally fine. You might get a little bit more performance out of a Iterative solution, but even for pretty deep arrays this should be plenty fine."
          },
          {
            "time": "[00:05:21]",
            "text": "So any questions about nested AP?"
          },
          {
            "time": "[00:05:21]",
            "text": ">> What would be the time complexity for this?"
          },
          {
            "time": "[00:05:21]",
            "text": ">> Good question. The time complexity."
          },
          {
            "time": "[00:05:21]",
            "text": ">> [INAUDIBLE]"
          },
          {
            "time": "[00:05:21]",
            "text": ">> Yeah, so what's the time complexity of our solution here? This is an interesting one to model because the depth of the recursion is not gonna be dependent on how long the array is, but the depth of the recursion is gonna be determined by how nested these arrays are, right?"
          },
          {
            "time": "[00:06:03]",
            "text": "So you can see here this only has of length one but it's nested a whole bunch, right? So we'd actually probably have to introduce some sort of third variable here or second variable. So we have n, typically the next thing you introduce is k, right? So this would probably be of complexity n because we would have certainly have to link loop over everything in the array, plus we'd probably have to times it by k, which would be the depth of recursion."
          },
          {
            "time": "[00:06:32]",
            "text": "So n k probably might need to check me on that one. It's kind of hard to model some of these things as big O because some of them don't lend themselves super well the big O analysis but that would be my guess"
          }
        ]
      },
      {
        "name": "12-recursion-practice-factorials",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's hop back over to our recursion. I wanted to give you a couple of examples here. Just because we're about to hop into some really heavy recursion, so I wanted to make sure that I really hammered home that you got recursion done pretty well. So, I'm actually gonna have you do another exercise in recursion."
          },
          {
            "time": "[00:00:21]",
            "text": "So, we did up here, fibonacci. Right? Which the definition of fibonacci is n-1 + n-2. Of the Fibonacci calls. Factorials are pretty similar, that if you have 5 exclamation point which is how you write factorial. A factorial is defined by n(n- 1) factorial. So, the factorial of 5 is 5 times the factorial of 4."
          },
          {
            "time": "[00:00:54]",
            "text": "Factorial, right? So what this actually ends up being is, if I have 5 factorial, let's see. 5 factorial is going to be equal to 5x4x3x2x1, right? Because 5 factorial is the 5 times 4 factorial. And he 4 factorial is this right? And then 3 factorial is this. And then 2 factorial is this."
          },
          {
            "time": "[00:01:44]",
            "text": "Does that makes sense? So again, this would actually be even easier to write as an iterative solution. But I want you to write this in recursive solution that it's the factorial 5 is 5 times factorial 4. And then the factorial of 1 is just defined to be 1."
          },
          {
            "time": "[00:02:05]",
            "text": "But let's pop over here to the test. Talk about what's going in here. What's your base case?"
          },
          {
            "time": "[00:02:05]",
            "text": ">> One."
          },
          {
            "time": "[00:02:05]",
            "text": ">> Yep. Good call. It's gonna be 1 and that's just, you can return 1. [COUGH] Then on your return call, like whenever you're gonna do the recursion, how many recursive calls you're gonna have?"
          },
          {
            "time": "[00:02:29]",
            "text": "Just one, right? Whereas Fibonacci was the Fibonacci of 5 is the Fibonacci of 4 plus a Fibonacci 3. The factorial 5 is 5 times the factorial 4, right? So you actually have one recursive call as opposed to Fibonacci where you had two. So first thing, base case, if num is greater than 2, sorry, less than 2 rather, less than 2 Return 1."
          },
          {
            "time": "[00:03:05]",
            "text": "Otherwise, we're just gonna return num times factorial of num minus 1. Or n here. Here we go. Whatever you call it, that there. So let's go back to num cuz I think that's clear. Well, maybe not. Anyway. So let's go ahead and try and run these tests. We'll click play here Play and then down here on recursion factorial, you'll see that we passed our test."
          },
          {
            "time": "[00:03:48]",
            "text": "So again, this would be 100 times faster if we wrote this in terms of a loop not in terms of a recursive function, but I find this pretty descriptive of what it is right? It's number of times factorial of n-1. These still kind of have to get that like Brainspace have, this is the body of a one part of the function, right?"
          },
          {
            "time": "[00:04:13]",
            "text": "So this factorial function actually does more work than just the two lines inside of it right? Because this is still gonna run several essentially iterations of it several levels of recursion. Cool. Any questions about factorials or recursion or anything like that? So the question is. It can get pretty hard to conceptualize what's happening in the middle of recursion, right?"
          },
          {
            "time": "[00:04:44]",
            "text": "It's hard to keep all that stuff in your brain because our brains don't really think in recursive manners right we think. Think very much in a linear imperative way of thinking. So coming into this more, I would say it's slightly more declarative. This slightly more abstract way of problem solving can be quite difficult."
          },
          {
            "time": "[00:05:05]",
            "text": "So what kind of tips and tricks do I have? Working through it one, just accept that it's kind of hard and that your brain is not built that way. Right? So, if it feels hard, that's because it just is hard. Okay? That's the first thing. The second thing that I'll tell you is, the first I try when I'm starting to write a recursive function."
          },
          {
            "time": "[00:05:23]",
            "text": "What's the base case? That's the first question that I asked myself. And where's the recursion happening? Typically at the end, not always. I try and get those kind of pieces down first. And that kind of like, frames my brain in terms of like, okay, here's what I'm done."
          },
          {
            "time": "[00:05:40]",
            "text": "And here's when I recurs that kind of provides a base level structure of what I'm expecting to get done in any level of recursion. The other thing that kind of helps me is when I'm writing this factorial function on line 15. It's kind of hard to accept that's going to return the right thing because I haven't necessarily completed writing that yet."
          },
          {
            "time": "[00:06:07]",
            "text": "But what you need to do is think, if I call factorial n-1 I need to assume that what comes back from that is correct. So you need to before you have finished writing the function assume that it's going to give you back correct output. So kind of building that base level assumption into your coding helps me kind of move forward because sometimes I get hung up is like well If I haven't written factorial yet, then how is factorial gonna give me the right answer?"
          },
          {
            "time": "[00:06:37]",
            "text": "And you kind of have to work backwards from okay, assume everything is correct. Now we need to go forward and actually make it correct. So I don't know those are my three best shots of providing you some sort of structure to it. Sometimes it helps to get on a whiteboard and just kind of diagram out the calls, right?"
          },
          {
            "time": "[00:06:58]",
            "text": "Like, model it as a tree. That certainly helps as well. Certainly when I was in college, I had a huge whiteboard my room and I just would just diagram everything out. But you can do that with paper and things like that. That always helps as well. Anything that you can do to make the abstract more concrete in your brain is just gonna help."
          },
          {
            "time": "[00:07:20]",
            "text": ">> Thank you."
          },
          {
            "time": "[00:07:20]",
            "text": ">> Yep."
          },
          {
            "time": "[00:07:20]",
            "text": ">> [INAUDIBLE]"
          },
          {
            "time": "[00:07:20]",
            "text": ">> Yeah, no problem. Any other questions?"
          },
          {
            "time": "[00:07:20]",
            "text": ">> Yeah, I got a question. So based on your explanation, I guess it's a good idea to think about recursion as a promise like, well, yeah, that'd be correct assumption."
          },
          {
            "time": "[00:07:20]",
            "text": ">> Yeah, based on my explanation, it'd be correct to think of recursion as a promise almost."
          },
          {
            "time": "[00:07:43]",
            "text": "I mean, promise in the sense of you'd get to treat it like something good is going to come back from it. Yeah, definitely. It's not asynchronous. All right."
          },
          {
            "time": "[00:07:43]",
            "text": ">> [INAUDIBLE]"
          },
          {
            "time": "[00:07:43]",
            "text": ">> Yeah, it's a future value for sure. But yeah, I just wanna make sure that people aren't getting caught up that it's not asynchronous, right?"
          },
          {
            "time": "[00:08:04]",
            "text": "So the question is here inside of this nested array, it's const current equals array. And then it's gonna recurs, and call it again. Well, because those are different contexts. It'll be fine."
          }
        ]
      },
      {
        "name": "13-merge-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is a recursive sort, this one's pretty difficult. I would say this is gonna be the first very challenging thing that I'm gonna have to do during the body of this course. So if this feels hard, it is hard, so I just want to give you permission before hand to be okay that this is gonna be hard."
          },
          {
            "time": "[00:00:22]",
            "text": "All right, so let's apply a recursion to sorting a list. Kinda like insertion sort, where you assume that a list of 1 is already sorted. We're going to take that and we're going to apply that to sorting. So the idea here is that we have a list of length 10."
          },
          {
            "time": "[00:00:44]",
            "text": "And we're going to take that and break that into two lists of length 5. And then break that again into things of two and three, and then eventually you're going to break everything down into lists lists of length one, right, using recursion. Once you arrive to a list of length one, that list is sorted."
          },
          {
            "time": "[00:01:02]",
            "text": "That's the base case, right? So you return that list of length one, and then you're going to stitch together in a sorted fashion. The two lists that are coming back, right? So if I get a list of length one and a list of length one, those are two sorted lists and then I can write a merging function that's gonna take two sorted lists and stitch them together."
          },
          {
            "time": "[00:01:26]",
            "text": "So let's see if I can kind of show you this a little bit. So let's say I called merge sort on this function here of 1,5, 7 ,4, 2, 3,6. Okay, I'm then going to call merge sort on 1,5,4,1,5,7,4 and 2,3,6. Okay, then I'm going to do this part first, right, because that's how the recursion is going to go, right?"
          },
          {
            "time": "[00:01:53]",
            "text": "It's going to go down one side and it's going to kind of go through the various different parts of the the tree. Okay, so I'm gonna take this list merge 1,5,7,4, that's gonna be broken down into merge sort of 1, 5, which also be broken down into this, but we'll do the first one first, then that's gonna be broken down into merge 1."
          },
          {
            "time": "[00:02:12]",
            "text": "We're sort of 1 and merge sort of 5, so you can see here we're three levels deep in our recursion. Okay, so so far all we've been doing, we haven't been doing anything other than just breaking big arrays down into smaller arrays. Okay, so we hit here one is of length one, this is the base case, right?"
          },
          {
            "time": "[00:02:35]",
            "text": "So this level of recursion is just going to return back up so returns the sorted list of one. Okay, then it's going to call this one over here, merge sort of five. So, this is of length one, this is the base case, and it's going to return. So now we have merge sort on both of these from depth 3, they're gonna be returning back up to depth 2."
          },
          {
            "time": "[00:03:00]",
            "text": "So now we're gonna call this merge function. Notice that merge sort and merge are slightly different. Merge sort, this is a recursive function, merge is not a recursive function. Merge is just a function then you're gonna write that you pass in two sorted lists. Now I'm extra emphasis on sorted, right, it has to be already sorted or all of our assumptions about this are gonna break down."
          },
          {
            "time": "[00:03:29]",
            "text": "So what merge does is it just, again merges together two sorted lists will basically just iterate through both of those lists and say, all right is 1 or 5 smaller? Want a smaller, add it to the sorted lists, right? So, once the one of the arrays is empty, then you can just add everything on the right array."
          },
          {
            "time": "[00:03:47]",
            "text": "So, in this case it's just 5, right, so, then we return back here. 1, 5 that's a new sorted list, right, that's what that merge algorithm does. It just takes two sorted lists makes one sorted list returns that. Okay, so now we have the sorted list of 1, 5."
          },
          {
            "time": "[00:04:08]",
            "text": "Notice that that's actually originally what it was. But it doesn't know that until it's actually run the whole gambit of merge sort. Okay, so now it's going to pop back up to here because this part returned, right merge 1, 5, due to how recursion works, right? This is now finished, it's, returned back and it returned this 1,5, all right."
          },
          {
            "time": "[00:04:35]",
            "text": "So now we're popping back up here to depth 2 and we're going to run merge sort on 7, 4. Okay, so that's going to get broken down again to merge seven and merge four. Sorry, merge sort 7 and merge sort 4, these are gonna be base case, base case there, and then those are gonna get returned back, and that's gonna merge, it's gonna get called on this list and this list, right?"
          },
          {
            "time": "[00:05:05]",
            "text": "So you're gonna ask the question, is 4 or 7 smaller, 4 smaller so you get this in the new array. Right arrays now empty, right, this one's now empty. So we can just blindly concatenate everything that's left in the left array. That's just one item, right, so now we have 4, 7, okay."
          },
          {
            "time": "[00:05:25]",
            "text": "Now we return that back, that gets returned back up to here, right, this level. So now we're gonna call merge on these two lists, right, the, 1,5 which we got from up here. And the 4, 7 that we got here, again, very critical, these are both sorted and we know that, is 1 or 4 smaller?"
          },
          {
            "time": "[00:05:54]",
            "text": "1, you add 1, is 5 or 4 smaller, because we're just going down the list here, right? So we go to here and we're comparing 5 to 4, you say 4 is smaller, so we have 1, 4 here. Then you ask is 5 or 7 smaller, 5 is to get 1,4,5 and then left to raise now empty, which is, cause all that's left is 7, right?"
          },
          {
            "time": "[00:06:18]",
            "text": "And then you just add that to the race, so now we have a larger list of 1, 4, 5,7. Okay, and it's just this, right, all you're doing is breaking everything down to small problems and building them back up and you're building them back together by using merge, right?"
          },
          {
            "time": "[00:06:38]",
            "text": "I also see people call merge stitch, right, because you're stitching together two sorted arrays. So 2,3 ,6 that's gonna get broken down to 2 and 3 and 6, 2 and 3, 2 is base case 3 is base case. Then we're going to call merge 2 and 3, then out of that we get returns sorted array."
          },
          {
            "time": "[00:07:00]",
            "text": "This should be 2,3, not 2,4, but yeah, 2,3 right there. Merge sort of 6, that's a base case, we return that, so now we're gonna merge together 2, 3, and 6, right? And by the end of that we get this return sorted array 2, 3, and 6, right?"
          },
          {
            "time": "[00:07:21]",
            "text": "So now we're back up to the point of here at the beginning, we have merge this and merge this, right. So that's what this is, and this is where we get our really big stitch together is 1 or 2 smaller 1 for 2 smaller 2 is 3, or 4 smaller 3."
          },
          {
            "time": "[00:07:42]",
            "text": "And you can see together this gets stitched all the way until it is that the right away gets empty and we concatenate everything in the left array, and we end up with 1, 2, 3, 4, 5, 6, 7. So that was a long journey, thank you for sticking with me."
          },
          {
            "time": "[00:08:02]",
            "text": "That is the entire algorithm, right, you have two functions you have merge sort and merge, the only thing that merge does is it takes two sorted lists and makes one sorted list. That's all merge does, it's totally blind to the rest of the world, doesn't care, not recursive."
          },
          {
            "time": "[00:08:19]",
            "text": "It's just one simple function that takes two sorted lists and makes one sorted list. And then you got merge sort that all it does is it breaks big arrays down into smaller arrays and then it concatenates the things that come back from its merge sort recursive calls and passes those into merge."
          },
          {
            "time": "[00:08:40]",
            "text": "So here's kind of a visual representation of it. And you might be asking, do I put does the left array have to be bigger than the right array, right? This one is a length 4, this is like 3, it doesn't matter, right? You can even be inconsistent, it doesn't matter."
          },
          {
            "time": "[00:08:58]",
            "text": "Okay, so this breaks this down into eventually lists of length 1, and then it stitches them back together. Until eventually you end up back here with a sorted list."
          }
        ]
      },
      {
        "name": "14-merge-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What is the big O here? The nice thing about Merce sword is every case is the worst case scenario. Every case is the best case scenario. Every case is the average case scenario. There's no difference between the best and the worst case of merge sort, right? Imagine if this was just 1, 2, 3, 4, 5, 6, 7, right?"
          },
          {
            "time": "[00:00:24]",
            "text": "This still would just get broken down into seven arrays and then stitched back together. It actually makes zero difference to merge sort. If it's reverse sorted, sorted, shuffled all those things you end up with the exact same algorithm. So that's goodness, right? That's good news. That's why most JavaScript engines like spider monkey v8."
          },
          {
            "time": "[00:00:49]",
            "text": "JavaScript core, most of them use merge sort under the hood. So if you call .sort or they're probably calling merge sort. They might be calling quicksort sometimes. We're about to do quick sorts so don't worry about that. So that's the good thing about merge sort is like, it's just a solid."
          },
          {
            "time": "[00:01:11]",
            "text": "If you don't know what's coming in Mercer is always a safe bet that like this is going to be pretty performant. So, let's talk about the big O of what it is then. Does every number get compared to every other number in the array? No it doesn't. Because we're using the fact that, if you have one sorted array, and you have another sorted array."
          },
          {
            "time": "[00:01:45]",
            "text": "If 1 is smaller than 2, then I know that everything else in the array doesn't have to be compared to 1 right? 1, by being smaller the 2 is also smaller than 3. And also smaller than 6. So I'm taking a shortcut here that by knowing that 2 is larger than 1, I also know that everything else in that array is also bigger than 1."
          },
          {
            "time": "[00:02:09]",
            "text": "So I'm skipping a bunch of comparisons that I otherwise would have to do. And the more and more things I throw at Mercer sort so if this ends up being of length 200 and this is of length 200. If one is smaller than two, then I know that I don't have to compare one to the other 199 elements in there right?"
          },
          {
            "time": "[00:02:28]",
            "text": "I'm skipping a lot of comparisons. So you could say this grows logarithmically, right. By having more and more I get the economies of scale and I don't have to make all those comparisons. So I still have to look at everything once. Every number gets looked at which says that it's end, right?"
          },
          {
            "time": "[00:02:51]",
            "text": "But I don't have to compare every number to every other number, which is not, means I don't quite get to n, I get to log n. So that's the big O of this computational or this time complexity here is n log n. Let's see how I wrote that."
          },
          {
            "time": "[00:03:09]",
            "text": "So I don't know where it is anyway. This is n log n computational complexity. Because you have to look at everything at least once. That's just the virtue of sorting is that every number has to be at least looked at, which means that you're looking at everything once."
          },
          {
            "time": "[00:03:27]",
            "text": "But you're not comparing one thing to everything else which makes it log n. As opposed to Insertion Sort, which it's worst case scenario. Every number is compared to every other number. That's why that's n squared. So the trick here for n log n kind of sorting scenarios is that you're looking for recursion."
          },
          {
            "time": "[00:03:49]",
            "text": "It's not always gonna make it log n but very frequently makes it log n. Okay, spatial complexity, notice here that we're creating a lot of arrays, right? We're breaking up one array down into a bunch of other arrays. That means that we are no going to have constant spacial complexity, we're actually going to have some spacial complexity here."
          },
          {
            "time": "[00:04:16]",
            "text": "In fact, mercer ends up being one of the worst ones because if you look here, every number gets at least one array created for it. So if it's a one-to-one mappings that means it's n right? So it's spatial complexities its' n. So for example, if you're on the ps3 and we were sorting huge numbers of numbers merge sort might be a bad idea, right?"
          },
          {
            "time": "[00:04:42]",
            "text": "Because it uses so much space. Might not be, but who knows. So space complexity is n. All right, so let's pop over to our code sandbox. We're gonna be here in Merge Sort. The sort visualizer will not work for merge sort or quick sort, because I didn't have a good way of breaking down the snapshots very well."
          },
          {
            "time": "[00:05:18]",
            "text": "So I just didn't try. So why don't we go ahead and give Mercer sort a shot? What let's just like quickly go over the base case, the base case is what you get an array of length 1 or 0. It should always be length 1 but just say length 1 or length 0."
          },
          {
            "time": "[00:05:39]",
            "text": "Then you just return that array. You don't do anything to it. That's the base case. You're gonna have to split the array into, you're gonna call merge sort on the left side, you're gonna call merge sort on the right side. And then you're gonna write another function const merge equals sorted array 1, sorted array 2."
          },
          {
            "time": "[00:06:02]",
            "text": "And that is going to return one sorted array. Let's actually just I'm going to just diagram this out for you. Here are you going to base case Return if length 1 or 0. Break into two smaller arrays. Call, mercer sort on left and right. Here, I'm just using terms left and right."
          },
          {
            "time": "[00:06:40]",
            "text": "You can call them array one, array two, array A, array B. I don't know why I like having some like cardinality to it of like this goes left, this goes right. In reality that doesn't make a difference. It does make a difference in Quicksort it doesn't emerge sort, okay?"
          },
          {
            "time": "[00:06:57]",
            "text": "And then you're gonna return the merge of left and right. So the first thing we want to work on is the base case, right? So, If nums.length is less than 2. So if it's of length 1 or length 0 cuz you can't have length negative of arrays, then we're going to just return."
          },
          {
            "time": "[00:07:26]",
            "text": "It's already sorted but we're not gonna do anything. I think to it. This is the base case. Everything's good. I'm going to break this into a little bit easier to read logic here. So I'm going to say cons length equals num sort length. Cons middle equals math.floor length divided by 2."
          },
          {
            "time": "[00:07:57]",
            "text": "So math dot floor if you don't remember, always rounds down on a number right? So if this is of length 7, then middle is going to come back as 4. Constant left equals nums.slice, 0 to the middle. slices, if you don't remember is going to return to a sub array."
          },
          {
            "time": "[00:08:25]",
            "text": "So this is going to be the smaller left array which is gonna be from zero to the middle of the array. And then const right is going to be nums slice. And we can if we just give it middle, then it'll automatically go to the end, right? So this is gonna be everything on the left."
          },
          {
            "time": "[00:08:45]",
            "text": "This is gonna be everything on the right Now you say const sorted, left equals merge. Sort left, const sorted, right equals merge, sort, right? And then down here, we're just gonna say return, merge, sort of left, sorted, all right. Cool? That is all you need to do. Put this above here so the comments are in the right place."
          },
          {
            "time": "[00:09:42]",
            "text": "That's all merge sort is break things down into smaller arrays and then merge them back together. So, merge, I'm just going to call this left and right, that's a bit easier for me to think of. But just again, just reiterating and I keep repeating and the reason why I keep repeating this because I forget."
          },
          {
            "time": "[00:10:02]",
            "text": "Left and right are already sorted. Just let's make a be abundantly clear it's you need to merge doesn't work if left and right aren't already sorted. So you don't have to handle the case of what happens if left or right is unsorted. That means something else broke, something else broke somewhere else."
          },
          {
            "time": "[00:10:24]",
            "text": "Okay const results. There's gonna be an empty array. And then I'm gonna do this with kinda a fun way, which I'm gonna say while left.length and right.length. And I'm gonna say if left of 0 is less than or equal to right 0. Okay, then we're gonna say results.push, so we're gonna put on the end the front of left."
          },
          {
            "time": "[00:11:08]",
            "text": "So we're gonna say left.shift. And again, JavaScript has weird naming for these kind of things shift is like popping off the front right? CF pop which removes the last item of the array and returns it. Shift does it from the front, right? Other languages will call this dq, right?"
          },
          {
            "time": "[00:11:29]",
            "text": "I guess it depends depends on what the language is trying to do anyways. Suffice to say shift removes the first item in the array and returns it. So this is gonna take the front item off of the left and push it on the end of results, okay? Else, we're gonna say results.push, right.shift, because we're not taking the left thing, we're gonna take the right thing, okay?"
          },
          {
            "time": "[00:11:57]",
            "text": "Now again, we're removing things from left and right eventually we're going to run out of things right? Either left is going to empty or right is going to empty first right? One of them by definition of what we're doing here. This is gonna break and one of them is still gonna have stuff left in it."
          },
          {
            "time": "[00:12:15]",
            "text": "So what we can do after that is we can say return results.concat left and right. Now why does this work? Results is gonna be an already sorted list that was building, and one of left and right is gonna be empty, right? What happens if you call a concat on an empty array?"
          },
          {
            "time": "[00:12:40]",
            "text": "Nothing, right, nothing happens cuz it's empty and there's nothing to concat. So one of these is just going to concatenate all of its numbers, right? And we know everything that's left is going to be larger than what's already in results because it's at the end of that array."
          },
          {
            "time": "[00:12:53]",
            "text": "So it makes sense. I mean you can have this keep going until they both have. If you did this instead or, You'd have to mess around here with the if logic to say like, if left out length and right.length and left is smaller than right, right? Then do that."
          },
          {
            "time": "[00:13:20]",
            "text": "But we don't have to do that because we're just going to do this concut down here and this'll work. Okay, that is all of merge sort. I mean, that's what nine to. 30 some odd lines of code, some of the white-space it's, I mean, let's go ahead and run and make sure that I'm not pulling your leg here."
          },
          {
            "time": "[00:13:53]",
            "text": "But if we go down to merge sort doesn't feel like running it right now. Merge sort, and I'm doing skip down here. So that's actually correct. And now I try running it again. Merge sort is passing. So again this is hard, right? If you didn't quite get it, or if you struggled with this, there's a lot of abstract stuff going on here."
          },
          {
            "time": "[00:14:26]",
            "text": "And I can only do this with some ease because I've done this so many times. Because I've taught it to a lot of people."
          }
        ]
      },
      {
        "name": "15-merge-sort-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the question is is on line 40? Here, why are we concatenating left and right? And the answer to that question is one of these is empty left and right, right? So, we just need to make sure that those results get concatenated onto the end of results so that we capture all those numbers, because we know everything that's in that's left in either left or right is by definition gonna be larger what's already in results, which is why we can just freely concatenate what's ever in there."
          },
          {
            "time": "[00:00:30]",
            "text": ">> I just was wondering like what's, like the policy for using built in JavaScript functions? Like cuz I seen the other problems and stuff and different solutions where some use built in JavaScript methods like reverse shift here. And then others trying to find solutions that are just more basic."
          },
          {
            "time": "[00:00:56]",
            "text": "Yes. Just wondering what, in your experience, what does that look like?"
          },
          {
            "time": "[00:00:56]",
            "text": ">> So I think the question is, in particular around push and shift here. And the question being like, what's our policy? What's the recommendation of when you can use shift and push and when should you drop into something lower and maybe do the direct manipulation yourself because the, yeah, this shift functionality could actually be quite inefficient in terms of how, it depends on how the array is implemented."
          },
          {
            "time": "[00:01:33]",
            "text": "In this particular case, I just want you to learn. So if you understand that stuff is coming off the front, we could have done this with counters and said, and have two, four loops and an ion and a jade that's moving forward and that would have probably been more efficient in terms of not Jocelyn the arrays around."
          },
          {
            "time": "[00:01:54]",
            "text": "That's fine. If you wanted to do that that makes sense. It probably will be more efficient. In this particular case, I just want you to learn how the algorithm works and I'm not interested in having the absolute most effective way of doing it. So it depends. Sorry, I apologize that that is the answer yet once again."
          },
          {
            "time": "[00:02:14]",
            "text": "If you are extremely sensitive to performance, then these are things you have to worry about. If you're not, then I'd say this is more readable then trying to keep track of two counters."
          },
          {
            "time": "[00:02:14]",
            "text": ">> Okay, that makes sense."
          },
          {
            "time": "[00:02:14]",
            "text": ">> Yep, good question."
          },
          {
            "time": "[00:02:14]",
            "text": ">> Yeah, I tried my hand in fighting the merge part of this thing and I recursive styles."
          },
          {
            "time": "[00:02:37]",
            "text": "Well,"
          },
          {
            "time": "[00:02:37]",
            "text": ">> I guess yeah, I guess you could, instead of saying ,merge stuff goes here. Instead of having a merge function here, I guess that works, but I wouldn't do that."
          },
          {
            "time": "[00:02:37]",
            "text": ">> That wasn't the thing like the merge function is separate in what I did but it's also it calls itself."
          },
          {
            "time": "[00:03:03]",
            "text": "Merges it in little parts. I think there is a reason, is there a performance reason to prefer an iterative approach in merging?"
          },
          {
            "time": "[00:03:03]",
            "text": ">> I'd have to think about that, but I can't see this being any clear, right? The reason why you would wanna do this recursively is if you made the code look better, and like can read better."
          },
          {
            "time": "[00:03:30]",
            "text": "But I don't know about you this I find this code quite readable. But it's obviously a point of opinion here. I would not make merge recursive, I can't think of a good reason to do that. You could, probably, I'd have to think about it. But I'll say this that typically merge is not made recursive."
          },
          {
            "time": "[00:03:59]",
            "text": "But to answer the online question here, you could absolutely do this just move this up in here. And then this would just be sorted left. Sorted right? And then you would just return and then you'd have to do the return, concat, Yeah, all that stuff would just end up here."
          },
          {
            "time": "[00:04:50]",
            "text": "And I think this should still work. What did I do? I hope this needs to be sorted left. There we go, and that works. So, the reason why I don't, [COUGH] excuse me. The reason why I don't like that is because I really liked having all this separated into one little merge function."
          },
          {
            "time": "[00:05:16]",
            "text": "One, this is now usable in other places. Not that I think you would, but it would be. But more importantly, you can actually write unit tests individually for merge, right? So you can actually test this one piece of function in isolation by itself. And that's always a good thing."
          },
          {
            "time": "[00:05:36]",
            "text": "As much as possible in general, just as a general programming rule, one function does one thing, as much as possible, right? Again, remember rule number one here is there are no rules. So if there's, if it makes sense to have a function do two things, then by all means do it."
          },
          {
            "time": "[00:05:53]",
            "text": "In this case, I think it makes a lot of sense to separate this into two separate things."
          }
        ]
      },
      {
        "name": "16-quick-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next thing that we wanna talk about is quick sort. So every time that you call .sort in JavaScript, usually it's calling merge sort, sometimes it calls quick sort. And when I talk about that, I'm actually just talking about this, right, where it's you call, on an array .sort, and it gives you an array back that is sorted, right, that's what I mean when I say like .sort."
          },
          {
            "time": "[00:00:29]",
            "text": "Most of the time it calls merge sort, for the reasons that we talked about previously, which is it's stable, it's average case scenario is really good, all those kinda things. Quick sort has some interesting properties, but one, it's better spatially in terms of that it uses uses less memory to do, so occasionally engines like V8 at least it used to, I'm not sure if it does anymore."
          },
          {
            "time": "[00:00:56]",
            "text": "Sometimes we'll call quick sort, it just depends. Okay, so it is another what we call divide and conquer algorithm. When I say divide and conquer, you can basically just replace that with recursive, right, cuz you're dividing the big problem into smaller problems, it's divide and conquer. It takes kind of a similar approach that it's gonna break a big array down into smaller arrays."
          },
          {
            "time": "[00:01:27]",
            "text": "But it does throw in a slightly different fashion, so let's talk about that. So let's say we have this array, this array here of 4, 9, 3, 5, it's gonna choose what's called a pivot. Right, so a pivot is going to be the last number here, the 5."
          },
          {
            "time": "[00:01:46]",
            "text": "Everything that's smaller than the pivot is gonna be put into a left array. Everything that's larger than the pivot is going to be put into the right array, right?. So this is the pivot 5, 5 has made the pivot since this last thing array and then we're going to divide this into two arrays."
          },
          {
            "time": "[00:02:04]",
            "text": "Four and three because they're smaller than five are gonna be put into a left array. So 4, 3 get put into this array and 9 is the only one that's bigger than 5, so it gets put into a right array, okay? Then we call quick sort on this array here 4,3 and we call quick sort, again on 9, okay?"
          },
          {
            "time": "[00:02:25]",
            "text": "Let's go down to 4,3, 3 is made the pivot. Everything that is smaller gets put into a left array, which is nothing, and everything that's bigger gets put into a right array, which is just 4. Those both immediately return because those are both base cases, right? The base cases either length 0 or length 1, right, cuz those are already sorted."
          },
          {
            "time": "[00:02:46]",
            "text": "And then what you do is you call concat on left array pivot, right array. So in this case the pivot was 3, the left array was empty array, and the right array was 4. So it's left array, which is blank, nothing, pivot which is 3, and then right array which is 4, okay?"
          },
          {
            "time": "[00:03:13]",
            "text": "So then this returns [3, 4] from this quick sort called here. And then we have 9 here, right, so this is gonna be this one here, base case returns 9. And then up here, we're gonna call concat on left array 3, 4 pivot, which is 5, and then right array, which is 9, so we end up with 3, 4, 5, 9."
          },
          {
            "time": "[00:03:42]",
            "text": "Kinda clever, right, so unlike merge sort, we all are gonna have one function. The one function is just gonna be the quick sort function that's it and that's basically the whole thing. That's what quick sort is in a nutshell. I've kind of found this for you, which is a visual representation of it."
          },
          {
            "time": "[00:04:07]",
            "text": "It is actually possible to do quick sort in place without actually breaking it down into separate arrays, which gives it much better spatial complexity. Don't worry about that today, today just use all the arrays let's go hog wild with all the arrays. This is easier to conceptualize, but just know that it is possible to do it in place."
          },
          {
            "time": "[00:04:53]",
            "text": "Some people find that confusing just keep in mind the pivot doesn't go into either array. Okay, let's talk about big O. So what's the worst case for a quick sort? Imagine if this was [1,2,3,4,5,6,7], 7 was the pivot, 7 is the largest item in the array. So that means everything is gonna go on the left array, and nothing's gonna go on the right array, and it's gonna keep breaking down that array that way."
          },
          {
            "time": "[00:05:29]",
            "text": "So the worst case there is that you get no benefit from the recursion and you end up with n squared, right? Because every item is gonna be looked at and compared to every other item in the array. So sorted lists are actually a disaster for quick sort, same with reverse sorted, right?"
          },
          {
            "time": "[00:05:45]",
            "text": "Cuz you have the same problem everything goes in the right array. There are ways to mitigate that risk. Which you can actually instead of just saying automatically 5 is the pivot, you could say, I'm gonna look at 4, 9 and 5 and I'm gonna find the middle most elements and make that my pivot, this is called quick sort 3."
          },
          {
            "time": "[00:06:04]",
            "text": "In which case you end up with a much better average case scenario of just n log n, right, which is the average case scenario. But the way that we're gonna do it today, we're not doing quick sort three, we're just gonna do quick sort. The worst case scenario is a sort of list."
          },
          {
            "time": "[00:06:21]",
            "text": "What's the best case scenario? The more shuffled the array is the better quick sort is. So that's both the best case in mostly the average case as well, which is n log n, right? Because not every element is being compared to every other elements in the array. So we end up with n log n just like merge sort, but it has better spatial complexity and technically can probably go a little faster."
          },
          {
            "time": "[00:06:45]",
            "text": "So some better coefficients. And we are gonna do it as a nondestructive version, but it is possible to do a destructive version which has better spatial complexity. So I think the way that we're gonna do it, it would be basically n in terms of spatial complexity. But if you do it destructively, you still have to make some allocations on the stack."
          },
          {
            "time": "[00:07:11]",
            "text": "Which would make it log n, cool. There are some variations of quick sort, like quicksort 3, that's what I was telling you about just before. There are some other variations but they're almost all variations around how you choose the pivot, cuz that's obviously pivotal, nice. [LAUGH] It's pivotal, I'm just seeing everyone shaking their heads like dear God, it's too late for a dad joke like that, [LAUGH]."
          },
          {
            "time": "[00:07:41]",
            "text": "It's very important how you choose your pivot. So that's where all the variations of quick sort come in and you can actually check that out on the Wikipedia page that it'll run down a bunch of those variations"
          }
        ]
      },
      {
        "name": "17-quick-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> I want to give you a shot to go do this, so we're gonna pop back over to quick sort here, quick sort, okay, and so, here we're gonna say base case, right? So what is base case, array of length zero or one in this particular case, we actually will see lots of arrays of length zero, right?"
          },
          {
            "time": "[00:00:30]",
            "text": "Because if there's nothing in the left array, we're going to call quick sort on that, and we need to handle that, so make sure you're providing for length zero or length one. Choose pivot. Here we're gonna separate into left and right arrays. Call quick sort. On, left and right arrays."
          },
          {
            "time": "[00:01:01]",
            "text": "Return, Left. Can cat, Pivot, great. That's it, that's the whole thing. Probably, I might have diagrammed that a little too out for you, but everyone can use a wind today [LAUGH] so I'm gonna give you 15 minutes to go ahead and get this done. And then you and I are gonna come back and do this together, and again make sure you move test out skip there, and yeah again this sorting visualizer is not gonna help you with this."
          },
          {
            "time": "[00:01:41]",
            "text": "So the question is this, if I have duplicate in my array, so if I have five and my pivot is five does the duplicate five go on the left or does it go on the right? And the answer is, doesn't matter, because it's gonna get sorted either way and I don't believe quicksort is stable, off top my head have to look."
          },
          {
            "time": "[00:02:03]",
            "text": "But in any case, in general with those kind of calls, it's just be consistent, so, if it's gonna go left always put in the left, if it's gonna go right always put it in the right, but in the end it just be consistent. Let's go ahead and go through this, so base case here, if nums style length is less than or equal to one, then you just return nums."
          },
          {
            "time": "[00:02:40]",
            "text": "Okay, gonna choose a pivot, and in our case, we're just always going to go with the last one, so const pivot equals nums of nums dot length minus one. So that's gonna be our pivot. And we'll separate into left and right arrays, so we're gonna say const left equals empty array, const right equals empty array."
          },
          {
            "time": "[00:03:20]",
            "text": "And then we're gonna say, four let I equals zero, I is less than nums dot length minus one, cuz the pivot is the last number, so we don't wanna capture that one, I plus, plus. And we're gonna say if nums of I is less than pivot. Then we're going to say left dot push nums of I else, all right, dot push nums of I, okay, so now we have a pivot we have a left array which contains everything is smaller."
          },
          {
            "time": "[00:04:23]",
            "text": "We have a right array which contains everything that's larger, so we can say const sorted left, equals quick sort left, const sorted right equals quick Sort right. And then I actually think that's just straight up valid JavaScript, so I think you can just say that, this would actually have to be sorted left, sorted left, sorted, right."
          },
          {
            "time": "[00:05:13]",
            "text": "That works, after I wrote the skip, and quick sort, do right, there it is, so pivots fine, even though this is just a number concat is smart enough to say it's like this is just a number. It's not an array, so I'm just going to insert this as an item in the array."
          },
          {
            "time": "[00:05:37]",
            "text": "If you look to my course notes, I actually combined two these three lines into one and I said return dot dot dot quick sort left, pivot dot dot dot quicksort right, like this. This should work as well, but let's just make sure quick, so where are you right there, click play, and you can see there that also works as well."
          },
          {
            "time": "[00:06:11]",
            "text": "This is called the spread operator, it's new as of yes five, so I think it's actually like six years old now, this is saying like, this is an array please spread this out over this new array, right? But this line and this line end up being equivalent."
          }
        ]
      },
      {
        "name": "18-quick-sort-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> I have a quick question about an error that I cause"
          },
          {
            "time": "[00:00:00]",
            "text": ">> Sure."
          },
          {
            "time": "[00:00:00]",
            "text": ">> When I first made it, I forgot to put the in for loop, the number dot length minus 1. And basically it seemed to cause a stack overflow and I was wondering I was trying to figure out why that would cause that."
          },
          {
            "time": "[00:00:18]",
            "text": "And I was wondering if you could give me some idea."
          },
          {
            "time": "[00:00:18]",
            "text": ">> Sure, so he's saying he forgot to put the minus 1 here and that was causing a stack overflow."
          },
          {
            "time": "[00:00:18]",
            "text": ">> That's it looks like, yeah."
          },
          {
            "time": "[00:00:18]",
            "text": ">> Because so it means you're inserting your pivot into the left and right."
          },
          {
            "time": "[00:00:35]",
            "text": "It probably means that eventually, you're gonna run into an array that's always of link 2, right? So it's going to keep calling that. Right array or left array, which is never gonna hit that base case, right? Because it's never gonna hit link one, because those arrays have to get progressively smaller and smaller."
          },
          {
            "time": "[00:00:55]",
            "text": ">> Okay, and why would it be stuck at 2?"
          },
          {
            "time": "[00:00:55]",
            "text": ">> So let me see if I can invent an example. I think if you did this where your number is equal to 1, let's do 9, 8, 7, so 7 would be the pivot And then it would try and break this down and 7 would always get."
          },
          {
            "time": "[00:01:27]",
            "text": "So basically, this would just keep calling recursively endlessly on 9 and 8, 9, 8, 7, assuming everything went into the right array. Or 9 or so maybe this is better, Because everything would always go into the left array. No, I had a right before okay. So seven Because this is not equal to this or this is equal to this rather everything would always get put into the right array."
          },
          {
            "time": "[00:01:59]",
            "text": "So then it would call quicksort on right which would always endlessly be 9,8,7."
          },
          {
            "time": "[00:01:59]",
            "text": ">> Yeah I have chosen the question from movement of especially convexity, and when we call quicksort, left and quicksort, right, if we just our wide left and right array, so we don't create a new one every time."
          },
          {
            "time": "[00:02:23]",
            "text": "So maybe it's whatever improve the spatial complexity."
          },
          {
            "time": "[00:02:23]",
            "text": ">> Specifically here, he's asked, I think you're asking me online set 37, 38 instead of storing these variables, what if we just overrode them? The amount that you would affects the memory would be trivial to the point that I say it wouldn't matter."
          },
          {
            "time": "[00:02:43]",
            "text": "Because sort of left and sorted, these are actually just gonna be pointers. They're actually not gonna be full copies and pointers are the smallest thing you can possibly store in memory. So that would be a optimization that I don't think would really help you very much. Might help a little bit."
          },
          {
            "time": "[00:03:01]",
            "text": "But it's like grabbing a bucket out of the ocean, right? It's gonna be such a small amount versus the much bigger things that are going on."
          },
          {
            "time": "[00:03:01]",
            "text": ">> I tried to be smart and use for off instead of for loop. And I had the same problem essentially right? I wasn't removing pivot and I were just stuck."
          },
          {
            "time": "[00:03:23]",
            "text": ">> Yep, so he's saying instead of using a for loop he used like the functional like for each or something like that."
          },
          {
            "time": "[00:03:23]",
            "text": ">> For off."
          },
          {
            "time": "[00:03:23]",
            "text": ">> For off loop yeah, so a for off loop here which looks like for lead item of numbers like this right? The unfortunate thing about this is, it's always going to capture the last item in the array, which means your pivot is gonna be put into your left or right, which means that you're gonna probably end up in a stack overflow situation."
          },
          {
            "time": "[00:04:00]",
            "text": "So a lot of just normal for loops. I know they're not the most appealing looking piece of code, but they are extremely useful."
          },
          {
            "time": "[00:04:00]",
            "text": ">> Poke the pivots and use the for off without problem."
          },
          {
            "time": "[00:04:00]",
            "text": ">> Yep, so you could absolutely just say, pivot equals instead of doing this, he would say const pivot equals nums dot pop right and this would actually remove the pivot from the from the array and then you could absolutely do a for of loop here."
          },
          {
            "time": "[00:04:39]",
            "text": "That would work great. Many ways to skin this cat."
          },
          {
            "time": "[00:04:39]",
            "text": ">> Can you please walk us through the time complexity of this code?"
          },
          {
            "time": "[00:04:39]",
            "text": ">> Yeah, so the time complexity of this is average case scenario and login. So let's look down here a unit test case. So here, we're gonna put 5 as the pivot and then, 10,8,6,9,7 are gonna go on the right array and then everything else is gonna go on the left array."
          },
          {
            "time": "[00:05:22]",
            "text": "So this is to say every item is going to be looked at the at least once, right because we're splitting it into different pieces. So let's just say that there's at least n. So that's where the n part of this is because we're gonna look at everything at least once and make comparisons at least once for everything."
          },
          {
            "time": "[00:05:38]",
            "text": "However, when we're doing the yeah, so when we're putting 7 into the right array and we're putting 4 into the left array, 4 and 7 are actually never going to be compared to each other ever. We're doing this by virtue of the fact that if we know something is smaller than 4 and we know something is larger than 5, right?"
          },
          {
            "time": "[00:06:03]",
            "text": "That means that we can make the fundamental assumption using the transitive property. And I don't know I did air quotes there. It's literally called the transitive property in mathematics. 4 must be smaller than 7, right? So we can use that property of mathematics to say like cool. 4 and 7 never have to be compared to each other because I already compare them both to 5, right?"
          },
          {
            "time": "[00:06:24]",
            "text": "So that means that we're going to get these like economies of scale. So if we do a huge quicksort on a huge array, that means that there's a bunch of comparisons that we never have to do, as opposed to something like insertion sort, which where everything has to be compared against everything else every single time an average case scenario."
          },
          {
            "time": "[00:06:45]",
            "text": "That's why that one ends up being n squared and this one, it's average case scenario ends up being n log n because normally they don't have to be compared to each other because we can look at those pivots. So that's why it ends up as n log n."
          },
          {
            "time": "[00:07:00]",
            "text": ">> Yeah, but there's something I'm struggling with. How could I get to the login part from the code? So I guess maybe mathematically, help me understand it better. But yeah, I understand that it's because it's a divide and conquer algorithm is getting smaller and smaller and we're working with the smaller lists but getting to that login just by looking at the code i.e, I'm struggling with that."
          },
          {
            "time": "[00:07:35]",
            "text": ">> Unfortunately there's no and hopefully answering your question that you have. Like you there's no hack here for us to look at and say, we have nested for loops, therefore we have n squared, right, unfortunately, there's not really a good way of doing that here. The best indication that you have this is gonna be log in is that it's recursive."
          },
          {
            "time": "[00:08:00]",
            "text": "But still that's that's an indication it's indicates to you that it might be login. But it's not necessarily like we saw, for example that count two or factorial for example, those are not, those are just n, right? They're not login. So the way that you have to conceptualize in your head to figure out what the login is, is that just what I was telling you before those diminishing the more items I throw out this, the less comparisons that it adds."
          },
          {
            "time": "[00:08:32]",
            "text": "As we add more we get those kind of economies of scale. Once you kind of realize that like you're using these kind of transitive properties to avoid making some of the comparisons, that's where it's gonna say like okay, this is definitely login right that's the indication that's the proof that you need in your head for you to say this is login because I don't have to compare everything to everything else."
          },
          {
            "time": "[00:08:54]",
            "text": "I don't really know if I have a more succinct answer than that. Yeah, it, it's hard [LAUGH] And like even when I'm sitting there, like I've messed this up in interviews as well, I remember specifically that I messed this up in a Facebook interview. So it's not apparent and it's pretty difficult, right?"
          },
          {
            "time": "[00:09:15]",
            "text": "Which is probably why they choose to ask you these questions."
          },
          {
            "time": "[00:09:15]",
            "text": ">> Assuming we have some data set that we know, a statistical distribution about, does it make sense to choose a pivot with outside the data sets? Like okay, I these are student grades and I know the they are in the range of 4200 usually and the mean value is about 70, so I can start with 70 without actually including it."
          },
          {
            "time": "[00:09:53]",
            "text": "Just for the first iteration, does it make sense?"
          },
          {
            "time": "[00:09:53]",
            "text": ">> So the question is if you have some knowledge of the distribution and the average and the median, perhaps, maybe the medians rather than most, actually, it's definitely the most useful thing there. Would you be better off selecting something that you know to be a good pivot that might be outside of the normal data set."
          },
          {
            "time": "[00:10:25]",
            "text": "I guess, yeah, I can see that definitely being helpful. And just not including the pivot, right, cuz the pivot wouldn't be actually in the data set. That's only gonna help you for the first pivot though, right? And the disadvantage that we're gonna have here is, now we have to have a specialized case that the first level of recursion is gonna be different than every other level of recursion, right?"
          },
          {
            "time": "[00:10:48]",
            "text": "Because at that point, once we go down into the lower level of recursion, all bets are off, we can't use the same pivot again."
          },
          {
            "time": "[00:10:48]",
            "text": ">> I was thinking like since we are already iterating over everything in the first pass, maybe while we're sorting it into left and right parts we could be Just taking a running average or something like that?"
          },
          {
            "time": "[00:11:16]",
            "text": ">> So,"
          },
          {
            "time": "[00:11:16]",
            "text": ">> For the next pivot, I mean"
          },
          {
            "time": "[00:11:16]",
            "text": ">> The issue with like, you could always like, you could write a piece of code to always select the perfect pivot, right? But then when you're looking at every item in the array every single time, which greatly adds to the complexity."
          },
          {
            "time": "[00:11:34]",
            "text": "[LAUGH] So that that in and of itself, always looking for the perfect pivot, you're actually ruining what makes this algorithm efficient at all right? Which is the fact that you don't have to look at every item every single time. In the sense of, yeah, that you would have to first find the perfect pivot."
          },
          {
            "time": "[00:12:01]",
            "text": "Yeah, and then that would kind of ruin the fact that you, you had to search through at once to find the median, pivot and then split it. I think the thing that points to after that is like there are more efficient ways of selecting that pivot. The one that I'm familiar again is Quicksort."
          },
          {
            "time": "[00:12:19]",
            "text": "Three, we look at the first item, the middle item and the last item. And that that mostly solves almost all of the distribution problems that you'd run into And that's kind of the one that people tend to favorite because one, it's fairly simple and easy to understand and to it it like, prevents you from having worst case scenarios."
          },
          {
            "time": "[00:12:40]",
            "text": "But there are some other ways of selecting that pivot that I'm actually not familiar with submit one of them might do that. I just can't conceptualize a pyramid off the top, my head."
          },
          {
            "time": "[00:12:40]",
            "text": ">> So very simple sample just source 80% of the problem maybe."
          },
          {
            "time": "[00:12:40]",
            "text": ">> Yeah, you could still have the problem where you were always selecting the top three items in the array But the statistical probability of that is not very large, right?"
          },
          {
            "time": "[00:13:11]",
            "text": "Cuz if you're always selecting the bottom three or the top three items in the array you still run into the worst case scenario. Which is not great, but the fact that you go from doing that frequently with just one pivot to almost never if you select three pivots and then choose the median one."
          },
          {
            "time": "[00:13:31]",
            "text": ">> It's kind of complicated depending on data set. Maybe there are some specific cases where just the guessing a good pivot would make sense. But I think what you say covers so much ground just by itself. That's what I said, it probably becomes unnecessary in most cases?"
          },
          {
            "time": "[00:13:31]",
            "text": ">> Well, and I think another thing that you might be thinking, you should think about is if you have that much knowledge about what your dataset is gonna look for, or is what it's gonna look like, quicksorts' probably not the best choice at that point, right?"
          },
          {
            "time": "[00:14:06]",
            "text": "It might be like something insertion sort, cuz if it's already nearly sorted, then insertion sort is gonna be better. And if you already know the median, I guess if you know the median and you know it's totally shuffled, maybe. [LAUGH]"
          },
          {
            "time": "[00:14:06]",
            "text": ">> I mean, student grades are a good example."
          },
          {
            "time": "[00:14:21]",
            "text": "You know the distribution, but they may come in any order."
          },
          {
            "time": "[00:14:21]",
            "text": ">> But at that point, if it's gonna come in any order quicksort is already very good at that. And having the perfect pivot doesn't make it a whole lot more effective, right? As long as it's an okay pivot."
          },
          {
            "time": "[00:14:39]",
            "text": "It usually works pretty well."
          }
        ]
      },
      {
        "name": "19-radix-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next Sort that I wanna talk about with you is one called Radix Sort. Sometimes this is called Bucket Sort, though actually technically Bucket Sort is something different, but it's very similar. In any case, this is something called a non-comparison sort, in that you'd never actually directly compare numbers to each other use a method called bucketing."
          },
          {
            "time": "[00:00:29]",
            "text": "And you can see kind of see that happening here, it's really strange. So you can't even really measure it with big O in the sense that, it's not gonna be N squared, or anything like that, it's actually going to be I think, MK? [LAUGH] But we'll get into that here in just a second."
          },
          {
            "time": "[00:00:46]",
            "text": "So yeah it's a non-comparison sorting. We do something by actually comparing different number of places instead of comparing numbers directly. And I'll get into that here in just a second. So we're gonna sort parts of the array first, right? So let's take a look at this array that I have here in my notes 109, 224, 901 and 58."
          },
          {
            "time": "[00:01:11]",
            "text": "So the first thing that you're gonna do is you're actually going to sort it by the ones first. So 9, 4, 1, 8. So you can see here, after the first pass, we have 901, 224, 58 and 129, right? So you can see it's actually sorted by the ones place."
          },
          {
            "time": "[00:01:33]",
            "text": "Then we're going to sort it again but by the tens place, right? So after the second round, we have 901, 109, 224 and 58, then we're gonna sort of one more time by the hundreds. So at this point we'll have 058, right? 000 here, 109, 224 and 901."
          },
          {
            "time": "[00:01:58]",
            "text": "And you can see after having done that, sorting it by the hundreds place which is the largest place that there is we end up having a sorted array. Kind of a mind bending way of sorting. It's not something that a human would ever kind of think of directly."
          },
          {
            "time": "[00:02:16]",
            "text": "So you can kind of see that happening here. It'll sort them into buckets by zeros, ones, twos, threes and fours, and you do it for however many places there are. So in this particular case, there's up to 1000. So we do that sort four different times. Makes sense?"
          },
          {
            "time": "[00:02:40]",
            "text": "Sort of? So, again, what's the big O of this? The big O of this is gonna be a little bit different than we're used to because we have to account for this how many buckets or how many times we have to do the sorting, right? So we're gonna call that term k or w in this case, let's just go with k."
          },
          {
            "time": "[00:03:09]",
            "text": "And instead of being On squared, you end up being which is n times n, you end up being n times k. So it's kind of n squared in the sense that it's two different terms multiplied to each other. So you might ask me, is this better than n log n?"
          },
          {
            "time": "[00:03:26]",
            "text": "Well, as you may have guessed being this fun of the course, it depends, right? It depends on what the distribution of your numbers are, right? So if you have a lot of very long numbers that are distributed really well, right? So there's like kind of a uniform distribution with lots of terms, right?"
          },
          {
            "time": "[00:03:46]",
            "text": "So if you have, hundreds of 1000s that are distributed across that entire range, then radix sort actually ends up being a pretty good sort. But if you're sorting 500 numbers and they're all between 0 and 100, it tends to be kind of inefficient and you'd be better off with something like quick-sort or something like that."
          },
          {
            "time": "[00:04:09]",
            "text": "So, spatial complexity n being n plus k, where n is the length and k is how many places there are to sort by. So it's not great on spatial complexity because you have to do a lot of bucketing. So that's why it's only favorite employees specific circumstances. But I wanted to show you how you can sort things without actually ever directly comparing numbers, right?"
          },
          {
            "time": "[00:04:40]",
            "text": "So like in this case, 109 is actually never directly compared to like 901, right? The only thing they're ever compared by is just by these buckets. So I'm gonna give you a chance to try and code this up. I'm gonna help you kinda get started here. That's fine."
          },
          {
            "time": "[00:05:08]",
            "text": "And actually, I'll just come back to here. That was quick-sort. Let's get into radix sort. Okay, so you can see here, these are all the numbers that you're going to be sorting by. And if you wanna just do something for fun here, you can actually do this. It'll just sort 99 very long numbers for you."
          },
          {
            "time": "[00:05:32]",
            "text": "So you can see how efficient this actually can be. But this is kind of extra credit down here. Let's focus on this one up here. Okay, so we're gonna do a radix sort here. So, I'm gonna just advise you on some helper functions I think you should code for yourself."
          },
          {
            "time": "[00:05:59]",
            "text": "One should be function getDigit. We give it a number, a place, and the longest number. So for example, if I put into let's say I have a number like 1391, so that would be the number. And I give it a place of 0 cuz I want the 0 with place."
          },
          {
            "time": "[00:06:36]",
            "text": "And I have the longest number in here. It's like, correct my doing got to make sure I'm doing this right way. And then the longest number in here. So the longest number would be like the longest number in your particular set rise. So if I had a number like 30,000 in my set, or let's even look at this, the longest number in this set is of length 4, right?"
          },
          {
            "time": "[00:07:12]",
            "text": "So 3000, 1244, so the longest number in that particular case would be 4. Actually is there. And 4 in this getDigit that should return here. The one right? Number equals that place equals that and longest number equals 4 Sorry, I'm just making sure that I get this correct."
          },
          {
            "time": "[00:08:07]",
            "text": "Anyway, this getDigit helper here is gonna help you here. So that you can just provide these numbers here so that it helps you with the bucket sorting. Then I would also just write a function called get longest number? A lot of times you'll know this going into your data set, right?"
          },
          {
            "time": "[00:08:27]",
            "text": "You'll know that the longest stuff will be of length 4, length 5, or length 6 or something like that. But in this particular case, I will just provide that here, get longest number And in this particular case, get longest member if you call it on this data set, it would return 4, right?"
          },
          {
            "time": "[00:08:56]",
            "text": "Right, the reason why you need longest number here, that's what I was trying to remember is, let's say the longest number in your data set is 3000 but you give it number 3, right? So the longest number here is gonna, or so not the longest number, but the place will be 4 on that."
          },
          {
            "time": "[00:09:13]",
            "text": "So you'll actually get back to 0, does that makes sense? Okay, and then let's go into what radix sorting is gonna do. So find the longest number Create how many buckets you need. In our case, since we're doing base 10 math, this will be an array of arrays."
          },
          {
            "time": "[00:09:52]",
            "text": "Right and then you'll have a bucket for 0123456789. Okay, then here you'll have a for loop For how many iterations you need to do. So that will be based on the longest number, right? Because you need to do one iteration for each of the longest numbers. And then basically what you do is you gonna throw them in the buckets and then you're gonna dequeue them back out into your final results."
          },
          {
            "time": "[00:10:22]",
            "text": "And you'll keep doing that back and forth until you end up with the correct answer. So inside that for loop you'll have Nq, which is the word for just like throwing something into an array the numbers into their buckets. This will probably be a while loop. That's why I have that."
          },
          {
            "time": "[00:10:59]",
            "text": "And then here we're gonna have another for Loop, For each bucket where you dequeue all of the results. That's more or less kinda step-by-step what you're going to be doing. I kinda diagram this modality because it's kinda an abstract one to think about. But the idea again, let's just go back to our visual here to kind of just take this step by step."
          },
          {
            "time": "[00:11:38]",
            "text": "So notice for each one of these, it's enqueuing them I just make that bigger. There we go. First by the 0's, right? 0's, 1's, 2's, 3's, 7's, right? You can see the highlighted in red of the one that it's enqueuing at the moment. Then, what it does notice, it just dequeues them out in order, right?"
          },
          {
            "time": "[00:12:06]",
            "text": "So, all the 0's are coming out, all the 1's are coming out. And so after the first iteration we have this array that's sorted by the 1's places, right? And then it does it again, notice that the red ones are now the 10's, right? So now we're sorting by the 10's place."
          },
          {
            "time": "[00:12:25]",
            "text": "And that goes back into these buckets. Notice that nothing's ever being compared to each other. We're never asking, is this bigger than this? We're just putting in, into the buckets and then back out into the general results already. Okay, so this gets put back into these buckets by the 10s place."
          },
          {
            "time": "[00:12:43]",
            "text": "Notice that 1and 7 are in the 0, right because they have no 10s place. And then these just get dequeued out again. And now notice that it's sorted by the 10s and the 1s place right so 1, 7, 10 20, 21, 20, 22, 27, 30, 38, 43, 77, 80, 82, 93, 99."
          },
          {
            "time": "[00:13:06]",
            "text": "And then we do it again for the hundreds. And then notice that it's sorted now by the hundreds. Right, notice that 793 is the last one in here now. Whereas one is still the first one, and then you do it one more time for the 1,000s place. And then you dequeue all that back, and there you go."
          },
          {
            "time": "[00:13:31]",
            "text": "Now everything is sorted without ever asking is this bigger than this? There's no If statements in there, it's just putting things in in and out of buckets."
          }
        ]
      },
      {
        "name": "20-radix-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> That is radix sort, I'm gonna give you some time now to work on the exercise, just head over to your code sandbox. Head over to the radix sort test dot js, and then we'll come back and we'll do this exercise together. So, let's do the get digit function first, so const string equals number two string."
          },
          {
            "time": "[00:00:32]",
            "text": "Reason why we do this is now we can actually use chart at, right, which is a little kit that allows us to return one part of the number. You also totally could have done some mathematics with mod and that would work as well that might even be easier."
          },
          {
            "time": "[00:00:54]",
            "text": "I don't know this is the way I did it, you can do it however you want to. Okay, const size equals string dot length, const mod equals, longest number, minus size and then we return string. place minus mod or 0. So now this will return, so now I can just use this getdigit function to get back a specific digit that I'm looking for."
          },
          {
            "time": "[00:01:35]",
            "text": "Okay, get longest number, there's again many ways to figure this out. But what we're gonna do here is, let longest equals to 0. I mean, you could do this with a reduce. There's a bunch of ways to do this, but let's just do it with for a for loop, set like fortnight, no, it's not."
          },
          {
            "time": "[00:02:02]",
            "text": "Alright, let i equals zero, i is less than My get longest number right should be an array is less than array dot length i plus plus and then counts current length. Length equals array at i dot 2 string dot length, right. So if this was 3000, this would return current length would be 4, right?"
          },
          {
            "time": "[00:02:44]",
            "text": "And I'm just looking for what the longest number is there so I can know what to provide get digit up here. Okay, and then I'm gonna say, longest equals current length. Is greater than longest, then it's gonna be equal to current length, otherwise longest. This is a ternary for those of you that are not familiar with it, it's just a condensed if statement right?"
          },
          {
            "time": "[00:03:19]",
            "text": "So if current length is longer than the new longest will be the current length otherwise it will stay what it already was which is longest. You could totally put this in an if statement as well, I just like turn arrays, okay, then down here we return longest. So now we have a function that'll get us the longest number in array, cool."
          },
          {
            "time": "[00:03:48]",
            "text": "Const longest number is equal get the longest number with the array. So that's that, okay, here we just need to create the data structure that we're going to use. I just did like a little shortcut here a const buckets equals new array. Of length 10 dot fill, Dot map, And this will just fill it with brand new empty arrays."
          },
          {
            "time": "[00:04:36]",
            "text": "You totally could have made a for loop or something like that would make these buckets as well, but suppose we say this line 42 all it does is it creates an array of 10 empty arrays, right? Cool. So let's do this then we'll do a for loop, let i equals 0."
          },
          {
            "time": "[00:05:10]",
            "text": "I'm sorry, let i equal longest number minus 1. I is greater than or equal to zero, i minus minus. So we're gonna start like if this is, 4 is the longest up here, then we're to start at 3, we're going to go down to 0, okay? First thing in here is while there's something in the array."
          },
          {
            "time": "[00:05:43]",
            "text": "So while array dot length. We're gonna say const current equals array dot shift, so we're gonna pull the first thing off the array, I'm gonna say buckets, Getdigit, Current, i, longest number. Calling this getDigit function that we have up here, right? Dot push current, okay, so we'll have those ten arrays, right?"
          },
          {
            "time": "[00:06:25]",
            "text": "And we're just enqueuing it somewhere into one of these, right? So if this was like this one here, let's say 1244. For the first iteration, it's going to grab this four number and it's going to push it into the four spot, the four buckets, right? And then when we're done, we will pull that back out."
          },
          {
            "time": "[00:06:48]",
            "text": "But let's see the going back to our little graphic here. It's this part that we're doing, the part where it's pushing it in. Right, that's what this first enqueuing is doing. So we're pushing into these 0 through 9 buckets over here. Okay, that's what that while loop is gonna do."
          },
          {
            "time": "[00:07:14]",
            "text": "So after this is done, we're gonna have all of our numbers bucketed by whatever place we're sorting by. Okay, and then we have to go ahead and dq all of these, so we're gonna say for let J equal zero. J is less than 10 J plus, plus, you could also say,buckets dot length, but it's always going to be 10."
          },
          {
            "time": "[00:07:47]",
            "text": "Right, unless you're gonna be like doing hexadecimal bucket sorting. I mean you could there's no reason why it wouldn't work. Why while, buckets, J dot length, you're just going to pop them off. Array dot push buckets J shift, so we're going to be taking them off of the front of the buckets and you're going to be pushing them onto the array."
          },
          {
            "time": "[00:08:32]",
            "text": "Then down here you are going to return array. All right. So let's make sure that this is not auto running, we're gonna take this off of skip. And we're gonna see if we can run this code under radix sort make sure that this actually is running radix sort right there works."
          },
          {
            "time": "[00:09:14]",
            "text": "So, let's take this one off to see if it works with even bigger number sets. Run it again and looks like it's still working, cool. So just for fun, I'm gonna copy all of this. Ones that don't need that and let's hop over to our sort visualizer because this actually will work for that."
          },
          {
            "time": "[00:09:47]",
            "text": "And paste this over here and I'm just going to call this sort instead of radix. Okay, and then we'll head over to our little browser here, we'll click on sort. And let's also modify this just a second with this. Okay, and then here, when I call it with sort nuns."
          },
          {
            "time": "[00:10:41]",
            "text": "And then here we do have to snapshot. So, we'll first snapshot with the array, snap shot array and let's snapshot at the end of all every one of these snapshot. Here with the array, so we're only getting seven unique snapshots, right because we're only doing it at the end of all the bucketing and D bucketing."
          },
          {
            "time": "[00:11:13]",
            "text": "We could code up a more capable bucket visualizer but this is what we have for right now. But notice after one iteration all the zeros are at the beginning 1, right, 2,3,4,5, right, and then after the second iteration, it's 0,01,02,03,05,06. Right, after the third iteration, it's sorted by the hundreds, so 001,002,008, so on and so forth."
          },
          {
            "time": "[00:11:51]",
            "text": "After the third iteration, it's sorted by the thousands than the tens of thousands. And then afterwards, this bottom one is totally sorted. Pretty wild, right, I can't imagine how people come up with these things. So the question is, what's mod here, I didn't know what to call it."
          },
          {
            "time": "[00:12:15]",
            "text": "[LAUGH] Because you need the last number in the array and then we're counting backwards, right? Which is a weird way to do math and code, right. So on the zero with iteration I need the ones place which is going to be the last index in the string, right?"
          },
          {
            "time": "[00:12:33]",
            "text": "So if I have, let's say, the longest number is 100. And I'm asking for the zero with element, actually the two index of that string, right? So, this took me a bit of trial and error to get this exactly right. So if it took you some trial error or you didn't find like couldn't figure it out, I do not blame you."
          },
          {
            "time": "[00:12:55]",
            "text": "This actually probably took me 20 minutes of just like following my brow with my computer before I finally figured it out. Valid question, does this kind of defeat the purpose of the entire sword like in terms of like its complexity? Let's go with yes and no, sorted slash, it depends, right, everyone loves that damn answer now."
          },
          {
            "time": "[00:13:17]",
            "text": "One, you're not really doing much heavy lifting here, right? Like you're not doing any comparisons, you're not doing anything like that really you're just asking for the length. So on one hand, not particularly, on the other hand, you are looking at every number here and grabbing the lengths."
          },
          {
            "time": "[00:13:35]",
            "text": "We do need this longest number just to make sure that the math here is correct. I'm sure there's probably a more efficient way of doing this. But this is already hard enough to conceptualize. So I wanted to kind of take a shortcut so that you all could probably focus on the more important part of this, which is the bucketing part of this, but you could probably What do I want to say here, you could probably combine this into one more effective function."
          },
          {
            "time": "[00:14:07]",
            "text": "Right, but I didn't wanna overload you with with concepts here. And in other words, I haven't thought of a better way to do it but there probably is one. But I guess another thing I would say is like if you were actually deploying radix sort in production and you were writing the code yourself."
          },
          {
            "time": "[00:14:27]",
            "text": "You'd probably have to have some knowledge beforehand of what kind of ranges of numbers you'd be dealing with, right? Well, I imagined many of you did get met and some of you probably didn't get it as well. That's totally fine, this is kind of again, a difficult one to conceptualize."
          },
          {
            "time": "[00:14:45]",
            "text": "But hopefully you're grasping at least the the method here, right? I'm actually less concerned that you successfully pass the unit test and I'm more concerned about does the sort makes sense to you. Like that's the most important thing here is like this, this kind of pattern of like, hey, let's take this apart and compare things piece by piece, right?"
          },
          {
            "time": "[00:15:07]",
            "text": "That kind of concept is one that I really want you to walk away with here, because that actually could be useful to you later while you're writing code somewhere. You also totally could write radix sort for something like strings, right? Instead of queueing this buckets here, in an array of 10, this could be an array of 26."
          },
          {
            "time": "[00:15:28]",
            "text": "If you're doing like the English alphabet, right? And you could do bucket sorting that way, or radix sort rather using letters, right, that totally works as well or hexadecimal. And it would be 16 buckets or binary actually, binaries are really effective. Use case for this, right, because you would just be queuing zeros and ones, right?"
          },
          {
            "time": "[00:15:53]",
            "text": "We should go pretty fast, so, yeah, just another interesting kind of arrow to keep in your quiver."
          }
        ]
      },
      {
        "name": "21-binary-search",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> I imagine many of you kind of like conceptually already understand this, even if you haven't put a name to necessarily this algorithm. But it's useful for you to just kind of put a name to it right at once make sure you understand it. The act of searching is kind of similar to sorting and the fact that you are comparing numbers one to each other."
          },
          {
            "time": "[00:00:20]",
            "text": "But in this particular case, we're not trying to get all the numbers in one particular order we're actually just trying to find one particular element in the array. If you're running a search on a array that's not sorted, the only kind of search you can really do is linear right which is you just write a for loop or a while loop and say like is this it?"
          },
          {
            "time": "[00:00:40]",
            "text": "Is this it? Is this it? And you just kinda go pick for that that just checks every single element in the array. However, if you have an array that's already sorted, you can use binary search. And I imagine if you're old enough to remember phonebooks, [LAUGH] Which may not be everyone that's watching this video."
          },
          {
            "time": "[00:01:02]",
            "text": "The way that you search in a phonebook if you're looking for I don't know, hold in the phonebook, you open it to the middle, you're gonna land on like M or N. And then you're gonna split the difference and go halfway between M and N, right? And then you're just gonna keep going half and half and a half until eventually learn on the Hs than the HOs and the HLs, right and then eventually we'll find holes right."
          },
          {
            "time": "[00:01:23]",
            "text": "So this algorithm of splitting the array in half and then half and then half and in half until eventually you land on the exact correct element it's called the binary search, right? So, imagine we have this array here, again, binary search works only if it is sorted, right, and we're looking for 12."
          },
          {
            "time": "[00:01:45]",
            "text": "So what you do you always you just start in the middle, right? So the middle is 19, you say is 19 equal to 12? No, it's smaller and then you go to the left and you split the difference there. So you look in the middle of the smaller half."
          },
          {
            "time": "[00:02:00]",
            "text": "So between 19 and 0, that middle is going to be ten, right? You ask this ten equal to 12? The answer no it's not. So you go larger, right? And you go right and you look in the middle of the larger half, which is between, in this case just between 10 and 12, right?"
          },
          {
            "time": "[00:02:19]",
            "text": "And then you just look there, which is going to be 12. And then you ask as well be equals to 12, yes, you found the element that makes sense. Just keeps cutting the array in half until eventually you find that the item that you're looking for. One of the questions you might ask is like, if it's of length 3, do I go to the smaller side or the larger side?"
          },
          {
            "time": "[00:02:44]",
            "text": "Doesn't matter, just pick 1. I think in this particular case I went to the smaller side, which is why we looked at 10 first instead of 12. Any questions about the algorithm of binary search? Is this best done recursively? No, I would say this is much better done with a loop than it is."
          },
          {
            "time": "[00:03:07]",
            "text": "Yeah, I guess you could totally do this with recursively. I probably would do this with had loop. Let me just make sure that I'm not telling you lies here. Search. Yep, either way though, I mean, honestly, binary search, even on extremely large arrays. Is really effective. So you probably would be fine to do it in recursive ways as well, but my solution is iterative."
          },
          {
            "time": "[00:03:54]",
            "text": "What is the O of this? Well, we're not looking at every element in the array, right? So it's not n it's gonna be less than n because we're just starting in the middle and then we're going to the side that we need to. So we're not looking at every element in the array."
          },
          {
            "time": "[00:04:11]",
            "text": "So less than n, we do have to look at some elements in the array. And it also we get economies of scale if we have extremely large datasets. So that puts us at login, right? So binary search as an algorithm is time complexity, login. And if you don't create any additional data in the process, so it's constant space."
          }
        ]
      },
      {
        "name": "22-binary-search-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, let's hop into the CodeSandbox here, it's under Search. So search.test.js. I have two for you here to try. You can do a linear search, if you want to, which is just really you're gonna loop over and say, is this it, is this it, is this it, right?"
          },
          {
            "time": "[00:00:30]",
            "text": "Feel free to skip that one, I'm actually less interested in you doing that one. I'm more interested in you doing the binary search here. So here we have a binary search. Here, right? And we're looking for someone here in this, right? In this case, we're looking for 23."
          },
          {
            "time": "[00:01:00]",
            "text": "Study them in there it is looking for, right? Okay? So I'm gonna call it binary search with 23, right? And what I want you to do here on this unit test is, I want you to write a binary search where you look for ID 23 and you return back to me this particular object."
          },
          {
            "time": "[00:01:26]",
            "text": "And then if you have extra time, go ahead and give the linear search a shot too. All right, let's do some searching, soul searching. I'm gonna change LinearSearch to be called soul search instead, just kidding. Let's just do this linear search really quick. It's just one really simple for loop here, let i = 0, and there's a just a trillion different ways you could do this."
          },
          {
            "time": "[00:01:59]",
            "text": "I'm gonna do with a for loop because we've been doing that the whole time, but you absolutely could have done a reduce a filter for each. Something like that, any one of those would have been fine. if (id === array[i].id), then return array[i]. Otherwise, you can return null, you can return undefined."
          },
          {
            "time": "[00:02:36]",
            "text": "I'm gonna do return void 0, which is undefined, right? Okay, so here we do that, remove the skip. Take a look at the tests and run them again. We should here on search, so far so good, nothing broken, cool. Binary search here, let's do, let min = 0, let max = array.length-1."
          },
          {
            "time": "[00:03:16]",
            "text": "Again, array here, by definition, must be a sorted array or binary search is not going to work. Whereas, linear search here it can be done on any array, sorted or not, okay? Let index, let element. Okay, and then you just say while(min <= max), index is going to be equal to Math.floor."
          },
          {
            "time": "[00:03:55]",
            "text": "And here we're gonna say (min + max) divided by 2. So again, we're kinda just moving halfway between these. That's what this index is, the Math.floor(( min + max) divided by 2) equals. And then we're gonna say element at that particular array is equal to array[index]. So this is whatever the element is here."
          },
          {
            "time": "[00:04:26]",
            "text": "So we're gonna say here if element.id is greater than id. Then min is going to be equal to index + 1. So that we're setting the minimum index to be one greater than the elements that we were just looking for, right? Also the element that we were just looking at rather, not looking for."
          },
          {
            "time": "[00:05:00]",
            "text": "Else if element.id is greater than id, then max is going to be equal to index- 1, as you might imagine. So if the item that we're looking at is greater than the thing that we're looking for, then we're going to move the max one underneath it. So if it's not less than, and it's not greater than, then that means by definition, it's that, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "We found the thing, in which case we say return element. Okay, so if it's in the array, this logic will find it. If this while loop breaks, which means that the max and the min overlap, that means we have looked at the entire array and we did not find it."
          },
          {
            "time": "[00:05:54]",
            "text": "In which case you can return null, return void 0. I like undefined because it just means that that's not there, right? You technically could have something that's null in the array, but again, we're splitting hairs. It depends on the semantics you want to assign to undefined or null, but I think actually undefined a better answer, so let's just go with that."
          },
          {
            "time": "[00:06:17]",
            "text": "Okay, so that should do that. Let's go ahead and remove this and see if our tests pass. And looking down here at search.test.js, looks like it works."
          }
        ]
      },
      {
        "name": "23-arraylist",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> I bring these up ArrayList here and now linkless after this because, first of all I'm using Java terminology and I apologize for that. But I don't also know of any better terminology for this and I think it's important for you to know these two data structures. We're talking two different ways that you could implement an array, right?"
          },
          {
            "time": "[00:00:17]",
            "text": "Like if I was gonna go write my own standard library with my own array types. These are kind of the two chief ways of doing it, this is really awkward for us to try. And model this in JavaScript because Java JavaScript doesn't really give you a choice, we have one array data type, and it's just called array, right?"
          },
          {
            "time": "[00:00:38]",
            "text": "But if you're in a language like Java or other languages like that, they actually give you a choice of what type of array that you're going to use. And you choose one depending on what kind of operations you're going to be doing with your array. Again, JavaScript being the high level language that it is, doesn't give you a choice."
          },
          {
            "time": "[00:00:58]",
            "text": "So an ArrayList again, imagining in your head that you're implementing an array for yourself, right? An ArrayList is kind of how you would think of it, right like that's how most of us would conceptualize how to put something in memory. So, again, pretend for a second that JavaScript has no array tied, so for right now you can't say x equals square brackets."
          },
          {
            "time": "[00:01:29]",
            "text": "I want you to think about how would you implement an array yourself using just objects. So for an ArrayList basically, I think imagine most of you would say like, okay. Well if I'm going to be doing with objects, I can just say that let's just put it in here."
          },
          {
            "time": "[00:01:49]",
            "text": "You might have an object that looks like my array equals object, I could just say array 0 or .0 = 1. I guess it doesn't like dot, so you do array 0 = 1, array 1= 2, right? So I mean obviously at the end of the day this looks actually fairly similar to what would be implementing it as, right."
          },
          {
            "time": "[00:02:18]",
            "text": "But imagine this would be like sequentially allocated in memory, right. So basically all of the various different items in your array would be co located in memory. So that if you were asking for like hey I want index 4, basically we would hop into memory. We'd look for index 0 and then we will go four places over and we would arrive at our item in the array, right?"
          },
          {
            "time": "[00:02:40]",
            "text": "So everything is just located right next to each other in memory, that makes sense? The advantage of this is it makes lookups super easy, right if I know the index and I know the object, I know exactly where it is in memory. Cuz you can think of memory is just like one super long array, right with various different addresses that we could look at."
          },
          {
            "time": "[00:03:04]",
            "text": "Yeah, so that makes lookups super easy because we can just say, okay, go to this place in memory and go seven places over. And then you have array index 6, while it's super advantageous for lookups it's kinda disadvantageous for like deletions. Possibly for additions, certainly for shifting things around, right?"
          },
          {
            "time": "[00:03:28]",
            "text": "Because if I wanna delete, let's say I have an array of size 10, so let's even go like this. So now I have 2=3, right and I have an array that has 0,1, 2 and 3, if I delete index 0 what happens? I now have to go and shift everything up, right now I have to say array 1 is assigned array 0, other way around array 0 is assigned 1."
          },
          {
            "time": "[00:04:10]",
            "text": "And I have to say array 1 is assigned array 2. And now if I say array again, and then I have to finally say delete array 2. So now if I look at my array now, that's what I had to do to actually delete something out of the array."
          },
          {
            "time": "[00:04:34]",
            "text": "That's kind of burdensome, right [LAUGH] Now imagine if my array is of size 10,000 and I want to delete arrays 0. I don't have to go shift 9999 things in memory, that doesn't sound like fun, that actually sounds pretty computationally inefficient. So that's where ArrayList kind of falls apart because it makes these deletions, right."
          },
          {
            "time": "[00:05:05]",
            "text": "Or if I wanna insert something straight in the middle, that becomes really burdensome. So that's why ArrayList for arrays is really good for things you have to do a lot of lookups on, a lot of addition. And then adding things to the end typically isn't too bad as long as you have sufficient space in memory."
          },
          {
            "time": "[00:05:22]",
            "text": "All that kind of stuff is great, but as soon as you wanna do a lot of deletions and additions in the middle ArrayList is not a good thing. Yeah, keep in mind you do have to do a lookup in a deletion in order to do a deletion. This is true regardless, we kind of ignore that part of it but let's talk about the big O's of this."
          },
          {
            "time": "[00:05:45]",
            "text": "So, a big O of an ArrayList lookup in terms of like if I asked you for array one like this. This would be constant time, right because I'll have to do is find the object, hop over one space, there it is. That's considered constant time for a lookup, however if I wanna do a deletion, what is that?"
          },
          {
            "time": "[00:06:08]",
            "text": "That actually ends up being N, right? Because I have to shift everything over in memory every single time that I do that."
          }
        ]
      },
      {
        "name": "24-arraylist-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's go ahead and go implement something with ArrayList. So I have the arrays up here we're going to get ArrayList.test. And I have a couple of things that I want you to do here. So I want you to implement an object. You have this class here, ArrayList."
          },
          {
            "time": "[00:00:23]",
            "text": "And I want you to have an integer for the length, right? So you're gonna have to keep track of what the length of your particular object is. I want you to implement a push and a pop method, so this is basically gonna be a stack at the end of the day, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "So you can push numbers on the end, right? You can pop numbers off the end. And then I want you to implement a get function and then a delete function. Which accepts an index, removes the value from the list and then it will do a collapse on that particular part, right?"
          },
          {
            "time": "[00:00:58]",
            "text": "So if I delete from index 1 of my length 10 array, you're gonna have to collapse all those various different methods. And so if you've never worked with classes before, let's just make sure that you get a clear not testing on classes. So you're gonna have a constructor, probably."
          },
          {
            "time": "[00:01:16]",
            "text": "This is where every time that I call new right here, Right, where I say new ArrayList right here, the constructor method gets run. So here you're going to instantiate all your variables. You're gonna have a push method, which is going to accept a value. And this is going to add an item to the end of the array."
          },
          {
            "time": "[00:01:50]",
            "text": "A pop method which doesn't have anything. This is going to remove the last item in the array. Okay, and returns it. You're gonna have a get method, Which is going to take an index, And returns that item from the array, And you're gonna have a delete method. Which takes an index removes item from the array and collapses, The array."
          },
          {
            "time": "[00:02:44]",
            "text": "When I say collapse, right? You need to shift everything over. So you can call this collapse. You can call it shift. You can do whatever you want there, okay? You are not allowed to use arrays at all for this. So everything needs to be done in terms of just saying I mean, let me just look at how I did it here."
          },
          {
            "time": "[00:03:16]",
            "text": "Yeah, so I have something here that I just said this .data equals empty object, right? And then I use the data object to store all these various different values in. In fact, I'll just do this for you. This is the constructor that I have. So go ahead and just copy that."
          },
          {
            "time": "[00:03:40]",
            "text": "Cool, any questions about the exercise here?"
          },
          {
            "time": "[00:03:40]",
            "text": ">> So if it's not found the index for the good function what it should return? Avoid zero is good, undefined. I don't think I test you on it. So I don't think it matters. But in that particular case, I would. You can either throw an array out of bounds or you could return undefined So, push for an ArrayList is pretty straightforward."
          },
          {
            "time": "[00:04:16]",
            "text": "This.data, this.length, Equals value, this .length plus plus. This is the advantage of ArrayList. This is a very, very straightforward operation. Pop pretty similar so cons response whatever you wanna call this, equals this .data, this .length-1. You probably wanna have some sort of logic to make sure that you're not popping off and array link 0."
          },
          {
            "time": "[00:05:01]",
            "text": "In this particular case, I'm not really worried about corner cases. I just wanted to kind of get the gist here. I'm gonna say delete this .data, this .length -1. This .length, minus minus return response. Okay, that'll remove something off the end of there. The get it's the most beautiful part of this is return."
          },
          {
            "time": "[00:05:38]",
            "text": "This.data index. Right, the whole reason for ArrayList is that this is very fast and very simple, right? As you can imagine, there's basically no bugs that that could happen here, right? I guess you'd have to worry about array or index out of bounds, but that would be just about it."
          },
          {
            "time": "[00:06:04]",
            "text": "Okay, and then delete. This is where things get a little hairy. We're gonna say const response = this.data[index]. And then we'll return this at the end. You could also could just return true or something like that. That's totally up to you. But here we're gonna have to do something to delete this."
          },
          {
            "time": "[00:06:34]",
            "text": "So I'm gonna write a method called collapsed two. So I'm gonna say this, this collapsed to index, if you've never seen the underscore leading, this is kind of how you symbolize in JavaScript a private method. Since JavaScript until very recently didn't have private methods. Technically, you can put up a pound here, And then you could say collapse to Yeah, so this actually is not enabled right now in the in code sandbox and we're not gonna to go enable it."
          },
          {
            "time": "[00:07:19]",
            "text": "But that's how you would actually do a real private method in JavaScript. Let's just replace that with an underscore. Honestly, I like this better anyway, it allows me to mess with the function which is kind of fun, right? It's fun to mess with the react internals and stuff like that."
          },
          {
            "time": "[00:07:35]",
            "text": "But apparently they don't like it. [LAUGH] All right, so we're gonna have this method called collapse to what it takes in an index. And we're gonna say for, let i=0. Sorry, let i=index rather i is less than the length i ++. Okay, and then we're gonna say this .data i = this .data i+1, Then we're gonna to eventually say delete this .data, this .length -1 cuz we're eventually gonna move that to kinda our we're removing the last one from the array and then we're gonna say this.length--."
          },
          {
            "time": "[00:08:38]",
            "text": "So this is starting i at the index and then from there until the end, we're going to shift everything over to the left one. That's what this part does, this for loop, we're going to delete the one at the end, right? And then we're going to detriment the length."
          },
          {
            "time": "[00:08:57]",
            "text": "Okay, and that should be, Enough, I think for us to pass the unit tests here. So if we go down to arrays. And I think I need to remove the skip, I do. Let's see all messed up, this.data is not a function. Yep, sorry, that should be square brackets, not, Parentheses."
          },
          {
            "time": "[00:09:30]",
            "text": "Let's try that again. And there we go, passing the tests. I hope you gained a healthy appreciation of what arrays do for you. [LAUGH] If nothing else, that's one good takeaway from this. The question is, could we technically we use the delete method for pop? Yeah, I think that would absolutely totally work."
          },
          {
            "time": "[00:09:52]",
            "text": "It's probably even as you just say this. Well, I guess you'd have to, yeah, return this start delete this .index -1."
          },
          {
            "time": "[00:09:52]",
            "text": ">> That's going to be this dot length minus. Because of the length to be the index rate, this .length .index"
          },
          {
            "time": "[00:09:52]",
            "text": ">> Yeah sorry, not, yeah, length. And normally hold it does pass."
          },
          {
            "time": "[00:10:32]",
            "text": "Yep, so that's probably even better to just reuse the logic that you have."
          },
          {
            "time": "[00:10:32]",
            "text": ">> Shouldn't it also have a big function as well, or it's four different data structures?"
          },
          {
            "time": "[00:10:32]",
            "text": ">> She does have a what as well?"
          },
          {
            "time": "[00:10:32]",
            "text": ">> A peak."
          },
          {
            "time": "[00:10:32]",
            "text": ">> Yeah, I mean, if we were implementing a truth stack, you would have a peak as well, which would be basically this .length- 1, right?"
          },
          {
            "time": "[00:10:57]",
            "text": "But we're not implementing a true stack. Did I say peak up here? Yeah, so, yeah, to be a real stack, you would have peak as well."
          },
          {
            "time": "[00:10:57]",
            "text": ">> Good, thanks."
          },
          {
            "time": "[00:10:57]",
            "text": ">> Yep. Cool other questions? So takeaway here get really great with the ArrayList. Delete kind of annoying. So if you have something that you're going to be reading from and unnecessarily adding and removing a lot of things from ArrayList, typically your best bet."
          },
          {
            "time": "[00:11:37]",
            "text": "Now, if we have something that's going to be Written to and deleted from a whole lot but not necessarily read from as much. There's another thing we can use called LinkeLists and that's what we're going to do next."
          }
        ]
      },
      {
        "name": "25-linkedlist",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's pop over here to LinkedList. LinkedList, instead of having everything co-located in memory, so it's all just one after each other. Basically, you kind of embrace a little bit of chaos and say, well, they're gonna be all over memory, but basically, we're gonna have nodes. Let's say, okay, this node holds 22, this one holds 2, this one holds 77."
          },
          {
            "time": "[00:00:21]",
            "text": "And they just point to each other in memory, right? So, 22 doesn't know about the rest of the list, all it knows about is where the next thing is, right? 2 doesn't know about anything else besides where 77 is, right? And they just had these nodes that point to each other."
          },
          {
            "time": "[00:00:38]",
            "text": "Now, this makes it hard for reads, right? Because if I wanna get index 10 over here, I have to follow the entire chain to get there, right? It's not necessarily ideal. But you can see here this is doing an add. And the adds are really great, cuz all you have to do is you add something."
          },
          {
            "time": "[00:00:55]",
            "text": "Let me just step through here. So, yeah, here, this is doing a find, until it finds where it's supposed to go. And then it's going to land right here, right? So, we create this new node. All we have to do to add this between 43 and 76 is, move the pointer for next from 76 to 50, and then add 50's next pointer to 76."
          },
          {
            "time": "[00:01:20]",
            "text": "And all of a sudden we've added something to the middle of the list, right? By the same token, if we wanted to do something like delete 43, all we'd have to do is go to 6, change its next pointer to be 76. And all of a sudden it's totally deleted from the array."
          },
          {
            "time": "[00:01:35]",
            "text": "We don't have to do anything else, right? So that's the distinct advantage of LinkedLists, is that it becomes very easy to delete and add things in the middle. [INAUDIBLE]. All right, so with LinkedLists, we're gonna have two classes that we're going to implement. We're gonna have like a LinkedList class, right?"
          },
          {
            "time": "[00:02:02]",
            "text": "Like we had an ArrayList class. We're also going to have a node class, right? So, the node class is gonna have two things on it. All it's gonna have is next, and the value, right? So, again, this 2 node right here, has a value of 2 and a next of the 77 node, and that is it."
          },
          {
            "time": "[00:02:23]",
            "text": "It doesn't know about what's before it, it doesn't know about what's after it. By the same token, the LinkedList class, all it has is the head, right? So 22 here is the head, which is the first note in the array, and then it doesn't know where everything else is, right?"
          },
          {
            "time": "[00:02:40]",
            "text": "So you have to follow it, to try and get that. So, let's dissect the delete really quick with a LinkedList, right? So we have these notes here, so [a] and these pointers, right? So let's say that we wanted to delete index 2, which is this one here, this one that says [c] in it."
          },
          {
            "time": "[00:03:07]",
            "text": "We'd first seek or do a get till we get to the [b] here, right? Then we will change the [b] to be the next of the [c], right? So that [b] now points to [d], and then that's it. Decrement the length, return the deleted node, and that would be it."
          },
          {
            "time": "[00:03:33]",
            "text": "Same things if this is doing an insertion up here between the 43 and the 76, you find 43, you point 43 to 50 and then you're done. And then, well, and you point 50 to 76. So, the lookups on a LinkedList are n, right? Because you have to loop through the entire list until you find the thing that you're looking for."
          },
          {
            "time": "[00:04:04]",
            "text": "The gets and lookups are not great. However, the deletes and the insertions are constant time, right? Because all you have to do is change your pointers and you're done. So, again, if you're deleting and inserting into the middle of a list, LinkedLists are amazing. But if you're doing a lot of reads and not doing much modification of the list, then don't use LinkedLists."
          },
          {
            "time": "[00:04:28]",
            "text": "There are variations of LinkedLists, as well. One of those is a doubly LinkedList, which will have a next, but it will also have a previous, right? So, if you can see that something is going to be closer to the end of the Linked List, you can start on the tail and then backtrack to find the thing that you're looking for."
          },
          {
            "time": "[00:04:46]",
            "text": "So, it kinda helps a little bit with those, gets, right? You can never have to go more than half of the array. But, at the same time, instead of just having to change, next, you'll also have to change previous for the insertions and the deletions. Do I have any practical use cases for LinkedLists?"
          },
          {
            "time": "[00:05:10]",
            "text": "I think the answer for JavaScript, it's basically, never. You would almost never implement this yourself because JavaScript arrays are still probably gonna be faster than anything that you could implement. If I was writing something in C, or C++, or Java, or something like that, it can make a pretty big difference."
          },
          {
            "time": "[00:05:36]",
            "text": "One of the nice things about LinkedLists is, you don't have to pre-declare how big they're gonna be, right? Because you can always just add something to the end. Because you can go anywhere you want in memory. With ArrayList you kinda have to pre-declare how much memory you wanna use, which means that can be inefficient."
          },
          {
            "time": "[00:05:56]",
            "text": "I think the Java ones are actually smart enough to reallocate themselves, but nonetheless, that's a downfall, as well. In terms of a practical example, I'm struggling to think of a concrete necessarily example, at the moment. But the general idea is, if you need to insert into the middle or delete from some sort of array, which I'm sure you can fathom situations where you're doing a lot of deleting and modifying of arrays."
          },
          {
            "time": "[00:06:29]",
            "text": "LinkedLists is where that's really gonna shine. But for the most part, ArrayLists kind of tend to be the default, because most of the time we tend to read more from arrays instead of modify them. So, that's the best general advice I'm gonna give you. It's not really super top of mind, again, cuz JavaScript, for the most part you don't really have to care about these."
          }
        ]
      },
      {
        "name": "26-linkedlist-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so the first thing on push that we're gonna do, we're gonna say const node equals new node with a value, right? We're gonna say this length plus plus. We're gonna say, if I don't have a head, this dot head, then we say this dot head equals node."
          },
          {
            "time": "[00:00:24]",
            "text": "Otherwise, simply we'll just say this dot tail dot next equals node and this dot tail. Equals node, right? So, the idea here is no matter what. Whatever you're pushing on a list is definitely going to be the last item in the array, right. So this dot tale is always going to be assigned node, the the new node, no matter what."
          },
          {
            "time": "[00:00:57]",
            "text": "If you're pushing in a new head, or sorry if you're pushing into an empty list. It's also going to be the head, otherwise. The tail dot next is gonna be the node, right? And then again here at the bottom, we're always going to assign the tail to be the new node."
          },
          {
            "time": "[00:01:15]",
            "text": "Okay. Pop, we're just gonna do return this dot delete. This dot length minus 1, right? And then we'll cut up the delete here in just a second. For the find, we're just gonna say if index is greater than or equal to this dot length. Returned no, right? So if we try and find something that's out of bounds just return nothing."
          },
          {
            "time": "[00:01:45]",
            "text": "Otherwise let current equals this dot head. Then we'll do a for loop here for let I equals zero. I Is less than or equal to index minus 1. And then I plus plus. And we're just going to say current equals current dot next. And we'll just kind of be looping through all those nodes until we arrive on the one that we want."
          },
          {
            "time": "[00:02:15]",
            "text": "And then at the bottom will return current. So this is just gonna be an internal find sort of method here so that we can find nodes. We never wanna return nodes directly to the consumer of this linked list because they wouldn't know what to do with it right."
          },
          {
            "time": "[00:02:29]",
            "text": "This is an internal data structure here. Forget. We're just gonna say const node equals this dot find index. And here we can say if there's no node here, then return for zero, if you wanna return undefined, otherwise return node dot value. So that's the get, pretty straightforward and then delete is where things tend to get a little bit more hairy."
          },
          {
            "time": "[00:03:08]",
            "text": "So the first thing we wanna do is we wanna handle, if they try and delete the head. So if index triple equals zero, then we need to handle that specifically. So const head equals this dot head and we're gonna say if head, they want to say this dot head equals head dot next."
          },
          {
            "time": "[00:03:37]",
            "text": "Otherwise, we're gonna say this dot head equals null because we need to handle it differently. If it's the only item in the array versus, it's just the head of a long list, right? That's what this is doing here. And then here underneath that, we'll just say this dot length."
          },
          {
            "time": "[00:03:59]",
            "text": "Minus minus and return head dot value. So that handles it if we're trying to delete the head, otherwise we need to say const node equals this dot find index minus 1, right? So this is going to find the node previous to the one that we wanna delete. We're gonna say const excise as in the the node that we want to cut out is gonna be equal to node dot next, right?"
          },
          {
            "time": "[00:04:31]",
            "text": "Then we're going to say, if there's no excise. Then here we could throw an error or something like that, we can return void zero you can do whatever you want I returned null. Depends on what kind of semantics you want to assign to it. Then we're gonna say node dot next equals excise dot next."
          },
          {
            "time": "[00:04:56]",
            "text": "I'm gonna say if there's node dot next. Then this dot tail is equal to node dot next. And this done link minus minus. And return excise dot value. Okay, so let's see if that passes our tests. And thus, was great. So again, this is kind of where link less fall down."
          },
          {
            "time": "[00:05:39]",
            "text": "Is that anytime you wanna do a look up, you have to loop through everything to try and find the thing that you're looking for. Just not necessarily always ideal. But, this is where it's kind of really great as these deletes, despite the fact that this codes kind of like not fun to look at, it's constant time, right?"
          },
          {
            "time": "[00:05:57]",
            "text": "All you got to do is move the pointer from here to here. It's just pointing at a new node and we don't have to like shift our entire array over like we had to do with array list. Okay, so questions about linked lists."
          },
          {
            "time": "[00:05:57]",
            "text": ">> So intersect question on line 48."
          },
          {
            "time": "[00:06:20]",
            "text": "So why is there like a index minus one record less than or equal to index minus one because we can we give like a. [INAUDIBLE] Than index. Because that's what's correct [LAUGH] I mean we can look here."
          },
          {
            "time": "[00:06:20]",
            "text": ">> Just thinking like what [INAUDIBLE] right? I less than index for [INAUDIBLE]"
          },
          {
            "time": "[00:06:48]",
            "text": ">> I think it's just because we need to find, that's the way that those nodes had been numbered. It's, I guess you could restructure it, so that the indexes would be different. Like what refers to which index refers to which node because it's all depends on what kind of semantic value assigned to it."
          },
          {
            "time": "[00:07:10]",
            "text": "Yeah, that's, I think that's just that's the one that we'll find the correct one because we're just looping through all these current until we find the one that we're looking for."
          },
          {
            "time": "[00:07:10]",
            "text": ">> I think what she's saying you can remove minus 1, if you remove less than or equal if you just make it less than."
          },
          {
            "time": "[00:07:28]",
            "text": ">> Got you. I see what you're saying."
          },
          {
            "time": "[00:07:28]",
            "text": ">> Yeah [INAUDIBLE]"
          },
          {
            "time": "[00:07:28]",
            "text": ">> Totally."
          },
          {
            "time": "[00:07:28]",
            "text": ">> Yeah, and the other question is in line 65, like a, we are making a head tool model, but we are not making the tail to [INAUDIBLE]"
          },
          {
            "time": "[00:07:28]",
            "text": ">> This is true. Yep. That would have been a bug."
          },
          {
            "time": "[00:07:58]",
            "text": "So that's correct. Good call. As you can see, these tests are not exhaustive either. So I'm sure there's probably more bugs buried in here. Again, really what I'm going for is the core of it, what I really wanted you to see was this logic of how to find something in a linked list."
          },
          {
            "time": "[00:08:21]",
            "text": "And this logic here of just moving the pointer around. Right? Again, the point of this course is not [INAUDIBLE] thank you for helping me find the bug. I think that's a good to show people. But more what I'm interested in, what you find here is what's the actual logic here."
          }
        ]
      },
      {
        "name": "27-binary-search-tree",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Trees are another way to structure data that they're not arrays so that's the first thing that you should be aware here, like we're not going to be re implementing arrays like we were with ArrayList and linked lists. Trees are usually used for special case kind of things."
          },
          {
            "time": "[00:00:21]",
            "text": "So one we're gonna be doing binary search trees. Not all trees necessary have to be in sorted order but binary search trees actually do have to be right? So for example, like an array of this 1, 5, 2, 7, 3, this is a totally valid array. But this would not be a valid binary search tree."
          },
          {
            "time": "[00:00:41]",
            "text": "Binary search trees have ordered to them and they must be sorted at all times or it's not technically a binary search tree. If we add 5 to this tree here that had 1, 4, 6, 7, the 5 actually has to come between these two or it will not be a binary search tree."
          },
          {
            "time": "[00:01:02]",
            "text": "There's many, many variations of tree structures. There's B trees, there's red black trees, there's ABL trees, there's binary search trees, there's N trees. There's tons, and tons, and tons of types of trees. We're just gonna be looking at two of them today, which are binary search trees, as well as Avielle trees."
          },
          {
            "time": "[00:01:21]",
            "text": "At its core tree is pretty similar to a linked list, that you're gonna have a node. And those nodes have next counters or next pointers, right? We're gonna call those children, right? Because there's some inherent idea of hierarchy here that you have one node and that node has two children, and that has two children, and that has two children."
          },
          {
            "time": "[00:01:43]",
            "text": "That's important to know about trees as they have these sorts of hierarchies. The first one we're gonna be looking at is a binary search tree. Are often abbreviate abbreviated as BSTs. So you'll probably hear me call that. The binary part means that the node only has two children, right?"
          },
          {
            "time": "[00:02:05]",
            "text": "As opposed to a three tree which will have three children, right. So binary means two children at most. So it can have zero children, one child or two children. And then the search part means that it's made for searching. Are particularly well suited for searching anyways. So let's take a look at one such binary search tree that we have here in our notes."
          },
          {
            "time": "[00:02:31]",
            "text": "So we have 8. This 8 is gonna be considered the root of the tree. I don't know why trees always go from top down but that's just the way that they're always modeled. So here at the root, 8, everything left. So in this subtree here is all smaller than eight."
          },
          {
            "time": "[00:02:50]",
            "text": "Everything that's in the right tree, so the 10, 14, 13 that's all bigger than 8. That's always true for every node in the tree always or it's not a binary search tree. Right, so if you look here in this 3, sub tree here, right? One is smaller than 3, 6, 4, 7 are all bigger than 3, but all smaller than 8."
          },
          {
            "time": "[00:03:12]",
            "text": "That makes sense so far? So for example, if I put, I don't know, 9 here as the right child of the 7, that's no longer a valid binary search tree because 9 is in the left subtree of 8, and it's bigger than 8, therefore, it is not a compliant binary search tree."
          },
          {
            "time": "[00:03:33]",
            "text": "So I just wanna, again, you need to be able to make those sorts of assumptions about your code, or else, this is not gonna work, right? So why is this useful? Let's say I want the data that's stored in this 4 node. The nice thing about a binary search tree is you start with the root and then you say, okay, is 4 smaller than or bigger than 8?"
          },
          {
            "time": "[00:04:01]",
            "text": "Smaller, bigger, smaller, found, right? So lookups in binary search trees are no worse than login. Well, it's not totally true. The average case scenario of lookups in a binary search tree or login, right because we can skip a bunch of nodes. So for example, if I'm looking for 4, I didn't have to look at 10."
          },
          {
            "time": "[00:04:25]",
            "text": "I didn't have to look at 14. I didn't have to look at 13. I didn't have to look at 7 and I didn't have to look at 1, right? So the idea here is they become really easy to find. So basically, you're prematurely optimizing your data structure here for really fast lookups."
          },
          {
            "time": "[00:04:43]",
            "text": "The place that famously uses trees for lookups is database indexes. So when you say hey MongoDB make me an index of my IDs, what MongoDB does is it builds a tree out of all of your IDs, and then it has pointers to all the various different objects that it stores inside of MongoDB."
          },
          {
            "time": "[00:05:03]",
            "text": "Now, it's probably not a binary search tree. It's probably some other variation of a tree but it's almost certainly a tree. So that's why we wanna know how to use these trees because it's really useful for really fast lookups. So again .find is called with 4 here, right?"
          },
          {
            "time": "[00:05:24]",
            "text": "Start with the root 8 for smaller so go left, then you're here on route 3, right? Or no 3, 4 is larger so go right. Okay, so you're a node 6 now, 4 is smaller go left. And then you found here, this is node 4. So you found the thing that you're looking at."
          },
          {
            "time": "[00:05:41]",
            "text": "So that's the logic of a lookup inside of a binary search tree. So big O here, best case scenario is that it's the root which would be a constant 10 look up, right? So that's the best case scenario. The worst case scenario is that you have to go through every single item in the array."
          },
          {
            "time": "[00:06:01]",
            "text": "Right, so actually I have it down here that the worst case scenario looks like this. So if you add things in a poor order, you can get 1, 2, 3, 4, 5 and that means I have to go through everything to find the 5. We'll talk about how to address that later but that's the worst case for lookups."
          },
          {
            "time": "[00:06:27]",
            "text": "So how do we add elements to the array? Well, it's relatively the same. As a find, so let's say here I wanted to add 7 to this tree right here. We start at 10. 7 is smaller, so go left. It's larger than 5 so go right it's smaller than it, go left."
          },
          {
            "time": "[00:06:52]",
            "text": "And there's no node here as a left child of 8. So we just add it, right, we put a brand new node there, and we end up with 7 right there. Okay, so delete a few extra steps. The Delete. So let's say we have the same tree here, and we wanna delete 5."
          },
          {
            "time": "[00:07:15]",
            "text": "So that ends up being a problem. Because what do I put there instead, I can't just not do anything there. Well, there's kind of two different options there. You can put the greatest left sub child there. So in this particular case, the greatest left sub child would be 3."
          },
          {
            "time": "[00:07:34]",
            "text": "Okay, and I can put 3 there. And now the tree still works, right? So 10, 3, 8, 6, 7 that all still works. Or I can put the least right child. So the least right child in here is gonna be 6, right? So, if I put 6 here, the tree still works, right?"
          },
          {
            "time": "[00:07:58]",
            "text": "So, in that particular case, I'd have to move 6 up to here and then I have to move 7 to be the child of 8. So in this particular case, I would end up with 6 being here and 7 being down here. So kind of the cheap way of doing that as you call delete on 5."
          },
          {
            "time": "[00:08:21]",
            "text": "First thing you do is gonna call find on 5, which you're gonna find it here, right? Right there. Okay, we found 5. Then you do find least right sub child with 5. In that particular case, you're gonna find the 6 down here, this 6. And then all you're gonna do is you are going to move the value of what was in this one up to this one."
          },
          {
            "time": "[00:08:47]",
            "text": "So that's why I put this marking here. So you can see this used to be 5, but now we've just replaced the value of that 5 there with the 6. And then we took everything that's the right child of this one and we just move it up. So in that particular case you end up with 8 having a left child of 7."
          },
          {
            "time": "[00:09:16]",
            "text": "Make sense? Cool. So, there's a couple other variations of this scenario, for example, if you'd call delete 15, and it has no children, you just delete it. [LAUGH] Right? So here, you would just set the right child of 10 to be nothing. So that's pretty easy one. So if I call delete 15, right?"
          },
          {
            "time": "[00:09:52]",
            "text": "15 has no right child but it does have a left child. So all you do is you just move the left child up, and then you end up with that. Okay, we talked about worst case BSTs. If you add everything in a sorted order to a BST, you end up with this kind of straight line."
          },
          {
            "time": "[00:10:16]",
            "text": "Which is just like a really crappy linked list right? We'll talk about how to mitigate that with what's called a self balancing tree in the next lesson, but for now we're gonna have you build BSTs. So we talked about why to use a tree you basically optimizing for search ability."
          },
          {
            "time": "[00:10:38]",
            "text": "Because most trees have an average case look up of log n, which is good Even on extremely large data sets. Okay, so anyone have any questions about BSTs?"
          },
          {
            "time": "[00:10:38]",
            "text": ">> Yes sir I have."
          },
          {
            "time": "[00:10:38]",
            "text": ">> Okay."
          },
          {
            "time": "[00:10:38]",
            "text": ">> Is there any duplication is possible in BST duplicate element like two."
          },
          {
            "time": "[00:10:38]",
            "text": ">> Let me make sure I'm understanding you're asking, can you have duplicate elements in a BST?"
          },
          {
            "time": "[00:11:21]",
            "text": "Yep, so you can either put them in the left tree or the right tree, right? So let's say I added 15 to this one, right? I can either put it in the left tree or the right tree. And it doesn't matter just be consistent. The route is just the first elements that you added to the tree."
          },
          {
            "time": "[00:11:43]",
            "text": "So if I start with an empty tree and I call dot add with. 6, right, then 6 is my root element. So it just depends on the order that you added things to the tree."
          },
          {
            "time": "[00:11:43]",
            "text": ">> Is a doubly linked list, technically a BST since both seem like that, but left and right?"
          },
          {
            "time": "[00:12:02]",
            "text": ">> Is a doubly linked list technically a BST? It's not for a couple of reasons. One, doubly linked lists don't necessarily have an order, right? So, Right, if I have a doubly linked list, it's not necessarily going to have everything smaller to the left and everything bigger to the right."
          },
          {
            "time": "[00:12:26]",
            "text": "The other thing about a doubly linked list is, it's circular in the sense of three or cyclical I think is actually the term, 3 would point to 8 and 8 would point to 3 ,and that's not true for BST. 3 actually doesn't have a pointer up, right? It only has its pointer to its children, only 8 has a pointer to this, right?"
          },
          {
            "time": "[00:12:47]",
            "text": "So they're very similar in the sense that they both have two pointers to other items. But not necessarily similar to the fact that a doubly linked list is not a tree."
          }
        ]
      },
      {
        "name": "28-binary-search-tree-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, let's go edit on code is code sandbox. Top over to trees or I think they call it bst right here, bst.test and I want you to implement I think I just have to add I don't think I actually have you do. Let me just check to make sure that I asked you to do the right things."
          },
          {
            "time": "[00:00:38]",
            "text": "So I just have you do add, I don't actually have you ever do delete. So as a stretch goal, maybe later when your brain kind of recovers from learning all this stuff, you might come back and try and do deletes. But for now, let's just go ahead and stick to adds, so let's actually just kinda get you started here."
          },
          {
            "time": "[00:01:01]",
            "text": "Bst, So I might give you a constructor here and just set this.root = null, it's probably a good one to do right away. You're gonna do an add which is gonna take a value,okay. So you're gonna have to have some logic around,if this is the root. Okay, and then you're gonna have to do some sort of find the correct place to add."
          },
          {
            "time": "[00:01:50]",
            "text": "And so there's two ways you can do the add, here in my particular course notes, I do it via a while loop, so this could be or. Another thing you could do here is you could create a node class down here, that's a constructor that takes a value."
          },
          {
            "time": "[00:02:13]",
            "text": "You'll say this.value = value, you'll say this.left = null, and this.right = null. You could potentially if you wanted to create an add method on this, that takes the value and then this could be called recursively. So that's another potential. We'll be doing it with the while loop here but just know that's also another possibility here, depending on how you wanted to do it."
          },
          {
            "time": "[00:02:50]",
            "text": "And then The other thing that might be helpful. Is if you do a toObject method here and just return the root, so this return.root. I actually wrote a little visualization helper for you. So if you hop over to The source here and look at tree.js. This will actually help you visualize your whole app here if this will load."
          },
          {
            "time": "[00:03:44]",
            "text": "So you can see here I had this tree, if you return it to an object and it has value left and right. You can ignore height, cuz we'll talk about height here in just a second, so ignore height. But if you pass it a root node that has left and right nodes, this will actually visualize it here for you as well."
          },
          {
            "time": "[00:04:08]",
            "text": "But you don't have to do that right now, I'll show you how to do it when we do our solution together. For now, just get all the adds working correctly."
          },
          {
            "time": "[00:04:08]",
            "text": ">> How is this any different from running a binary search on the sorted array?"
          },
          {
            "time": "[00:04:08]",
            "text": ">> How is this any different than running a binary search [INAUDIBLE]?"
          },
          {
            "time": "[00:04:26]",
            "text": "Well, one's an algorithm for finding something in a sorted array, and one of them is a data structure used for storing information. Now you might ask, why would you ever use a binary search tree over something like a sorted array? And it has to do with how you would allocate things in memory, right?"
          },
          {
            "time": "[00:04:46]",
            "text": "So for a sorted array, you might try store that as a, an array list right, where everything is laid out sequentially in memory. Which is not usually gonna be possible particularly for something like a database index, right? Cuz those database indexes could be pointed to objects that are enormous, right?"
          },
          {
            "time": "[00:05:02]",
            "text": "So this would be more, something where you cannot be constrained by the memory you can kind of point to wherever things want to be in memory. There's other uses for trees too, that's just kinda the most classic one and the one that I have in my head at the moment [LAUGH]."
          },
          {
            "time": "[00:05:20]",
            "text": "But it's, yeah, I guess at the end of the day one's a algorithm for finding things on a sorted array and one of them is a data structure for storing lots of data in memory or on disk for that matter. So, it depends."
          },
          {
            "time": "[00:05:20]",
            "text": ">> A big chunk in the heap memory, you can just sprinkle it around then use pointers to [INAUDIBLE]."
          },
          {
            "time": "[00:05:44]",
            "text": ">> Exactly Yeah,"
          },
          {
            "time": "[00:05:44]",
            "text": ">> It's less prone to, it's fragmenting the memory alert, but it can find the space for itself easier on a fragment, yeah, right. Fragmentation is something far less concerning these days with just how memory works, right. It used to be much bigger concern, but, and in fact in this case, it's helpful, right, because we don't have to worry about knowing ahead of time how much data we're gonna allocate."
          },
          {
            "time": "[00:06:19]",
            "text": "So the first thing that we're gonna wanna do, with our tree is, just gonna erase this. If this.root ===null, then we need to create the root, right. So we'll say this.root = new Node(value), right, that's it. Otherwise wanna say let current = this.root, and then we're gonna use a while loop to try and find where it should go."
          },
          {
            "time": "[00:07:00]",
            "text": "So we're gonna say while and let me make sure this is not running when I do this because we're gonna write a quick while true loop, cool. So we're gonna do a while true loop because we want this loop to just keep running until we tell it to stop, right."
          },
          {
            "time": "[00:07:31]",
            "text": "There's always gonna be somewhere to put the add or to put this new node. So we're never going to run into a place where we don't wanna it. So that's why this is an okay opportunity for us to use a while true loop. So first thing I'm gonna say is if current.value > value, then go left other otherwise go right, right."
          },
          {
            "time": "[00:08:07]",
            "text": "Then inside of here we'll say, if there's a current.left Then we're gonna say current is assigned, current.left. I mean, the loop run again. If it's not then we're finally supposed to add it and we say, current.left is assigned new Node with value. Okay, if we go right then we're gonna say the opposite logics."
          },
          {
            "time": "[00:08:42]",
            "text": "If current.right Then we're gonna say, current is assigned current.right and we let the loop run again. Otherwise, we say current.right is assigned new Node with value Okay, in these two cases here 36 and 44, we're gonna say break. You could also just say return, which is fine as well."
          },
          {
            "time": "[00:09:28]",
            "text": "But I'm gonna say brake. If you're not familiar with brake, it just basically means, hey, I'm in a loop right now stop being in the loop,okay. And then I need to get out of the while loop, out of the else, in every case I'm going to return this, which is the tree itself."
          },
          {
            "time": "[00:09:55]",
            "text": "Okay, and then two objects just returns this.root, so that's okay. So, this should work, let's try. And let's just make sure that I take the skip out of here, I did not So let's try that again. And bst test is working, cool. So for funsies let's paste this over into our visualizer."
          },
          {
            "time": "[00:10:39]",
            "text": "Let me go over here into tree, and I'm just going to paste this right here. Then we're gonna pop over to our little tree visualizer here, and you can see, this is what my tree looks like. It's very large at the moment, maybe a bit too large, let's do something much smaller, maybe with 10 elements."
          },
          {
            "time": "[00:11:05]",
            "text": "And so you can see here, it helps me visualize what my tree ends up looking like, kinda cool, right? So you can see this binary search tree and particular in this case, it's not super balanced, right?. So if I try and find 4, I have to go through 92867 or 86534, till eventually I find 4, it'd be great if it was a little bit more balanced, right."
          },
          {
            "time": "[00:11:43]",
            "text": "In the sense of, everything was a bit closer to the root and it was kinda laid out better, we're kind of at the mercy of how the numbers are added. For example, if I don't shuffle these, let's just visualize what this looks like when I say, const nums =.range(10)."
          },
          {
            "time": "[00:12:11]",
            "text": "What did I do wrong here?"
          },
          {
            "time": "[00:12:11]",
            "text": ">> You forgot to [CROSSTALK]."
          },
          {
            "time": "[00:12:11]",
            "text": ">> Yeah, it's getting late in the day, my friends. So this looks really hairy. So you can see here I got 0, and then it goes to 123456789, right? So it's all just in one leg. So if I search for 9, I got to go through 9 hops."
          },
          {
            "time": "[00:12:37]",
            "text": "This is why you're actually not gonna see binary search trees, in production ever just normal straight binary search trees. Because they run into these worst case scenarios and it's not that uncommon to see him, right. So we're gonna talk about another one called avielle trees that mitigate this, but there's lots of strategies for doing this like red-black trees and other ones that I can't think about top my head."
          },
          {
            "time": "[00:13:06]",
            "text": "But when you get a random distribution like this, this isn't terrible, right? The max depth here is 6. Or let's do 50 again. Max depth 11 I mean not great, but it's a lot better than searching through 50 things, 11 is more palatable. How about 150? 15, so by tripling it I only added at most four more hops."
          },
          {
            "time": "[00:13:29]",
            "text": "950, 20 right, so you can see, this is where the logarithmic lookups really help, right? So now I have 950 elements in this array and at most I have 20 hops to find what I'm looking for. It's not too bad, right? But, if I change this to const nums down here, in fact we can just do it, and I did 100, right, this is the worst case scenario now where I have max depth of 100."
          },
          {
            "time": "[00:14:03]",
            "text": "If it's unclear this line 56 here is adding them in order, right, from 0 to 99, as opposed to 55 is taking the same numbers but shuffling them in some random order."
          }
        ]
      },
      {
        "name": "29-self-balancing-avl-tree",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about self balancing trees. So we're gonna talk about something called AVL trees which is going to respond to that problem that we just had that we have these kind of worst case scenarios that we have to go through 100 hops and 100 numbers. An AVL tree is the same as a BST."
          },
          {
            "time": "[00:00:23]",
            "text": "So every AVL tree is a BST. So that's one thing to keep in mind. Not all BSTs are AVLs. So an AVL tree is a specialized version of a binary search tree. And the good news here is you can add numbers in order, and it'll automatically bounce out your tree for you."
          },
          {
            "time": "[00:00:41]",
            "text": "It has a self balancing mechanism built into the tree. So AVL trees are not necessarily the best ones. In fact, I would venture to say that you'll never use AVL trees directly in production as well. But it's a really good, perhaps most simple self balancing tree that we can talk about."
          },
          {
            "time": "[00:01:01]",
            "text": "If you're wondering what AVL stand for, it stands for the last names of the authors, which is Adelson, Velsky and Landis, right? Hence, AVL. Okay. So the nice thing about AVL trees is, things mostly work the same. The deletes work the same, the ads work the same, the finds all work the same."
          },
          {
            "time": "[00:01:31]",
            "text": "All that stuff ends up being exactly the same except for one key part. So when you go down and you do an ad, you'll actually perform what's called a balancing. And that's actually going to allow you to make sure they have a balanced tree. So let's take a look at this one here."
          },
          {
            "time": "[00:01:52]",
            "text": "I'll just make this full size so you can see. So we're going to add a number here. So the first thing you do is you're gonna do exactly like a BST. You're gonna find where it should go, okay? So we're gonna add a child to the eight here."
          },
          {
            "time": "[00:02:09]",
            "text": "Okay, so I added nine here to the eight, right? So this is still a valid BST right now, right? Nothing here is a miss for a BST. However, this tree right here ends up being out of balance. This is much lower than like say, the 71 over here."
          },
          {
            "time": "[00:02:31]",
            "text": "So we wanna do some sort of balancing to make sure that these lookups stay really fast. So, what it's gonna do is it's gonna go up the tree and say, hey, is this leg balanced? Is this leg balanced? Is this leg balanced? It's gonna land on the seven, and the seven is out of balance."
          },
          {
            "time": "[00:02:50]",
            "text": "And the way we're gonna define our balance is the right child has two height difference from the left child, right? So the left child height of the seven is zero, right? It has no left children so it has no height on its left side. The right height, it has eight and nine, right?"
          },
          {
            "time": "[00:03:10]",
            "text": "So it has a right height of two. So it's going to balance itself through what's called a rotation, okay? So let's kind of just step back through that, right? So it's going to move eight to be the root of this little sub tree. It's gonna make seven the left sub child, and nine the right sub child."
          },
          {
            "time": "[00:03:36]",
            "text": "So you can see there now it's balanced and now everything is balanced, right? And there you go. So that's called a single rotation. I think it's technically a left rotation. As you might imagine, you can rotate the other way, right? So, the right child is heavy. But as you may imagine, you can also have the left child be heavy in which case, we would rotate to the right."
          },
          {
            "time": "[00:04:14]",
            "text": "And that's it. That's the only difference here that we're really concerned about, is these rotations. So before I advance there, does anyone have any questions about single rotations? At least conceptually. All right? So let's talk through what the rotations look like. I have five, eight and I try, which is currently a valid AVL, right?"
          },
          {
            "time": "[00:04:51]",
            "text": "This is a left height of zero and a right height of one, right? Which is not too different, right? It needs to be two different so if I had like a nine here for example, right? This is now not a valid AVL tree because this five is out of balance."
          },
          {
            "time": "[00:05:06]",
            "text": "Okay, so I call ad with nine. I do a normal BST add which puts it down here on node C. Now, I have to do a balanced check on my way up. So whereas before on the BST you and I did a iterative add, right? So we used a while loop to find the correct place to put the node."
          },
          {
            "time": "[00:05:31]",
            "text": "On an AVL tree we're gonna do it recursively because on the way back up, in fact you can see it here. So I add nine. And then every node on the way up, you can see where it says eight. It's saying, am I imbalance? Now does it on the seven, it says am I imbalance and it says no."
          },
          {
            "time": "[00:05:51]",
            "text": "And that's when we start doing the rotation. So on the recursion up, we're asking every single node, are you balanced after I added, okay? So, check the balance of node C, left height is zero, right height is zero. Node C here is in balance. On node B the left height is zero, the right height is one."
          },
          {
            "time": "[00:06:15]",
            "text": "So node B is in balance. It checks on node A. And it says the left height is zero, the right height is two. That's a difference of two, so this is out of balance. So, it's unbalanced, right heavy, child is right heavy. When I say child is right heavy, it means that it goes five, eight."
          },
          {
            "time": "[00:06:38]",
            "text": "And then its child is on the right, not on the left cuz that ends up being important, right? So if this was five, eight, seven, we would have to do something slightly different. In other words, if it's a straight line like this, we're gonna do a single rotation to the left."
          },
          {
            "time": "[00:06:56]",
            "text": "See, I always messes up. This is technically a right rotation cuz the right child is heavy. Anyway, doesn't matter. So what we're gonna do here is this is the entire logic of a rotation diagram, step by step for you, okay? So node A, yeah, you're gonna swap the values of node A and node B."
          },
          {
            "time": "[00:07:23]",
            "text": "So five is gonna go here and eight is gonna go here. Make node B's the left child of A. So you're gonna move node B to B here as the left child of node A. Make node C, the right child. So node c will be the right child of node A, okay?"
          },
          {
            "time": "[00:07:50]",
            "text": "We're gonna move node B's right child to its left child. In this case, they're both nulls so this step ends up not doing anything. And then you're gonna make node A's original left child, which was null in this case. So this is also not a necessary step. The left child of node B."
          },
          {
            "time": "[00:08:05]",
            "text": "And then you just need to make sure you update the heights on all of them when you're coming back out. So this is what you end up with. Where eight is the root, five is over here, and nine is over here. The thing that I wanna make sure you understand here, notice that node B's value used to be eight."
          },
          {
            "time": "[00:08:22]",
            "text": "And node B's value down here is now five, right? So we do swap some values around, whereas these nodes are, yeah, the nodes are changing values. Make sense? Good so far? All right. So I showed you a right rotation, right? Which is moving from the right to the left."
          },
          {
            "time": "[00:08:47]",
            "text": "As you might imagine, the left rotation is the exact mirror of what I just did, right? Okay? So this is the generalized formula here. Like literally I went line by line in my code and I diagrammed out. If you follow these steps exactly, this works in every case."
          },
          {
            "time": "[00:09:12]",
            "text": "Now let's talk about double rotations. I should say, this is the hardest thing you're gonna do today. I probably should have led with that, but here we are. [LAUGH] All right. So, double rotations. We are going to add nine to this array or to this BST, right? So we have this existing tree, we're gonna find where to add nine."
          },
          {
            "time": "[00:09:44]",
            "text": "Nine should go here, right? And so we end up with this tree. As you can see here, number seven here is out of balance. It has a right height of two and a left height of zero. So this is not gonna work, we need to perform a rotation."
          },
          {
            "time": "[00:10:04]",
            "text": "Now, here's the problem. If you notice, if you remember the other one, this line was straight so it had a right child and then a right child, right? That's allowed us to do a single rotation and everything was fixed. The problem with this is if it's a bent one, right, so you go right then left."
          },
          {
            "time": "[00:10:25]",
            "text": "This is a right rotation but a left child heavy. So we actually have to do what's called a double rotation. Now, the good news is you're just using the same rotation method just twice. So the first thing we're gonna do is we're gonna do a right rotate or sorry, a left rotation on this 11."
          },
          {
            "time": "[00:10:56]",
            "text": "And it doesn't actually show, it does, okay. All right, so we're gonna do that right rotation. So now we're right heavy again, right? So we made nine the child here and 11 the right child. So basically, we switch to these positions, right? So now nine is coming over here, 11 is going down here."
          },
          {
            "time": "[00:11:24]",
            "text": "And now we have a straight one, and now we can just perform a normal right rotation on seven, and then we end up with this rotation here. So that nine is now the root, seven is now the left child and eleven is now the right child. And everything is balanced, and happy."
          },
          {
            "time": "[00:11:49]",
            "text": "Hold on. So just to, yeah, feel free to watch that a few times to kind of understand exactly how the rotations happen. So one right rotation, sorry, left rotation on the nine, and then a right rotation on the seven is technically how that works. So let's just visualize why you do it this way."
          },
          {
            "time": "[00:12:25]",
            "text": "So I have five and eight, right, and I wanna add seven. So now I have a right heavy child on the five. So if I perform a single rotation just on the five here, I end up with this tree where eight is the root, five is the left child and seven is the right child."
          },
          {
            "time": "[00:12:49]",
            "text": "Still out of balance, didn't help, right? I just have a different problem now. So the correct thing to do here when you have a tree like this, where seven is the left child, is I'm gonna call right rotate on eight. It's literally just the same method, right? I don't have to write anything special, I just call left rotate, [LAUGH] call left rotate on eight."
          },
          {
            "time": "[00:13:12]",
            "text": "So now I have five, seven, eight, and I have this straight line here, right? And then I call, right rotate on five here, and I end up with five, seven, eight, like that."
          }
        ]
      },
      {
        "name": "30-self-balancing-avl-tree-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> A lot of information. I'm gonna give you an opportunity to do this. But we're gonna walk through this kinda piece by piece first and then I'm gonna give you some time to do the exercise. So let's pop over to our CodeSandbox here. And we're gonna pop into AVL and do AVL test here."
          },
          {
            "time": "[00:00:22]",
            "text": "Most of your actual logic is gonna live in the node. So I'm gonna say here we're going to code a constructor, And we're gonna say this.root = null, We're gonna do an add, It's gonna take in a value. And actually, let's just go ahead and do this together before I let you get started."
          },
          {
            "time": "[00:00:52]",
            "text": "I'm gonna say if this.root, then this.root = new Node(value), else what you're gonna do is you're gonna say this.root.add(value). And then we're gonna put all of the add logic on the node. Okay, and then we're gonna put two object method here, if you wanna use that visualizer again."
          },
          {
            "time": "[00:01:27]",
            "text": "That's just going to return this.node, return this.root, rather. Okay, this is the complete tree method, you don't have to do anything else here. That's it. Okay, on the node, We're gonna put a constructor, There we're gonna say this.left = null, this.right = null. We're gonna say this.value = value, so you also need to accept the value here."
          },
          {
            "time": "[00:02:21]",
            "text": "And we're gonna say this.height = 1, cuz we have to keep track of a height to know when we need to rotate things, right? So make sure when you're adding new nodes to your tree, make sure you're updating the height on the fly. Okay, you're gonna have an add method, Which is gonna take in a value, this is recursive, right?"
          },
          {
            "time": "[00:02:48]",
            "text": "So, you're gonna have this add method called the add method on its children, right? So if I have going back to here, Let's look at this tree I guess, if I call add on 15, what I'm gonna do is, I'm gonna call and I'm gonna add let's say 13."
          },
          {
            "time": "[00:03:09]",
            "text": "I'll say tree.add(13), and then I'm gonna say this.route add 13, it's gonna call this on its left child. So it's gonna say this.left add 13, this.right add 13, right? And it's gonna just go down the tree until eventually finds the correct space, right?"
          },
          {
            "time": "[00:03:09]",
            "text": ">> Would this be the recursive method that you talked about for the binary search tree?"
          },
          {
            "time": "[00:03:32]",
            "text": ">> If you did the recursive way with the binary search tree, this is the same logic, mostly, right? It's, you're definitely on a good start there."
          },
          {
            "time": "[00:03:32]",
            "text": ">> That's okay."
          },
          {
            "time": "[00:03:32]",
            "text": ">> Cool, good question. So, basically here you're gonna decide to go left or right. It's gonna look a lot like that while loop that we wrote if you wrote it like I did."
          },
          {
            "time": "[00:04:02]",
            "text": "Okay, Until eventually you're gonna find the right place. Find the correct place to add, And again, make sure you update, you're updating heights, okay? The very last thing that you wanna call on this add is this stop balance method. Okay, and then we're gonna make a balance method."
          },
          {
            "time": "[00:04:56]",
            "text": "You're going to basically on every node, you're gonna ask, is this node out of balance? By checking the highest, right, remember if it has two or more different switches, if it has two difference, right? Then that's you need to call a rotate. So, So if it is out of balance, if it's not out of balance then do nothing."
          },
          {
            "time": "[00:05:31]",
            "text": "If not out of balance do nothing, if it is balance ask is, All right, do I need to do, do I need to single or double rotate? So, if single just call rotate on self, if double call rotate on child, then on self."
          },
          {
            "time": "[00:05:31]",
            "text": ">> On line 16 is that supposed to be if it is balance or if it's out of balance?"
          },
          {
            "time": "[00:06:23]",
            "text": ">> Yeah, sorry if it is out of balance. Thank you, appreciate it, Okay? Then, we're gonna write two methods down here called rotateRR, And rotateLL. Why they're called RR and LL I'm not exactly sure, but I think everyone calls them that so I just continue to call them that."
          },
          {
            "time": "[00:06:56]",
            "text": "So, You call rotateLL if the left child is heavy, you call rotateRR, if the right child is heavy. So it's from the right to the left is right, from the left to the right is left. And then when you call these rotate methods, you're gonna have to do some updating on the heights as well."
          },
          {
            "time": "[00:07:20]",
            "text": "So I wrote a function called updateInNewLocation(). So if you're doing an RR, sorry, if you're doing a LL, you're gonna say at the bottom of this, this.right.updateInNewLocation(), this.updateInNewLocation(). Rotate and then rotate this one you say this.left.updateInNewLocation() this.updateInNewLocation(). Okay, here, You're just basically gonna calculate the new height, that's all this is gonna do."
          },
          {
            "time": "[00:08:10]",
            "text": "So basically you're gonna say, do I have a left child, do have a right child? If I have neither than I'm of height 1, in the heights I include myself as height 1. So actually, an empty child I had is height 1, but as long as you're consistent."
          },
          {
            "time": "[00:08:22]",
            "text": "If you wanna call a node with no children 0, that's totally fine too, I just stuck with 1. And that's really it. So the one thing I wanna say and just re-emphasize too, For the rotate, which is definitely the hardest code to write here, follow, This logic exactly."
          },
          {
            "time": "[00:08:55]",
            "text": "This is literally line for line the code that you need to write. If you do this, if you can translate this into code, that's the correct way to do rotations."
          },
          {
            "time": "[00:08:55]",
            "text": ">> Going down trying to find the final note to add the new value to."
          },
          {
            "time": "[00:08:55]",
            "text": ">> Yep."
          },
          {
            "time": "[00:08:55]",
            "text": ">> If the current node has just one child on one side and if I'm adding to that single child, I think that's right place for rotation?"
          },
          {
            "time": "[00:09:26]",
            "text": "So I think I can know beforehand, I'm not sure about this, can I? I'm going down trying to find a node to add to and I have this node which has a single child. And I'm sending the value towards that child, there is a rotation waiting to happen, is that true?"
          },
          {
            "time": "[00:09:54]",
            "text": ">> Probably. Are you saying that you can do this without a recursion and you could do it with a loop? Is that what you're asking? So to answer your question, it probably is, I'd have to write the code to really think about it. But the reason why you wanna do recursion is because you want to update all the heights on the way back up."
          },
          {
            "time": "[00:10:19]",
            "text": "So I guess if you were willing to keep a queue of items that you need to update the heights of. So you could like keep like a list of all the nodes that you've looked at so far, so that on the way back up, you can add them."
          },
          {
            "time": "[00:10:37]",
            "text": "Then that would probably would be okay, I guess you could just do it on the way down too. Yeah, I guess there are a couple of ways to, write this. This is just the way that made the most sense to me."
          },
          {
            "time": "[00:10:37]",
            "text": ">> Just trying to make sense of how this thing works."
          },
          {
            "time": "[00:10:52]",
            "text": "That's why not because I'm trying to avoid recursion."
          },
          {
            "time": "[00:10:52]",
            "text": ">> It's okay. It's still possible to use recursion and know beforehand, right?"
          },
          {
            "time": "[00:10:52]",
            "text": ">> Yeah, I think that's possible. But again, there might be some unforeseen issue that I'm not thinking of at the moment. But I'd love to see it, so if you wanna try writing it, let me know, that'd be great."
          }
        ]
      },
      {
        "name": "31-self-balancing-avl-tree-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go ahead and do the add first. So we're gonna say if, This. Or we'll say if value is less than this dot value, Then we're gonna ask if I have a left child. So if this dot left, Then we're gonna call this dot left dot add with value and recursively go down the tree here."
          },
          {
            "time": "[00:00:34]",
            "text": "Else, This dot left equals new node, Value. Then here we need to adjust the heights a little bit. So we're gonna say if no this dot right. Or this dot right dot height, Is less than this dot left, Dot height, Then we just need to make sure that say this dot height equals this dot left dot height plus one."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we're modifying the height here as we're going, we wanna just make sure that we're updating it as we go. And we're gonna have the mere logic in the else but just for the other side. So this is go left. And this is go right. So we're gonna say if this dot right, we're gonna say this dot right dot add value."
          },
          {
            "time": "[00:01:58]",
            "text": "Else this dot right equals new node with value. And same logic here. If this dot left, Or this dot right dot height is greater than this dot left dot height. Then we just wanna make sure that we say this dot height equals this dot right dot height plus one."
          },
          {
            "time": "[00:02:35]",
            "text": "So that's all of the add right there. As you can see here it looks. This is basically just a BST add done recursively with the addition of we're worrying about adding heights at the end. Otherwise this is exactly the same as the idea of adding an add to a BST recursively."
          },
          {
            "time": "[00:02:55]",
            "text": "With the only difference being here that we call balance down here. Okay? I'm just gonna delete all this. So the first thing we're gonna do in balance is say const right height is assigned this dot right. If we have one, then this dot right dot height. Otherwise it's zero const left height is assigned this dot left if we have one."
          },
          {
            "time": "[00:03:30]",
            "text": "It's gonna be this dot left dot height, Or zero. So we're gonna say if left height is greater than right height plus one. Meaning that there are two different, right? There we're gonna say const. This is the part where we need to check if we need to do a double rotation."
          },
          {
            "time": "[00:04:01]",
            "text": "So, bear with me for a second. We're gonna say const left right height is assigned this dot left dot right. If that exists, then we're gonna say this dot left dot right dot height or zero. Same thing here for left, left, height const. Left, left, height is assigned."
          },
          {
            "time": "[00:04:34]",
            "text": "This dot left dot left. And if that exists, then we say you could also do a what is it? Nullish selectors I think that's what they're called. No, I'm thinking the wrong thing. Where you just say, question mark like this. Can't remember the name of that feature, anyway."
          },
          {
            "time": "[00:04:56]",
            "text": ">> I believe it's called [INAUDIBLE] stuff like that."
          },
          {
            "time": "[00:04:56]",
            "text": ">> Null coalescing, that sounds right. I believe you [LAUGH]. But I don't think that's enabled in Code Sandbox right now by default. So we're just gonna do it this way. Dot left dot height or zero. Now we can check if this is basically bent."
          },
          {
            "time": "[00:05:19]",
            "text": "If it's bent, then we're gonna do a rotation. So what we need to say here is if, Left right height is greater than left left height, then we do this dot left dot rotate RR. So this is a double rotation here. If it's not, then we just skip that part and we just say this dot rotate LL."
          },
          {
            "time": "[00:06:04]",
            "text": "So if we need to double rotation on the left child we'll rotate to the right or from the right. And otherwise, and no matter what, if we're inside of this block, we're always going to rotate LL on the node itself. Here we're gonna say else if, Right height is greater than left height plus one."
          },
          {
            "time": "[00:06:31]",
            "text": "Then we need to do a rotation. And same thing here, const right right height is equal to this dot right, Dot right this dot right dot height, Or zero. Then const right left height is assigned this dot right dot left. We'll say this dot right dot left dot height, Or zero."
          },
          {
            "time": "[00:07:22]",
            "text": "Then if, Right left height, Is greater than right right height. Then we're gonna say this dot right dot rotate LL. And then this dot rotate RR. This is a double rotation. So this is the all of the logic for balancing that we run on on the node. Now we just need to go program these two functions."
          },
          {
            "time": "[00:08:18]",
            "text": "Rotate LL and rotate RR. But the nice thing notice again, this logic and this logic, it's the same function, right? Still works the same way. Which is nice, we don't have to code four different ways of doing rotations. It's just two ways of doing rotations and sometimes we do it twice."
          },
          {
            "time": "[00:08:40]",
            "text": "All right, this is gonna be fun, let's do rotate RR first. So we're gonna say const value before is assigned this dot value. Const left before is assigned this dot left. This dot value is assigned this dot right dot value. This dot left, Is assigned this dot right."
          },
          {
            "time": "[00:09:21]",
            "text": "This dot right is assigned this dot right dot right. If you're looking at this thing like how do I know how to do this? I looked it up [LAUGH]. I can't remember this from memory. This dot left, Dot right. Well that's nice for the sandbox. There we go."
          },
          {
            "time": "[00:09:50]",
            "text": "This dot left is assigned this dot right, this dot right is assigned this dot right dot right, this dot left dot right is assigned this dot left dot left. This dot left dot left is assigned left before. This dot left dot value is assigned value before. This dot left dot update in new location."
          },
          {
            "time": "[00:10:23]",
            "text": "This dot update in new location which I already had down there. Make sure I got that right, this top left. So I actually had these backwards. I did, sorry about that. Cool. So that is a right rotation. And now the nice thing, that left rotation is just the exact mere opposite of what we did there."
          },
          {
            "time": "[00:11:02]",
            "text": "So const value before is assigned this dot value. Const right before is assigned this dot right. This dot value is assigned this dot value. Sorry, this dot left dot value, left dot value. This dot right is assigned this dot left. This dot left is assigned this dot left dot left."
          },
          {
            "time": "[00:11:37]",
            "text": "This dot right dot left is assigned this dot right dot right. This dot right dot right is equal to right before. This dot right dot value equals value before. And then this dot right dot update new location and this dot update new location. Cool, so those are the two rotations."
          },
          {
            "time": "[00:12:18]",
            "text": "Now we're just gonna do the update new location and then we are golden. So if this dot right, And this dot left meaning there are no children for this. Then this dot height is equal to one. Else if, This dot right. Or, This dot left and this dot right dot height, Is less than this dot left dot height."
          },
          {
            "time": "[00:13:10]",
            "text": "So again, if I don't have a right child or I do have a left child. And the right height is less than the left height which means that we need to take the height from the left. Yep, then we're gonna say this dot height is assigned this dot left dot height plus one."
          },
          {
            "time": "[00:13:35]",
            "text": "Because we rotated it and now the height needs to be adjusted to whatever the left height's rotation is. So the left's height plus one is right because it's the parent of the child. Else, otherwise we can just say this dot height is assigned this dot right dot height plus one."
          },
          {
            "time": "[00:13:59]",
            "text": "So basically what we're saying, if this is a leaf node aka has no children its height is one. If the left child has the greater height, then use its height and add one. Otherwise use the right child and add one to its height. Right, because the height is always gonna be one more than one of its children."
          },
          {
            "time": "[00:14:33]",
            "text": "That was a little bit of code [LAUGH]. Hopefully you stuck with me. Let's see if our AVL tree actually passes unit tests. Let's click play. AVL test is now passing. Cool, I was very afraid it wasn't going to [LAUGH]. So I'll take questions here in just a second."
          },
          {
            "time": "[00:15:10]",
            "text": "But I wanna show you because I think this is the coolest part. We're gonna copy and paste this tree into our tree visualizer. Save it, I'm gonna pop over to our browser and look at our tree visualizer. Look how flat this tree is. How cool is that, right?"
          },
          {
            "time": "[00:15:39]",
            "text": "It's super flat. So we have max depth of 12. And how many things are we adding to it right now? 950 items in the array, or sorry that we're adding all at once. That's unbelievable. So that means despite the fact that we have 950 things in our tree, at most, we have 12 hops."
          },
          {
            "time": "[00:16:04]",
            "text": "So that means we can find data really quickly. So let's take a look at this as well. Now you can see, if we're adding 100 things, And we're adding them in order, This makes a very flat tree. So we kind of do away with that problem that we had before where it's super bent."
          },
          {
            "time": "[00:16:26]",
            "text": "Or sorry, not super bent, but it's super straight. So that's pretty cool too. I'm just gonna add 9,500 here, see what happens. It's probably gonna take a second. So I went from 950 to 9,500 items in my tree. And now at most I have 16 hops to find the item I'm looking for."
          },
          {
            "time": "[00:16:50]",
            "text": "Again, I think that's really cool. Maybe I just have a warped sense of what's cool [LAUGH]."
          }
        ]
      },
      {
        "name": "32-avl-trees-q-a",
        "timeFrames": [
          {
            "time": "[00:00:01]",
            "text": ">> Okay, let's take some questions about AVL trees."
          },
          {
            "time": "[00:00:01]",
            "text": ">> I guess I can go first. I'm kind of struggling where to put AVL trees conceptually. So the way I see computer science, right? It's, I guess I'm up. Three is here, drugs there, all that stuff. And then there's a VM please."
          },
          {
            "time": "[00:00:28]",
            "text": "I don't really get how they fit in the big picture. I don't know. I just don't strike me."
          },
          {
            "time": "[00:00:28]",
            "text": ">> Yep."
          },
          {
            "time": "[00:00:28]",
            "text": ">> I'm trying to put it somewhere desperate."
          },
          {
            "time": "[00:00:28]",
            "text": ">> For sure, no, I totally understand where you problem is. [COUGH] So the question is, what the hell do I do with this knowledge that I have now?"
          },
          {
            "time": "[00:00:48]",
            "text": "Why did I learn this? Why did you subject me to this torture? Valid question, honestly, I'm not totally sure myself sometimes. It's not cuz I'm a sadist or something like that. I mean a bit, but it's for fun. So the time that you want self balancing trees, so I'm gonna say self balancing trees as opposed to AVL trees."
          },
          {
            "time": "[00:01:14]",
            "text": "Because something like a red black tree which does the same thing just with different methodologies is better. It just works better but it's harder to implement. So, with self-balancing trees. Basically, you wanna think about using these when you have huge amounts of data like 9,500 things and you need to be able to find things very quickly."
          },
          {
            "time": "[00:01:37]",
            "text": "So, you're willing to sacrifice ad performance and delete performance for extreme searchability. That's really like, hey, self balancing trees, that's gonna be the thing that I need. So again, database indexes is like, is a good example of this. I have 1 million things in my database. I have I mean, how many Facebook users are there right, a billion users, and I need to be able to look up any user at any time."
          },
          {
            "time": "[00:02:05]",
            "text": "You're gonna use some sort of self-balancing tree probably for that index, right? Where you can say, give me user number 1350, and that'll go into the tree, and it'll find that really quickly and hand you back the user. That's the part where self-balancing trees end up being super useful for you."
          },
          {
            "time": "[00:02:26]",
            "text": "Does that make sense?"
          },
          {
            "time": "[00:02:26]",
            "text": ">> Yes, it does. So I guess, like it's a scalable tree, circle, right? That's what it is."
          },
          {
            "time": "[00:02:26]",
            "text": ">> That's exactly what it is. It's a extreme scalable tree."
          },
          {
            "time": "[00:02:26]",
            "text": ">> About the rotations is there like an explanation, that's much easier to or analogy for what happens during a rotation."
          },
          {
            "time": "[00:02:53]",
            "text": ">> I mean the best"
          },
          {
            "time": "[00:02:53]",
            "text": ">> I mean the concept I'm really struggling to understand."
          },
          {
            "time": "[00:02:53]",
            "text": ">> Weird so I totally understand. And honestly these videos are the best things I can show you, right? [COUGH] Basically, you're just trying to make the depth of the tree flatter, so I tried to do here with the the video that you can watch."
          },
          {
            "time": "[00:03:14]",
            "text": "If you go to visualgo.net, which is where these videos are from. They have here binary search trees and you can click on here. yeah cool, I got it. And then they have like a little AVL tree module up here. So you can insert in here, Click Go. And you can see here it will actually go through and insert all those things for you."
          },
          {
            "time": "[00:03:48]",
            "text": "You can kind of visualize what's happening. So that's the best thing I can say of like, how to kind of conceptually visualize them more. As far as like the specific logic of what it's actually doing for you like this code right here. It's just doing that mechanism of rotating the tree around."
          },
          {
            "time": "[00:04:14]",
            "text": ">> So, if you were to explain the difference between the left and the right rotation Apart from like, visualizing it isn't there's no real there's no easy way."
          },
          {
            "time": "[00:04:14]",
            "text": ">> There's no like, conceptual analogy to make there. It's just moving nodes around in a tree to make it look flatter."
          },
          {
            "time": "[00:04:38]",
            "text": "A right rotation, right? Is this right child? There's two here, the left child. There is zero here. And you're trying to make it so 8 is gonna be the root node of this, and then you're gonna have a left child of 7 and a right child of 9, right, cuz that's flatter."
          },
          {
            "time": "[00:04:54]",
            "text": "So it means that there are less hops, right, so that you end up with trees that are really nice and pretty, like these ones. That's the whole point of why you do it, and then the the actual mechanism that you do it is just, again, these steps right here."
          },
          {
            "time": "[00:05:18]",
            "text": "But beyond that, it's just it's really abstract [LAUGH] And I'm not sure if I can make that abstract concept any more concrete than it is because it's just inherently an abstract concept. Is that a sufficiently unsatisfying explanation of that?"
          },
          {
            "time": "[00:05:18]",
            "text": ">> I think I'll just go to visual go and try to little concept on that."
          },
          {
            "time": "[00:05:48]",
            "text": ">> I would say that would probably be your best bet, yeah."
          },
          {
            "time": "[00:05:48]",
            "text": ">> Thanks."
          },
          {
            "time": "[00:05:48]",
            "text": ">> Yep, of course. Is there another question?"
          },
          {
            "time": "[00:05:48]",
            "text": ">> This height thing is a bit confusing, the balancing thing. Correct me if I'm wrong, the balancing thing is like if height of the like, left and right is like minus is greater than or less than or less than 1."
          },
          {
            "time": "[00:06:12]",
            "text": "So is it balanced is it or like what like."
          },
          {
            "time": "[00:06:12]",
            "text": ">> So the difference has to be 2, right?. So again looking, let's look at this tree, right? so this 6 Itself has a height of, I call it 3 in mind, right? Because this is height 1, this is height 2, and this is height 3."
          },
          {
            "time": "[00:06:34]",
            "text": "So it's left height, sorry, the height of its left child is 2, and the height of its right child is 1, so they're balanced, right? Cuz 1 is only 1 different than 2. So as long as it doesn't have a difference of 2 or more, then it's considered balanced."
          },
          {
            "time": "[00:06:58]",
            "text": "If I added 2 here, so this would have, the 2 would go here, right? This would now have a left height of 3, and this would now have a right height of 1, so it'd be out of balance, and it'd be out of balance on the left. So we'd have to balance here."
          },
          {
            "time": "[00:07:18]",
            "text": "Does that make sense?"
          },
          {
            "time": "[00:07:18]",
            "text": ">> Yeah, what if you had a 0 then? Then the height of 6 would be 4, is it?"
          },
          {
            "time": "[00:07:18]",
            "text": ">> So if I added a 0 to this tree, where I'd go here, right? Same thing with we'd still have to rotate."
          },
          {
            "time": "[00:07:18]",
            "text": ">> Yeah, but the height of the 6 word like 1, 2, 3, 4, is that's how I've been I'm just confused with the like the current node we have given it as a height of 1, right?"
          },
          {
            "time": "[00:07:45]",
            "text": "Then it's like a, it's children predecessors would be the counting 2, 3, 4."
          },
          {
            "time": "[00:07:45]",
            "text": ">> Let's see if I can just explain it. So, if we added 0 to this tree, the 0 would go here, right?"
          },
          {
            "time": "[00:07:45]",
            "text": ">> Yeah"
          },
          {
            "time": "[00:07:45]",
            "text": ">> This would have a left height of 1 a right height of 0."
          },
          {
            "time": "[00:08:03]",
            "text": "This would have a left height of 2 and a right height of 1, that's fine. This would have a left height of 3, and a right height of 1. This 6 would be out of balance, and so we would rotate left"
          },
          {
            "time": "[00:08:03]",
            "text": ">> But yeah, little bit confusing yeah, but yeah."
          },
          {
            "time": "[00:08:27]",
            "text": "[LAUGH]"
          },
          {
            "time": "[00:08:27]",
            "text": ">> It's inherently confusing, [LAUGH] I didn't invent the algorithm. [LAUGH] Yeah, it just takes some getting used to. And again, this visual algo is actually pretty helpful and understanding. When to rotate left when to rotate like right."
          },
          {
            "time": "[00:08:27]",
            "text": ">> Yeah, another thing like the approach that we followed in this AVL trees like we applied the methods on all on load, right?"
          },
          {
            "time": "[00:09:01]",
            "text": "But can we follow the approach that we follow it on the binary search tree like on the tree node? Pre bootlicker we applied to makers like adding or checking these is it balanced or not like"
          },
          {
            "time": "[00:09:01]",
            "text": ">> This is what we were talking about before, so the question is in the BS tree, just bring it up here, in the BS tree we have all the the root the logic here for adding the tree."
          },
          {
            "time": "[00:09:30]",
            "text": "Use the while loop. And here in the AVL tree, we switch to a recursive add that exists on the node. Could you do it with a iterative approach on the tree? And I think the answer is no, I think you have to do it recursively because the balance has to be checked on the way up And I don't think there's another way to handle it, though, I could be wrong."
          },
          {
            "time": "[00:09:55]",
            "text": "That's just my intuition in terms of how I chose to implement it. Because I think you have to update the heights and you have to update the rotations in which case you would need to do that recursively"
          }
        ]
      },
      {
        "name": "33-depth-first-tree-traversals",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We are gonna do some tree traversals, I promise these are like a million times easier so you can kinda rest easy for a second. Again, that AVL tree is the most difficult thing that you're gonna learn in this course. So if you survived this far, you're over the crest of the mountain now, it's all downhill from here."
          },
          {
            "time": "[00:00:23]",
            "text": "So let's talk about traversals. And these actually end up being kind of important just in general, with traversing graphs and traversing paths, and mazes, and trees, and all that kind of stuff. So let's talk about a tree traversal. So a tree traversal in this particular case, imagine I gave you this tree, I just handed it to you and said, I want an array of all the numbers in this array or in this tree."
          },
          {
            "time": "[00:00:50]",
            "text": "How would you do that? There's a couple ways of doing it, and these are called traversals, right? So let's say I gave you this binary search tree, and I wanted everything. Just I don't care what order they come back in. Just give me all of the numbers that exist in the array."
          },
          {
            "time": "[00:01:10]",
            "text": "You could do what's called a pre-order traversal, which is I'm gonna give you 8, 3, 1, 6, 4, 7, 10, 14, 13. So basically, just the order that you visit all the nodes in, right? So since I start on the root node, I'm going to give you 8 first, then I'm gonna go to the left child and I'm gonna give you 3."
          },
          {
            "time": "[00:01:33]",
            "text": "Then I'm gonna the left child and I always go to the left first then right. Then I give you 6, then 4, then 7, then 10, then 14, then 13. So this is called depth first traversal because we're going as deep as we can first. And you can see here again using this tree up here, we call the method we'll call it pre-order traversal on the root node 8."
          },
          {
            "time": "[00:01:58]",
            "text": "We add 8 to the array, then we call pre-order traverse on the left child 3, we add 3 to our array. We call pre-order traversal on the left child 1 just here, right? Maybe I can zoom out a bit so you can maybe see a little bit of what's going on."
          },
          {
            "time": "[00:02:15]",
            "text": "So 1 has no children so you return up to here, and since we're doing this recursively, then we're going to process 6 next, right? And so on and so forth until you process everything in the array. That's called pre-order traversal, and you'll end up with this this array here 8, 3, 1, 6, 4, 7, 10, 14, 13."
          },
          {
            "time": "[00:02:39]",
            "text": "If I'm asking you for just every number in the array, that's great, right? That's you successfully fulfilled everything that I'm looking for. Now, given this as a binary search tree, what if I wanted everything in numerical order? So I want 1, 3, 4, 6, 7, 8, 10,13, 14, how would you do that?"
          },
          {
            "time": "[00:03:06]",
            "text": "Well honestly, it's the same thing basically, we just changed when we add numbers to the array. So what we're gonna do is we're going to go as far left as we can. So I'm gonna do call post, or this is gonna be called in-order traversal. I'm gonna call in-order traversal on 8, then I'm gonna call in-order traversal on 3, I'm gonna call it in-order traversal on 1."
          },
          {
            "time": "[00:03:30]",
            "text": "1 has no left child, so I add 1 to the array then I return. Then I add 3 to the array, and then I call in-order traversal on the right. So the only thing that's changing here is when I add the item to the array, right? Same exact logic go left, then go right."
          },
          {
            "time": "[00:03:49]",
            "text": "But with pre-order traversal, it's add to the array, go left, go right. If it's in-order to reversal, it's go left, add to the array, go right. And then as you might imagine, there is a post-order traversal, which is go left, go right, add to the array. And just to demonstrate the difference."
          },
          {
            "time": "[00:04:09]",
            "text": "Pre-order traversal gives you that number, in-order traversal gives you these numbers, and then post-order where I'm adding everything after I visit both the left and right child is this. So with post-order, always your route will just be last, right? Because that's the first thing that you call it with So, Why are we learning three different ways of doing the same thing?"
          },
          {
            "time": "[00:04:44]",
            "text": "It's a good question you might ask. If you want a sorted list out of an array, you're gonna use in-order traversal. If you wanted to make a deep copy of a tree, right? So if I gave you this tree and said, hey, I want a copy of this, how would you do that?"
          },
          {
            "time": "[00:05:02]",
            "text": "In this case, pre-order traversal is really helpful because you can create a new node and then add the children. So deep copies, you'd probably use a pre-order traversal. And then post-order would be great if you're trying to actually delete all the items in the array. Because what you'd wanna do is you want to visit both children, delete all of them, and then delete the node itself, and then return, right?"
          },
          {
            "time": "[00:05:24]",
            "text": "So post-order traversal would be something you'd probably do with a deletion."
          }
        ]
      },
      {
        "name": "34-depth-first-tree-traversals-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So you're gonna go over here to code sandbox. This is in tree traversals. We're gonna do the depth first traversals first here. You have three methods here that I need you to code up. And they're all extremely similar in terms of what code, they are doing. My code here just to make sure each one of these I have taking, 1,2,4,5 lines of code."
          },
          {
            "time": "[00:00:35]",
            "text": "Each one of these is five lines of code. They're essentially the same code just slightly in different orders. Okay, you have a tree here. Each one has a value a left child and a right child. The right child might be null and the left child might be null."
          },
          {
            "time": "[00:00:57]",
            "text": "And these are the numbers that you expect to get out of them. So there's gonna be recursive methods. And again, they're all gonna look really similar. You're just actually gonna shift one line for each one of these. So you're gonna say, first thing base case if no node, return array, and I am going to, make this not auto refresh, there we go."
          },
          {
            "time": "[00:01:26]",
            "text": "We're gonna say array.push node dot value. Then array equals pre-order traverse. Node dot left array. Array equals pre order traverse node dot right, array, return alright So. This is it for preorder traverse. So basically saying, if I have no node, so if I call this like a empty node or a null node, then do nothing, just return the array."
          },
          {
            "time": "[00:02:27]",
            "text": "I push in the value. And then I call the pre order traversal on the left node, and I call the pre order traverse on the right node. And then at the end of this, I just return the array. So the other two in order as you might imagine."
          },
          {
            "time": "[00:02:47]",
            "text": "So first of all, let's. Change those to be in order traverse so they're calling a correct method. As you might imagine, I just move when I do the push. That's it, that's the whole thing. One more time post-order traverse this one's really gonna shock you of how it works."
          },
          {
            "time": "[00:03:12]",
            "text": "So we're gonna copy and paste this, paste that so that's postorder traverse. And what you do here is you just move it down one line, that was it not as it's not gonna shock you at all. Or maybe we'll I don't know he might be easily surprised. That's it, that's all the traversing that's we're gonna do here."
          },
          {
            "time": "[00:03:33]",
            "text": "Let's make sure that my code works here. We're gonna run our tests again and here in traverses. Traversals our, I need to change the skip down here. Run this again, Then traversals depth first reversals solved."
          },
          {
            "time": "[00:03:33]",
            "text": ">> And can we do a quick like pseudocode step through of like just one of them."
          },
          {
            "time": "[00:04:04]",
            "text": "Just to kind of get, visual light, you have a three node tree, just something quick, to see how that works."
          },
          {
            "time": "[00:04:04]",
            "text": ">> All right, here's our three node tree that I just invented now. In a pre-order traversal. The first thing you gonna do, is gonna cut on the root note, right?"
          },
          {
            "time": "[00:04:31]",
            "text": "Cuz that's all you have, right? Is the root note of the tree. You're gonna have your array, right, that you're trying to get all of the numbers gathered up into. In a pre-order traversal the first thing you're gonna do is add 8 to the array, right? Pre, we're gonna add it to the array first, then you call it on the left node."
          },
          {
            "time": "[00:04:49]",
            "text": "So you call preorder traversal on the left node. Again, first thing you need to do here is call, you're gonna add three. So now we have eight comma three. We'll call on the left node. That's no.we'll call it on the right node, that's no, and then this returns right, so returns back to eight here."
          },
          {
            "time": "[00:05:07]",
            "text": "We're then going to call pre order traversal. On 10, right, that's gonna attend to the array. It's gonna call on the left node on the right node, those are both nodes. So we end up with eight 3, 10.In order traversal,again, you would do it with, you're gonna call it, in order traversal on 3."
          },
          {
            "time": "[00:05:35]",
            "text": "You're gonna call it on its left no, which is no. Then you're gonna add three to the array, then we're gonna call it on the right node, nothing there. So we have three, this returns up here. This is now totally processed that it's left sub-tree, so we're gonna add eight to the array."
          },
          {
            "time": "[00:05:49]",
            "text": "So we're gonna have three comma eight, and then we're gonna add the right or we're gonna call in order traversal on the right node. So we're going to call it on its left child. No, we're gonna add 10 to the array, so we're gonna have three 8, 10."
          },
          {
            "time": "[00:06:02]",
            "text": "Then we're going to go into call it on its right node, nothing there. Okay, one more time. We're gonna do it with post order traversal. Here, we're gonna call Postal retroversal on 8. We're then gonna call it on 3, three is gonna call it on its left child, then its right child."
          },
          {
            "time": "[00:06:21]",
            "text": "Both of those are no it's gonna return back, so then we're gonna add 3 to the array, right? This is gonna return up here. Then we're gonna call postal retroversal on 10. We're gonna call it down here. It has no left child, has no right child. Then we're gonna add ten to the array."
          },
          {
            "time": "[00:06:36]",
            "text": "It's going to return up here and then finally, on the root node, we will add eight to the array, right? So, then we end up with three, 10 eight in post order traversal."
          }
        ]
      },
      {
        "name": "35-breadth-first-tree-traversals",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We just did depth-first traversal. So let's hop down here and do breadth-first traversal. Going back to our little fun tree here, same tree, what if I want you to look at the nearest nodes first, right? So that, the nearest nodes to 8 are 3 and 10. And then 1, 6, 14, and then 4,7,13, right?"
          },
          {
            "time": "[00:00:24]",
            "text": "So we're actually moving down level by level, right? This is called a breadth-first traversal because we went for breadth first as opposed to those which were going as deep as possible first. Now we're trying to go as close as possible first. Okay, so a breadth-first traversal of this array is going to be 8, 3, 10, 1, 6, 14, 4, 7, 13."
          },
          {
            "time": "[00:00:59]",
            "text": "So how do you do that? Well, we're gonna do it with a queue. So a queue, if you remember, the first item that you add to it is the first item that you get out of it, right? It's kinda like standing in line, right, the first person who stands in line is the first person that gets on the ride or on whatever."
          },
          {
            "time": "[00:01:22]",
            "text": "So what we're gonna do is we're going to add 8 to our queue. And then we're going to pull off 8, add it to our array, and then we're going to enqueue both of its children. So we're gonna to add 3 and 10 to our queue. We're then going to process 3, right?"
          },
          {
            "time": "[00:01:40]",
            "text": "And then we're going to enqueue both of it's children. So our queue right now will be 10, 1, 6, right? So on and so forth. Every time that you pull a node off, you're gonna grab its value, you're gonna add both of its children to the queue, and then just keep processing until the queue is empty."
          },
          {
            "time": "[00:02:00]",
            "text": "So, start by adding 8 to the queue like this. Process 8, and when I say process, I just mean add it to the final array, right? So we process 8. So we add that to the final array which is equal to 8 right now. And then we enqueue 3 and 10 to the processing queue."
          },
          {
            "time": "[00:02:23]",
            "text": "So we have 3 and 10 in our queue right now. We're going to dequeue 3, which is the first item in the array. And the queue right now is just gonna be 10. We're gonna enqueue 3's children. So we're gonna have 10, 1, and 6 in our array right now in our queue, and we're gonna add 3 to the final array."
          },
          {
            "time": "[00:02:45]",
            "text": "So we have 8 and 3. Okay, we're gonna dequeue 10, this one here. Dequeue 10, so the queue right now is just gonna be 1 and 6. We're gonna add 10's children to the queue. So, it's gonna be 1, 6, and 14 in the queue. And we're gonna add 10 to the final array here."
          },
          {
            "time": "[00:03:09]",
            "text": "So we have a 8, 3, 10, right? 8, 3, and 10. We're gonna dequeue 1, which is the first one in here in the queue of things to process. And the queue now is just 6 and 14. We're gonna dequeue 10, we did that. We're gonna queue 1's children."
          },
          {
            "time": "[00:03:29]",
            "text": "I doesn't have any children, so nothing gets added. We're gonna then add 1 to the final array, we end up with 8, 3, 10, and 1, right? And I hope you're seeing the pattern here, which you pull off an item of the queue, you add it to the final array, and then you enqueue it's children."
          },
          {
            "time": "[00:03:44]",
            "text": "And you just keep doing that. It's not recursive, it's iterative. And you just keep doing that until you've gone through everything in your queue. So again, our final array here will be 8, 3, 10, 1, 6, 14, 4, 7, 13. So you might ask now, why is this any different or better than depth-first traversals, right?"
          },
          {
            "time": "[00:04:09]",
            "text": "Why do I need to learn four different ways to traverse things? Well, this is really good for nearness, right? What if I wanna find, I don't know, the nearest 6 to the 8, right? Now, if I was doing depth-first traversal and I had a 6 way down here that was super deep in the array, I would find that one first, right, because depth is gonna go deep first."
          },
          {
            "time": "[00:04:34]",
            "text": "So you need to do something like breadth-first traversal. This actually ends up being one of the more useful ones that I'm teaching you, because we're gonna do pathfinding and graphs here in just a second, which use breadth-first traversal quite a lot. So if this isn't quite concrete why this is useful, believe me, in the next two lessons, you're gonna find out very concretely why this is useful."
          }
        ]
      },
      {
        "name": "36-breadth-first-tree-traversals-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so go into breadth first traversal here, you can see here I have a tree here and what you'll get out at the end is, A through K in the alphabet. Let's see if there's anything I need to tell you about first. Yeah, and actually you can do this iteratively or recursively."
          },
          {
            "time": "[00:00:29]",
            "text": "They both end up being relatively similar. So I'll leave it up to you if you wanna do it recursively or iteratively. We'll do both of them when we come back so you can see what they look like. Let's do iterative first. I don't know, it depends on what you want to do."
          },
          {
            "time": "[00:00:52]",
            "text": "We'll do, my notes here have recursive first, we'll do recursive first. So if the queue has no length, this is the base case, right. Then you would just return the array, right. Okay, const node equals queue.shift, right. Because we're gonna pull something off the front. Array.push, node.value. Then you can just gonna say a for array.left, or sorry, not array but node."
          },
          {
            "time": "[00:01:33]",
            "text": "If node.left, then queue.push, node.left, okay. Same thing but for right, so if node.right queue.push node.right. And then you're just gonna say return breadthFirstTraverse queue and array So this is a recursive approach to this. Let's run the test to make sure I got to unskip this. And make sure that traverse is working okay, traversals breadth first test, there it is, working."
          },
          {
            "time": "[00:02:27]",
            "text": "All right, so let's do this again but let's do const breadthFirstTraverse2 equals queue, array. And we're gonna say while queue.length, we're gonna say const node equals queue.shift array.push. Node.value. Just do this, right? Add the same thing here. And then at the end you just return the array. So let's just change these so this is two and this is one so we can see if this passes our unit test."
          },
          {
            "time": "[00:03:28]",
            "text": "It's now like that, traverse, there we go. All right, run our unit test one more time. Lo and behold, traversals breadth first traverse. This also works as well. I kinda like this solution. I think it's gonna be more performance and I also just, not that that's really what I'm concerned about."
          },
          {
            "time": "[00:03:54]",
            "text": "I think this code is easier to read, because I understand, I don't have to conceptualize what's happening with recursion. I can just say, as long as there's stuff in the queue, keep processing the queue. That makes a lot of sense to me. You can get there with this, right?"
          },
          {
            "time": "[00:04:08]",
            "text": "It's fine, but I do prefer this."
          }
        ]
      },
      {
        "name": "37-heap-sort",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Alright, let's talk about heap sort. Heap sort is kind of another really interesting one. You kind of are gonna emulate a tree inside of an array and then by doing that we're able to kind of identify what the largest number in the array is. And then we can use that data structure to then sort a list by knowing always what the largest number in the array is."
          },
          {
            "time": "[00:00:26]",
            "text": "So, let's kind of unpack that a little bit more. So again, a heap is an array. A heap is inherently array, but it represents a tree like data structure. You're gonna find that these heap data structures are kind kind of similar to binary search trees, but not totally."
          },
          {
            "time": "[00:00:49]",
            "text": "Heaps are used a lot in computing, they're typically used to represent things like priority queues. And so, a priority queue is a queue, but every item in the queue has a priority associated with it. A good example is like network stacks, right. Some Internet traffic that you have is more important than other pieces of Internet traffic you have."
          },
          {
            "time": "[00:01:14]",
            "text": "A good example that would be like, if you're doing Netflix and Dropbox at the same time, you want that Netflix traffic to be the most highest priority because you don't want your video to stutter, but your Dropbox can sync whenever right. If your Dropbox drops some packets or it gets slowed down or something like that, that's totally fine."
          },
          {
            "time": "[00:01:30]",
            "text": "You're gonna take 90 minutes instead of an hour to sync all your changes. So, that's all represented by a heap typically, not always but frequently. So, anytime that you're talking about priority queues, your brains just automatically go heaps, right, cuz that's just like those two just kinda go together."
          },
          {
            "time": "[00:01:56]",
            "text": "Okay, so let's talk about the difference between a binary heap which is an array and a BST, which is a tree like data structure. So BST is typically made up of node objects. Typically, I imagine you can model it other ways, but the way that we just did it together, it was made up of nodes, whereas a binary heap is always an array."
          },
          {
            "time": "[00:02:18]",
            "text": "The biggest difference here in a binary search tree, there is a strict rule that if you have a node, everything on the left is smaller and everything on the right is bigger, right. That's a strict rule for a binary search tree. If it doesn't adhere to those rules, it's not a binary a search tree."
          },
          {
            "time": "[00:02:36]",
            "text": "That's not necessarily true in a binary heap. In a binary heap, the only rule is in fact, you can see it here, the numbers that are higher so like the 7 is always bigger than the numbers that are lower, right. So in this particular case, well, I have another one down here, yeah, let's look at this one."
          },
          {
            "time": "[00:03:02]",
            "text": "So this 100, it's bigger than 19 and it's bigger than 36. So the only guarantee that I can make about a binary heap is that, all the numbers underneath it are smaller, right. So if I have 19 here, all the numbers underneath 19 the only thing I know about them, is that they're smaller."
          },
          {
            "time": "[00:03:18]",
            "text": "There's no semantics of what goes left and what goes right, the only thing is that I know is that anything that's lower than it in the tree is smaller, right. So, you can see here I have 3 over here, right, so this wouldn't be a binary search tree because 3 is on the right."
          },
          {
            "time": "[00:03:36]",
            "text": "But it is a valid binary heap because 3 is smaller than 19. Does that make sense so far? Cool, so that's the next rule. If you do an in order traversal of a BST, you get an order array, right. That's one of the things that you and I looked at previously."
          },
          {
            "time": "[00:03:59]",
            "text": "That's not true with a binary heap, right, we could do an in order traversal here, right, and you would not get a sorted list out of that. And then probably one of the last really big differences is that a binary heap is always a complete tree. Let's see what I mean when I say complete."
          },
          {
            "time": "[00:04:17]",
            "text": "It always fills out as maximally as possible, right. So notice that 2 and 7 are here underneath the 17 and 3 has no children. If I moved 7 to be underneath 3, that wouldn't be or let's say 7 underneath 25, even though that would be adhering to the rule that 7 is smaller than 25 smaller than 36 which is smaller than 100."
          },
          {
            "time": "[00:04:36]",
            "text": "It wouldn't be a maximal tree or a complete tree because we have to fill out this part first, right. So if we were gonna add another number to this, let's say we're gonna add 1, right, the 1 would go underneath this 3 here, right. It has to, we couldn't put it anywhere else Cool, so that's what I mean when I say it is a complete binary tree."
          },
          {
            "time": "[00:05:06]",
            "text": "Binary heaps come in two flavors. This is a max heap. Max heaps are useful for sorting numbers, right. So, we'll just see here in just a second how to turn this into a sorted list. But there's also a min heap, right, which you could use to do a reverse sorted list."
          },
          {
            "time": "[00:05:25]",
            "text": "And the only difference between max heap and a min heap, this is a max because the top node, the root node is the largest number in the heap. The min heap would be the opposite, right, so 1 would be the root node here cuz it's the smallest number in the heap."
          },
          {
            "time": "[00:05:44]",
            "text": "Don't have to worry about the date today, we're just doing max heaps. Okay, so how do we represent this tree here as an array? Well for any array in the index, or sorry, in any index in the array, so let's say like 19 here, which would be index one, the way you find this left child is this formula here, which is 2n+1, and then you find this right child has 2n+2."
          },
          {
            "time": "[00:06:15]",
            "text": "So this is 0, so 2 times 0 plus 1, so that's 1. The left child of 100 is at index 1, and the right child is at index 2. If we go down to this one here, the index 1, its left child will be 2n + 1. So that's 2 plus 1, so its left child is at index 3, and its right child as at 2n + 2, so 2 times 1, 2 plus 2 is 4."
          },
          {
            "time": "[00:06:47]",
            "text": "So you can see that here is the array representation of this binary heap. 0 is the route 100 it's left child is at 19 it's right child this here, 36 at index 2, okay, and then it's left child, 17, right, is here and 3, then 36 is left child, 25 is there and then right child is 1, right, 2, 7, right."
          },
          {
            "time": "[00:07:16]",
            "text": "So you kinda just go down the list right that, so it's like a totally flat structure like that. And again, this is the formula 2n +1 finds the left child for any index in the array. So if I had index 10, and I wanted to know where its left child was, I'd say 2 times n, 20, right, plus 1, 21."
          },
          {
            "time": "[00:07:36]",
            "text": "So, the left child of index 10 is at index 21, Okay, that's how we get everything down into a squished array. That's why it's also it's important that it's a complete tree, right, cuz we're just adding numbers on to the end of the array. That's why we don't have any holes in our tree."
          },
          {
            "time": "[00:08:04]",
            "text": "Okay, good so far? Okay, So once you construct a heap, right? So once we make this data structure, and I'll show you how to make this data structure here in just a second. The one thing that you always know is that the index 0 is the largest item in the array."
          },
          {
            "time": "[00:08:29]",
            "text": "100% of the time, right? Because the rule that this one has to be larger than the things underneath it, lends itself to the fact that the root has to be the largest because it's larger than this. It's larger than this. And these are both larger than everything underneath them."
          },
          {
            "time": "[00:08:44]",
            "text": "Therefore, 100 must be the largest thing. So all we do with a heap sort, is we turn an array into a heap, right? So we turn an array so it looks something like this, right? Then we just take the top root off, so we just remove index 0."
          },
          {
            "time": "[00:09:07]",
            "text": "And we remake the heap. So in this particular case, 36 would be the largest item here. So what would happen, we would remove 100. We'd put that into our new sorted array. We'd move 36 up, right? So now 36 would be the root. And then we'd moved 25 up to be here, right?"
          },
          {
            "time": "[00:09:26]",
            "text": "So then, yeah, so we keep moving things up. That process is called heapifier. And then we just kind of continue to do that. We remove items from the array and then we heapify the array, again to make it a max heap again. So, The first step of making a max heap."
          },
          {
            "time": "[00:09:59]",
            "text": "If I have an array that's not a max heap already. So let's go through it step by step here. Let's say this is our initial array right here, and we're gonna do heap sort on this, 5, 3, 2, 10, 1, 9, 8, 6, 4, 7. The first thing that you're gonna do, is you're gonna start at index 4, which is this one."
          },
          {
            "time": "[00:10:17]",
            "text": "Then we're going to work backwards here. And we're gonna call heapify, which is a function that I'm gonna show you how to write here in just a second. On every item in the array, all heapify does is it makes sure that this particular item is bigger than all of its children in the heap."
          },
          {
            "time": "[00:10:36]",
            "text": "Okay, so I'm gonna start this one. The left child is index 9, which is this one value 7. And it's right index would be, sorry, right child would be index 10, which is out of bounds, right? So we have 1 here. We have 7, which is going to this left child."
          },
          {
            "time": "[00:10:56]",
            "text": "And it's out of bounds, so it doesn't have a right child. 7 is larger than 1, so we're gonna swap the left child and the parent. So after that, you get 7 and 1, right? That's all that happened there, is these just swapped places, Okay? Then we're gonna run that again on this one, index 3."
          },
          {
            "time": "[00:11:20]",
            "text": "Its left child is index 7, which has value 6 here, right? And its right child is index 8, value 4. So these two right here are the child of this one. Neither is larger than 10, so we don't do anything. And we just go to the next iteration, okay?"
          },
          {
            "time": "[00:11:42]",
            "text": "We're now going to index 2, value 2, which is this one, right? Index 2, value 2, left child is index 5, value 9. And the right child is 6, index 8, right? So these two are the child of this one here. So obviously 9 is the largest here, and it's larger than 2."
          },
          {
            "time": "[00:12:08]",
            "text": "So we're just gonna swap 2 and 9. So now we have 9 here and 2 has gone there, Okay? Then we're gonna go to index 1 value 3. So we're going here. The left child is index 3 value 10, so this one. And the right child is index 4 value 7, this one."
          },
          {
            "time": "[00:12:38]",
            "text": "So these two are the child of this one, Okay? We call heapify on that, obviously 10 is gonna be the largest number there. So you're just gonna swap those two. So we swap 3 and 10. But now we have to call heapify on the one that we swapped with, right?"
          },
          {
            "time": "[00:13:06]",
            "text": "Because now we don't necessarily have that guarantee that we had before. So we moved 3 to here, and now we have to call heapify on this one, and make sure that it's bigger than it's children. Its left child is 6, and it's right child is 4. 6 is the biggest one of those."
          },
          {
            "time": "[00:13:24]",
            "text": "So we're gonna swap 3 and 6 here. So we end up with 3 being all the way down there now, and 6 being over here. Okay, last one we have the root. So its left child is 10, and its right child is 9. 10 is the biggest. So we're gonna move 10 and 5."
          },
          {
            "time": "[00:13:48]",
            "text": "Then we're gonna call heapify again on 5, to make sure that it is in the correct place. Its left child is 6, and it's right child is 7. 7 is the biggest there. So we'll move 7 and 5. So now 7 is here, 5 is down here. Okay, we currently call heapify on that."
          },
          {
            "time": "[00:14:11]",
            "text": "Its left child is 1, and it doesn't have a right child cuz that's out of bounds. So that's fine. That's okay. So now that we've done this initial heapifizition, I guess is how we would say it, right? Now this is considered a max heap, right? This is now officially a max heap, we've built one."
          },
          {
            "time": "[00:14:38]",
            "text": "So all we're gonna do now, and this is actually kind of fun in my opinion. Maybe I have a warped sense of what's fun. That's probably true. I probably admit that too much in this course as well. Anyway, you're stuck listening to me, anyway. What we're gonna do is, now we're gonna actually go through and do the sorting process."
          },
          {
            "time": "[00:14:59]",
            "text": "So the one thing that we know, for sure, with this max heap that we have here, is 10 is definitely the biggest number. Anything else we can't super guarantee, but we can guarantee 10's the biggest number. So, all we're gonna do is we're gonna swap 10 and 1."
          },
          {
            "time": "[00:15:15]",
            "text": "So 10 and the last number in your heap, okay? So now we've moved 10 here to the last number in the heap. And you and I both know now, that's the correct place for it, right? Because it's the last index in our array. And it is the biggest number, okay?"
          },
          {
            "time": "[00:15:33]",
            "text": "Well, now 1's out of place, right? That's not correct. So what are we gonna do? We're just gonna call heapify on it, right? Cuz we know everything underneath here was a correct heap until we swapped this. But as long as we call heapify on this, right? So that's actually moved 1."
          },
          {
            "time": "[00:15:51]",
            "text": "So you had 7 and 9 here when you moved the 9 up here, right? And then we have to call the heapify again on that one. And that's going to move it with the 8 here. Okay, and then we would call heapify on this again, but it has no children, right?"
          },
          {
            "time": "[00:16:12]",
            "text": "So now, again this 9 for sure is the largest value in our heap, right? Definitely, so all we're gonna do again is swap 9 and 4. So cuz now we know for sure 9 and 10 are definitely the two biggest numbers in our array. Okay, now we have 4 up here and we just call heapify again, on this one."
          },
          {
            "time": "[00:16:35]",
            "text": "So on and so forth, just swapping it to the end and calling heapify to get it back to being a max heap. Until eventually, you end up with a sorted list. Okay, [LAUGH] that is how you create a max heap. And how to create a max heap and also how to do heap sort."
          },
          {
            "time": "[00:17:08]",
            "text": "Question then ends up being, what is the big O of heap sort? It has constant space complexity, right? Cuz we're not creating anything additionally. I wanna say it's n squared. I'm gonna show you how many cheated this. There is a website called Big-O cheat sheet, and it's exactly that."
          },
          {
            "time": "[00:17:34]",
            "text": "So heapsort is n log(n). Yeah, I guess that makes sense because not every number has been compared to every other number. And you will get an economy of scale as he started going larger and larger, yep. So heapsort here, n log(n) with spatial time complexity of, sorry, space complexity of constant."
          },
          {
            "time": "[00:17:54]",
            "text": ">> So what would be like a good use case for heapsort besides priority queue? Only priority queue, right?"
          },
          {
            "time": "[00:17:54]",
            "text": ">> Yeah, I mean the question is, when is a good use case for heapsort? It's got a really good average case, so like merge sort. No matter if it's big or small, like whenever you're creating a max heap, whether it's a sorted list or a non sorted list or a random list, it's very predictable in the way it acts."
          },
          {
            "time": "[00:18:26]",
            "text": "Couple that with the fact that it doesn't have any additional memory that it has to incur. And I could see it being useful in a situation where memory is a concern but you still need an n log(n) sort. And you need to be able to handle sorted lists, reverse sorted lists, randomly sorted lists."
          },
          {
            "time": "[00:18:46]",
            "text": "And you didn't necessarily have any guarantees about how your data is gonna look when it came in. I would say in that very specific case, you could have a good use case for perhaps using heapsort, with the only caveat there is perhaps quicksort would still be better. [LAUGH] Yeah, so very likely merge sort and quicksort more or less are almost always the sorts that you wanna use cuz they just end up being better sorts in general."
          },
          {
            "time": "[00:19:19]",
            "text": "But I could see heapsort being useful in this case. I would say just in general, the most useful thing you're gonna take away from this is what is a heap and, how do I build a heap?"
          },
          {
            "time": "[00:19:19]",
            "text": ">> If the arrays are resorted, it would just return the array, correct?"
          },
          {
            "time": "[00:19:32]",
            "text": ">> So the question is, what happens if the array is already sorted? It wouldn't just return the array. You would build a max heap, like it would be like merge sort where it would just go through all the steps, right? The heap sort is not gonna care that it's already sorted, right?"
          },
          {
            "time": "[00:19:47]",
            "text": "It's just gonna go ahead and build this max heap. And then, do its heap sorting. Yeah, in those particular cases where you suspect the array might already be sorted. Insertion sort is typically the one that you wanna choose."
          }
        ]
      },
      {
        "name": "38-heap-sort-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go ahead, and go set this up. We're gonna pop over to our code sandbox, that's fine. We're gonna go into heapsort. Okay, and then I gave you, you do not have to do it this way. I'm just trying to kind of help you along and give you the skeleton of how to do this."
          },
          {
            "time": "[00:00:32]",
            "text": "I suggest you break this down into three functions, right, heapsort which is actually what's gonna be called. Then this function called heapify, which is just my favorite word in this entire course is it there's some good words in this course but heapify is a pretty good one. This is actually that process that's gonna check."
          },
          {
            "time": "[00:00:51]",
            "text": "Okay, am I in the right place? Am I bigger than my children? Do I need to swap these? So that would take in the array, the index and the heap size and then you can figure out where you need to move things. And then createMaxHeap. This is basically going to be the function that just loops over your array and calls heapify in reverse order."
          },
          {
            "time": "[00:01:15]",
            "text": "I actually even gave you here in the course notes, the loop, right, this is the loop that you're going to write of what to loop over. This is the for loop that you're going to put inside of your createMaxHeap. The reason I gave this to this because it took me way too long to figure this out myself."
          },
          {
            "time": "[00:01:32]",
            "text": "I didn't want you to have to struggle on something that didn't seem like it was that useful too. Cool, and then you'll put that here inside of createMaxHeap. And then I wrote one more function here just called swapPlace. Just takes a index1, index2 and an array. And all this does is swap two items in an array, because you have to do so much swapping in here."
          },
          {
            "time": "[00:02:08]",
            "text": "It's nice to just have kind of a helper function that does it for you. Again, I'm just kind of throwing out ideas here. You're welcome to do however, we're where you see fit. There's not much recursion in here, the only place that you're gonna use a little bit of recursion is inside of heapify."
          },
          {
            "time": "[00:02:25]",
            "text": "So heapify does call itself sometimes Let's hop into this heapsort function. I don't know why I feel like I have to like extra emphasize the P in heap,but every time it says heap sort, I don't know. Anyway, array=createMaxHeap(array). Okay, so we're gonna go into it. We'll create a MaxHeap down here and this function down here, but after that point we'll have a MaxHeap."
          },
          {
            "time": "[00:03:03]",
            "text": "Then all we're gonna do is we're gonna say let i=array.length-1. So we're gonna start from the back, right? I is greater than 0. Obviously we don't need a heapify on 0 with time, right, because once everything has been swapped, inherently the last number or the first number, the 0 with index will be the smallest item in the array."
          },
          {
            "time": "[00:03:30]",
            "text": "Hence the greater than and not greater than or equal, and then i- -. Okay, so we're going backwards over the array. All we're gonna do is we're going to call swap place, 0, i, an array. And then all we're gonna do is say heapify(array 0, i). Okay, so this is the core sorting part of the algorithm right here."
          },
          {
            "time": "[00:04:02]",
            "text": "Create a MaxHeap, then just work backwards over the array, swap places, and then call heapify, that's it. CreateMaxHeap, let's do swap place first because that's what I have my notes first. Pretty simple, you're just gonna say, let temp = array[index 1] array[index 1] is signed array[index2]. Array[index2] is assigned temp return array."
          },
          {
            "time": "[00:04:51]",
            "text": "Okay, that's swap place. Let's go down and do, CreateMaxHeap, this one. Here we're gonna say, for and we're just going to do that, for loop that I was talking about let i = math.floor, (array.length/2)-1. I is greater than or equal to 0, i--. Kind of a bit of a mouthful there."
          },
          {
            "time": "[00:05:32]",
            "text": "Okay, and then we just call heapify on array, i and then array.length. So you might be asking, what is this length? This heapSize, right, is because as we're sorting our array, the length of our array kind of changes, right. Because as we're doing this part. This i's was changing, right?"
          },
          {
            "time": "[00:05:59]",
            "text": "So that everything before the i in here is sorted. So we want to exclude those from our heapify, right? So going back to here, basically when we're starting arriving to here, right? We want to kind of remove these from our heap. These two are no longer children in our heap, right?"
          },
          {
            "time": "[00:06:19]",
            "text": "So that's what that array size of the heap size represents, as we want to say everything in here is the unsorted heap. Everything over here is the sorted part of the array. We kind of divide our array that way. And what's keeping track of that is this heapSize variable."
          },
          {
            "time": "[00:06:35]",
            "text": "That's when you're doing a createMax Heap. You're just passing array.length as the heapSize. Whereas this changes here for this heapify code. Hopefully makes a little bit of sense. All right, let's get into the heapify. This is just a lot of conditional logic here. So let's grab the left and the right child."
          },
          {
            "time": "[00:06:57]",
            "text": "That's the first thing we'll do, left =2* index + 1, right? And same thing here, right, is that + 2, okay? So for whatever item in our array here the index we now have the left child and the right child. And we're going to say if heapSize>left and array(largest) let's see."
          },
          {
            "time": "[00:07:41]",
            "text": "I forgot to do this variable as well. Let largestvalueindex=index. And so what I'm just gonna keep track of in this particular variable is, where is the largest values index, and then I'll just use if statements to check. I'm sure there's a more elegant way you could probably do this."
          },
          {
            "time": "[00:08:02]",
            "text": "I was just trying to be clear. So largestvalueindex> array( left), then largestvalueindex is assigned left. And then we'll ask the same question for the right side. In fact, you could probably even just copy and paste it and modify it a little bit. Change this to right. In fact, everything just changes to the right yep, so right, right, right."
          },
          {
            "time": "[00:08:40]",
            "text": "So I had to change right three different times there. Okay, so after asking these two questions. We all know is the parent, the left child or the right child, the largest item of those particular three. And then all I have to do here is I have to say, if largestvalueindex is not equal to index."
          },
          {
            "time": "[00:09:08]",
            "text": "So basically do I need to do something if, so first thing, swapPlace of index, largestvalueindex and array, okay. So this will actually do like the swapping that we were talking about and then. We just need to make sure that we call heapify on the child array, largestvalueindex and heapSize."
          },
          {
            "time": "[00:09:48]",
            "text": "That's it should be. Let's go ahead and run this make sure that I'm not telling you sweet little lies, And none to do that. But that, it's not running. Why is this not running, please run. I didn't call it the test I skip down there. Now let's try it."
          },
          {
            "time": "[00:10:20]",
            "text": "Run, run, run, run, one failed. Array is undefined, and where's that? 14. CreateMaxHeap, I didn't return the array, return array. So line 23 there, I had to put a return array. Let's try that again. There you go, that worked. So yeah, make sure down here you are returning the array though honestly."
          },
          {
            "time": "[00:11:14]",
            "text": "You could have just said create Max because it modifies the array itself anyway. Right, make sure that I'm not telling you more lies But yeah, that should work, it does. Either way, we'll leave it like that because I have it in my notes. I like doing things like this where I say it's assigned to this."
          },
          {
            "time": "[00:11:38]",
            "text": "So people are aware, hey array here it's getting overwritten, despite the fact that semantically it ends up being the same thing. Okay, any questions about heapsort?"
          },
          {
            "time": "[00:11:38]",
            "text": ">> Yeah, confused by recursion. What's your base case, how does it exit, how does it stop?"
          },
          {
            "time": "[00:11:38]",
            "text": ">> Yeah, so the question is, what's the base case in the recursion?"
          },
          {
            "time": "[00:12:01]",
            "text": "Valid question because typically we want to put it up here, right? So it's pretty obvious, in this particular case, the base case is when you start going out like either a swap doesn't happen or you go out of bounds. So I guess that either case, it's when a swap doesn't happen, right?"
          },
          {
            "time": "[00:12:17]",
            "text": "So this only happens when largest value index changes, and eventually you're going to go outside of your array, right? So, eventually you're going to start asking the question is like, looking at this one, Like 7, right, or index 8 here. This doesn't have any children, therefore swap cannot happen, right?"
          },
          {
            "time": "[00:12:41]",
            "text": "And therefore that's the base cases when there's no swap to happen. Does that make sense?"
          },
          {
            "time": "[00:12:41]",
            "text": ">> Yeah, it makes sense."
          },
          {
            "time": "[00:12:41]",
            "text": ">> Cool, good question, thank you, other questions? So how does the number heapSize change over time? Is that a fair assessment of the question?"
          },
          {
            "time": "[00:12:41]",
            "text": ">> Yes, that's correct, I just forgot the link."
          },
          {
            "time": "[00:13:00]",
            "text": ">> That's good, yeah, it's a weird word. So the, how does the heapSize change over time? So let's talk about because heapify is going to change and we kind of use it in two different places. It does the same thing. But we use it in two different ways, kind of."
          },
          {
            "time": "[00:13:17]",
            "text": "So the first time we use it is here instead of createMaxHeap. And this is where we were starting in the middle. Again, if we go up to my example up here, right, we start here, when we're doing createMaxHeap. And the reason why we don't start there is because these don't have children, right?"
          },
          {
            "time": "[00:13:37]",
            "text": "So we would never have to swap them with anything because they have no children to swap with. So we start here because this is the first one to guarantee to have a child, right? So here, the entire array is the heap. We have nothing on the sorted part of the array yet, this entire thing is considered the heap."
          },
          {
            "time": "[00:13:54]",
            "text": "Therefore, that's why here, the heapSize is the array.length. Now when we get down to this part here, which is we're actually doing the sorting. Let's scroll down to that. Now the heap size is not actually all ten elements of the arrays, right? Now the heap size is just index 8 and below, right?"
          },
          {
            "time": "[00:14:20]",
            "text": "So the first 9 elements in the array. So that's why heapSize on this very, very first iteration. There's gonna be a 9, yeah 9. And that's gonna decrease over time, right? Because this sorted part of the race you have 10 here, then 9, then 8, then 7. So it's just gonna work backwards, until eventually, the entire array ends up being sorted."
          }
        ]
      },
      {
        "name": "39-graphs",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this data structure is ends up being one of the more useful ones and it's used a lot. A graph is basically just a tree that doesn't have a root, right? So you're gonna have a node, and that node is gonna be connected to lots of other notes, right?"
          },
          {
            "time": "[00:00:16]",
            "text": "Whereas trees we have this sort of hierarchy right where you have like a root and it has children and those have children's Graphs are more other similar to that, but they don't have hierarchy, right? You have this graph or this node and this node and this node, and they're connected to each other."
          },
          {
            "time": "[00:00:33]",
            "text": "But not any one of them is going to be the parent. Right, they're just connected. So a really good way of thinking about that would be your friends on Facebook, right? You have this person, and they're all connected to each other via friendships, right? But they're not necessarily have any sort of hierarchy, right?"
          },
          {
            "time": "[00:00:54]",
            "text": "There's no one friend that owns the other friend. I don't know, maybe you have a weird friend group, my friends don't own me. Like in the Facebook example we can have a node and the node can be represented as a row in a database, right? So I could have 100 people that exist in my friends database right?"
          },
          {
            "time": "[00:01:11]",
            "text": "And then I probably have like a separate table, that would probably call something like edges. So an edge is typically what you would call the thing that connects to different things. And an edge describes a relationship. So if I have person here, person here, and then I have an edge between them, that edge would be the friendship, right?"
          },
          {
            "time": "[00:01:31]",
            "text": "But, you can imagine there might be multiple different kinds of edges, right? So in a previous course that I taught on front of masters called the complete intro to databases, I talk about a database called Neo for j which is a graph database. And, the example that I given that is you have movies, actors and directors right?"
          },
          {
            "time": "[00:01:52]",
            "text": "Directors are connected to movies via, they are the director, right? So that's the name of the edge, there's directed. Actors are connected to movies via acted, right? So an actor, its relationship to a movie is that it acted in the movie, so. As you can see, you can have different types of edges as well."
          },
          {
            "time": "[00:02:13]",
            "text": "Another interesting kinda caveat, there is a Facebook friendship is bidirectional, right? So if I add you on Facebook, you have to approve me adding you on Facebook, and therefore, we become friends with each other, right? So that relationship exists in both ways. I am your friend, you are my friend."
          },
          {
            "time": "[00:02:32]",
            "text": "Let's consider Twitter for example, where I just follow you. So that's unidirectional, that I follow you but you don't necessarily have to follow me back, right? So that would be an example of a unidirectional edge. Cool. So that kind of just describes at a very base level of like what a graph data structure is."
          },
          {
            "time": "[00:02:52]",
            "text": "And a graph database like Neo for j is just a very large graph data structure. If you're interested in that, I highly suggest taking my course the complete intro to databases. I talked a lot about it. It's kind of fun. I think it's approachable to anyone. If you're this far in this course, you can definitely take that course and be okay."
          },
          {
            "time": "[00:03:12]",
            "text": "I'm gonna assert that I think this course is harder. Graphs are everywhere. So we talked about social networks. That's kind of the easiest one to think about, but your Internet of Things, right. So all of your various devices that talk to each other, those are almost always represented as graphs."
          },
          {
            "time": "[00:03:29]",
            "text": "Neural network, machine learning libraries like TensorFlow, or pytorch. Those have tons of graphs in them. Everything that we're kind of just modeling in terms of like sensors, and mapping the virtual world or sorry, mapping the natural world to the virtual world. Just everything is a graph, right? Everything is just describing a relationship between two different objects."
          },
          {
            "time": "[00:03:54]",
            "text": "So, let's talk about social network cuz I think that's kinda of an easier one to conceptualize. We're going to be tracing a virtual made up social network. That's definitely not LinkedIn. So the idea is that you have a bunch of co workers that are connected to each other, right?"
          },
          {
            "time": "[00:04:14]",
            "text": "And each one of those co workers has a title, right? So this person is a programmer, this person is an architect, right. And they have various different connections that are on this social network. What if we wanna do some sort of analysis, right? So let's say, I want to find out the most common job title in my social network, right?"
          },
          {
            "time": "[00:04:36]",
            "text": "I'm connected to five people, and I wanna find out how many are the most common job title, and not only my connections, but my connections, connections, right? So how would you go about thinking about doing that, right? So let's say I have me here, and I wanna find out the most common in two degrees, right?"
          },
          {
            "time": "[00:04:57]",
            "text": "So I wanna find out what Maria's, Bob's, Alice's and Sally's are, right? I'm not connected to Alice, so I have no edge between me and Alice. And I'm not connected to Sally. I'm just connected to Bob and Maria. Well, I don't wanna analyze who Maria's connected to, or sorry, who Alice is connected to and who Sally is connected to, I just wanna analyze these four people."
          },
          {
            "time": "[00:05:21]",
            "text": "Cuz Alice and Sally could be connected to a lot more people. Well, let's think back to the the algorithms that we learned earlier in this course. If I did a depth first traversal of this social network, I would not only analyze Sally's, I would analyze Sally's connections, and that person's connections, and that person's connections because I'd be going deep first, right?"
          },
          {
            "time": "[00:05:45]",
            "text": "So it doesn't make any sense for us to do any sort of depth first traversal. But what if we did breadth first traversal, and just limited how many degrees we went, right? With breadth first traversal, we can say, I wanna look at the first layer, or the second layer, or the third layer, right?"
          },
          {
            "time": "[00:06:02]",
            "text": "And we can look at just the people in those kinda connections. So we're actually gonna use that exact same algorithm, breadth first traversal. And we're just gonna apply to a graph where there's no root. But everything works exactly the same, right? We're still gonna use a queue and all that kind of stuff."
          },
          {
            "time": "[00:06:16]",
            "text": "So when you're looking at the problem here, maybe take a gander at the code that you wrote for your breadth first traversal, cuz it's gonna be pretty similar. So, if I wanted to find out. All these people's job titles, I would me to the queue first, right? Just like a breadth first traversal."
          },
          {
            "time": "[00:06:41]",
            "text": "Then I would dequeue me and I would add my job to the tally, so program manager. Then I would queue my connections, Bob and Maria. Then I would dequeue Bob, and add Bob's job to the tally, Bob to designer. And then I would queue Bob's connections, Sally and Alice."
          },
          {
            "time": "[00:07:02]",
            "text": "Then I would dequeue Maria, cuz she'd be the next person in my queue here, so I queue her so I'm connected to Maria. And that Maria she's also a program manager. And then I would queue Maria's connections. So, that would be just Alice, right? But here's the thing."
          },
          {
            "time": "[00:07:22]",
            "text": "I already queued Alice because I'm connected to Bob, and Bob is also connected to Alice. So I would have to make sure that I ignore Alice or she'd get double count, right. So that's one thing about graphs is whereas trees, I can guarantee this branch doesn't connect to this other branch, right?."
          },
          {
            "time": "[00:07:39]",
            "text": "So I can be guaranteed that all these nodes that are being entered into my queue are unique. That's not necessarily true in a graph, right? I can be friends with you, you can be friends with that person, right? And also others of my connections can be friends with that person without me ever being friends with that person."
          },
          {
            "time": "[00:07:55]",
            "text": "So we don't have any sort of guarantee, right? So, that's just one necessary concern that you should concern yourself with is like, hey, make sure I don't add duplicate people to my queue. Okay, so after I do that and after I've processed brought Bob and Sally, I've actually already done my first iteration one degree of separation, right?"
          },
          {
            "time": "[00:08:19]",
            "text": "So if I was just doing one degree of separation, then I'd already be done. out it would be one for loop, right? And then if I wanted to do a second degree, I would just do through that for loop again, and I would just enter the queue again."
          },
          {
            "time": "[00:08:34]",
            "text": "And, that's how you kind of do these various different degrees of separation. So does anyone have any questions about how to process a graph?"
          },
          {
            "time": "[00:08:34]",
            "text": ">> So quick question about duplicates. I guess they would need to have some sort of unique value, right? In this case, that would be Alice."
          },
          {
            "time": "[00:08:54]",
            "text": "So we would check if this is already in our array, we just ignore it, right? We just keep it?"
          },
          {
            "time": "[00:08:54]",
            "text": ">> Yeah, so the question is it's like, what's a good mechanism for detecting duplicates in this. In the code that, cuz this is actually the problem that I'm gonna have you solve here in just a second."
          },
          {
            "time": "[00:09:14]",
            "text": "All of the people have an ID. And I just add that ID to a set and I say, hey, if this is already in my set, don't add it to the queue. That's a pretty elegant way of handling it, but it's up to you. You can handle it."
          },
          {
            "time": "[00:09:29]",
            "text": "There's a lot of ways to to handle that. It's a good question. Cool, and again, feel free to pop over here to the Complete Intro to Databases. Down here there is these whole section on graphs. We talk a lot about connection and edges, and how to do this at super large scales, right?"
          },
          {
            "time": "[00:09:56]",
            "text": "How does Facebook manage its social graph, those kind of things. So, definitely take a look at that. Okay, so question?"
          },
          {
            "time": "[00:09:56]",
            "text": ">> Yeah, question about graphs. How do you limit the amount of loops when you don't know the node to stop at?"
          },
          {
            "time": "[00:09:56]",
            "text": ">> How do you limit the amount of loops when you don't know the user to stop that."
          },
          {
            "time": "[00:10:21]",
            "text": "Okay, so that's a good question. Let's go take a look at traversals here, and the solution here. So we're gonna be looking at this one, the iterative one. So we have the while (queue.length), okay. So one degree of separation is everyone that I know, right? So what I can do to start this queue here, say skip here, so don't do anything weird."
          },
          {
            "time": "[00:10:58]",
            "text": "I have this queue that I'm making right now. So if I'm just going to go for just one degree of separation, all I have to do is say const. My connections = me.connections right? Then I would just say my connections.length. Bam, this would just be one degree of separation, right?"
          },
          {
            "time": "[00:11:24]",
            "text": "Now, if inside of this particular while loop. Let's go back and say this is queue now. And here inside of my while loop here, what I end up doing is I say, alright, queue.push, connection.connections, right? So my connection's connections, let's just call this person. So, and I'll just say this is a const newQueue."
          },
          {
            "time": "[00:11:59]",
            "text": "Or let. Okay? And I'll put some actually new queue. So what I'm gonna be doing when I do this new queue.pushperson.connections. What I'm doing, alright this is actually not be pushed but can cap, whatever it's fine. This is basically preparing the queue to process again, right? And then instead of having a while loop here, you're just going to have a for loop."
          },
          {
            "time": "[00:12:36]",
            "text": "That's going to go for only so many loops, right? So by just tracking how many times you're queuing up the users, or how many times you're processing your connection's connections, that's how you can limit how many degrees of separation you're gonna go. But basically, when you're processing one degree of separation, you're getting ready to process the next one by queuing up all of their connections, until eventually get to the point is like, okay, I've now processed three degrees of separation."
          },
          {
            "time": "[00:13:06]",
            "text": "I'm gonna start processing that right, despite the fact you actually have queued up a fourth degree of separation process. Hopefully that kinda gives you some indication. That's how I did it. I think it's as far as I know the only way to do how to do it. And then if that still doesn't make sense, then we'll come back and we'll do it together and we can talk through it."
          },
          {
            "time": "[00:13:31]",
            "text": "Right, let me unbreak my breadth first traversal."
          }
        ]
      },
      {
        "name": "40-graphs-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so let's pop over to our code sandbox again. We're gonna go into the graph here. So the first thing here is you're gonna see there is a job site js. This is a very long file with a lot of people with randomly generated names, titles and companies."
          },
          {
            "time": "[00:00:19]",
            "text": "So again, I didn't write these, I generated these. And these people are all connected to random people. Right, so this person 27 Reuven Dowbekin is connected to id 33, 43, 503, 940, 175, 825. So these are all the connections that this person has. And some people, this one has only three, this person has four right?"
          },
          {
            "time": "[00:00:50]",
            "text": "So there's a varying amount. So this describes our social network of people I think there are 1000 people in this particular set. Okay. If we head over to our function here I kind of describe a little bit. This is what the items the objects look right? They have an id, they have a name accompany a title and a connection."
          },
          {
            "time": "[00:01:20]",
            "text": "And I gave you here a function that you can just call like get user 12 right? And this will hand you back. The user that's associated with id 12, right? So that's what this function is there for. So actually, if I said get user 308, it would literally hand me back this object Okay."
          },
          {
            "time": "[00:01:48]",
            "text": "So what I want you to do, now if you can get rid of this, this is not true anymore. You can ignore that code pen link that's in there. So, find most common title, what I want you to do is I'm gonna give you an id. So I'll give you id 30 on this one, and then I'll give you degrees of separation, right?"
          },
          {
            "time": "[00:02:17]",
            "text": "So, the one degree of separation would be all the people that I'm connected to. And two degrees of separation would be the people I'm connected to and the people they are connected to, right? So on to three degrees, which is the people those people are connected to and all the people that are inside of that."
          },
          {
            "time": "[00:02:33]",
            "text": "And the last one here which is the extra credit one, user id 1with seven degrees of separation, which is all 1000 users except five, right? Yeah, so that's what I want you to do. I want you to find the most common job title amongst all of these people in these networks."
          },
          {
            "time": "[00:03:00]",
            "text": "There should be exactly one answer. If you did help here down in this yeah, I actually do have this little function that I commented out here that logs things out in a very useful way. So that can be helpful to you as well. If you need something that's going to log something out for you So first thing we're gonna do down here in the findMostCommonTitle, we're gonna create a queue."
          },
          {
            "time": "[00:03:33]",
            "text": "So let queue = and then we're just gonna just queue up ourselves, okay? We're gonna create a new set, so const seen = new set. And with one fun thing with sets, you can give them an array of things to see their data with. You don't want to requeue the id right there."
          },
          {
            "time": "[00:03:58]",
            "text": "So we're going to add ourselves to the already seen set. And then we're going to have a jobs objects where we're going to keep track of all the jobs that we're gonna see, okay? Okay, now we're gonna write a for loop, let i = 0, i is less than or equal to degrees of separation."
          },
          {
            "time": "[00:04:22]",
            "text": "Right because we're only gonna go so many degrees and then i++ const new queue. New queue equals empty array. And then here we're gonna say while queue.length. So the first thing we do is I'm gonna say const user get user with queue.shift. So we're gonna pull the first user off."
          },
          {
            "time": "[00:05:09]",
            "text": "Okay, and then here I'm gonna queue up the next iteration. And the way I'm gonna do that is I'm gonna save for. Let j=0, j is less than users, user rather.connections.length. J++. I'm gonna say const connection = user.connections(j). Then here, I'm just going to say if I've already seen this user before."
          },
          {
            "time": "[00:05:59]",
            "text": "Or rather if I haven't seen this user before. Seen.has(connection). So if I've seen this user before I'm not gonna add them to the new queue. Otherwise, I'm gonna say newQueue.push(connection) seen.add(connection) so I don't add the user again. Okay, so this is the part where I'm queuing up for the next particular iteration."
          },
          {
            "time": "[00:06:38]",
            "text": "And then down here, I'm just gonna say jobs[user.title] = jobs, user.title. So if I've seen the user before, or sorry, the job title. So let's say it's program manager. If I've seen it before, if it already exists, then what I want to do is jobs(user.title) +1, or I want to be 1, right?"
          },
          {
            "time": "[00:07:18]",
            "text": "So if I've never seen it before, then I'm going to start it with one. So if this is two, then I wanna make it three. If it doesn't exist, then I wanna make it one. That's what this little bit of logic is doing. Okay? And then at the end of this I'll have this newQueue, right?"
          },
          {
            "time": "[00:07:43]",
            "text": "Which is gonna be the new things, the next level of connections I wanna process. All I have to do is at the end of this. Loop here is I'll just say queue = newQueue. Okay, so this four loop is gonna determine how many degrees breadth first traversal I'm gonna do it on my connections."
          },
          {
            "time": "[00:08:13]",
            "text": "And what this is doing is this is queuing up the next level of connection. So for example, if this is three right I actually will have the fourth level of connection's ready to process, but it just won't do it right. Because this will prevent me from looping again."
          },
          {
            "time": "[00:08:32]",
            "text": "Okay, now I'm going to end up with this object called jobs which kinda look something like program manager. Designer 3 right and I need to turn this into a sorted list. There's a bunch of ways to do that. I'm happy with any way that you choose to do it."
          },
          {
            "time": "[00:09:00]",
            "text": "I'm just gonna go with object keys. So I'm gonna say const jobkeys. This actually probably would be better off broken into a different function. I just didn't, Object.keys[jobs]. This will give me back an array of all the keys that are in the jobs object. And then here, I'm just gonna loop over it and say let biggestNumber=jobs."
          },
          {
            "time": "[00:09:29]",
            "text": "Excuse me [COUGH] sorry, let biggestNumber=Jobs (jobkeys)(0) Let jobName =jobKeys(0) And then I'm just gonna do a for loop over this and try and find the one that has the biggest number. You could absolutely do this with like a reduce as well. If you're into functional programming like that, but I find reduces are frequently pretty hard to read."
          },
          {
            "time": "[00:10:13]",
            "text": "So I'm just gonna do with a for loop i is less than jobkeys.length i++. Const currentJob =jobkeys(i). If jobs. CurrentJob. Is bigger than biggestNumber then jobName =currentJob and biggestNumber is assigned jobs(currentJob). Okay, at the end of this little bit right here, I will have the job name which will be the job that has the most connections in my social network."
          },
          {
            "time": "[00:11:23]",
            "text": "Okay, and then down here we can just say return jobName. Okay, we'll move skip down here. And we will run this. And if you look down here at graph, you can see here that graph is passing. So one more we'll see if that works with extra credit. And looks like it is."
          },
          {
            "time": "[00:12:04]",
            "text": "So just for kind of funsies, let's go grab over here from the solution this little bit here, which is I just wrote a little utility to log out. All of the. See all the job titles sorted. All right so let's try running that. Play, you can see down here this is actually logging out for us all the various different job keys."
          },
          {
            "time": "[00:12:43]",
            "text": "Let's get that too. And then we'll clear this and run it again. So you can see here geological engineer that has 16. The rest of us have 15 that's the last one. That's the extra credit. The one here with user 307 with 4 degrees of separation. Pharmacist is 11."
          },
          {
            "time": "[00:13:06]",
            "text": "Graphic designer on this one is 5. And the top one here, sorry yeah, that would be 0.5. Librarian here is 3 with 2 degrees of separation. Cool, so any questions on graph? Is it always going to have or is any solution always going to have that amount of time complexity in it for graph traversal?"
          },
          {
            "time": "[00:13:39]",
            "text": ">> Yeah, okay, I get your question. So, I guess the question really is like what's the complexity of this? Cuz it's not n cubed. So I know I told you to look out for yeah, that's good question. I know I told you to look for for nested loops, but in reality here it's not like this is looping over everything in the particular array, right?"
          },
          {
            "time": "[00:14:03]",
            "text": "It's looping over a very small subsection of things to the point that we can basically ignore it, right? Because, like if we look back at our jobs array, right? If it was n cubed, that means for every additional person that we put in this that we would be increasing the amount of processing that we'd have to do by a significant amount right?"
          },
          {
            "time": "[00:14:22]",
            "text": "This means that everything would have to relate to everything else in the array twice in like a exponential fashion, which is not true, right? Everything that we add to the jobs array actually really only adds basically, a negligible amount of complexity, right? So and the reason for that, if you're looking at this, I'm looping over everything in the array."
          },
          {
            "time": "[00:14:52]",
            "text": "So it's important to know like what you're actually looping over. In this particular case, we're not looping over everything in the array, we're just looping over connections, right. And those connections is never very much, now, if every user is connected to every other user in the array, then we be in a world of hurt here, right?"
          },
          {
            "time": "[00:15:13]",
            "text": "But in this particular one, we're just really asking, have I seen this connection before, no, cool, I'm good. So the complexity here is really determined on how many degrees of separation we're going out there. The more degrees of separation that we're fanning out too, we're getting exponentially more complexity."
          },
          {
            "time": "[00:15:36]",
            "text": "So any big how, here is going to have to include however many degrees of separation that we're going to go out. It's going to be in terms of the degrees of separation. And as far as what a few."
          },
          {
            "time": "[00:15:36]",
            "text": ">> How deep in the graph, we're like the tree like structure that we're going, that's just going to exponentially increase."
          },
          {
            "time": "[00:15:54]",
            "text": ">> Right."
          },
          {
            "time": "[00:15:54]",
            "text": ">> Exactly, okay, that makes sense. Thank you."
          },
          {
            "time": "[00:15:54]",
            "text": ">> Yeah, of course. I mean, have you heard of the degrees of Kevin Bacon right? Any actor can be connected to Kevin Bacon with like 7 degrees of separation. That's because once you go out 7 degrees of separation, you're now interacting with half of the world's populace."
          },
          {
            "time": "[00:16:14]",
            "text": "Right or something weird like that. So, yeah, it's exponential based on that. So yeah, good question. Thank you."
          },
          {
            "time": "[00:16:14]",
            "text": ">> If we use the max heap to sort the traversals would it be more efficient than just a linear iteration on the results array?"
          },
          {
            "time": "[00:16:14]",
            "text": ">> If you used. So here, we use a max heap."
          },
          {
            "time": "[00:16:39]",
            "text": "So no, I don't think so. So, this is a linear search, right this is basically the definition of a linear search, which a linear search is just and right because we look at every single item in the array. And when you have an unsorted array, which is basically what this is, your best case scenario is that you look at every item in the array."
          },
          {
            "time": "[00:17:05]",
            "text": "Whereas if you're making a max heap, it's going to be n plus a bit more because you're doing some unnecessary comparisons to get ready to do like heapify and be able to do either dq or like a heap sort. So you're doing extra work that you don't actually really need to do."
          },
          {
            "time": "[00:17:27]",
            "text": "So I really appreciate where that person's head is going because they are thinking about it as, hey, I need to find the biggest number on this array. Heaps are very good for that. So that's a good brain space to be in. And I think that's like, don't lose that."
          },
          {
            "time": "[00:17:42]",
            "text": "But in this particular case, literally the most effective thing you can do is just a for loop saying, are you the biggest number? Nope. Are you the biggest number? Until you eventually get to the end, you will have found the, biggest number. Now the difference in complexity here is miniscule, to the point that I wouldn't really care so much if I saw that in code."
          },
          {
            "time": "[00:18:03]",
            "text": "It's just overkill. And in reality, we could've just used, I think there's an -.max, right? That's probably what I would've used because that does that automatically for you, but yeah, cool, good question. And yeah, definitely go check out that Neo4j stuff, if you enjoyed this. We just basically implemented a bunch of stuff that Neo4j just does for you, allows you to write queries that like, hey, give me the most common job title within 5 degrees of my network."
          },
          {
            "time": "[00:18:39]",
            "text": "And Neo4j is like, cool, I got that and it can just go do all that processing for you automatically just by writing really cool queries. And now you have the foundational knowledge that you would need to understand what's actually going on."
          }
        ]
      },
      {
        "name": "41-pathfinding",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is going to be very similar to graphs. This is gonna be very similar to breadth first traversal. So keep those kinda things in your brain while we're working on this, okay? Imagine you have a six by six grid looks something like this, right? And you wanna get from point A to point B, okay?"
          },
          {
            "time": "[00:00:19]",
            "text": "So that's a 11 to 26, where 00 is this one, we'll always do 00 on the top left. How would you do that? Like what algorithm would you write right now to get from point A to point B? I imagine most you just say, go towards it, right?"
          },
          {
            "time": "[00:00:41]",
            "text": "So just say like, all right, I'm too far to the left and then too far up, assuming you start from A so just go down until you run out of space to go down or you're on the correct level, and then head right. That would work, right? Cuz there's no obstacles here."
          },
          {
            "time": "[00:00:58]",
            "text": "They will just go here, here, here, here, or you could do it the opposite saying, go right until I'm on the right thing and say go here, here, here, here and then you'd arrive, right? Seems like it would work, right? Okay, yeah, exactly. This is what we diagram out, you just go down until go there, it's five."
          },
          {
            "time": "[00:01:21]",
            "text": "That would be the shortest path between point A and point B. Now, what if we add a wall in the middle there? That gets a lot harder, right? Cuz if you try and do this, you're gonna go here and then you're gonna hit a wall. Okay, well, you could try to be exploring the wall and say, okay, I can't go that way, this way, down again and then right again, I'd find it."
          },
          {
            "time": "[00:01:49]",
            "text": "So we could probably write some really basic, go left and right to try and get around the wall kinda thing. But as you might imagine, this is gonna spiral out of control really quickly. What happens if there's no a wall that you have to go all the way down and then back up and around right, or what happens if there's all sorts of various different walls?"
          },
          {
            "time": "[00:02:09]",
            "text": "Cuz I could really easily trick your algorithm, at which point you'd be writing so many special cases that it would just be an absolute mess of code. Wouldn't it be better/easier if there was just some algorithm that we could write that allowed us to always solve these problems?"
          },
          {
            "time": "[00:02:28]",
            "text": "So let's try something here and it's called Dijkstra's algorithm. And the first thing I'll say is we're actually not gonna do precisely Dijkstra's algorithm. Dijkstra's algorithm actually allows you to be even more clever, but we're gonna be doing like the most basic implementation of something that could be considered compliant with Dijkstra's algorithm."
          },
          {
            "time": "[00:02:52]",
            "text": "And the idea here is that you spiral outward from your points until you find a place where they meet. So what we're gonna do instead is we're gonna go to A and we're gonna explore one in every direction. Then we're gonna go to B and we're gonna do the exact same thing."
          },
          {
            "time": "[00:03:10]",
            "text": "We're gonna explore one in every direction. We haven't met yet. So we're gonna go back to A and we're going to go one more in every direction. So this is to a way, to a way, to a way, to a way, to a way, right? Assuming we can't go diagonal, right?"
          },
          {
            "time": "[00:03:30]",
            "text": "The same thing was 0.2, 2222. Eventually, just going kinda that spiraling outward. We're gonna find this point here where this three and this three might meet. And all of sudden now we know a path because we've spelled out where from both of them that if we go 1, 2, 3, 3, 2, 1, we have found the shortest possible path between these two points."
          },
          {
            "time": "[00:04:05]",
            "text": "So this might look to you kinda like breadth-first traversal and that's because it's actually precisely to what it is. The name of this algorithm is breadth-first pathfinding. And Dijkstra's algorithm is really just that doing breadth-first traversals. Just with adding the ability to add weights onto all those various different points, you can say, go towards it first and then try and go left, or you can add some heuristics to how it works."
          },
          {
            "time": "[00:04:35]",
            "text": "And ours, we're just doing dumb just spiral out until you find the where it meets. So you can think of all these points like 1, 1, it's basically a graph, right? It's a graph of coordinates that connects to other coordinates in the graph. So all we're doing here is we're just spiraling out of our graph and we're just checking all the children in a breadth-first traversal sorta pattern, okay?"
          },
          {
            "time": "[00:05:05]",
            "text": "This is basically tree traversal all over again. We're just using coordinates instead of using connections on our network or nodes in a tree. There's a really cool visualizer here that I linked too down here in the bottom that, let's see, bidirectional. And let's just draw a line between the two of these."
          },
          {
            "time": "[00:05:31]",
            "text": "And you can say start search and it'll show you except that's not what we wanted to do. That's you want breadth-first search. Don't allow bidirectional start search. So this is literally what you and I are doing together. And then eventually when it finds somewhere that these meet, it'll take that path as the shortest path."
          },
          {
            "time": "[00:05:59]",
            "text": "And like this can handle pretty difficult situations that you put it in. So now, if we were trying to go directly to this, we would have a hell of a time getting out of our little box here. But with this, it just spirals outward, until eventually finds the space, until it keeps spiraling, until eventually it's gonna find some way to get there."
          },
          {
            "time": "[00:06:26]",
            "text": "Now as some of you might be saying like, that looks like it's kind of inefficient, cuz once you start getting to these really deep traversals, yeah, it gets a little weird, right? Which is where some of these other ones, like this is Dijkstra over here. But this just allows you to put some more weight on going towards something instead of going away from it."
          },
          {
            "time": "[00:06:55]",
            "text": "But there you go. Okay. So I also linked a little Stack Overflow here if you want somebody to decline the difference in depth between breadth-first search and Dijkstra's algorithm. So this is still gonna work the same way, where you're just queuing like, you're going to add something to a queue, and then you're gonna process all the items in the queue."
          },
          {
            "time": "[00:07:23]",
            "text": "This works just like the graph, this works just like breadth-first traversal. You're just using coordinates instead of using people in a social graph. The other thing that you need to keep track of is what has been visited by what. So I need to keep track of that this point has been visited by A cuz what you need to check as soon as this one is found you to say, okay, I'm point A, this has been visited by A and this one's been visited by B."
          },
          {
            "time": "[00:07:52]",
            "text": "And then when you find that both of them have been visited by different coordinates, then you know that you found the shortest path there. So you're gonna have to do some strategy of keeping track of this has been visited by A, this has been visited by B and this has not been visited at all."
          },
          {
            "time": "[00:08:08]",
            "text": "So, again, be really inspired by what you just did with graph, cuz the algorithm works pretty similar."
          }
        ]
      },
      {
        "name": "42-pathfinding-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Okay so I'm gonna give you these graphs here. And I want you to find the shortest path between these two different things. So everything that is a two in this is point A or point B, right? It's one of the points I want you to find the shortest path between the twos."
          },
          {
            "time": "[00:00:21]",
            "text": "And anything that is a one, is a wall right? So you can't go through ones. Okay, and these just get more and more complex. And I also give you if you wanna check the edge cases right? So this one for example they're right next to each other, and in this one it's actually impossible."
          },
          {
            "time": "[00:00:46]",
            "text": "But again, this is extra credit down here so don't worry about this I'm more concerned about these ones. This one, it's kinda hard to see but this is actually a spiraling graph right? So the two here is, this is possible but you can see here it spirals through this wall."
          },
          {
            "time": "[00:01:02]",
            "text": "So this one's pretty difficult. I would recommend just taking this one at a time, right? So instead of saying all these all at once, I would just start with the four by four. And then I would just say, start skip this one, .skip this one, and .skip this one down here and just worry about the 4 by 4 one at first and then worry about the 6 by 6, and I would work for it that way."
          },
          {
            "time": "[00:01:33]",
            "text": "The other thing that I gave you here is I wrote this ridiculously colorful logger. So if you want something that's gonna kind of help you visualize what's happening with your maze, this will help you. You have to give it an array of arrays, sorry an array of objects."
          },
          {
            "time": "[00:01:58]",
            "text": "And that has to have an opened by and a number, zero means no one owns it. One means it's owned by A and two means it's owned by two. So let's see if I can, there we go. This is what this object has to look like for this logger to work."
          },
          {
            "time": "[00:02:18]",
            "text": "The close to be true or false where if it's true it's a unpassable wall. And then the length is how far it is away from the node that you're tracking. So let's just pop in here and I can show you what that looks like. Log maze there and log maze there, okay?"
          },
          {
            "time": "[00:02:46]",
            "text": "And then let's run these again so you can kind of see what that looks like. Play. So this is what it ends up logging out is these mazes. So you can see this as the 15 by 15 one, 0 0 is where it starts right? And 0 0 here."
          },
          {
            "time": "[00:03:09]",
            "text": "The green ones are visited by A, the red ones or pink ones are visited by B. So that's what this logger thing will do for you. It'll show you step by step, you can see the path finding algorithm working here, right? So these double dots represent places that it hasn't visited yet."
          },
          {
            "time": "[00:03:29]",
            "text": "And the Xs represent the waltz. So use that if you want to you don't have to. I just found it easy for me to kind of visualize how things were pathfinding. Okay, any questions about any of this?"
          },
          {
            "time": "[00:03:29]",
            "text": ">> Besides being fun, why is it useful?"
          },
          {
            "time": "[00:03:29]",
            "text": ">> There, I have found, well I guess one is just applying breadth traversal."
          },
          {
            "time": "[00:04:01]",
            "text": "And I'm actually trying to show you less why pathfinding and mazes is useful, and I'm actually trying to have more show you why breadth first traversal is just used everywhere and you probably don't even realize it. Like the ability to find how near something is to something else is extremely useful."
          },
          {
            "time": "[00:04:17]",
            "text": "So that's probably the core concept I want you to take away from that. Secondly I have been asked this exact question in interview with large tech company that probably shouldn't tell you which one it was, but one you've heard of we'll go with that. So this will be useful in interviews, to it is fun."
          },
          {
            "time": "[00:04:38]",
            "text": "[LAUGH] And do I have reason number three? I don't know. If I guess you end up working on the Google Maps team this will probably be something that you might think about. But beyond that, I don't know if I've actually had to find how near two things are on a graph before."
          },
          {
            "time": "[00:04:57]",
            "text": "I have had to use, graph traversal, but not necessarily pathfinding."
          }
        ]
      },
      {
        "name": "43-pathfinding-solution-a-neighbors",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first thing that I want you to do here in this find shortest path, you can write another function that does this, or I just do it right here in line. I need to create a, basically a grid that's the same size of this maze, but that I can like add objects to, right?"
          },
          {
            "time": "[00:00:16]",
            "text": "So I'm just gonna write like a really, oops, don't do that. Const this maze's called visited, that's what I'm gonna call it. And I'm just gonna write this in terms of a quick map. But you could totally do this with a for loop or something like that. Actually, maybe let's even just do this in terms of, well, let's just make a whole different function."
          },
          {
            "time": "[00:00:42]",
            "text": "Okay, here we go, function, Generate (visited). And it's gonna take in the maze, I think, and that's it. In here we're gonna make an array called visited. So const visited equals empty array. And here we're gonna write a for loop, for let i = 0, i is less than maze.length i++."
          },
          {
            "time": "[00:01:35]",
            "text": "Okay, so this is gonna be looping over the y axis of our particular array. Cuz, remember our array's 2D. And then inside of that, we're gonna do another for loop, for let, i or let j = 0, j is less than maze( i.length), j++. And actually we could probably make this a little bit better, let's make i here."
          },
          {
            "time": "[00:02:13]",
            "text": "We're gonna make that y. And then instead of j here, we're gonna make this x. Just to make a little bit, so we can keep track of x and y. Okay, and then we're going to say, Yeah, const new, or coordinate, let's call it coordinate, Is a new object that is, Yeah, it's gonna have closed, And that's gonna be if maze( y x is triple equal to 1)."
          },
          {
            "time": "[00:03:26]",
            "text": "Length is 0 because nothing has touched it yet, right? So we haven't actually started traversing our maze yet. And it hasn't been opened by anyone. So I'm gonna make these little variables at the top just help me keep track. So I'm gonna say const, Null_one = 0, const by_A = 1, and const by_B = 2."
          },
          {
            "time": "[00:03:58]",
            "text": "And then that way I can say open by null_one. And this makes more sense than open by zero, right? This just makes it a little bit easier to read. So I'm gonna have this coordinate. Here we're gonna have this const yaxis is gonna be equal to new array."
          },
          {
            "time": "[00:04:16]",
            "text": "And what we're just gonna do here is we're going to, Push into the y axis. So we're gonna say yaxis, Dot push(coordinate). And then down here after this for loop, we're gonna say, Visited.push( yaxis). Then down here return visited. So the code that I have here in my notes looks fairly similar."
          },
          {
            "time": "[00:04:59]",
            "text": "I just did the exact same thing with a map instead of a couple of for loops. So let's just make sure that this actually looks like the way I think it's gonna look. Console.log, Oops, const visited = generate(visited), With maze and console.log(visited). Okay, so let's do this. We don't wanna skip this anymore."
          },
          {
            "time": "[00:05:44]",
            "text": "And we'll just do that. And then we'll click play and see what comes out. So you can see here I got an array back. That's actually new to this as well with graph test. Get rid of that, okay. Back in pathfinding.test. So you can see here each one of these has length, for this one, closed false, length, open by zero."
          },
          {
            "time": "[00:06:22]",
            "text": "So this all looks like it's above board. But this is all I did, right? I basically took this and I made it into my own data structure. So I can keep track of what's opened, what's not opened, all that kinda of stuff. And let's actually do this for this one as well, just so I make sure that this, 6 by 6, good news, these are all six."
          },
          {
            "time": "[00:06:50]",
            "text": "And I just wanna make sure on row 4 here, sorry, row 5, That these are closed. And they are, okay, cool. So this looks like it's generating okay. So now I have a data structure that I can work with. That one should be open, open, and this one should be closed."
          },
          {
            "time": "[00:07:12]",
            "text": "Close, cool, great. That works great. So now we have this generated visited maze here that we can work with. And the first thing that we're gonna do is we're gonna say, visited[ [ya], [xa])] is assigned, or, sorry, opened by A, right? So we're gonna start with our maze."
          },
          {
            "time": "[00:07:45]",
            "text": "And we're gonna spiral out from there. And this looks a little weird for people, because we're used to x comma y. But just think about in the sense of that we're opening the y axis first and inside of the y axis is the x axis. That's why it's ya, xa Same thing here visited ybxb.openedby by b."
          },
          {
            "time": "[00:08:12]",
            "text": "Okay, and now we'll have like on this one, we're opening this one correctly, we're opening like that, right, wherever the twos are. Okay? Then we're gonna do an aq and a bq. So let aq assigned, and we're just gonna queue up our very first note here. So visited, Actually we can just even copy this, right?"
          },
          {
            "time": "[00:08:52]",
            "text": "And let bq equal that. And this is just gonna work exactly like how it worked with our graph, right? We're just going to go through our aq and our bq, we're gonna spiral them out where we're going to read first traverse until they crossover with each other. So, our outer loop, how far do we wanna go?"
          },
          {
            "time": "[00:09:19]",
            "text": "We wanna go until we find that they meet or they don't meet, right? So we're gonna say while aq.length and bq.length. Whereas before on our social graph, we wanted to limit how far out we would traverse, in this case, we wanna go as far as we possibly can until we find the answer."
          },
          {
            "time": "[00:09:42]",
            "text": "So, if we get through all of this and we don't find anything, then we're gonna say return negative one where negative one means I didn't find the path, right? There's no path between these two particular things, okay? Then up here we're gonna have an iteration number let iteration equals zero."
          },
          {
            "time": "[00:10:08]",
            "text": "And the first thing we're gonna say is iteration plus, plus. This is so we can mark that, like if we're exploring here this will be one, this will be one, this will be two, this will be two, this will be two, right? That's why we're gonna keep track here of the iteration const a neighbors equals aq."
          },
          {
            "time": "[00:10:44]",
            "text": "So, I wrote all these with reduces, which I don't think is the best way actually to demonstrate this. All right, so let's write a function down here before we get into this called get neighbors. Function get neighbors. So we're gonna give it our visited graph. We're gonna give it x and we're gonna give it y."
          },
          {
            "time": "[00:11:31]",
            "text": "So, basically what I want to do with this function is I wanna say, if I give you a coordinate x and y, give me back all of the neighbors that exist for that particular item. So I'm gonna give it an empty array. And then basically all we wanna do here is we just wanna check to make sure that we're not going out of bounds and that we haven't already visited that, right?"
          },
          {
            "time": "[00:11:57]",
            "text": "So, if y minus one is greater than or equal to zero, right? So if we're going up and we're not going to negative one, right, we're not going out of bounds of our particular array. And, we haven't already visited it, right? Because we don't wanna revisit the same things over and over again."
          },
          {
            "time": "[00:12:23]",
            "text": "Y minus 1 x, So this is just going up one bit on the same x-axis. Axis, it's a hard word. And it's not closed. That's y minus 1, so it's actually going left. Yep, then neighbors, oops. Neighbors.push visited y minus 1x. So we're just gonna do the same thing for all of our neighbors, right, we're gonna go left, up, right and down."
          },
          {
            "time": "[00:13:21]",
            "text": "So, luckily these are all kind of minor variations of each other, right? So this one is gonna be instead of y minus 1 plus 1, okay, and instead of going out of bounds this way, we're just gonna go to visited zero.length. I'm assuming that it's a square, not a square but at least rectangular grid, right?"
          },
          {
            "time": "[00:13:48]",
            "text": "So it's not jagged on the edges, which is why I'm just looking at visited zero, okay? And then here will be plus 1 and that's it, right, plus 1, okay? And we're gonna do this again, but we're gonna do x minus 1 that's greater than or equal to 0 and y, x minus 1 closed."
          },
          {
            "time": "[00:14:27]",
            "text": "Okay? Same thing here, this is gonna be x minus 1. And this is up. Then one more time for x plus 1. And this is for visited.length And visited x plus 1, x plus 1 and this is down. Okay? And then here, this will return to us neighbors, right?"
          },
          {
            "time": "[00:15:13]",
            "text": "So now we can give it any sort of visited array with x and y and we'll get the valid neighbors for us to nq after this. So, what we're gonna do here is we're gonna get the neighbors for a neighbor so const a neighbors, this is assigned get neighbors."
          },
          {
            "time": "[00:15:40]",
            "text": "We have to go through axis to it this way. So we're going to say four let I, Equal zero. I is less than aq. .length, i++. And we're gonna say, Let aNeighbors, Equal empty array, aNeighbors.push, For all the neighbors in the aQueue. So we're gonna say aQueue, const neighbor, const coordinate = aQueue that."
          },
          {
            "time": "[00:16:42]",
            "text": "We could have totally done it this way. In fact, let's just do it this way. Sorry, one more time. While aQueue.length, we're gonna say const coordinate, aQueue.shift, okay? So now we can have a coordinate here, and this is gonna keep going until all of this has been emptied."
          },
          {
            "time": "[00:17:13]",
            "text": "And we're gonna say aNeighbors.concat, Get neighbors of visited coordinate.x and coordinate.y. There we go. Took me a second, but we got there. But the basic idea here is we're gonna go through everything that's in the queue and we're going to enqueue all of its valid neighbors. So then we're gonna have this aNeighbors, and this is gonna have to be equal."
          },
          {
            "time": "[00:17:49]",
            "text": "So we have to say a, Like that cuz concat gives you back a new array, right? At the end of this aNeighbors is gonna have all of the valid neighbors on there. So we're gonna have to go and modify all of these to be opened by a with all of their correct lengths."
          },
          {
            "time": "[00:18:14]",
            "text": "Okay, so let's go ahead and do that. We're gonna say, Let's even just say this, gather a neighbors. And then process a neighbors for let i = 0, i is less than i, or sorry, neighbors.length, i++. Const neighbor = aNeighbors(i). I'm seeing neighbor so many times. It's losing all meaning to me."
          },
          {
            "time": "[00:19:10]",
            "text": "Have you ever had that happen to you? I think it's called semantization or something like that, where you say something so many times that you don't think you're actually spelling it correctly anymore. That just happened. All right, if neighbor.openedBy === B, BY_B, then guess what, we found the answer, hallelujah, return neighbor.length + iteration, right?"
          },
          {
            "time": "[00:19:42]",
            "text": "So this is just saying if I have spun out and I've encountered the next thing that has been opened by b when I'm doing it on a, it means cool, we found the path. So we add my length that I have of how far away I am from my origin plus the iteration, which is how far away you are from the other one, right?"
          },
          {
            "time": "[00:20:04]",
            "text": "Then you've found the correct one. All right, else if neighbor.openedBy === NO_ONE, so if this hasn't been opened before, Then we're gonna say neighbor.length, we're gonna consider this one visited, right? So neighbor.length = iteration, neighbor.openedBy BY_A, and aQeue.push neighbor. Right, so it means that we've gotten one forward, we're not going to queue this neighbor that we're looking at now for the next iteration so that we can go ahead and process it on the next go around."
          }
        ]
      },
      {
        "name": "44-pathfinding-solution-b-neighbors",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Okay, so this does all of A. And actually, this would probably eventually end up working. Because if you have the A will just continue to spiral out, eventually it's gonna find B, but we want to do it on both sides. So we're gonna basically mirror this logic but for B."
          },
          {
            "time": "[00:00:19]",
            "text": "You might be able to break this into a function that does it for both. I didn't, so I'm actually just gonna copy this. We're gonna do this same thing for B neighbors. So bNeighbors and then we're gonna have our own little bQueue. So in here we'll have bQueue."
          },
          {
            "time": "[00:00:49]",
            "text": "Okay and then instead of BY_A, this will be BY_B and this one will be BY_A. And yeah, so you could totally do this by extracting this into a function and then just passing it into both. That would work. This is process bNeighbors. Okay. I think this should probably work."
          },
          {
            "time": "[00:01:42]",
            "text": "Maybe it didn't. But let's check. So receive negative one and expected we've six. Same thing with this one. So both of these they're coming back as never finding anything. Which is not good. It should. It should find things. Thank you that shift aNeighbors, aNeighbors concat. So let's console log here."
          },
          {
            "time": "[00:02:28]",
            "text": "Well, let's put on our log, may this function. So down here, We're gonna put logMaze(visited) and also up here, log it as well. So log maze(visited) lets try that and we'll try running it again, see what happens. All right. So we're getting, nothing visited. Okay, so this is not what you want."
          },
          {
            "time": "[00:03:12]",
            "text": "We would like to visit things. So aQueue, this should have something in it. So there's probably something wrong with our get neighbours here. Check that out. So it's never coming back with anything. Which is problem, okay, so let's check out why that might be. Why that might be happening."
          },
          {
            "time": "[00:04:06]",
            "text": "Coordinate. And let's click play. So that's a thing, got that. But it doesn't have coordinate that x and coordinate y. Y does it not have x and y. That's y. So up here in our generate visited maze, we just need to put x and y in here. We also need the coordinate to know exactly what its coordinates are."
          },
          {
            "time": "[00:04:47]",
            "text": "Otherwise they won't be able to find that. So let's try that again. And there we go, that was it. So let's go and skip the rest of our tests here. We did six by six we want to do eight by eight and 15 by 15. There we go, spiraling out there."
          },
          {
            "time": "[00:05:26]",
            "text": "You can see here it's meeting here at 38 38. Cool, yeah, I'm happy with the solution. This ended up being a bit more verbose than what I have in here in my course notes. I'll leave both of them so you can take a look at them. This one I used without doing any maps or reduce, whereas in my other one I used a couple of maps and a couple reduces as well."
          },
          {
            "time": "[00:05:53]",
            "text": "So both are totally valid. I'm gonna go ahead and assert that this might be a little bit clearer, just cuz it's easy to read line by line. Okay, any questions about our solutions here? Actually while someone's thinking. Just one second. I'll let you ask. I'm the worst. I asked too many questions and I tell you to shut up."
          },
          {
            "time": "[00:06:19]",
            "text": "Anyway, so [LAUGH] This was the bug here on line 32 and 31, is I forgot to put the x and y. If you haven't seen that before, it's x, x. Y, y right? But if you just if it's called the same thing, you can just do that and we'll put it."
          },
          {
            "time": "[00:06:36]",
            "text": "Yeah, those two things are equivalent. But yeah, that was the bug. You got to put those there. Okay, sorry. Go ahead with your question."
          },
          {
            "time": "[00:06:36]",
            "text": ">> Yeah. My question was, it gets to a point that it's so abstract. It's basically impossible to solve it even in a day. So how would you go about solving a problem like this?"
          },
          {
            "time": "[00:06:52]",
            "text": "From the very beginning, I guess."
          },
          {
            "time": "[00:06:52]",
            "text": ">> Yeah, at the beginning of this course I definitely tried to warn you that colleges will spread this kinda stuff out over a couple of years. And I'm just throwing it all at you in an afternoon, right? So one, I am quite sorry."
          },
          {
            "time": "[00:07:09]",
            "text": "[LAUGH] This is really difficult to process all at once. Really, for someone taking this course, I would invite you to give this, the time that it needs to kinda sink into your brain. I probably would try and do these like, one at a time. Maybe one a day or something like that."
          },
          {
            "time": "[00:07:30]",
            "text": "And the reason why I feel that's fair to say is it probably took me two or three months to prepare all this course material. And then I'm just expecting you to learn it all in a day. And I already knew how to do this stuff, okay? So, one, I'm just giving you permission to feel this is super hard, right?"
          },
          {
            "time": "[00:07:46]",
            "text": "And two, there's really no substitute for just walking away from the computer. Taking a walk. Thinking about it. Exercising. Unwinding, playing with your family, whatever that means to you. That's what you need to do. Because you won't be able to sit down and do this entire course in one sitting."
          },
          {
            "time": "[00:08:06]",
            "text": "Or you're just about 100 times smarter than I am, both of which are total possibilities. So, does that help any?"
          },
          {
            "time": "[00:08:06]",
            "text": ">> Yeah, but I guess also. Trying to solve it on paper before you start writing code will be also helpful."
          },
          {
            "time": "[00:08:06]",
            "text": ">> For sure, yep. I mean, this is why when I, in college I, the first thing I bought when I was very poor in college was a giant whiteboard."
          },
          {
            "time": "[00:08:31]",
            "text": "And that was the most helpful thing that I had the entire time. It's just diagramming it out reasoning through all these kinda things. I'm actually getting a big one installed in my new office that I just moved into, it's a whiteboards are great. But also if you don't have that pen and paper or Microsoft Visio or Google draw."
          },
          {
            "time": "[00:08:50]",
            "text": "Any one of those things can definitely help you with just putting your very, very abstract thoughts on the paper."
          }
        ]
      },
      {
        "name": "45-tries",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's keep going. So we just did pathfinding. And now we're going to do, how do you think you would pronounce that? It's tries. And I did not make that up, that's actually the correct way to pronounce that. So I still call this tries despite the fact that it's spelled trie but let me explain to you why it's called a trie."
          },
          {
            "time": "[00:00:29]",
            "text": "It's actually from the word from retrieve, right? So, this is in the middle of this right? So how do you say retrieve like that? So it's trie in the sense of retrieve. However, the funny thing too in order to implant the trie you must use tries as in like these kind of tries."
          },
          {
            "time": "[00:00:48]",
            "text": "So, I just have a immense amount of disdain for whatever person thought that was a good name for that particular data structure. But here we are, that's what it's called. So what is a trie, beyond being just a trie. It's a trie that's optimized for searching, by prefix."
          },
          {
            "time": "[00:01:09]",
            "text": "So almost exclusively, as far as I know, this is useful for like typeahead, I don't know if you've ever heard of typeahead. But it's the idea if I start typing S, A, N it's gonna auto-complete to San Francisco, San Diego, San Jose right, it's gonna start trying to guess what I'm doing."
          },
          {
            "time": "[00:01:26]",
            "text": "The best way to implement those sorts of typeaheads is using this data structure called trie. Okay, so a trie starts with a root node which is typically just an empty string, right. Basically represents nothing. Then you'll have notes coming off for the first letter that someone might type."
          },
          {
            "time": "[00:01:48]",
            "text": "So let's take a look at this one. That's B, right? So you'd have like an empty string, root node, then someone would type B, right? And then people, the typeahead was start trying to guess what the person's asking for. So let's say that they were trying to get to Boston, right?"
          },
          {
            "time": "[00:02:06]",
            "text": "They would type b-o, and then off of this, o node, there'd be s, t, o, n for Boston. But there would also be b-o-i-s-e for Boise so that's kind of the idea here with tries is trying to guess what the user is trying to do, so that you can kind of like help them with whatever they're trying to do."
          },
          {
            "time": "[00:02:30]",
            "text": "So each one of these write b-o, the b the s, the t, the o they enter their own individual nodes. In this particular case there's probably not another US city that starts with b-o-s-t-o right? So there's probably only one end off of the Boston search term here, but some of them as you might imagine, there's lots of American cities that start with b-o, right."
          },
          {
            "time": "[00:02:54]",
            "text": "So this is gonna have like 15 different sorts of notes hanging off of it. So, in fact, some of them that that can be kind of difficult is there's American cities that are self contained and other ones right. So that like there's a city called Sandy and there's a city called Sandy Springs but these are both valid cities."
          },
          {
            "time": "[00:03:16]",
            "text": "So you can have to provide for both of those. So this is y here this y node, right, let's say that b-o-s-t was a valid city this t would have a complete flag on it that says that b-o-s-t is actually a valid city. But it would also say I also have children too, by the ways because Boston is also a valid city Cool."
          },
          {
            "time": "[00:03:41]",
            "text": "What else? So like, let's take San Francisco and San Diego, those have a space in them, right? So it's san<space>, you would just treat that space as if it was a normal character, right? There's no special consideration given to spaces. And yeah, that's really about the entire idea here is you're just going to make these tries."
          },
          {
            "time": "[00:04:07]",
            "text": "This b-o right this could have infinite amount of children there could be a b-o-i a b-o-s, a b-o-n, a b-o-f, right, as many as you have cities to justify. So let's talk about how you would build one of these."
          }
        ]
      },
      {
        "name": "46-tries-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The exercise is under trees. Inside of trees is cities dot j s and in here I have I think 926 of the largest cities in the US. So, your particular task right now, is going to be to construct a tree. Out of all of these various different cities in the United States."
          },
          {
            "time": "[00:00:29]",
            "text": "I don't think there's any duplicants. In here, right? But you're gonna have a note for our a note for m a note for E, and each one of those is going to have various different notes off of it. So what you're gonna do, down here, as you can see in the unit test You're gonna call something that's called create tree."
          },
          {
            "time": "[00:00:55]",
            "text": "Once you have a function up here, that's gonna create a data structure with all these various different nodes in it. It's gonna give you a list. So for the first one I only give you 10 cities for the second one, I give you 10 cities for the third one, give me 25 last one 200 200 and then eventually I start giving you 500 and then all of them, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "And then under that, I'm gonna ask you to give me a function on that tree that you give me back called complete and I'm gonna give you a string here. So let's take a look at cities again. If I go up to the first 10 cities, which will be all of these ones right here, there's San Diego, San Antonio and in San Jose, right so these three cities will be in there."
          },
          {
            "time": "[00:01:52]",
            "text": "So in that test here, if I start asking you to complete san you should give me back San Antonio, San Diego and San Jose doesn't matter what order It's up to you, but that's the job to do here. I think that should be pretty good explanation here. Any questions about the exercise or how to do it, you're just gonna be building a big tree of all these."
          },
          {
            "time": "[00:02:29]",
            "text": "Do keep in mind that like, again, going back to our picture here, there's an O here and there's an O here. So you'll have hundreds of O nodes, right, and they'll just be in different places. So don't try and we use the same O node for everything, right?"
          },
          {
            "time": "[00:02:44]",
            "text": "You're not gonna have just 26 nodes. For this particular data structure, you're gonna have thousands of nodes. Yeah, and then someone asks for you to complete Bo, what you're going to do is going to say all right, go to the root node hop to be hopped. Right, and then ask what are all the auto completions that I can get out of this this and you'll just say, okay, well I'm gonna go down this path I'm gonna get Boston."
          },
          {
            "time": "[00:03:14]",
            "text": "I'm gonna go down this path and get Boise and then I'm gonna return those as my answer right. So this is more depth first traversal, right? We're depth first traversing these trees."
          }
        ]
      },
      {
        "name": "47-tries-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's build some trees. So we know trees.test.js. And the first thing we're gonna do here is under the create tree, we're gonna create this new node with an empty string, right? Cuz remember I was telling you the root node needs to be an empty string. And then we're just gonna say for let i equals zero, i is less than words, dot length words being all the words that I'm getting back from the test here."
          },
          {
            "time": "[00:00:35]",
            "text": "There'll be the city names. I plus plus and when I say const word equal words I and then we're just gonna say root.add word.to lowercase. We're gonna keep everything in lowercase here so we don't get too caught up on what's lowercase and what's not. Okay. So this is all we're gonna do for create tree, we're just basically going to put all of the logic here into the node."
          },
          {
            "time": "[00:01:15]",
            "text": "Okay, here in the root node, let's make a constructor. This is gonna take in a string. I'm gonna say this children is an empty array. This dot terminus is what I call that, but you could call it whatever you want. Basically what I'm saying is like, am I on a valid word right now, right?"
          },
          {
            "time": "[00:01:42]",
            "text": "So, if I'm searching for Sandy. Sandy is going to be valid like a valid term, so, this will be true for that. And it will also have children, that's what I'm trying to illustrate there. This value is going to be equal to a string of zero, right? So the first letter is going to be of the string is gonna be its value."
          },
          {
            "time": "[00:02:10]",
            "text": "So again, we're kind of trying to build B and then I'm gonna cut pass the string Austin to another node, and then the string stun and then t. Right, so basically this node is going to build itself with all of its children. And then I say here if string.length."
          },
          {
            "time": "[00:02:37]",
            "text": "Is greater than one, so if it's more than just a character then I need to say this .children.push new node. Right, so we're gonna recursively create new nodes of string substring. One, basically what I'm saying here is, if you pass me Boston, I'm gonna make the value B."
          },
          {
            "time": "[00:03:04]",
            "text": "And then I'm gonna create a new node in my children of oston. All right, cool. Else this dot terminus equals true Cool, all right. Okay, then we're gonna create another one here called add string. I wanna say const value equals string, zero, constant next equals string, dot substring one and then we're just gonna do a four."
          },
          {
            "time": "[00:04:18]",
            "text": "Let i = 0, I is less than this, but children dot length I plus plus const child equals this dot children I. We're just kind of looking here for where we're gonna put our new string here whenever we called add. All right so cons child equal this dot children, then we're gonna say, if child's dot value, triple equals value."
          },
          {
            "time": "[00:05:04]",
            "text": "Then inside of here we're gonna say if next is the particular next substring that we're looking for. Then we're gonna say child that add next. Otherwise else child dot terminus equals true, right? Cuz when we're adding something new either we have more to add or we've reached the end, in which case we're going to say cool."
          },
          {
            "time": "[00:05:35]",
            "text": "This is a complete string right here. Yeah, and I got too many curly braces here. Okay, and then once we've found that here, we're gonna say return. Okay, and then inside of that. Instead of add. So here. So, outside of that for loop thumps, so for loop This return should be inside of this one."
          },
          {
            "time": "[00:06:28]",
            "text": "Yep, okay, so line 38 should be here on 37. It should be inside of this if value here. Yep, okay, cool. I was getting confused there for a second. Then down here, we're just gonna say this.children.push, new node string. Okay, cool. So just kind of to work backwards through this or work forwards through it rather."
          },
          {
            "time": "[00:07:00]",
            "text": "Whenever we're trying to add a new string, we're trying to get to the point at the end of this where we can just concatenate holistically a whole new node to it, right? So again, going back to here. We're gonna go if we're trying to add. I don't know."
          },
          {
            "time": "[00:07:22]",
            "text": "Bolton, right, which is another city, we would start at the node we go to B, we'd go to o and then we'd see that there's no l here, at which points would say cool add lton here, right? So what this is doing is this is finding. It goes until the end until it runs out of places to go."
          },
          {
            "time": "[00:07:40]",
            "text": "And then it says, cool, I found that place, add the rest of the new string. Unless, let's say we had a city for some reason called Bossed right, it would find here like, okay, this is the end and then it would just mark t as a terminus. And if called self good, everything's good to go."
          },
          {
            "time": "[00:08:00]",
            "text": "So that's what happens here. Yep, that's what happens here in add. Okay, so let's write complete, so we're gonna say let completions, cuz we wanna find all of them. If you ask for San, we wanna get San Diego, San Francisco, all of those, so that's why that's an array."
          },
          {
            "time": "[00:08:26]",
            "text": "And then we're gonna say, For let I equal 0. I is less than this dot children dot length i plus plus and when I say const child equals this dot children. I lm not gonna say completions Equals completions.concat(child). And we're gonna write a second method here called _complete."
          },
          {
            "time": "[00:09:13]",
            "text": "This one's going to be like the externally facing that people are going to call this API. But we're gonna write our own complete internally called _complete with string empty string and array, and then we're gonna write a recursive method. That's actually going to recursively call complete on all of the children to make sure that we get all of the various different possible completions."
          },
          {
            "time": "[00:09:41]",
            "text": "So underscore complete here, we're just gonna write that above. And it's gonna take in the search string, so the one the string that we're building, okay? So search we're gonna take in built which we've stuffed we've already built so far. And then we're also going to take in, they already made suggestions, right, because you might get multiple suggestions for completions whatever you wanna call it."
          },
          {
            "time": "[00:10:09]",
            "text": "So we're gonna say if suggestions.length is less than or equal to 3, and sorry, the suggestions rather. We're only gonna start autocompleting if they've typed three things in, right? I'm sure you've noticed that on Twitter you have to type like three things and if you're looking for something or otherwise won't complete it."
          },
          {
            "time": "[00:10:35]",
            "text": "That's what that's doing or search and search 0 is not equal to this dot value. So this is saying, hey, you called complete. This is not a match with the particular element I'm on. So let's say I was searching for BO, and I was on the A child is a K."
          },
          {
            "time": "[00:11:03]",
            "text": "This doesn't match, so I'm not gonna do anything here, I'm just gonna return right away. In either one of these cases, what we just wanna do is we just wanna return the suggestions. Okay. So if this terminus if we found something that is a complete thing, then we're just gonna say suggestions."
          },
          {
            "time": "[00:11:33]",
            "text": "You know what I was, the suggestions here is the completions. I'm sorry, remember what the exact code I wrote here [LAUGH] So the suggestions here is all the ones that we have found so far. We're only gonna suggest to up to three at a time right? If someone starts typing San and you suggest them 700 cities named San they're just gonna get overwhelmed."
          },
          {
            "time": "[00:11:55]",
            "text": "So in this particular case, we're just going to suggest them the top three. So suggestions dot push and then hear what we're gonna say it was gonna put built Built, And this star value. So built so far like so if we're searching for Boston, right? This is going to find built, which will get to bosto, and it's gonna find N as the next one being the terminus, right?"
          },
          {
            "time": "[00:12:32]",
            "text": "In which case, this will push into the suggestions Boston. If you feel like this is more clear, you can also do. In fact let's just put it that way, built plus this dot value, that might be a bit clear. It's just string concatenation, I was doing it with a template string before, okay?"
          },
          {
            "time": "[00:12:58]",
            "text": "Then under that we're gonna say this dot children. And then yeah, let's just do it this way for let I equals zero. i is less than this dot children dot length. I plus plus, and we're just gonna say child. Complete, sorry, child dot underscore complete. Where we say const child is assigned this.children i, like that."
          },
          {
            "time": "[00:13:38]",
            "text": "Child.complete, search.substring one so everything from the first character, so you cut out the 0th element of this. So again, if we're searching and we typed b, we'll cut this one out and then we'll pass that one on, right. So that's what that's doing. Built plus this dot value and suggestions."
          },
          {
            "time": "[00:14:15]",
            "text": "And, you can say suggestions equal here if you want to. It doesn't really matter, because we're operating directly with on suggestions we say, push here, right? But if you want, you can say suggestions equals child like that. And then at the very bottom here, we're gonna say return suggestions."
          },
          {
            "time": "[00:14:46]",
            "text": "All right. So I think that should be it. Make sure that my stuff works here. One failed skimmer that path finding madness log maze. Okay, they're, there, let's try that again. So let's pop into why our test is failing. Completions is undefined, that seems like it could be a problem."
          },
          {
            "time": "[00:15:36]",
            "text": "It's because I don't return them. Start with that. Return completions All right, so this one complete is still undefined. Not sure what I did here, all right, one more time. There we go, and does that is passing now, okay? So this is how you basically do type ahead like this."
          },
          {
            "time": "[00:16:30]",
            "text": "I don't know if this was invented at Twitter, but certainly Twitter's one made it popular. Of everything that I've showed you today, trees are actually one of the more recent innovations in computer science for dealing with type ahead. Again, it's still depth first traversal on the tree, right, which is something from the 50's, 60's, 70's, probably even before that."
          },
          {
            "time": "[00:16:49]",
            "text": "But using it as like a type of head kind of guests UI trick. That's more more of one of the recent innovations here. All right, any questions about trees?"
          },
          {
            "time": "[00:16:49]",
            "text": ">> So to add more order to say words, you would add weight to them, right. That's how we would solve the problem."
          },
          {
            "time": "[00:17:13]",
            "text": ">> Yeah, so let's say one of the words was more important than the others, right? Like let's say you want to suggest, based on population, right, that would be like a good indication you can suggest. Boston before bountiful, right? In this particular case, the way that we did it here, you would just add Boston first, right?"
          },
          {
            "time": "[00:17:30]",
            "text": "And that would make it come up first. So you could do it that way. The other thing you could do is you could put exactly what you said which is like a priority or a weight or something like that. So you'd have to do all of the completions and then you'd have to kinda sorted out by which one had a higher priority."
          },
          {
            "time": "[00:17:45]",
            "text": "Or actually probably a better way of doing that is, every time you added something new, you would just make sure that it would be reordered so that the higher priority ones end up being higher, right? Cuz the advantage of this tree is that if you go down here to the suggestions, this part right here."
          },
          {
            "time": "[00:18:03]",
            "text": "This actually quits after three times, right? So, it's actually quite fast, so, it can do completions really, really quick. And if I have to go do all of the completions every single time, every time that I type B, it's just going to slow to a crawl right? Before it does all of those completions."
          },
          {
            "time": "[00:18:20]",
            "text": "So that's why I would be inclined to say is that you should build the data structure in such a way that the higher priority ones come up first."
          }
        ]
      },
      {
        "name": "48-bloom-filters",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's do the last exercise in this course before I release you and your brain from this vise of knowledge that I'm throwing at you, this curse of knowledge. Let's talk about Bloom filters, which is just like a fun thing to say, it sounds like it's a really happy data structure, actually think it's named after the guy that invented it."
          },
          {
            "time": "[00:00:26]",
            "text": "They normally are, I can't remember why it's actually called a Bloom filter, but here we are. Bloom filters are something that you actually do see quite a bit out in the wild today. There's actually a really great article here on medium about medium itself that I dropped in here if you wanna take a look at it."
          },
          {
            "time": "[00:00:44]",
            "text": "And I also put the Wikipedia article in here so you can see, here's a bunch of places where people are using Bloom filters. So what is a Bloom filter? The Bloom filter is a data structure that was designed so that we could ask it questions about extremely large data sets and it could give us an answer of no or maybe, right?"
          },
          {
            "time": "[00:01:07]",
            "text": "So it's a way that you design a set. And so when I say a set I mean I can add things to a set and then I can later go back and ask the set do you have this in your set? And we actually did this already with graphs, so let's just hop back over to graphs so I can show you concretely what I'm talking about."
          },
          {
            "time": "[00:01:32]",
            "text": "Here I have this set called seen, right? And this is a set. And then later I ask scene hey, have you seen this connection before, and it says yes or no, right? This has been added to my set, or this has not been added to my set. This is 100% accurate, right?"
          },
          {
            "time": "[00:01:50]",
            "text": "If you ask it have you seen number 32, it will give you the definitive answer of yes I have seen 32, or no I have not seen 32 before and it will be 100% correct always. A Bloom filter, well, so the downside of this particular set implementation though is that you must store everything in the set, right?"
          },
          {
            "time": "[00:02:09]",
            "text": "Everything that I add to the set has to be stored somewhere, so if I add 100 million things to the set, it has to store 100 million things, right? This is where Bloom filters can be kind of interesting, storing 100 million things doesn't sound like fun, what if I could store way less things and get most of the same advantage?"
          },
          {
            "time": "[00:02:30]",
            "text": "That's what a bloom filter is. A Bloom filter, you can add things to it and it does kind of a little bit of a trick to say, hey, I might have seen this before, or no, I have definitely never seen this before. So by trading off that accuracy, you can drastically reduce how much storage you're using, so let's talk about when that would be."
          },
          {
            "time": "[00:02:54]",
            "text": "Normally we don't want a margin of error with our data structures, right? That's not something that's desirable about a data structure, however, using a lot less space can be. So, in this medium article right here that I'd linked you to, they talk about their recommendation engine. In the recommendation engine, you scroll down to the bottom of your article and they recommend you 3 more articles that you might like to read."
          },
          {
            "time": "[00:03:19]",
            "text": "Medium doesn't want to ask you, hey, you should read this for something that you've already read before. However, it's impractical for medium to store for every user every single time how many things that they have read that are related to something. That would be an enormous data set given how many users medium has."
          },
          {
            "time": "[00:03:37]",
            "text": "So, what they have done instead is they use a Bloom filter to say, hey, has this user ever read this article before? And the answer is either no, they have never read this article before, or maybe, they might have read this article before. And the advantage here is that, if they don't recommend something that you haven't read before, that's okay, right?"
          },
          {
            "time": "[00:03:57]",
            "text": "It's okay for them to just say, here's 3 things that we definitely know you have never read. And so they're okay with that trade off of, we're willing to not recommend articles that they haven't read before to trade off in favor of much smaller storage. And we can always show them things that they had never read before."
          },
          {
            "time": "[00:04:17]",
            "text": "Is that kind of make sense? It's just, they have this acceptable margin of error. And you might ask how big is the margin of error? And then, it depends on how much space you're willing to take. If you're willing to take a lot of space you can get that margin of error down to like 1% or 0.1% or something like that."
          },
          {
            "time": "[00:04:37]",
            "text": "If you're not willing to do that, it'll get up to 50% margin of error it depends on how big you make the data structure. So, let's say that we have a Bloom filter with 10 elements in it, right? The way that we're gonna model a Bloom filter is we're gonna have an array of 0s and 1s."
          },
          {
            "time": "[00:05:00]",
            "text": "A 1 means that it has been seen before, and a 0 means that it has not been seen before. What I'm gonna do is I'm gonna run whatever string that I'm trying to put in the array. So let's say I'm trying to put Brian in my set, right?"
          },
          {
            "time": "[00:05:15]",
            "text": "In my Bloom filter. I'm gonna run it through 2 to 5 hashing functions, all right? Even 8, right? You can as many hashing functions as you wanna do. The more hashing functions you use, the more space you're gonna use, but also yeah, it just depends on kind of the margin of error that you wanna do there."
          },
          {
            "time": "[00:05:41]",
            "text": "So let's say I'm doing it through 3, I'm gonna run Brian through 3 different hashing functions. And a hashing function if you're not familiar with something, just takes a number or takes a string and converts it to a number, right? So in this particular case, I'll run it through 3 different hashing functions."
          },
          {
            "time": "[00:05:55]",
            "text": "Let's say one of them gives me 2, one gives me 5, and one gives me 8. I'll go back to my data structure here and I will flip the two elements to 1, the five elements to 1, and the eight element to 1, okay? Now if I go back later and say hey, have you seen Brian before?"
          },
          {
            "time": "[00:06:15]",
            "text": "I will run it through the same hashing functions, which will definitely give me back 2, 5, and 8 again, right? And I'll look at 2, 5, and 8 here and it will say maybe, I might have seen Brian before, in which case I wouldn't use it, right? Now, if I go back and ask later have I seen Sarah before?"
          },
          {
            "time": "[00:06:35]",
            "text": "Let's say that it gives me 2, 2, and 4, so I go to 0, 1, 2, this one has been seen before, right? So there's that, and it goes to 4 which is this one, which is a 0, because 0 hasn't been flipped before, it definitely has never seen Sarah before, for sure, right?"
          },
          {
            "time": "[00:06:53]",
            "text": "So if it encounters any 0s here you can go ahead and say, I've never seen Sarah before, you can safely use that one Okay, so let's say that we add one more item to the array which is Simona, which gives me back back 0, 4, and 5, if we went through hashing functions."
          },
          {
            "time": "[00:07:15]",
            "text": "So now I erase this. Now if I go back and ask Sarah again, if you remember that was 2, 2, 4, so 2, 2, and 4. Despite the fact that it has never seen Sarah before, it's gonna say yeah, maybe I might have seen Sarah before and in this case it would be a false positive, right?"
          },
          {
            "time": "[00:07:31]",
            "text": "It would be coming back to you and say, I might have seen this before when in reality it hadn't seen it before. That's the entire gist of Bloom filters right there. Instead I could be storing Sarah, Simona, and Brian in the set, and I could get a 100% accuracy."
          },
          {
            "time": "[00:07:48]",
            "text": "But with this, even if I add 100 elements, I still need to take 10 items in the array, if I had a 100 elements, then I'm definitely gonna get false positives every single time, right? But I would still only take 10 items in the array, right? I wouldn't have to store 100 things."
          },
          {
            "time": "[00:08:09]",
            "text": "Okay. So, the more items you add to a Bloom filter, the more you increase the false positive rate that should be pretty obvious. You can mitigate this by having a larger array. You can also have more or less hashing functions depending on how much memory you're willing to fill up versus how many false positive you wanna be, right?"
          },
          {
            "time": "[00:08:31]",
            "text": "So let's say I added one more hashing function, and that returned 9 for Sarah, right? In that case, I wouldn't have gotten a false positive. So the more hashing functions you're willing to add as well means you're likely gonna get less false positives. Not totally true, because whenever you add things as well, yeah, so you kind of have to mess around with it to kind of really figure out what your false positives rate."
          },
          {
            "time": "[00:08:58]",
            "text": "You get really mathematical with the false positive rate, so yeah, definitely just check out the Wikipedia they explain it pretty well there."
          }
        ]
      },
      {
        "name": "49-bloom-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we're gonna come over here to our exercises, and we're gonna go to Bloom Filters. Okay, and let's take a look at this. So first of all I have three hashing functions here for you that I have already built for you. You don't have to do anything about them, you don't have to understand how they work."
          },
          {
            "time": "[00:00:23]",
            "text": "They use a library called xxhashjs, which is just a really fast hashing algorithm. They'll take a string and turn it into a number, and then I turned that number into a number between 0 and 199, right? So that you can use a bloom filter of size 100. So the first thing I'll say here for your bloom filter, in fact, this just kind of set this up for you so you can get rolling right away."
          },
          {
            "time": "[00:00:50]",
            "text": "Bloom filters solutions. So I would just put a constructor up here. And then I would just say like this._array = new Array(100).fill(0). So this will give you an array on this ._array that is just filled with 0s, right? And then you'll just be flipping those to 1 just like how I showed you."
          },
          {
            "time": "[00:01:24]",
            "text": "So all you need to do is do an add here and a contains here, and we'll go from there, cool. This is actually a fairly straight forward one, I think I only end up writing ten lines of code to get all this all done. So, yeah, cool. Let's build a bloom filter."
          },
          {
            "time": "[00:01:48]",
            "text": "So, the first thing we already built here was this array = new Array(100).fill(0). We have an array of 100 things filled with 0s, right? So, to do an add really all we're going to do is this._array. And then we're gonna put our three hashing functions here, string = 1, right?"
          },
          {
            "time": "[00:02:15]",
            "text": "And actually we're just gonna do that three times for all of our three hashing functions. That's it, that's all I gotta do to add something. So one big key thing that you know about Bloom filters, we can't delete anything, right? Because how do you know what to delete and what has previously used and what hasn't, right?"
          },
          {
            "time": "[00:02:38]",
            "text": "There's no additional information here. So that's another kind of downfall of Bloom filters is that they cannot delete from a Bloom filter, Okay? Then here with the contains, all you're gonna do is return and I'm gonna show you a little trick here. If you put a double exclamation point this is gonna coalesce it into a Boolean, right?"
          },
          {
            "time": "[00:03:03]",
            "text": "So this is gonna take whatever this comes back as a true or false. And I'll say this._array, each one string and then I want to do this like this h2. Sorry, this one right here is gonna be h2 and this one right here is gonna be h3, just like that."
          },
          {
            "time": "[00:03:40]",
            "text": "So, yeah, let's talk about this is a little bit clever, but let's just walk through it. Each one, so this is gonna be either a 0 or a 1, this is gonna be a 0 or a 1, and this is gonna be a 0 or a 1, right?"
          },
          {
            "time": "[00:03:57]",
            "text": "0s, if you do this, I'll just ignore that's not helpful. Make a little bit bigger down here. If you look here in the bottom, right, if I do, 0 == false, that's true, right, same with true == 1. So these things if you're willing to do, what's the word I'm looking for?"
          },
          {
            "time": "[00:04:29]",
            "text": "That's just escaping me, the term there, anyway. If you're willing to convert it from a number to a Boolean, then you can do it this way with a double equal sign. So if I put !!0 that actually comes back as false, right? And if I put !!1 that comes back as true."
          },
          {
            "time": "[00:04:56]",
            "text": "So if I do !!0(&&0 &&0), that's false, but if any one of these is true, this comes back as or actually, Right? So only if they all come back as 1 is it true. So now, we should be able to run our test here. Let's reset my Zoom here play."
          },
          {
            "time": "[00:05:35]",
            "text": "And if you go look at Bloom filters we got to not skip this, And click Play. And did that work? No. How these are all skipped, let's do this. Okay, one more time, let's try it, Bloom filters, there we go. And let's click on that, you can see that it's returning false and empty, handles one item, handles many items, all that works super well."
          },
          {
            "time": "[00:06:26]",
            "text": "Okay, so you could have done this in a much less clever way and just said like if this._array h1 === 1 and the h2 and h3, all that kind of stuff. And that would have probably been more clear, but this seemed kind of terse and nice so I went well with that."
          },
          {
            "time": "[00:06:48]",
            "text": "That's it, that's all Bloom filters. Anyone have any questions about Bloom filters?"
          },
          {
            "time": "[00:06:48]",
            "text": ">> Yeah, I got a question about implementation. Because it's JavaScript, right? Like no matter what our hash function is gonna return, it's still gonna put it there. The fact that we create an array of size 100 doesn't matter, right, like, technically."
          },
          {
            "time": "[00:07:11]",
            "text": "If it doesn't return the number if it's gonna return the string, Is just gonna go there and create a property."
          },
          {
            "time": "[00:07:11]",
            "text": ">> Yeah, that's true. Okay."
          },
          {
            "time": "[00:07:11]",
            "text": ">> I think, I mean, not good programming, but let's just triple check, make sure that correct. If I say x = empty array, and I say x(100) = 1, and then I asked for x(100) gives me 1 back, yeah?"
          },
          {
            "time": "[00:07:40]",
            "text": "So, you're absolutely correct."
          },
          {
            "time": "[00:07:40]",
            "text": ">> Okay, good."
          },
          {
            "time": "[00:07:40]",
            "text": ">> So, but here we created a number, an array of 100. So I guess what you're saying is, JavaScript will dynamically allocate that for you no matter what. So you could have just said new Array and you can treat undefined as 0."
          },
          {
            "time": "[00:08:04]",
            "text": "Yeah, that would work with JavaScript. I don't know if I suggested it, do I suggest it? I don't know if it matters, honestly, I don't know. [LAUGH] It's good to have defined boundaries to your problem."
          },
          {
            "time": "[00:08:04]",
            "text": ">> Yeah, just my problem is like, it's kind of an illusion if our hash function is not just numeric, right, it's still gonna work."
          },
          {
            "time": "[00:08:25]",
            "text": "Like we're not gonna know,"
          },
          {
            "time": "[00:08:25]",
            "text": ">> Yep. Yeah, yeah. And the only reason that does work is cuz we have these modules right here for our hashing functions that guarantees that it stays between 0 and 99."
          }
        ]
      },
      {
        "name": "50-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Congratulations. This is one very long very difficult definitely not one to take lightly course. There's just a just dump truck full of knowledge here. And if you feel you just got hit in the face with a book, that's probably because it's pretty close to that right? So what I'm trying to say is don't expect all of this to sink in."
          },
          {
            "time": "[00:00:24]",
            "text": "Some of these concepts you'll probably never ever think about ever again. And some of them you might find yourself thinking about frequently. One of the most important things though, here is that you've been exposed to these things, right? So now that if you come, to a time much later where you need something that a bloom filter could solve, you might not be able to remember exactly what a bloom filter is implemented like or how to make it work, all that kind of stuff."
          },
          {
            "time": "[00:00:47]",
            "text": "But you now you know that there's a data structure out there is, that you can, contain a lot of information in one very small memory footprints right? And that kind of pattern matching ability is actually really what I want you to have to know that these things are out there, that you know where to find them, you know how to Google them, those kind of things."
          },
          {
            "time": "[00:01:11]",
            "text": "And more than anything I really hope that you took away the science of trading off, right? The idea of do I have enough CPU? Do I have enough memory? Is this code more readable? Is this code less readable? Do I always wanna use as less memory as possible?"
          },
          {
            "time": "[00:01:24]",
            "text": "Do I always wanna have the fastest algorithm? These are all the kinds of things that I continue to want, you just need to be thinking about and hopefully the message that you walk away with is write readable code first, then worry about performance later. That's the mantra that I choose to live by when I'm writing code."
          },
          {
            "time": "[00:01:44]",
            "text": "Yeah, spend time trying to solve problems. Don't try and spend time anticipating problems that you may never have. That's in general, generally you wanna have problems before you solve them because typically you will not solve the correct problems. And only when you need really raw performance should you really be dropping down into these really low level constructs."
          },
          {
            "time": "[00:02:07]",
            "text": "But instead, it's just good for you to know one how things work. And then if you ever did need to drop down into these low level constructs that you know where they are and how to find them. So thanks for sticking with me. Hope everyone here enjoyed the course."
          },
          {
            "time": "[00:02:23]",
            "text": "And yeah, I'll take any last questions we have before we wanna sign off."
          },
          {
            "time": "[00:02:23]",
            "text": ">> Like you said all about balance all that stuff. That's not what's happening for me. I'd like, I just got invited for Amazon interview out of the blue."
          },
          {
            "time": "[00:02:23]",
            "text": ">> Congrats."
          },
          {
            "time": "[00:02:23]",
            "text": ">> Found myself in a predicament, essentially I build some stuff, I build websites."
          },
          {
            "time": "[00:02:41]",
            "text": "But in big companies, tech interviews are focused on computer science more than what you build. And I've been grinding for ten hours a day solving lead problems. I guess the question is what impresses you on the interview?"
          },
          {
            "time": "[00:02:41]",
            "text": ">> First thing you kinda just have to know and embrace is you're not necessarily in control of your entire interview."
          },
          {
            "time": "[00:03:01]",
            "text": "For me, that kinda takes some pressure off, I don't know it. For me it just, that helps me realize that, I can work on the things that I'm gonna work on and realize that the other parts are just gonna happen, however they're gonna happen and I lack control in that situation."
          },
          {
            "time": "[00:03:17]",
            "text": "So that's the first thing. The second thing is that it's really gonna depend on who your interview is. Some of them are just looking for a checklist, all right, he found this problem. She did this, they did that right? And they're just going down their checklist. And so frequently you can kinda tell cuz they're fishing for specific answers."
          },
          {
            "time": "[00:03:36]",
            "text": "In that case, I just asked a lot of questions of the hem to try and figure out what they're looking for and me that helps a lot. And then for me, I don't know, there's some interviewers and I think that are more like me, which is just like, actually don't really care if you can, pathfinding maze, right?"
          },
          {
            "time": "[00:03:56]",
            "text": "We don't path fine mazes at Microsoft, right, what I do, I mean, I guess the Bing Maps team does but I shut down. [LAUGH] What I care way more about is that you communicate that you're telling me what you're thinking that you're collaborating, you're thinking out loud, you're asking good defining questions."
          },
          {
            "time": "[00:04:19]",
            "text": "All right, you're asked me to pathfinding, this maze. Can I go out of bounds? Are there extra walls? What color's the floor? I don't know, it's just really defining the problem space of that you're looking into. And that's the kind of person that I wanna work with that's gonna fully understand a problem and then devise the correct solution."
          },
          {
            "time": "[00:04:40]",
            "text": "So yeah, ask a lot of questions. Another like really good pro tip with interviewing with those big tech companies is if you're having a hard time solving part of it, just make a huge assumption about it and ask if it's okay, right. So if you're saying I need to navigate this in 3D space, can I just invent a black box function that gives me the correct coordinates to go to?"
          },
          {
            "time": "[00:05:02]",
            "text": "I don't know, I'm making stuff up now. But something like that, where you just say like, you cut off a huge portion of the problem. You make an assumption about it. It's like, Hey, can I have this function? A lot of times, they'll be like, Yeah, sure. I don't care."
          },
          {
            "time": "[00:05:13]",
            "text": "You can. You can assume that about your code, right? Then you don't have to solve problems for Ray you can kind of work and make them work against themselves. So"
          },
          {
            "time": "[00:05:13]",
            "text": ">> Okay, yeah, that makes sense. Just to try to simplify. Okay."
          },
          {
            "time": "[00:05:13]",
            "text": ">> Always ask what metrics are going for right?"
          },
          {
            "time": "[00:05:31]",
            "text": "Am I supposed to be going the fastest? Am I supposed to be the most clearest thing? His memory a concern like asking a bunch of questions like that, about what metrics they're most interested in. That's also impressive and useful to you. So that helps, too."
          },
          {
            "time": "[00:05:31]",
            "text": ">> So metrics, and you also mentioned, consider the cost of algorithms, right?"
          },
          {
            "time": "[00:05:51]",
            "text": ">> Yep."
          },
          {
            "time": "[00:05:51]",
            "text": ">> He said I think, Okay?"
          },
          {
            "time": "[00:05:51]",
            "text": ">> Yeah, a lot of times will ask you like, what's the big O of this? I mean, again, I don't talk about bingo too much when I'm working at Microsoft, so I don't really care if you can come up with bingo but lots and lots of companies do so you should really drill down into that read up more on and do some exercises on defining the big old problem."
          },
          {
            "time": "[00:06:15]",
            "text": ">> Okay, thank you."
          },
          {
            "time": "[00:06:15]",
            "text": ">> Other questions."
          },
          {
            "time": "[00:06:15]",
            "text": ">> I have one in the same vein is Victor's coming from someone who doesn't have a computer science background who went to a boot camp primarily for front end development. And you have a lot of experience with the larger companies that, I'm looking to try to interview for."
          },
          {
            "time": "[00:06:41]",
            "text": "Do you have any recommendations or any advice for any approaches towards problem practice, leak code and whatnot that you find is very helpful leading into interviews?"
          },
          {
            "time": "[00:06:41]",
            "text": ">> Okay, yeah. So when I'm solving a computer science the problem, what are my kind of my steps?"
          },
          {
            "time": "[00:06:41]",
            "text": ">> Yeah, exactly."
          },
          {
            "time": "[00:06:41]",
            "text": ">> I try and reasoned it out in English first, kind high level steps of, I'm gonna do this, I'm gonna do this, I'm gonna do this, then I'm gonna return this."
          },
          {
            "time": "[00:07:13]",
            "text": "And then at the very least, the whoever's interviewing knows that you understand the problem and knows that you understand the solution. And then at that point, you're just in the semantics of syntax, right? So I found some people have been really effective with like, cool. I'm gonna create three functions."
          },
          {
            "time": "[00:07:30]",
            "text": "I'm just gonna pseudocode this does this, this does this, and this does this. So even if you run out of time, it's like okay, I was interviewing Shawn and he got through the first two functions. I didn't finish the third one, but he obviously got with a third function was supposed to do."
          },
          {
            "time": "[00:07:45]",
            "text": "That's I mean, it's not gonna work for everybody, right? It depends on what kind of jerk you're interviewing with, right? A lot of them will just say, cool, that's good enough. Obviously he knows what he's talking about. Some of them will be like I don't wanna name and shame the companies too much, but one of them in particular is just me like no, you had to read every semi colon or I'm not gonna count it."
          },
          {
            "time": "[00:08:09]",
            "text": "But your best shot for sure is making sure that the full solution Is down however you choose to do that. My personal style is just to write the function signatures, the return types and the kind of high level comment of this is what this is gonna do. And then I go back and fill it in and that works well for me to both one, explain what my intentions are, and for me to organize my thoughts."
          },
          {
            "time": "[00:08:35]",
            "text": "Well, thank you friends, please, do and redo these exercises. Cuz again, they are difficult. And the more you do them, the more they're gonna sink in. So yeah, thanks for spending some time with me learning some computer science. If you'd like to let me know on Twitter, star, the repo on GitHub, that's always fun too."
          },
          {
            "time": "[00:08:58]",
            "text": "And be sure to share this with other people as well. Hopefully it can be helpful for them as well. All right. Thanks, everybody. Talk to you later. Thank you very much. Thank you. Yep. [APPLAUSE]"
          }
        ]
      }
    ]
  },
  {
    "name": "intermediate-typescript",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to intermediate TypeScript, I'm Mike North, I'm a Senior Staff Engineer at LinkedIn, and I work in the developer productivity and happiness org. My job is predominantly helping make our COI and our UI ergonomics around developer infrastructure great. And TypeScript is a huge part of that, and that's why I'm a great person to speak to you about TypeScript today."
          },
          {
            "time": "[00:00:26]",
            "text": "Among the top goals that I have for this course is, number one, I wanna make sure that I package and pass onto you all of the key learnings that I have gained through many hours of helping guide and tutor others around TypeScript. So you're going to see a lot of little pieces of code throughout this course, that you can copy and paste right into your own app, and they can solve some of the common problems that I get a lot of questions about."
          },
          {
            "time": "[00:00:58]",
            "text": "By the end of this course, I also want you to be able to understand complicated type information. And I'm gonna show you a sample of where we're going to be, by the time this course wraps up. This may look scary right now, but take my word for it, we'll know how to break this down and how to troubleshoot it, and how to understand it, by the time we get through intermediate TypeScript."
          },
          {
            "time": "[00:01:23]",
            "text": "What should you already know by the time you start to take this course? Well, first, you should have a lot of experience working with regular JavaScript. We're going to be making extensive use of classes, functions, a sync await, promises, so you should be very comfortable working with those concepts."
          },
          {
            "time": "[00:01:42]",
            "text": "You also should have equivalent knowledge to what we cover in the TypeScript fundamentals of V3 course. In particular, you should be comfortable working with basic types for functions, objects, arrays, and tuples. And you should have crossed the threshold where you understand how generics work, at least with one or two type parameters."
          },
          {
            "time": "[00:02:07]",
            "text": "And this is something we cover in TypeScript fundamentals V3. Finally, make sure you brush up on index signatures, that's going to be a very important part of some of the more advanced topics that we're going to cover today. It's also worth stating that practical experience will aid you in terms of connecting the concepts were talking about today, to real-world situations."
          },
          {
            "time": "[00:02:30]",
            "text": "So it's helpful if you've worked in a code base that consumes type information for common libraries like react. We've spent a lot of time making this workshop as easy to use as possible. So, all you're going to need, is this website that we're working on today and the official TypeScript website."
          },
          {
            "time": "[00:02:54]",
            "text": "We've brought a lot of the features of VS Code right into your browser, so we'll be able to clearly see examples that highlight what's going on. And we'll be able to write our own code, and even write some code to pass some tests. As of the time we're recording this course, I have made four types of courses for Frontend Masters, and the way I think about them is as follows."
          },
          {
            "time": "[00:03:20]",
            "text": "TypeScript fundamentals and intermediate TypeScript are core courses, and most of our time together is gonna be spent in a lab environment. The idea here is that it's easy to teach these concepts in small controlled examples. And once we turn the light bulbs on, once we understand how things work, that makes it easier to take that knowledge and apply it in a more practical situation, and that's where these electives come into play."
          },
          {
            "time": "[00:03:47]",
            "text": "Production grade TypeScript and JS TS Monorepos, in those courses, we build an app together step by step. And that's where you can look for the applied techniques and the real world design patterns. We assume, in those courses, that you have already substantial experience working with TypeScript. And this is where you can learn to build things for production and at scale."
          }
        ]
      },
      {
        "name": "1-declaration-merging",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first topic we're going to discuss today is declaration merging. And this is the phenomenon by which types, and values can piggyback on top of each other. And they can be treated as a single named entity in your source code. By the end of this chapter, you'll be able to look at tooltips in Visual Studio code, which is the same tooltips that we see on this website."
          },
          {
            "time": "[00:00:24]",
            "text": "And you'll be able to make sense of exactly what's going on. Am I working with the type? Am I working with the value? How can I tell the difference? In this example, we have two what I'm going to call identifiers. And what I mean by an identifier is just a named thing that's defined in a single place."
          },
          {
            "time": "[00:00:45]",
            "text": "So we have one identifier called Fruit, which is a type. We know that, because it's an interface. And here is an identifier called banana, which is a value. TypeScript allows us to stack multiple things onto a single identifier. In this situation, we can see that we've named our interface, and our const variable the same thing, right?"
          },
          {
            "time": "[00:01:08]",
            "text": "They both fruit both with the capital letter. And we can see when we look at the tooltip for the interface, it's clearly just an interface. When we look at our variable, clearly it's just a concept declaration. But look at what happens when we attempt to export this as if we were exposing it outside of this TypeScript module."
          },
          {
            "time": "[00:01:28]",
            "text": "We can see this tooltip contains both, there's our const declaration, and there's our interface. These are actually two things stacking on top of the same word, Fruit. There's actually a third thing that we can stack onto this tooltip, so to speak unto this word, and that is a namespace."
          },
          {
            "time": "[00:01:51]",
            "text": "So in this example, we can create a class called Fruit with a static function on it. Now, we can create a namespace. And you can think of this as serving a very similar purpose as static class functions. And then finally we have a type called Fruit. So, if we hover over this export, and look at the tooltip, now we have three things class, interface, and namespace."
          },
          {
            "time": "[00:02:18]",
            "text": "So this is three things in one. Now you may be wondering when I'm importing stuff from other dependencies, how do I know what I'm working with? Well, I'm going to give you some investigative tools that you can use. To probe around, and to figure out what exactly is on one of these identifiers, right?"
          },
          {
            "time": "[00:02:42]",
            "text": "If I'm given Fruit, how can I test whether it's a class, sorry, how can I test whether it's a value, or a type, or both, or maybe neither? So, here are our tools. First, let's begin by creating a value, a type, and a namespace. And we've given them obvious names, so that when I put them up the screen here, you can remember what's going on, right?"
          },
          {
            "time": "[00:03:10]",
            "text": "So we've clearly got a value here. We've clearly got a type, which is just an empty interface. And then here we have a namespace. So you know something is a value if in a let or const declaration like this, you can put it on the right-hand side of the equal sign, and you get no error."
          },
          {
            "time": "[00:03:33]",
            "text": "If we try to do the same thing with the type, like we're doing down here, you can see that the compiler is not happy with us. And it's telling us is a type only refers to a type, but we're trying to use it as a value. So this alerts us to the fact that this is purely a type, there is no value part to this identifier."
          },
          {
            "time": "[00:03:58]",
            "text": "Let's look at a similar test but four types. So if we try to put this on the left-hand side of this assignment operator, and we get no error. That's an indication that this identifier can be treated as a type. And look what happens down here, if we try to do the same thing with a value, we get an error message."
          },
          {
            "time": "[00:04:20]",
            "text": "The thing we're using, it refers to a value, but we're trying to use it as a type here. So that failure tells us there's no type piece to whatever is on this thing, which is purely a value. Now, there's no equivalent test for namespaces, although the tooltips make it fairly obvious what's going on."
          },
          {
            "time": "[00:04:45]",
            "text": "So you see the word namespace on the left of the tooltip, that is a clear indicator. So you'd have to hover over it in order to figure out what exactly is happening there. While we're talking about namespace, some of you may be wondering, what's the point of these things?"
          },
          {
            "time": "[00:05:01]",
            "text": "And maybe you haven't seen them before, and you're wondering why they're even part of TypeScript? Well, an important aspect of TypeScript is it needs to be able to describe existing JavaScript libraries. Just think about when TypeScript was first made, and when they were trying to gain adoption. They needed to be able to say, here's type information that matches this existing library, which is written in regular JavaScript."
          },
          {
            "time": "[00:05:31]",
            "text": "So they needed to be able to type things like jQuery. And if we go to the jQuery homepage here, we can see some example usage right on the front page. So if we look down we can see, all right? Sometimes we're invoking this dollar sign thing as a function."
          },
          {
            "time": "[00:05:48]",
            "text": "And then down here, it appears that we're grabbing things off of the dollar sign, and they themselves are functions. So let's copy that code over, right? So this is basically the same code, it represents the same code. And we need to be able to describe types that can allow us to do these kinds of things."
          },
          {
            "time": "[00:06:13]",
            "text": "Here's how we might accomplish that. You can see here we're defining a function whose name is dollar sign. And we pass a selector in this could be up here, like h1 tags with a class title. And we're going to get all matching elements in a node list, as return value."
          },
          {
            "time": "[00:06:33]",
            "text": "In addition to that, to support this use case here, with .ajax, we need dollar sign to be a namespace that kind of stacks on top of that function of the same name. And that's what's allowing us up here to invoke this directly. And to use some of these functions that are sort of dangling off of the main function here."
          },
          {
            "time": "[00:06:58]",
            "text": "That's where namespaces are useful. Now, writing a library in this way. It's sort of leftover from the old way of consuming JavaScript dependencies, where you'd add a script tag to your app. And you would find that when all of your scripts have loaded, there's this global variable that has been tacked on to window or something, dollar sign, right?"
          },
          {
            "time": "[00:07:26]",
            "text": "And you could grab that, and basically access all of the capabilities of a library through that global variable. We don't really write things that way in modern JavaScript code bases. Now that we have modules, and better ability to consume third party code in that way. But we still need to be able to describe types for some of that old stuff that's lying around."
          },
          {
            "time": "[00:07:49]",
            "text": "So my advice is don't use namespaces too much. Don't focus on them too much. Cuz they're really about backwards compatibility, and not something that you often find is added to modern code bases. So now that we have a basic understanding of declaration merging, and how we can sort of sandwich or stack multiple things on a single named identifier."
          },
          {
            "time": "[00:08:19]",
            "text": "I want us to take a look back at the way classes work. So let's say that we have a class, like what you see on the screen now. It has three fields, each of which is optional, name, mass, and color. And then, it has a static functions. So, you could think of this, as a kind of a backup constructor of some sort."
          },
          {
            "time": "[00:08:42]",
            "text": "Sometimes you find that that's a good way to use static functions, a good use case for them rather. So if this is our class, let's apply the tests that we just discussed, and identify whether this is a value, or whether this is a type. So first we can test for value."
          },
          {
            "time": "[00:09:02]",
            "text": "And our test is to put it on the right-hand side of the assignment operator, and see if we get an error, and we don't. That means Fruit is a value. And when we take a look at this value. We can see that there's this createbanana thing, but note that we do not see color in this list."
          },
          {
            "time": "[00:09:21]",
            "text": "The reason is the value here is the class itself, not an instance of Fruit, it's the the factory or the constructor, right? We're seeing createbanana. We're seeing call, which indicates that this is kind of a function like classes or functions. So we would call this the static side of the class."
          },
          {
            "time": "[00:09:46]",
            "text": "Now, if we take that exact same identifier, and we test whether it's a type, the test is positive. The Fruit identifier is also a type. And when we look at the available completions here for the letter c, we can see that color is the only thing that's showing up."
          },
          {
            "time": "[00:10:07]",
            "text": "That's because when used as a type, this class is an interface that describes an instance of the class. So if you've been using classes, all along, now you know that they are a value, and a type of the same name stacked on top of each other. And depending on the context in which you use it, whether it's in the value position over here, or the type position over here."
          },
          {
            "time": "[00:10:35]",
            "text": "You're using one piece of it, or the other. So you've been making use of declaration merging, all along."
          }
        ]
      },
      {
        "name": "2-modules-cjs-setup",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Next let's talk about modules and interrupt between a modern TypeScript code base and common JS libraries. Node still uses common JS as its defaults module format although modernization efforts are underway, it'll be a long time before we can forget about this older way of writing JavaScript code."
          },
          {
            "time": "[00:00:24]",
            "text": "This is one of the trickiest aspects of getting dependencies to work nicely with your own code. And I have helped seasoned experts overcome the stumbling blocks I'm about to show you. So this is a lot of tips and tricks. They're valuable even for you experienced TypeScript practitioners. The reason we even need to talk about this is because until 2015, there was no standardized module format for JavaScript projects."
          },
          {
            "time": "[00:00:54]",
            "text": "As a result, several community based solutions emerged. We have CommonJS which was popular in the node community, AMD and UMD and these were more popular for browser based apps. Because of all the bundling technology we use for browser based apps, these two types of modules AMD and UMD have sort of gone away, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "Very few people write code like that, although sometimes we have these as a compiled target we don't really see that code. Common JS has stuck around and it's largely as I said, because of node, right. Node still consumes common JS libraries. And the core libraries of node are written in this format, so we need to know how to consume them."
          },
          {
            "time": "[00:01:47]",
            "text": "It's important to understand that I'm assuming and I encourage you to only write ES modules these days. You should be writing your own new code, using the new standard. Because that's a good way for you to be forward compatible, right? That your code will have a longer shelf life."
          },
          {
            "time": "[00:02:09]",
            "text": "First, everything you're used to seeing around model imports and exports in the Java script world, also works for TypeScript. So here are a bunch of examples. We can go through them very quickly. But they all work in TypeScript and JavaScript alike. So we've got multiple named imports. We have a default import, a named export a default export, these are re-exports, right?"
          },
          {
            "time": "[00:02:37]",
            "text": "We're sort of passing lemon and lime which originate in citrus, into our module and then export them out as if they're our named exports. All of this works in TypeScript. Although it is not super common in JavaScript projects, you're going to see things like this a lot in the TypeScript world, because often this is the solution to common JS entrop."
          },
          {
            "time": "[00:03:06]",
            "text": "So we see up here you have this module called berries. We're getting strawberry and raspberry from it. This would let you get a name space with all of the different berries hanging off of it. There's even a capability to alias a name space re-export, which is something TypeScript does today, and something JavaScript has just added to their draft specification for the language for the year 2021."
          },
          {
            "time": "[00:03:33]",
            "text": "So soon you will start to see this as a feature that you can use broadly across JavaScript. Great so that's stuff that works in JavaScript, also works in TypeScript let's talk about the more interesting thing. What are the special import concerns, you need to know about, as you take on authoring a library or an app in TypeScript?"
          },
          {
            "time": "[00:03:57]",
            "text": "Well first, if you're writing code that looks like this, or if If you're looking to write typed code that does the same thing as this, often you can just use this namespace import, right. So when we say I'm gonna grab this namespace fs from this module, if you've ever used this fs module which is one of nodes core modules, it's just a collection of functions hanging off of this fs thing."
          },
          {
            "time": "[00:04:23]",
            "text": "There's like read file sync, right file sync, read JSON, write JSON and the fs is just sort of a way to hold them all together. And we can import it just like this. Or you could import using a named imports like specific things from fs. Almost all common JS interrupt can be handled in this way."
          },
          {
            "time": "[00:04:48]",
            "text": "But there's one case that will really throw you for a loop if you encounter it and that's the case where whatever the module is exporting as its single export, it is not something that looks like a namespace. So let's look at this case here, where we have a function and effectively in our common JS code, we would see something like this, right?"
          },
          {
            "time": "[00:05:15]",
            "text": "module.exports equal In this whole function. Now we can't represent a function as a namespace, and by the way this is the equivalent code in TypeScript to accomplish this here. So if we try to consume it in this way, we're going to get an error message. And this says that if we wish to use ACMA script, imports and exports with this module, we have to turn a compiler flag on called esModuleInterop."
          },
          {
            "time": "[00:05:45]",
            "text": "And this error message is telling the truth. But what it's not telling us, is that there's an alternate solution to this problem and that is, for us to use an import that is not aligned with the ACMA script standard. And this will save us from having to turn this flag on."
          },
          {
            "time": "[00:06:04]",
            "text": "Why would I want to leave this flag off? Well, this is what I call a viral option. So viral options like es module and allowsSyntheticDefaultImports, if those are necessary, if you have to turn those on in order to make your types work, everyone who consumes your types will also have to turn them on."
          },
          {
            "time": "[00:06:28]",
            "text": "So particularly when I'm writing library code, I jumped through some serious hoops to make sure that I leave these off. And that means that if you're using one of my libraries, it's your decision whether you want to enable these or not. I don't want to force that decision on everyone who uses my code."
          },
          {
            "time": "[00:06:48]",
            "text": "So I call these viral options because when one library enables them, anyone who consumes it also has to turn it on. Thankfully, we have another solution to this problem, right. And that's the non ECMO script import. Here is how it works. So we still have this code here remains the same as when we last saw it."
          },
          {
            "time": "[00:07:10]",
            "text": "But here is the key thing, the key idea. This looks kind of like a common JS Import. But one words different, right? We're used to saying seeing const createbanana = require(\" /fruits'), but we see import instead of const. This is what makes it kind of a unique thing, right?"
          },
          {
            "time": "[00:07:32]",
            "text": "It's the imports used to be this way in very old versions of TypeScript, and you can still use them. And you can see the type information still comes along for the ride here. So given that in this situation we have to choose between a bunch of non ideal possibilities either forcing consumers of our code to turn some compiler option on, or doing this, I would sooner do this because I like the idea as a library author, I think it's part of my job to like absorb some of that pain for downstream consumers of my code."
          },
          {
            "time": "[00:08:09]",
            "text": "So I will almost always do something like this compared to forcing people to change their compiler settings. If we look at what this code compiles out to, thankfully, it's exactly what we would want. We can see module.exports = createbanana. And if we look up, that's what we were trying to accomplish here."
          },
          {
            "time": "[00:08:36]",
            "text": "And here, we can see that this is required, just the way we would hope to see common Jas code, if we have written it in regular JavaScript, right. It's just consuming the entire module as a single thing, invoking it directly because it's a function, we're good to go."
          },
          {
            "time": "[00:08:58]",
            "text": "Just on the topic of making sure your types don't require special compiler options, a quick reminder that VS code will download type information in the background as it sees users consuming a library. And there's a possibility that even if they're not depending on your library's types like directly, they'll start to see some autocomplete information in their authoring environment."
          },
          {
            "time": "[00:09:26]",
            "text": "So it's important especially if you're doing open source work, it's important to be good citizen. Make sure that if you publish types, those types of work. And make sure that you don't spread those viral options, and put that burden on your consumers cuz it may be a very tricky thing for them to straighten out, if they start to see red squiggles under their code cuz TypeScript is unhappy."
          },
          {
            "time": "[00:09:52]",
            "text": "Finally, I wanna talk about importing things that are not JavaScript modules. So if anyone in the class uses web pack or parcel or snow pack, anything like that, the way these bundlers work, is your JavaScript modules occasionally will point to non JavaScript things, that need to sort of be packaged in the same layer of assets as their respective JavaScript modules."
          },
          {
            "time": "[00:10:22]",
            "text": "So here let's imagine we have a react component that needs an image file, well, you could import an image like this. Here's a link to the Webpack documentation where I copied this line from. Now TypeScript is not happy with this by default. It's saying, I can't find a module named file.png, and that's because there is no TypeScript module called file.png, not in this environment."
          },
          {
            "time": "[00:10:50]",
            "text": "So we need some way to tell TypeScript that whenever we import a png file, it should be regarded as a JavaScript module with a default export, that is of type string. This can be accomplished if you create a file called global.d.ts, and you're gonna wanna create something called a module declaration."
          },
          {
            "time": "[00:11:13]",
            "text": "So in plain language, this could be taken to mean, I hereby state that a module exists and the name of that module is some arbitrary text followed by .png. And the default export of this module is going to be a value whose type is string. As a result of having this little piece of type information, elsewhere in your project, you're gonna see that this exact same line that was failing before, it's now not only error free, but we can see that the value of this IMG thing, it is of type string, which is great, that's ripe that's ready to put into an image tag source equals this, right?"
          }
        ]
      },
      {
        "name": "3-type-queries",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Type queries allow us to obtain a type from a value. And there are two new keywords I want to introduce, which fit into the category of type queries. Those are keyof and typeof. So first, we're going to look at keyof. keyof allows us to obtain all of the keys of an interface or object type of some sort."
          },
          {
            "time": "[00:00:30]",
            "text": "So here, note that we're looking at a type alias, right? And if we hover over Date here, you see obviously the word interface Date. That's an indication that we're working with this as a type. And we're using this keyof operator, and then we're getting something here, it says DatePropertyNames."
          },
          {
            "time": "[00:00:50]",
            "text": "We can't really see much more about this. Now, in JavaScript, we can have property keys that are strings or numbers or rarely symbols is a separate type symbol. So not all keys are strings. But if we wanted to take this thing that we have here and say, I wanna see the keys that are only strings, only those keys that are also a string, we could use the intersection type operator."
          },
          {
            "time": "[00:01:22]",
            "text": "Remember, if we think about the Venn diagram, the intersection type operator will help us to select only those things that are in the overlap portion of the Venn diagram, right? We're saying you must be a key of date and you also must be a string. And if you meet condition one and condition two, then you're part of this new type."
          },
          {
            "time": "[00:01:46]",
            "text": "If you think about geometry, and I'm sort of revealing my educational background here. I'm a mechanical engineer by education. I think of this kind of like a dot product in that, if you remember that you can kind of define vectors as some portion in the x direction and some portion in the y direction."
          },
          {
            "time": "[00:02:05]",
            "text": "You're kind of getting the part of a type that aligns with some other type, kind of like a dot product. That's useful enough to me that I want all of the other sort of visual learners to think of it that way. So it's the sub-part of keyof Date that is also included with string."
          },
          {
            "time": "[00:02:30]",
            "text": "So here we've got the same line that we had above. In our second line, we're saying intersect this with string, and look what we get. We get all of the property names of date that are also string. We've got toDateString, toLocaleTimeString, getFullYear, 33 more, right? It's even truncating this tooltip."
          },
          {
            "time": "[00:02:56]",
            "text": "There's a lot going on here. So remember, we're still working with types, but what we've created here is a union type, right? This is the or concept of all of the different property names, which could include methods or fields that we could find on date. We've obtained type information here."
          },
          {
            "time": "[00:03:17]",
            "text": "So if we wanted to get the other things that are left over, apparently there's this Symbol.toPrimitive thing. And you can read more about that here, but that's why this didn't show us a list of strings. There's actually one symbol in there and it's for converting a date to either a number or a string."
          },
          {
            "time": "[00:03:38]",
            "text": "And there's a footnote if you wanna play with that, if you're curious and wanna pull that thread. So that's keyof. It's gonna be really important later in the course, keyof. typeof, so this is a much more direct type query in that we're literally saying, I have a value and I wish to get the type that describes this value."
          },
          {
            "time": "[00:04:03]",
            "text": "So here's a little bit of sample code. I've made sort of a non-trivial value here just to sort of make things interesting. We have a fetch which returns a promise that resolves to a response, right? Look at that return type, they're promise, and then generic over response. And then here, we've created a second promise that resolves to a string."
          },
          {
            "time": "[00:04:28]",
            "text": "Promise.all, it takes an array of things. Any of those that are promise-ish, it'll wait for those. So if we await this, look at that tooltip, it's a tuple containing a response and a string. But let's pretend that this was much more complicated. We don't have a nice type that describes this."
          },
          {
            "time": "[00:04:49]",
            "text": "So if we wanted to obtain that type, all we'd need to do is grab this, right? This is our value. See the word const in the tooltip? We're using this typeof operator, or this keyword rather. And then we can create a type alias that describes what this thing is."
          },
          {
            "time": "[00:05:10]",
            "text": "You may be wondering like, where might I use this? Well, what if you're consuming a library that exposes some things to you, some values? But they don't give you the type information for these things directly as an interface or as a type alias that you could independently import and export."
          },
          {
            "time": "[00:05:31]",
            "text": "But if you wanted to make a function that takes the return value of something else or a function. What if this were a webpack config, a really complicated, big, big object with lots of stuff on it? If you wanted to make a function that takes a webpack config as an argument, this would be a way where you could say, hey, look, I have this thing."
          },
          {
            "time": "[00:05:50]",
            "text": "Maybe it came out of a function as a return value. And now I can have a type for it, and I can use that type for something else. It's great for sort of threading concepts through and making sure you're still referring to the original source of truth. I don't have a tuple written in this piece of code at all."
          },
          {
            "time": "[00:06:07]",
            "text": "I mean, unless you would argue that this is a tuple, but certainly not a tuple type. This is a value, right? It's the thing passed into Promise.all. But I am very much referring to the type information for resolve, for fetch, for Promise.all. That's all baked in to this Response, string."
          },
          {
            "time": "[00:06:29]",
            "text": "So if these were to ever change, if I upgrade my typescript version, for example, everything will flow through very nicely. I'm still just pointing to one single source of truth. I'm just sort of giving it a name so I can hold on to it with this type query."
          },
          {
            "time": "[00:06:44]",
            "text": "So typeof is also useful for obtaining the static side of a class. By static side, we mean like the factory, right? It's the ability to create new fruit in this case and any static methods that are on this class. So if we look at the tooltips below here, we haven't written the word typeof, but we can see it appearing to us."
          },
          {
            "time": "[00:07:11]",
            "text": "If we store as a variable a copy of this Fruit class, not an instance, we can see the type of this variable is typeof Fruit. And then if we create an instance, we can see that the type is just Fruit. So if you wanted to see the static stuff available on a class and you wanted a type for that, remember, if we just use Fruit in the value position as we are here, we're referring to the constructor, right, the class, not an instance."
          },
          {
            "time": "[00:07:48]",
            "text": "And then if we look at what its type is, now we have a way of getting access to it using this type query."
          }
        ]
      },
      {
        "name": "4-conditional-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types are kind of a ternary operator, but for type information. In fact, they use exactly the same syntax. And in this chapter, we're gonna look into these things. And we're gonna work up our way to what's coming next in the chapter after this, where we will see that there are some utility types that become possible once we introduce this concept of conditional types."
          },
          {
            "time": "[00:00:33]",
            "text": "Utility types are just, they're things that come with TypeScript for free, that are so broadly useful, that they're just included with TypeScript itself. It's kind of a little standard library. So first, let's talk about ternary operators as they pertain to values. You're used to seeing this in JavaScript already in all likelihood."
          },
          {
            "time": "[00:00:57]",
            "text": "So, it's just if, then, else logic and ternary, of course, just means having three parts. And we have our three parts here, right? So, if we have a value, we could say x is negative only if it is less than 0, right? So if it's greater than or equal to 0, it is non-negative, otherwise, it's negative."
          },
          {
            "time": "[00:01:25]",
            "text": "And there are three parts here. There's a condition to evaluate an expression to use if that condition evaluates to true. And then the expression to evaluate if that condition evaluates to false. All of this is gonna serve you well as we start talking about the equivalent in the types world."
          },
          {
            "time": "[00:01:46]",
            "text": "Let's look at the equivalent in the world of types. We have two appliances here that are used for cooking. We've got a grill and an oven. And they have no common shared method names. So we would say there's not very much overlap between these two things, between grill and oven."
          },
          {
            "time": "[00:02:04]",
            "text": "But that's what we're defining here. And then we can define a type that conditionally turns into either a grill or an oven. And we're gonna unpack this syntax piece by piece in just a moment. But for now, I just want you to observe the result. And the result is, remember, this is just a literal type."
          },
          {
            "time": "[00:02:28]",
            "text": "It's not a value. It's a specific string type, a string that only matches one particular thing. So if we say this is a cooking device of type grill, we get a grill out. If we say it's a cooking device of type oven, we get an oven out. And we also see the very familiar ternary operator at work here."
          },
          {
            "time": "[00:02:56]",
            "text": "And this is a condition. This is what to use if the condition evaluates to true and this if false. So if we strip everything back, we can see the pieces of interest, right? Those three parts. And it works exactly the same way. So we can kind of map it out in this way."
          },
          {
            "time": "[00:03:18]",
            "text": "If we've had a condition, expression if true, expression is false, they're just type expressions, they're not value expressions. And frankly, these two pieces here are not interesting, you could put whatever type you want there. This condition is kind of interesting. So, you can see that we're using the extends keyword here."
          },
          {
            "time": "[00:03:37]",
            "text": "And we've used it in a couple places. So if you took the fundamental course, we used extends to describe constraints for type parameters. A way of saying I take type T, and T must be at least this type. It at least must be an object that has an ID property on it, or it must be at least a string."
          },
          {
            "time": "[00:04:00]",
            "text": "Could be more than a string, but I want, I need to be able to assume that I can treat it as string and as a minimum requirement. Well, in this context, the word means the same thing. We're saying that, T must be at least this type. It's not an equality check."
          },
          {
            "time": "[00:04:23]",
            "text": "I think of it more like a greater than equals comparison. You are at least of this type. And this is the only tool we have as of today's version of TypeScript for expressing conditions. We can only use this extends word."
          }
        ]
      },
      {
        "name": "5-conditional-types-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, quick little exercise here, with our understanding of how extends works. I want us to look at this list of eight examples, and tell me whether you think this will evaluate to true or false. So, just take a moment and look at these eight things, and we'll reveal the answers in a moment."
          },
          {
            "time": "[00:00:26]",
            "text": ">> Don't peak down here, this is where the answers are. Don't cheat yourself out of the learning experience here. But just think through these eight situations and see if you can figure out what's true and what's not. We're gonna go over the answers to this eight question quiz."
          },
          {
            "time": "[00:00:46]",
            "text": "And in doing so, we're gonna learn a little bit more about how this extends keyword works. So, we're gonna open up our spoiler warning. And so, as everywhere else in this course, these little code snippets, they're coming like directly from TypeScript compiler output. So you know I'm not lying to you."
          },
          {
            "time": "[00:01:09]",
            "text": "This is compiler results we're seeing as answers. So first, 64 extends number, that is true. And the way I encourage you to think about this, if you watch the TS fundamentals course, we likened types to kinda set theory, where we could say this type here, it's like any number you want, as long as it's 64."
          },
          {
            "time": "[00:01:37]",
            "text": "And over here, it's any number you want. So, the extends keyword, it's kinds like asking a question, does everything on the left fit within the set on the right? So, is the set 64 allowed within the set of all numbers, it is true. And here, we can see that the reverse is not true, why?"
          },
          {
            "time": "[00:02:03]",
            "text": "This number set here, that's gonna include the number 63, which is not in the set that only includes 64. So, this is just way too general. It includes things that won't make this type happy. So, number does not extend 64. Applying that same technique, we're seeing if the set of all possible string arrays fits within the set of all possible values that could ever exist in JavaScript, seems true."
          },
          {
            "time": "[00:02:39]",
            "text": "Within everything we could create in JavaScript, of course, we can include all string arrays. In chat says, I thought the inverse. I know man, that's why we're going over this. Like, this is a common misconception and I had to wrestle with this exact same thing. So, the slow and steady approach here is, well, it took for me to learn this."
          },
          {
            "time": "[00:03:03]",
            "text": "So, that's why I'm passing it on to the class. So, yeah, the set of strings is included in the set of any possible allowed values. And the set of all string arrays is also included in the set of all possible arrays. This type on the right includes arrays of numbers, arrays of Boolean, arrays of promises, right, and arrays of strings."
          },
          {
            "time": "[00:03:27]",
            "text": "So, there we go. This one's interesting. I bet a lot of people got this wrong. I bet a lot of people got this wrong. Because when you take things out to the infinities, right, to the infinitesimally strict and the infinitesimally not strict, it's very confusing to think about this, and it's tempting to stop applying the mental model."
          },
          {
            "time": "[00:03:53]",
            "text": "I bet a lot of people got this one right up here, and if you got them reversed, that's fine, right? That just means you didn't understand which direction extends was operating in. But I suspect if you mirror your answers, you might have had inconsistent results between this and this."
          },
          {
            "time": "[00:04:14]",
            "text": "Well, let's apply our same logic here. Never, the set of all values that can make never happy, empty set. Does everything that is included in an empty set fit in the set of all possible JavaScript values? Yes, of course. If we had to write a for loop to verify this condition for answer number five, we would never even loop over anything, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "There's nothing to check. And we kind of default to true. It's like, do you have room in your house for everything that's inside this empty box? Sure, [LAUGH] then yeah, there's nothing in there. We have room, that's the way to think about this. Here, this is another kind of interesting edge case, does the set of everything include the set of everything?"
          },
          {
            "time": "[00:05:09]",
            "text": "Sure, kind of with the reflexive property, this would better be true. Getting a little bit more complicated here and thinking now in terms of the type for a class constructor like a factory versus an instance. So, we've got first, the instance case, right? That's the interface called date."
          },
          {
            "time": "[00:05:31]",
            "text": "Does this include the set of all things that can be used with the new keyword? That's what this type means. Are you a newable, sometimes people use this newable word, right? So, an instance of date is not newable but if we put this type of keyword in front of it, and we get the type of the factory for dates, it turns out that that is newable."
          },
          {
            "time": "[00:06:06]",
            "text": "Does anyone have any questions about these? So, raise your hand or type y in the chat if you've got at least one of these wrong, and now you kind of understand a little bit more about how extends works, after thinking through it again. So, Dimitri asked the question, the modern set theory has some limitations for case six."
          },
          {
            "time": "[00:06:28]",
            "text": "We don't understand why exactly, maybe I could learn a little bit more about that. What I do think is if we just say, does everything in box A fit inside something designed for B? And in this case, we're sort of moving everything over like by definition, like the set of all strings is included in the set of all strings, right?"
          },
          {
            "time": "[00:06:53]",
            "text": "So, Christoph, you make a good point. And if you're watching this course now, you were thinking that extends sort of operated in the reverse direction. You might have thought about it as like, does the thing on the left, is that the larger of the two sets, and then this is the smaller of the two sets?"
          },
          {
            "time": "[00:07:15]",
            "text": "It's actually the opposite. Remember, extends is about getting more and more specific. If you have a base class and you make a sub class, and then another sub class, you're adding more properties, right? If we started out with any, we have the set of all possible things that you could create in the JavaScript universe."
          },
          {
            "time": "[00:07:39]",
            "text": "And then, we'll start saying well, all right, let's make it more specific. Let's just talk about arrays. All right, let's talk about just arrays that only contain strings. Well, every time you make one of those statements and you're saying, let's make this more specific, let's define more type information, let's add more constraints, you're narrowing, and narrowing, and narrowing and you're making drilling down."
          },
          {
            "time": "[00:08:06]",
            "text": "And there are fewer and fewer things in your set. So when we say it's 64, it's almost like a weird way to say it, but the 64 have a base class of number. Kind of a base type of number like, if we widen it out, would we end up with a number?"
          },
          {
            "time": "[00:08:29]",
            "text": "Like if we made string array more general, would we arrive at all possible arrays, right? Well, making it more general, let's allow non-strings to be included. And then we could say, maybe it doesn't have to be a array, more general still. So, let's start zooming out. These are great questions, and this is one of the best things I can do with this the short time we have together, to help you get over these hurdles."
          },
          {
            "time": "[00:08:57]",
            "text": "Let's put this conditional type concept to work. And we're going to look at an example and build our way up to some of the standard utility types, that are included with the TypeScript programming language."
          }
        ]
      },
      {
        "name": "6-extract-exclude",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Extract and exclude, these utility types which are included as part of TypeScript, they're used to obtain some sub part of a type, either through specifying what you're looking for, or what you're not looking for. Extract is about defining what you're looking for and you get that piece."
          },
          {
            "time": "[00:00:24]",
            "text": "Exclude is about describing what you want to leave behind, and you kind of get everything else. So these, behind the scenes, just use a conditional type. So we'll be able to put this concept we just learned into action now. So let's say we have a type that looks like this."
          },
          {
            "time": "[00:00:44]",
            "text": "So we have favorite colors, and we have a bunch of colors that are listed, right? So think of this, if we were in CSS and we were using the color or background color property, you can write out the word red. Or you can define colors like hash, F00."
          },
          {
            "time": "[00:01:05]",
            "text": "Or you could say RGB parentheses 255. You could specify your decimal values for each of those eight bit color slots. So we're allowing all of that here. So we kind of have a mix, right? We have strings, we have a three part tuple. And then we have an object with properties red, green and blue."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we wanted to obtain only the subset of what's described by this type, that is also a string, we could use extract in this way. If we scroll to the right, you can see that we get just the strings. The tuple is not there, the object is not there."
          },
          {
            "time": "[00:01:52]",
            "text": "We could do the same thing by changing this second thing, the second type that we pass to extract. And now what we're saying is within favorite colors, give me whatever sub part of this type has a property called red, whose type is a number. We don't need to specify this whole thing here."
          },
          {
            "time": "[00:02:21]",
            "text": "Remember, it's not an exact match. This is a minimum requirement. So let's pop this example out into the playground, and let's say, what if we did this? Let's add an alpha channel, right? We could, well, this is not gonna be because it overlaps so much with the other type."
          },
          {
            "time": "[00:02:44]",
            "text": "Let's say I'm just gonna do this. I just don't want one to be strictly a superset of the other. I want them to have some overlap where we can see an interesting thing. So if we look at object colors, now look, we selected both of those, if you see in the tooltip."
          },
          {
            "time": "[00:03:02]",
            "text": "The object that has green and blue written as words versus their first letter. So it's almost like a query searching for things that might contain a substring of, here's a fragment, you'll find me the whole thing. You can think of it kind of that way, at least when we're using it in this context."
          },
          {
            "time": "[00:03:21]",
            "text": "This is where we're doing the searching. Make that a little bigger. This is where we're doing the searching. And then this is the clue, right? This is the fragment to use as the basis for the search. That would be a perfectly valid way to think about this. And of course, with tuple colors, I'm just gonna pop back here."
          },
          {
            "time": "[00:03:44]",
            "text": "We could search so the result we get, of course is number, number, number. Let's try some other things here. What if we just search for things like a tuple of length 1, we get a never, not found, right? That's what it is in this case. It's like I examined everything, and here's the set I found, developer, it's an empty set, sorry."
          },
          {
            "time": "[00:04:09]",
            "text": "But if we did this, what if it's a wider type, a more general type that still kind of matches what we're looking for. Hey, there we go. Yeah, an array of numbers that is exactly three slots. Sure, I mean, it is an array of numbers. It's a very special array of numbers, it's specific, but we can search for something that is more general."
          },
          {
            "time": "[00:04:38]",
            "text": "In the same way that up here, right, we're searching for any object that has a property red whose value is a number. And we were picking up more than one thing. So you search with something that's more general and the matches will be at that level of specificity, or even more specific, right?"
          },
          {
            "time": "[00:04:59]",
            "text": "We're searching for any number arrays. And if we had, let's say we allowed an alpha channel here, maybe this one might work in a more interesting way. So now we'll get both. We'll get the three place tuple and the four place tuple. Why? They're both different kinds of number arrays."
          },
          {
            "time": "[00:05:17]",
            "text": "So one of the key insights I wanna make sure you walk away with, how to think of this specific versus general. What's this extends keyword all about? And this is really important in terms of making sense of what we're looking at here. Yeah, so in plain language, what this type is all about, we're extracting the subset of favorite colors that is assignable to string."
          },
          {
            "time": "[00:05:43]",
            "text": "That's specifically this thing up here, right, where we're grabbing the subset that is assignable to a type Exclude is the opposite of extract. And it's useful if you can very easily define what you wish to leave behind. So it's the same exact example, I've just changed the word extract to exclude, and here we're saying, show me all."
          },
          {
            "time": "[00:06:16]",
            "text": "Show me everything that doesn't match string. Show me everything that doesn't match string. So we get our array of numbers and we get our object. Those are the non string parts of favorite colors. So, how does it work? Here are the definitions of these two types. This is pulled straight out of the TypeScript source code, and it's very, very similar to what we were working with before."
          },
          {
            "time": "[00:06:47]",
            "text": "So in plain language, here's what's happening. We have a type T, this is a type parameter, and it's what we're operating on. In this case up here, we used favorite colors, right? It's this mixed bag. It's the haystack in which we're searching for a needle. And then we have typed U, U describes what we're searching for."
          },
          {
            "time": "[00:07:12]",
            "text": "So you can think of this almost like we look at all the different parts of type T, especially if it is a union type with this whole operator here. We're gonna look at each piece of it and we're going to see which of those pieces extend from you."
          },
          {
            "time": "[00:07:34]",
            "text": "Which of them match U or are even more specific than U but still match the minimum requirement of U? If this turns out to be true in the exclude case, we leave it out. We leave out whatever matches, otherwise we let it pass through. And this is the only difference between the two."
          },
          {
            "time": "[00:07:58]",
            "text": "It's never colon T versus T colon never. It's just the inverse condition, right? So this is a good example of how you might use conditional types."
          }
        ]
      },
      {
        "name": "7-type-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> First, I'd like to address some questions that I see in chat. So Dimitri asks, would it be correct to say that if I say that generics used are used more often when we write libraries. So Dimitri asks, are generics more appropriate to use in libraries versus app code?"
          },
          {
            "time": "[00:00:25]",
            "text": "I don't really think that it hinges on whether your code is library or app related. For example, I know of many apps that have use of generics in their data layer where they might have some concept of record type. Maybe if they're hitting like a SQL database, they have a primary key that's always ID, and they want some predictable pathway for going to fetch some information using generics and app code."
          },
          {
            "time": "[00:00:58]",
            "text": "In that area it's quite common. I would say the more reusable, the more reusability is a concern, the more you're gonna want to Leverages generics for that purpose. Yeah, libraries tend to get reused quite often. But it's not limited to libraries for sure. Leslie asks, I feel like generics can easily see him so complex because everyone's using random non-expressive letters."
          },
          {
            "time": "[00:01:31]",
            "text": "To represent types, is that considered the standard? There is no standard, I would say it's the norm to use these capital letters starting with T, but that is a leftover remnant from the C++ days. Sort of started in C++ with template classes, and then made its way into generics and Java and C-sharp."
          },
          {
            "time": "[00:01:54]",
            "text": "And now it's sort of this pattern that everyone who's used this concept before in other languages, they're used to doing it that way. I do 100% agree with you though. That, we don't like single letter variable names for values. Why are we cool with single letter names for types?"
          },
          {
            "time": "[00:02:13]",
            "text": "That's a very fair point. The good news is there's nothing that stops you from giving these more meaningful names, although you're going to come across a lot of code that just sort of has these very abstract letters. That make it difficult to sort of read the code, and understand what the intent of the developer was."
          },
          {
            "time": "[00:02:32]",
            "text": "That's a totally fair point."
          },
          {
            "time": "[00:02:32]",
            "text": ">> We see here like we use this extractor type, special type from the library, is this equivalent to the end operator? We use the model at the beginning with the key off date we combined and to extract on it the case on it, is extract basically doing the same thing or is there a difference?"
          },
          {
            "time": "[00:02:55]",
            "text": ">> That is a very, good point. So, there, I'm not sure if there are a 100% the same, but it's true that. The, it's true that the intersection type operator, that end type does accomplish things that are also possible using this syntax, with this arrangement of things. Now, I think you might get some side effects."
          },
          {
            "time": "[00:03:31]",
            "text": "But like in some cases, I'm reluctant to say that it will always work. But that's a very, very good point you bring up. I think, logically it makes a lot of sense. You're trying to get, the portion of one type that also is assignable to another type it would seem that's what we're dealing with."
          },
          {
            "time": "[00:03:54]",
            "text": "I just don't want to unfirmed say, yes they're absolutely the same thing. But they seem like there could be. This obviously you can't do with the end and the or would not give it to you either. Does that make sense?"
          },
          {
            "time": "[00:03:54]",
            "text": ">> Yes."
          },
          {
            "time": "[00:03:54]",
            "text": ">> So this exclude is sort of like the end to end it's useful to have a generic that will do that for you."
          },
          {
            "time": "[00:04:20]",
            "text": "And by the way, you're also going to see that there are things in fact, we're about to talk about the infer keyword. There are things that make it beneficial to use type params and to use a generic for extraction of some subpart of a type from another type."
          },
          {
            "time": "[00:04:45]",
            "text": "So I think you'll see a rationale for why it makes sense to do this shortly."
          }
        ]
      },
      {
        "name": "8-inference-with-conditional-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types have a special tool called the infer keyword, which can be used to extract some sub part of one type from another type. And it's not a coincidence that in the same release of TypeScript where we got conditional types. We also got this infer keyword you might feel, especially once you get used to using infer, you might feel that conditional types are sort of a very weak feature of the language."
          },
          {
            "time": "[00:00:36]",
            "text": "Without this infer keyword, it's almost like this. This is a necessary part of the story and they go hand in hand with conditional types. This infer keyword can only be used within the condition expression of a conditional type it can be used anywhere else in any kind of type expression."
          },
          {
            "time": "[00:00:58]",
            "text": "So, what we're gonna do since it's kind of an abstract concept, we're going to walk through a situation where we find that. The thing infer does for us is conspicuously missing from the language won't go up to a problem that only this new language feature could solve. And that'll help us understand how it ties into the practicalities of what we're trying to build in our In our real world apps."
          },
          {
            "time": "[00:01:28]",
            "text": "So, let's say that we have a class that takes a really complicated options object. And we'll say that it's called WebpackCompiler. And this is actually a subset of the Webpack configuration object. You don't need to remember all this, the whole point of having types is you want autocompletes here, right?"
          },
          {
            "time": "[00:01:48]",
            "text": "Cuz it's very, very flexible, like you can do a lot of different things here. But let's imagine that in the source code that we're consuming, it looks just like this, where we do not have an interface or a type alias that defines this. We only have it explicitly specified as the type of the one argument passed to the constructor, and then let's say in our own code, we want something like this where we define a configuration."
          },
          {
            "time": "[00:02:22]",
            "text": "We attempt to compile and then if something goes wrong, we log an error message out. And the configuration is part of that error message. Maybe this code is run on a machine that we don't have direct access to. And it's important that we be able in logs to see that."
          },
          {
            "time": "[00:02:42]",
            "text": "Like if it's a GitHub action, for example, we want to be able to see in the logs like this was a failure here was the config. I can copy this and I could run it. So I simply mean to convince you that This is something you might actually do, right?"
          },
          {
            "time": "[00:02:57]",
            "text": "And unfortunately, we have a spelling error here. We've said watch instead of wutch, and we get no type checking help with this spelling error. Why? Well, let's look at the type of this configure object. It's not anything that looks connected to the Webpack config. It's just an object that has two properties on it."
          },
          {
            "time": "[00:03:21]",
            "text": "We're just getting straight up inference here, based on the value or we're setting CFG to and we're passing it In the WebpackCompiler and nothing's objecting there why almost everything on this options object is optional, and we have an entry. That'll work. And the other property will just be disregarded."
          },
          {
            "time": "[00:03:46]",
            "text": "So, we want TypeScript to be able to help us out here. But we can't do this right now. Like if there was something else to import, maybe we could import it, we could use a type annotation here, and then it would start to catch our error. But as I said before, in this case, like all we have is, there's this class that I'm using and has a constructor."
          },
          {
            "time": "[00:04:10]",
            "text": "And the first argument of the constructor wants this thing. So we want to basically pull this type out somehow get a handle on it locally in our app code or our library code, we want to be able to give it a name and refer to it and use it as the type for variables."
          },
          {
            "time": "[00:04:29]",
            "text": "As if we just obtained it as an interface. So this is our goal. We want something like that. Something named that we can refer to, we just gotta get a handle on it first. And the infer keyword is what's going to let us do this. So it lets us abstract some piece of a type from a larger type."
          },
          {
            "time": "[00:04:55]",
            "text": "And before we go back to our Webpack example, which is very complicated, just the nature of that type is complicated. I want to work on an example that has the same approximate structure meaning it still is a one argument constructor. And we still want to obtain this thing, but all of the other noises is out and I think that if we solve this problem, we will also solve the same problem in the WebpackCompiler example."
          },
          {
            "time": "[00:05:26]",
            "text": "So we want to design some sort of type that takes fruit stand or some variant of it as a type parameter. And it emits array of strings. Right like, here's a class. Give me the first argument that the compiler or that the constructor receives. So this is actually the answer here and it looks quite complicated."
          },
          {
            "time": "[00:05:53]",
            "text": "We're going to pick it apart. You will understand every little piece of this syntax, but first I want you to accept that it works. So we've got this, this is sort of the answer here. We've got this fruit stand thing. And we've got like constructor Arg we pass in type of FruitStand."
          },
          {
            "time": "[00:06:14]",
            "text": "And what do we get out? The first argument that the constructor takes. Here's our WebpackCompiler example. We pass in type of that, and we get out. That's the type that we wanted this whole time. We wanted to sort of, grab that first argument, give it a name and we could Give this a name like this with the type alias, we could call it WebpackCompiler options if we want to."
          },
          {
            "time": "[00:06:39]",
            "text": "So this appears to work, it does work. Let's pick apart what all this stuff means here. So first we're just gonna build it up piece by piece. First we have a type alias and we're calling it constructor Arg. It takes a single type parameter, which we're calling C."
          },
          {
            "time": "[00:07:02]",
            "text": "It's gonna be C for class. Next, we want to create a conditional type and, we're gonna be analyzing the static side of a class, which is that's why up here, we're using type of right. That's to get the type of the class, not a type of the instance."
          },
          {
            "time": "[00:07:27]",
            "text": "And we want, To match that against something like this, right, this again is our any constructor type, right? This is this represents anything in JavaScript that is newable regardless of how many arguments it may take, regardless of what it instantiates. If you want to know more specific newable."
          },
          {
            "time": "[00:07:50]",
            "text": "You might put something over here, like any constructor that makes dates. Well, that's gonna be the date constructor. So, we started with this. So all we've added is the condition portion of what will become a conditional type. So this is we've already learned about this right we have our type puram."
          },
          {
            "time": "[00:08:11]",
            "text": "We're testing whether the type that C represents is included in the set that this represents. So is C in the set of all things that are newable. Now, we're about to make a little change that will make this a more specific type. But we want to collect that first constructor argument that this is where the infer keyword enters into the story."
          },
          {
            "time": "[00:08:36]",
            "text": "So we're going to change from accepting any arbitrary list of arguments to accepting a first argument which must be there and we're adding something here it looks like it's a new type parameter kind of, it doesn't it's not going to end up having to be part of our type parameter list."
          },
          {
            "time": "[00:08:57]",
            "text": "But typically we still use title case for this, right? And infer is to the left of it. So you can think of this almost like it's like a vacuum the end of a vacuum, right? We're gonna suck up whatever's here and call it A and after a we're prepared to have zero or more other arguments."
          },
          {
            "time": "[00:09:22]",
            "text": "We don't really care about those. But to maintain the flexibility of this thing that we're building will tolerate other arguments. You don't have to give us exactly a one argument instructor. Are our constructor we just want the first argument of any constructor. Now, the more keen eyed of you may notice, this is actually we've made this type more specific."
          },
          {
            "time": "[00:09:47]",
            "text": "So if we let me get both of these on the screen here, this type matches any newable, including zero argument constructors. This, you're gonna have to have one argument, right? This has to be present. I'm okay with that in this situation because the whole point is we're trying to obtain that."
          },
          {
            "time": "[00:10:09]",
            "text": "So if it sort of Nevers out, right, it sort of grounds out in the case where we use it with zero argument constructors like. I would say that it's a sign of misuse anyway, and that would be a reasonable result. There was nothing to obtain, so never. Right."
          },
          {
            "time": "[00:10:27]",
            "text": "So this is our condition here and now all that's left is for us to fill in what are we emit? What type do we evaluate out to if the condition It's true. And what do we evaluate out to if it's false. So in the case where our condition evaluates to true, we're able to use this type A, just as if it were a type parameter."
          },
          {
            "time": "[00:10:55]",
            "text": "So you can think of this kind of like it's in scope, right? You could use a here or you could use it here. But it's not just a placeholder like a label just so we can give this thing a name. So when people read our code, they can understand what's going on."
          },
          {
            "time": "[00:11:11]",
            "text": "We suck this up with our vacuum, and we can put it out here. Right? So we're saying if C, is a newable. Suck up that first argument that's passed to the constructor and give me its type. Now we need to put something here. And a good way to think about how we handle the other case, right the case where we turn up with nothing."
          },
          {
            "time": "[00:11:41]",
            "text": "We want to make sure that if we use this with a union type, with the or type It kind of disappears. And what I mean by that is whatever type we end up with here, right? Like if we evaluate out to this case, let's say that's x. I want wanna make sure that when we we evaluate an expression like this, we end up with just a string or number it kinda just, it's like multiplying by one, like just an identity thing where it's sort of like vanishes."
          },
          {
            "time": "[00:12:13]",
            "text": "That'll ensure that we're not adding noise whenever this type sort of plays with other types. So we can try that with any and look what happens when we do union any it swallows everything. Union any always swallows everything. The way I think about this, it's like if you send your friend to go to the grocery store."
          },
          {
            "time": "[00:12:43]",
            "text": "You're saying pick up three organic eggs, and 25 grams of some spice. And also get me everything in the store please. Well, you could have just led with that right? You could have just said, give me everything in the store. That's why this swallows everything. It's kind of like multiplying by zero in some way, in that if this is found in a union type, if you ever see this, it just makes the whole rest of the union type pointless because it's just going to evaluate out to any."
          },
          {
            "time": "[00:13:21]",
            "text": "So not only is this the wrong answer, this is not what we desire. It's like the exact opposite of what we desire. We want something that disappears, not something that dominates over and kind of takes over. The whole type. So if this gives us the exact opposite of what we're looking for, it makes sense to me to try the opposite of any, right?"
          },
          {
            "time": "[00:13:43]",
            "text": "So we're going to try this with never, and we in fact do get what we want. So when you're making these conditional types, in the case where something didn't match and you kind of just want to like escape out let's just like forget about it. Often you're just gonna want to admit and never type."
          },
          {
            "time": "[00:14:01]",
            "text": "Because that well, when used in a union type like this it will just disappear. No noise, so let's apply that to our constructor, our extractor, and we can see this is the answer. This is what we ended up with. So just again, to recap, it's a generic type that takes a type parameter C, we look at sea and we see If it's a newable, and if that newable takes at least one argument, we have a match."
          },
          {
            "time": "[00:14:42]",
            "text": "And in the event that we have a match, we're going to use our infer keyword which is like a vacuum. We're gonna suck up whatever's in that first argument, and we're going to put it in a box called A. And then, in the event that we had a match, we will always enter this branch."
          },
          {
            "time": "[00:15:03]",
            "text": "So you're always going to enter this branch, which is why you're gonna wanna use eight here. Often down here, you could put another ternary operator, you could chain these together. And you could say, well if it's a one argument constructor, we do this. Maybe if it's a two argument constructor, we build a tuple with the two things."
          },
          {
            "time": "[00:15:23]",
            "text": "You can sort of chain these together. It's normal by the way to see this chaining because, unlike in the value based JavaScript world, there is no more verbose and explicit equivalent to the ternary operator. We can't like expand this out into if then else. I know that some people don't like nested ternary is for that reason."
          },
          {
            "time": "[00:15:44]",
            "text": "So finally let's look at at the result here. So no matter what we use this type with, we can see that we get the result we're looking for. We get the first argument the constructor takes. So you can create a new date like literally new date. You can pass it a string, a date as a string, a number, which is like milliseconds since the epoch."
          },
          {
            "time": "[00:16:12]",
            "text": "And then you could create a date from another date here is the resolve and reject. you're used to seeing in a promise constructor. Here's our Webpack config. So now we have this ability to using infer, to suck up a part of a type and to obtain it and to create maybe a local reference to it in some way, taking this all the way to the finish line."
          },
          {
            "time": "[00:16:39]",
            "text": "If we go back to our first example, our motivating use case where we had the spelling error, and instead of just creating this object with inference taking care of the typing, we add this here we give it an explicit type annotation. As we've done right up here, we can see that not only do we get an error where we hoped we would get an error."
          },
          {
            "time": "[00:17:06]",
            "text": "TypeScript is found that there is a watch property and the word we used is pretty close to watch. So maybe it's a spelling error. Even guessing that it might be just a spelling mistake. So there you go. This is a great use of the infer keyword. And I use it all the time for this exact use case."
          },
          {
            "time": "[00:17:33]",
            "text": "Where I'm consuming some code and I wish I could obtain this type maybe because just for logging reasons or something, I want to like create the things that I'm passing into the function. First, log that out and then pass it in. And this is a great way even if those entities those types are not available for direct import by whoever made the library."
          },
          {
            "time": "[00:17:58]",
            "text": "That doesn't hold you back, you can still do this. So, be caution that I want to give you is in a very large app, be careful that you don't do this too too much, because it's not simple for the type checker to evaluate. And if you end up with with too much of this kind of behavior here too many conditional types, too much infer you can end up slowing down your the speed of your type of heads."
          },
          {
            "time": "[00:18:34]",
            "text": "Now that's not I would say only worried about this if you start experiencing that problem. It's not the kind of thing where, you want to make sure you avoid the problem so that you don't get out of control in the first place. Really, if you're looking to improve your performance, just make sure If you're not making like overusing this this feature of the language."
          },
          {
            "time": "[00:18:57]",
            "text": "But totally fair to use totally, the only tool for the job in many cases."
          }
        ]
      },
      {
        "name": "9-inference-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So Frank asks, this was a few minutes ago. So we made this type ConstructorArg, right, that was kind of what we ended up with, this was the last thing that we worked on in the previous chapter. Does the TypeScript team plan to make this a standard type, it seems pretty useful, same with JSON value in the last workshop."
          },
          {
            "time": "[00:00:26]",
            "text": "Yeah, this is a good point, and what I will say is that the bar is pretty high for including something in TypeScript itself. So we have, for example, Extract and Exclude, these are core types that are already in TypeScript. What I will say is there's nothing stopping you from writing your own types as a little library and importing that in the projects that you care about."
          },
          {
            "time": "[00:00:57]",
            "text": "For example, if I go to github.com/mike-north, how do I spell my name again? [LAUGH] Mike-north/types, you can see I have a little git repo here that is types, interfaces, and classes that I often use. And look, there's ConstructorArgs, so I bring this package into a variety of things that I work on."
          },
          {
            "time": "[00:01:26]",
            "text": "And some of these have made it into the language already, like at the time I wrote this library there was no required and there was no make everything optional, but I made my own. And as a result they're still here and that's fine, I'm not under pressure to get rid of these because these don't add to asset size, right, they just compile straight out, it's an identical type to what they have built."
          },
          {
            "time": "[00:01:57]",
            "text": "If we click that you can see that, well, we'll look more into this but It's just type information in a little JavaScript library. And if you would look at what happens with this kind of library when it's all bundled up, with one tiny exception here, so I create something called a deferred which is actually a class, right, so this isn't purely type information, a lot of this library is, right."
          },
          {
            "time": "[00:02:22]",
            "text": "But here, this is kinda like an inverted promise where whoever is holding the promise, they get to call resolve or reject from the outside, so it's gonna add a tiny little bit of asset size but nothing to be concerned about. So that's how I would answer this question, as you find things that are useful package them up and make them into little libraries that you can consume."
          },
          {
            "time": "[00:02:52]",
            "text": "I have one called JSON-typescript, and if we look at what this library contains it's very, very similar to what we built in the fundamentals class, right, this is an old school way that involves types and interfaces so this is compatible with TypeScript 2.8 even. I'm doing the same thing that we did in the fundamentals class, so all I have to do is install this package in a project and I can import stuff from it just as if it were a little library."
          },
          {
            "time": "[00:03:22]",
            "text": "If you wanna know how to set these kinds of libraries up robustly, and by that I mean if we look at this mike-north/types thing and the CI pipeline I have going here, I believe I'm testing against multiple nodes, like multiple versions of Node JS and multiple versions of the TypeScript compiler."
          },
          {
            "time": "[00:03:44]",
            "text": "And this means that as new dependencies are added, if you have dependencies here you're making sure that everything still continues to work in a very complete way. So this would be like I would be flattered and proud if you were to copy the infrastructure here and to use this for your own types, right, you just take everything in this source folder and modify it or add to it as you see fit."
          },
          {
            "time": "[00:04:12]",
            "text": "And feel free to open pull requests into mine if you think mine's useful and you wanna build on that instead, but this is sort of my own little mini standard library if you will. So we have three things ahead of us. Two more chapters in the website, and then I'm going to try to put everything kind of together in accomplishing a non-trivial task in the TypeScript playground, and that's gonna be building a little mini data layer."
          },
          {
            "time": "[00:04:40]",
            "text": "Because when we have different types of records, we have a lot of well structured type information and it's a place where we can take advantage of some of the things we've learned for high code reuse. So that's what we have ahead of us."
          }
        ]
      },
      {
        "name": "10-indexed-access-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about Indexed Access Types. The concept here is we're going to grab a piece of type information from another type using something that feels like a property key. So let's imagine we have an interface called Car, we can grab just the type of the color property here."
          },
          {
            "time": "[00:00:28]",
            "text": "Using, it kind of looks like the square bracket access notation for taking something off of a dictionary or accessing an element of an array. Note that although when working with values using the square brackets, we know that we can use .notation, right? So if we have a dictionary, and we saw this we probably say, well why don't you just doing like car.color?"
          },
          {
            "time": "[00:00:56]",
            "text": "That will not work here, this must be using square brackets. And you have to pass a string literal type into it. So there is some enforcement of a constraint here, so color is present on key of car. But look what happens if we use something that's not on car."
          },
          {
            "time": "[00:01:20]",
            "text": "So you'll get an error message. There is some validations helps catch spelling errors or if you were to remove something from car you think it's unused, then have confidence that all of these index access types will light up. And of course you can repeat this pattern, right? So if we only wanted to have the red part of car color, we could say give me color, and then within that just grab read."
          },
          {
            "time": "[00:01:52]",
            "text": "And so you could see these boxes, these square brackets applied over and over. Interestingly, if we pass a union type through this indexed access type, we get a union type out. So year is a number, color is red, green, and blue on an object. So you can see here it's, I call this projecting, right, you can almost sort of send your union type of keys into this index access type."
          },
          {
            "time": "[00:02:27]",
            "text": "And you get arguing union type of types of the values instead of types of the keys. Pretty straightforward concept, it's just sort of accessing a piece by name. And I know I use similar language to describe, extract, and exclude. Hopefully you can see the difference between what we're looking at here which is grabbing a chunk of an object type as is."
          },
          {
            "time": "[00:02:54]",
            "text": "As opposed to the conditional type with the infer keyword, where we were grabbing the constructor or looking at the construct signature, plugging up the argument out of that. That's a much more heavy handed way to do things behind the scenes it's also much more expensive to do things that way."
          },
          {
            "time": "[00:03:12]",
            "text": "This is cheap, this will not really affect your performance. Okay, last big concept and it's a big one, this is like a triple size section here, it's mapped types. So let's take a look at that."
          }
        ]
      },
      {
        "name": "11-mapped-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're about to see all of the concepts we've talked about today come together through something called mapped types. This is the most powerful tool, in my opinion, for transforming types, right, taking some type, making it another type in a very organized and deliberate way. Where does mapped types get its name from?"
          },
          {
            "time": "[00:00:26]",
            "text": "A great way to remember it is it's kind of like array.map, if you're familiar with that, in that what we're about to see it feels sort of like looping behavior. Where we're iterating over all the keys of something and we're producing a type for a value. Again, we're purely talking about type information here, but the mental model of array.map and looping through and providing that transformative logic that you'd define with the callback for array.map."
          },
          {
            "time": "[00:01:00]",
            "text": "That's conceptually gonna fit pretty nicely with what we're about to see here. Let's take a look at the basics. So if you recall from TypeScript fundamentals V3, or equivalent experience in the wild, index signatures. You've seen index signatures before, hopefully, and this is what they look like. Note that we have kind of an arbitrary word here describing a property key."
          },
          {
            "time": "[00:01:30]",
            "text": "It's an arbitrary property key with an arbitrary name, meaning for a dictionary, if I access any key at all, I'll get this value type out. And then here is the value type. So this is like a generic type for a dictionary. I mentioned this in the fundamentals class."
          },
          {
            "time": "[00:01:46]",
            "text": "I'll often say I want t or undefined here, because there's always a possibility that when you access something on a dictionary, it might not be there. And I want to keep myself honest and to make sure I check for the presence of a thing when I grab it out of a dictionary."
          },
          {
            "time": "[00:02:03]",
            "text": "So we could see here, we can create a what I'm calling a fruit catalog. It's a dictionary of fruits, it'll start out empty. Here I'm kinda illustrating the problem I just talked about. But when we access any key we wish despite the fact that this is empty, we see we get a fruit back."
          },
          {
            "time": "[00:02:21]",
            "text": "So this what we're passing in for the t and we're kinda threading it through. This is an index signature, we've already covered this before. I'm gonna introduce a new concept here. And why did need a new concept? Because the only thing an index signature allows us to do is say for an arbitrary key, here is the type you can expect to receive."
          },
          {
            "time": "[00:02:47]",
            "text": "What if we have something more specific than just a narrow string? Or sorry, something more specific than any string rather. What if we have a list of properties and we wish to use that and not just the Wild West like you could put fruitCatalog.turnip or whatever you want, right?"
          },
          {
            "time": "[00:03:11]",
            "text": "We don't want that, we want something a little more deliberate. Well, this mapped type is gonna allow us to do something like this. Now, because in my mind at least, when I say the word dictionary, that means this very flexible key value store where I can hang whatever I want on an arbitrary key."
          },
          {
            "time": "[00:03:30]",
            "text": "So I'm gonna actually call this something different, given that we're no longer gonna be in the world of arbitrary keys. We have a set description of the keys we wish to use and then we have some value types. So we're gonna call that a record, and to avoid collision with something that exists in TypeScript already, I'm gonna call this MyRecord, right?"
          },
          {
            "time": "[00:03:53]",
            "text": "Just to avoid colliding with an existing type. So here's what's going to change. This is our interface as before, and here is the new signature. And we can look at these side by side in a moment. But for now, I want you to look at the fact that when I access cherry and apple, I get a type of fruit that's coming out."
          },
          {
            "time": "[00:04:19]",
            "text": "But when I try to access pineapple, we get nothing. Pineapple does not exist on MyRecord, and cherry and apple are here. So it seems that we're able to say, here are the specific property keys that I wish to use. Whereas with the index type, it was kinda like put it anywhere in this object and I will hold it for you."
          },
          {
            "time": "[00:04:43]",
            "text": "So let's compare these two signatures side by side. On the top, we have this mapped type and on the bottom, we have the index signature. And I've hidden out the type for the value here, because really, that's not what these signatures are all about. We can put whatever we want there in that dot, dot, dot."
          },
          {
            "time": "[00:05:03]",
            "text": "We'll talk about that later. Right now let's just look at the stuff that's on the left side of the colon. So index signature, the name doesn't really matter. I mean, you can put something there if it will help the reader understand what you're trying to do, maybe it's customer ID or something like that."
          },
          {
            "time": "[00:05:23]",
            "text": "Something that has some meaning to the reader, but it's not as if you're referring to this value anywhere. You're not saying name doesn't matter dot whatever, you can't use that. We're gonna see later that in this mapped type, we're able to use this. So giving it a name and making that name descriptive is a little bit more important."
          },
          {
            "time": "[00:05:44]",
            "text": "So here we have a colon in a regular index signature, and here we have this word in. And you can think of, when I talk about looping behavior, think of this union type as what we're looping over. And think of this as your i, right? For i equals 0 and loop over this."
          },
          {
            "time": "[00:06:08]",
            "text": "Or if you're doing a for in, right, where you're like, const key in dictionary. Fruit key is first gonna be apple and then it's gonna be cherry, and we're kind of processing, at least mentally we can think of it as a loop. Now remember, this is just type information."
          },
          {
            "time": "[00:06:29]",
            "text": "So there's no code that's being run and looping. There's nowhere you could put a break point to see what's going on. But the mental model of looping will hold up here. So mapped type lets you be more constrained and specific. Index signature, by its very nature, is about defining arbitrary key value relationships, different tools for different jobs."
          },
          {
            "time": "[00:06:54]",
            "text": "One's not necessarily better than the other. But if you were to say FruitKey in string, you would now be using a mapped type that is equivalent to the index signature below. Cuz it would just iterate, it would say like for every string, every possible string, here is the way I defined my value type."
          },
          {
            "time": "[00:07:17]",
            "text": "If that statement is not proof, that statement should be proof that there is no real looping that's happening behind the scenes. Because there's no way to iterate over every possible string in JavaScript, not in a way that will perform. There's just no way, let's just say there's no way."
          },
          {
            "time": "[00:07:36]",
            "text": "It's sort of a projection but it feels like looping to us. We can think of it as looping. So the in keyword, it's a telltale sign you're dealing with a mapped type. And index signatures, you can only define them on arbitrary strings or arbitrary numbers. That's it. And look what happens if we try to be more constrained in a regular index signature."
          },
          {
            "time": "[00:08:01]",
            "text": "We're literally told that these error messages are getting better with every release, consider using a mapped object type instead. If we attempt to do the thing that mapped types are designed to do, or we're doing it the wrong way, we're told, just go make a mapped type, please."
          },
          {
            "time": "[00:08:21]",
            "text": "Cool, so that's the difference. Seems like an index signature builds on top of that concept, but it's different. So, let's make our MyRecord type just to show what that is, right? This is not generic yet. It very specifically operates on apple and cherry, and it very specifically operates on fruit."
          },
          {
            "time": "[00:08:44]",
            "text": "Let's make that a bit more generalized. So what we're gonna do is replace this fruit key thing, right? Where it says FruitKey in apple or cherry. So let's rename that to key, down here. And then we're gonna pass in this apple or cherry thing. We'll make that a type parameter here."
          },
          {
            "time": "[00:09:04]",
            "text": "We'll call it the KeyType. And that'll be the first thing. And then this thing to the right of the colon, you've got this fruit. So we wanna make that generic. We'll pull that into a type parameter as well. So that's all we're doing. And by the way, this is from an experienced practitioner of TypeScript."
          },
          {
            "time": "[00:09:25]",
            "text": "This is a good pattern to follow, implement the non-abstract thing, and then start pulling things out to make it parameterized. It's a good way to make sure that you at least can affirm that continues to work with the use case you care about. So now we'll end up with something like this."
          },
          {
            "time": "[00:09:47]",
            "text": "It's much more generalized where we can specify here that we can pass in something like apple or cherry, right? Pass that in as strings. Kind of like those will be the names of the properties. This will be the values, the value of the property. And then it's almost like we're looping over everything in the key type we passed in."
          },
          {
            "time": "[00:10:13]",
            "text": "First apple, then cherry, and then we're giving this type. We're giving it a value type on the other side. Now, this is already built into TypeScript, but now you understand how it works hopefully. So it's called Record. And I want you to look at these side by side and see that aside from this, the names of these properties, which I've tried to be just a bit more descriptive than single letters."
          },
          {
            "time": "[00:10:44]",
            "text": "We had the same form here, with one exception, and that's like this keyof any. But down here, you can see that like, these are the types of keys that JavaScript allows. You can have numbers, symbols or strings, and that's it. So I've just said, okay, well, strings, this is most of the stuff I care to work with here has property keys that are strings."
          },
          {
            "time": "[00:11:08]",
            "text": "So that's a difference in the constraint, but doesn't make things fundamentally different. And then we have key in, some type that we passed in. So this is property key in K, well, there it is. And then there's the second type of param, and there it is. And here's our second type of param, and there it is."
          },
          {
            "time": "[00:11:29]",
            "text": "So really, what we're able to do with this mapped type is build up an object with a set of known keys that have a consistent value type. That's the first use case for this. Now, why might you care about this? Well, sometimes you want to maybe have a bunch of form fields and they each have sort of a value and whether they're validated or not."
          },
          {
            "time": "[00:12:05]",
            "text": "It's great to have a nice dictionary like this, especially if you're pre-creating one and you know exactly what you expect to be there. I'm blurring the line here between a record and a dictionary. But this is a quick and easy way to go ahead and create one. I would say this is a subtype of a dictionary."
          },
          {
            "time": "[00:12:28]",
            "text": "A dictionary is flexible in that you can have arbitrary keys and this has specific keys. So this is just a more specific thing than a dictionary."
          }
        ]
      },
      {
        "name": "12-advanced-mapped-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Now let's combine this knowledge with what we just covered in the previous chapter, and that is an indexed access type. So what I've done here, and I apologize that the tooltip is kind of adding a big gap in the code, but this is just one type here, right?"
          },
          {
            "time": "[00:00:23]",
            "text": "What we're doing here is we wanna grab a portion of the window API as in the global that's available in a browser. And when do I do this? Well, especially if I'm writing code and I expect to make my tests nice and easy through dependency injection, I kinda want to limit myself to accessing only certain things on Window."
          },
          {
            "time": "[00:00:54]",
            "text": "So that I make sure that if I have to stub them in tests, or maybe if this is a single page app that I have to server render, well, there in the node world I might have to stub like polyfill some Windowish things so that the thing renders properly."
          },
          {
            "time": "[00:01:12]",
            "text": "But I wanna give myself sort of a explicit boundary so I know whenever I cross it. I can show you after we go through this a more real world example involving Chrome extensions and their Chrome extension API's. So great. So we have, we gonna call this part of Window and what we want is to grab only, we want something that looks like Window but it only has a couple things that can be found."
          },
          {
            "time": "[00:01:46]",
            "text": "So we're saying we're looping over these three things. So it's sort of almost like four each of these three, key is gonna be these sort of one at a time. And now we're using an indexed access type, right? So key is first gonna be document. So we're using Window[document], and we're gonna get this document type."
          },
          {
            "time": "[00:02:11]",
            "text": "And then the same thing for navigator, and then the same thing for set timeout, right? Here's the callback, and then here's the timeout number, and then here are the the arguments that are passed to the function. People, this is a rarely used aspect of set timeout. But ultimately, we get a subset of Windows, we get a portion of it, only these keys that we're interested in."
          },
          {
            "time": "[00:02:42]",
            "text": "So again we're gonna make this a little bit more generalized by pulling hard coded things out into typeparams. So the first thing we'll pull out is, we wanna pull out the keys, right? So that's this list of things here. So now we've got like Key in Keys, and that's a typeparam up here."
          },
          {
            "time": "[00:03:05]",
            "text": "And note that we're saying, Keys extends Key of window. Why do I want this, well pop out to the playground just so we can see it for ourselves. What if I did this? I would wanna be told, sorry, it's a pipe. I would wanna be told that zzz it's not a thing that could be found on Window, it's not found on Key of Window, Right?"
          },
          {
            "time": "[00:03:36]",
            "text": "A deliberate spelling error. If I took this away. Well the error would pop up in a different place. But now I'm being told hey, hey, hey, you can't just use Key as an index access type here, how do I know that that stuff's gonna be found on Window?"
          },
          {
            "time": "[00:03:56]",
            "text": "You could say hey it's a string, but so the first error is Keys, it could be a promise it could be a function, there's no constraint on Keys. I can't use that in a match type cuz can only use things that are like property keys, right? This is a core constraint of map types."
          },
          {
            "time": "[00:04:15]",
            "text": "It's about a property Key and looping over them. So even if I solve that by saying, It's a string, now this piece is gonna say, well, how do I know that these are things that I can get off of Window. It could be an arbitrary string. So that's why we have this in place just kinda makes everything work."
          },
          {
            "time": "[00:04:38]",
            "text": "It's not only a valid property key but it's the subset of all allowable property keys in JavaScript that will work with Window. And now, theme coming back, right? The error is popping up at the location where I apply my fix because I have misspelled this, and now things start to pass."
          },
          {
            "time": "[00:05:00]",
            "text": "So that's why you can see kinda how if we relax this, things will start to get angry in various places. This has to be a valid property key and hen this has to be a valid property key for Window. But we can get the same result out now, right?"
          },
          {
            "time": "[00:05:26]",
            "text": "So we had part of Window, this was hard coded for these three properties. So we made something here called PickWindowProperties, that's the more generalized thing, and then we can leverage that. So this is the general solution up here. We can get our specific solution back by saying, I wanna pick things off of Window, and here are the names of the properties that I wish to pick."
          },
          {
            "time": "[00:05:53]",
            "text": "Let's generalize it one step further by abstracting Window away. So we're gonna get rid of this and pull it out to a typeparam. So what we've done here, instead of calling it pickWindowProperties, we're just calling it PickProperties. And just as before we have these Keys that come in, I've actually moved it to the second type parameter, up here was the first, right?"
          },
          {
            "time": "[00:06:18]",
            "text": "I mean, it was the only one but it's in the second position now. So we have a valueType and then we have Keys, where these are Keys that are found on this valueType. And I'm using this map type here. So previously we were seeing what Window[Key], and now we're seeing ValueType[Key]."
          },
          {
            "time": "[00:06:42]",
            "text": "And we're still able to get our specific result here. Because we're parsing in Window, this is the thing we're plucking properties off of, and these are the names of the things that we're kinda peeling off. Let's open this in the playground. So I don't wanna talk about why I ordered these typeparams in this way."
          },
          {
            "time": "[00:07:11]",
            "text": "If I tried to reverse them, I might run into a problem, actually does this work now? That would be pretty cool. Wow they fixed this. All right, well, you'll still see stuff written the other way and I can kinda explain the rationale behind it. Just poking at it making sure, something's not right here."
          },
          {
            "time": "[00:07:39]",
            "text": "Let's see, I need the comma and then I think it'll work. Yep, okay, so it seems like this has been relaxed. But previously, you kinda had to state upfront. If I wanted to use ValueType in an argument, we first had to state the typeparam has to exist first, and then we can refer to it as a constraint for another typeparam."
          },
          {
            "time": "[00:08:07]",
            "text": "But it appears that recently they've relaxed this, which is kind of cool. That would let us build this API signature the way that we want, and in this case, just in terms of how you could read this out loud, I kinda like like this better. So I want to pick the properties document, navigators, setTimeout, setInterval from Window."
          },
          {
            "time": "[00:08:30]",
            "text": "And I like that rather than saying I want to pick the following things from Window, here are the properties that I want. You have both options available to you now. All right, Tristin asks a good question, in fact you've asked it twice and you've been very patient. So mapped types do they extend from dictionary, and since mapped types are a subset of a dictionary that extends word is still strange to me."
          },
          {
            "time": "[00:09:03]",
            "text": "So I would encourage you to think about this in terms of set theory. So if you imagine all of the dictionaries that could be in the universe. So things like this, right? All of these with all the possible property keys and all the possible ValueTypes. Some of them, [LAUGH] Some of them will be full of stuff, some of them will only have a couple property Keys."
          },
          {
            "time": "[00:09:41]",
            "text": "When we talk about something that is more constrained than this, more specific than this, we would say that it extends from this. So when we talk about mapped types kind of extend from their dictionary equivalents, you can think of it as, Dictionaries are more flexible than mapped types."
          },
          {
            "time": "[00:10:09]",
            "text": "So if I had, Or well, say this is a dictionary, Of dates, So it starts at empty. And then this will be, A index signature. And this is gonna require that I do a new date. Start of week is a new date. And I'll get rid of this little side panel here."
          },
          {
            "time": "[00:11:04]",
            "text": "Okay, so just looking at this code here, I would say that this dictionary is more flexible and more general than this type here, why? This has no opinion about which Keys dates are stored under. This one does have an opinion. So if I change these to let declarations, This is gonna be a problem."
          },
          {
            "time": "[00:11:36]",
            "text": "Because we can't, when we say I have a slot that's designed for a record, what guarantee do we have that end of week and start of week are here? We don't have that guarantee. Whereas in the other direction, Totally fine, why? The dictionary is ready to handle start of week, end of week, start of year, end of year, whatever you want."
          },
          {
            "time": "[00:12:03]",
            "text": "So that's, we see a Key insight here that records, these records are more specific than dictionaries. And when we talk about this extends word that's used in type parameter constraints, and in these conditional type conditions, the meaning of extends is, Something like this. We're saying is T, are all values that we could possibly have for T, to all of those satisfy what is described by date."
          },
          {
            "time": "[00:12:48]",
            "text": "And date could have many others that don't satisfy T, but does everything in the set that could be a possible T? Does all of that fit into date? So really we're saying, is T a specialized flavor of date? Is it a more specific version of date? It's a really tricky conceptual thing to get over, so I would encourage you if you're still having trouble with this, please ask more questions."
          },
          {
            "time": "[00:13:16]",
            "text": "Please keep kind of poking at this because it's one of these big lightbulbs that when it turns on, things become much more clear pretty broadly across the language. So now that we've generalized this let's look at what we have. We have a mapped type where we take two typeparams here, right?"
          },
          {
            "time": "[00:13:35]",
            "text": "So we take a value that we're plucking things off of this previously was Window. And then we have some union type potentially, that is one or more Keys that are found on this ValueType. And we're iterating over those Keys, and we're plucking the values off and this is what we get."
          }
        ]
      },
      {
        "name": "13-pick-mapping-modifiers",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Well, we have arrived at another built- in type that TypeScript includes, and that is Pick. So if we look at the built in pick up here, and the pick properties that we made, they're basically the same type parameter names aside. ValueType is going to be the T, as you can see it here and you can see here,ValueType is here, and here or also, there's a Keyof T and a Keyof ValueType, and then here we're creating over the keys."
          },
          {
            "time": "[00:00:36]",
            "text": "So that's how pick works. It like where for record, we just needed the map type. Here we're using this indexed access type to grab something off of something else, if that makes sense. We're using that square bracket notation. We're saying, here's document, give me document, right? Record if we look at it one more time, it was just a consistent thing we were always placing there, like, it's always going to be the same."
          },
          {
            "time": "[00:01:15]",
            "text": "Whereas here we're kind of like Were using a different key. And so as a result, what comes out like these are obviously different types. Document, navigator, set timeout. That's what this index access type gives us when used with a map type. Let's talk about mapping modifiers. These are just kind of something potentially to memorize or just remember that it exists, but not not an incredibly abstract concept."
          },
          {
            "time": "[00:01:46]",
            "text": "So, the way to think about this is, as we loop over in our map type, as we loop over all the keys, we have the option to determine whether the ValueType should be read only or optional. There are two independent things. You can be read only and optional or you can be non optional and writable like they're totally independent."
          },
          {
            "time": "[00:02:15]",
            "text": "So, you're gonna see that we will find a question mark in some of these code example and the word read only. So here, this is a built in type. We're going straight to the built in types here because these are kind of less interesting to build up. But this is the key."
          },
          {
            "time": "[00:02:33]",
            "text": "This is the thing that makes partial different from pick. While there are a couple things, first off. Pick, lets see you specify which keys you would like. Here, we're iterating over all the keys in type T. And over here, we're saying the value may or may not be there."
          },
          {
            "time": "[00:03:02]",
            "text": "So that's partial, and this is the opposite of partial. The only thing that changes is we have a minus sign. It's almost like we're removing the optionalness as we loop over. This is a very weird thing like, a rare thing to for you to put into your own types."
          },
          {
            "time": "[00:03:19]",
            "text": "But that's how this works, right? It's just that and then read only here. So this would, it doesn't really freeze the object. Just remember that TypeScript disappears as part of your build process. And so at runtime like this might actually be a writable thing. But this would type check it."
          },
          {
            "time": "[00:03:42]",
            "text": "So create a version of something that is read only. Maybe it's an options, object that you're passing to function or some object you're passing in a function. You want to make sure that you don't modify it, like mutate the thing that you were passed, you might make it read only so that when you receive it, you'll be called out."
          },
          {
            "time": "[00:04:02]",
            "text": "If you ever try to mess with something that really should live in your stack, right? Now there's no built in type for removal of read only you could implement it like this, but is not necessarily a good idea. It's probably if someone made something read only, might want to figure out what that reason is they probably don't want it messed with."
          },
          {
            "time": "[00:04:27]",
            "text": "But just showing you that there is continuity here in terms of question mark and read only they both work with this minus sign. Just know that the positioning of these. So this is fairly easy to remember because it's the same location of that question marked as optional class fields or optional object literal properties."
          },
          {
            "time": "[00:04:51]",
            "text": "And read only that's always to the left cuz it's kind of like where you would put an access modifier keyword in a class field or a method it's like public read only function,."
          }
        ]
      },
      {
        "name": "14-template-literal-types-key-mapping",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Template literal types. Not deserving enough of its own section I don't think, but a kind of a cool thing. It's a recent addition to TypeScript. So as of the time of filming this course 4.3 is the most recent TypeScript release. So template literal types have not been around for all that long."
          },
          {
            "time": "[00:00:26]",
            "text": "But I would like to show them to you because especially around data layer stuff they are really, really promising. They look like a great way to make highly reusable things. So we're going to experiment with them here. I have first, a type that I'm calling ArtFeatures, things that could appear in a painting, and then I have colors."
          },
          {
            "time": "[00:00:56]",
            "text": "So using the same syntax that you're used to using for ES template literals, by that I mean the backtick strings where you can interpolate non-string values into a template string. We can create what's called a template literal type. And what we're seeing here, so first, let's look at the syntax."
          },
          {
            "time": "[00:01:20]",
            "text": "We've got the backticks here. We have the dollar sign single brace, we're used to seeing that, right? And what we get, it's sort of every combination of color and paintable art feature. So we've got a darkSienna_cabin, darkSienna_tree, darkSienna_sunset, and now we're going to sapGreen_cabin. And it keeps going and going and going."
          },
          {
            "time": "[00:01:45]",
            "text": "When I showed this to my wife, she said that looks like a factorial. That will tell you how many of these you're going to get, right? It's every possible combination, how many unique combinations you'll get. But these are not good, in terms of, sorry, these are not idiomatic JavaScript method names, right?"
          },
          {
            "time": "[00:02:11]",
            "text": "I'm calling this art method names and look at those types, we don't use snake case, right? Not in JavaScript, I mean you totally could. The language supports it, but it's much more conventional to use camelCase. So how would we accomplish this? Well, you have a couple little special things, special transformers of these elements within your template literal type that would let you do something like this."
          },
          {
            "time": "[00:02:42]",
            "text": "Capitalize colors and we've removed the underscore but look at the d in darkSienna. Despite up here it being lowercase, right, the first letter's been capitalized and so we can get some nice method names here. Not a coincidence by the way, the feature set was built such that you could have lowercased property names and then maybe have getters and setters."
          },
          {
            "time": "[00:03:08]",
            "text": "And you want when people are using your code to be able to use these as things that feel like they were painstakingly implemented one at a time when really, it's just sort of an a times b. And here is the format of the string that I want. So why am I talking about this in a chapter of this course called mapped types?"
          },
          {
            "time": "[00:03:33]",
            "text": "Well, let's bring it back to mapped types. So what we can do here, some people call this key mapping. And effectively if we go back to our analogy of array.map, when you use array,map, you are converting the values of array A to array B, right? You're just converting the values."
          },
          {
            "time": "[00:03:56]",
            "text": "This lets us manipulate the keys as we're making that transformation. Let's see what happens, right? So here's the mapped type, right? I'm saying I'm iterating over each key and by the way, let me introduce this before [LAUGH] we go too deep in here. Let's say that this is just some piece of data, a record that I persist to an API somewhere."
          },
          {
            "time": "[00:04:23]",
            "text": "I've got an array of numbers, I've got an array of strings, and then this flags thing is a record of Booleans. So I'm gonna pop out into the TypeScript playground, we can play with this. Data state.so we've got digits, which is a number array, here's flags. So I've got dark mode and mobile, those are each a Boolean, maybe little user preferences that someone could turn those on and off, right?"
          },
          {
            "time": "[00:05:01]",
            "text": "Here I'm just being yelled at because I'm using this before it's been assigned. But it's equivalent to, Equivalent to something like that. We already talked about record but just bringing us home there. So what this lets us do is we're iterating over all of the keys in this data state interface, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "So that's gonna be first digits, then names then flags, and then we're using this as keyword, as is how this remapping can happen. And we're adding the word set in front of it and capitalizing, so we get a little method here that's called setDigits, setFlags and we can pass these things in."
          },
          {
            "time": "[00:05:52]",
            "text": "So if you've written data layer code where you have a bunch of Boolean properties where it's is, is dark mode, is user opt into beta. Well, you could see how you can now in a very generalized way derive some controlled accessors for those kinds of things. Maybe you would use object.defined property to dynamically build something and then be able to represent the types accurately."
          },
          {
            "time": "[00:06:29]",
            "text": "Let me show you a library where I would hope one day they'd use something like this to define types. This is my favorite library for colorizing CLI stuff in JavaScript. And basically, to make this string blue with a red background, you do .blue, and then look at this, bgRed."
          },
          {
            "time": "[00:06:55]",
            "text": "So every colors available as a foreground or background. And now instead of explicitly saying we've got the red and then we've got here's the red and then here's the bgRed. But now you could define this template type that would just add bg capitalized, the R in red boom, and now you can make a really nice API."
          },
          {
            "time": "[00:07:17]",
            "text": "And this library is a pleasure to use, it's very easily proves that you can build beautiful and highly ergonomic APIs. Not rest APIs but functional APIs using this kind of technique. And look, we're now back to catching spelling errors again, we get true type checking here, because I left the E off of mobile and TypeScripts figured that out."
          }
        ]
      },
      {
        "name": "15-filtering-out-properties",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Finally, the last sub part of mapped types that I'd like to talk about is, how do we filter properties out? So, we've already seen how we have some control over what is included via filtering the property key, right? So we used extract before, and we can actually, this is pretty cool."
          },
          {
            "time": "[00:00:26]",
            "text": "We can use a template literal type, almost like a query tool here to say, show me those keys of document that begin with the word query. That's pretty cool, right? It's almost like a find the substring like a regular expression, right? Which of these keys begins with query because it's any string that begins with query."
          },
          {
            "time": "[00:00:56]",
            "text": "That's what we're matching against. So we get all these QueryCommandEnabled, querySelector, querySelectorAll, etc. So those are the keys of interest and we can produce a filtered version of this document type. Meaning we only get those properties that are specified by the keys of our choosing, because that's what we're iterating over, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "We're saying K is each of these 1, 2, 3, 4, 5, 6, 7 things, right, to each of these seven things. For each of them, we'll go look at the document, get the value type, and that's what we're gonna have there. So this is one mechanism of filtering, if the key is the determining factor, but what if we want to filter based on the value?"
          },
          {
            "time": "[00:01:46]",
            "text": "For example, what if we wanted the things on the document object that are functions who return either an element or an element list, right? And I'm kinda thinking about querySelector and querySelectorAll, just things that we use for retrieving or creating DOM nodes. Now, in advance, I couldn't tell you which keys, I mean, I can tell you querySelector, querySelectorAll, are gonna be included."
          },
          {
            "time": "[00:02:14]",
            "text": "But I can't tell you which things those would be, right? So we're gonna need to think about how to approach this. And first, we're gonna go down the wrong road. So I wanna be very clear. I'm showing you something that doesn't work, but I think it's a useful midpoint as we approach a better solution."
          },
          {
            "time": "[00:02:37]",
            "text": "So first we're going to use never, we're gonna use a flawed approach. Here's a disclaimer, don't copy and paste this code into your app, please. We're gonna use a flawed approach and use a conditional type with a mapped type, In order to do this filtering, so I'm gonna read this to you in pieces."
          },
          {
            "time": "[00:03:00]",
            "text": "So we're iterating over all of the keys of document and we're performing a test. What's the test? What's our condition, is the value type for a given property key. It doesn't extend. Right, is it at least a function with an arbitrary number of arguments that returns either an element or an array of elements."
          },
          {
            "time": "[00:03:29]",
            "text": "This condition is the right one for sure. This will be represented in our good solution in a moment. So we're comparing this to see if it matches what we're looking for. And if it does, we let it pass through Document [K], right? And if it doesn't, we say, never, hoping it will disappear."
          },
          {
            "time": "[00:03:53]",
            "text": "But it doesn't, as you can see up here, we end up with every single property that is on document including 235 that have been suppressed. And although the things that match, I mean they're still usable, right? We don't say never hear. It's totally usable. Although that still works, it's not really gonna help us when it comes to autocompletes."
          },
          {
            "time": "[00:04:22]",
            "text": "We're gonna go here and we'll say, okay, let's see what subset of things I have available. That's a never these are all nevers, it's just a bunch of noise, a bunch of garbage in here. AppendChild, is that one of them. So that one didn't get zeroed out. But these gotten zeroed out, it's just a bunch of junk in here."
          },
          {
            "time": "[00:04:42]",
            "text": "It's not giving me good feedback as to what I can successfully use. So, hopefully we all agree, undesirable result. How can we make this better? A better approach is gonna involve filtering those keys first. And then once we have the set of keys that match our condition which is gonna be a value based condition."
          },
          {
            "time": "[00:05:12]",
            "text": "Then we'll be in a position where we can get something that looks more cleaned up. And I first want you to witness that this works and we're gonna peel it all back, and build up to it slowly. So when I say that this works, first, there aren't over 200 things here and the things that are here, I can't spot any nevers on my screen."
          },
          {
            "time": "[00:05:40]",
            "text": "So let's compare, there's seven more and up here there were 235 more. So it seems it's much more filtered down. And I'm gonna also sanity test and say, well, adopt node, create element, querySelector, do these things, do they feel like they're for DOM query, or DOM element creation?"
          },
          {
            "time": "[00:06:02]",
            "text": "Yes, just on a conceptual level these seem like what I was looking for. And then finally down here, this was one of the things I selected. So, I'm gonna kick out to the TypeScript Playground. And this is the kinda thing I would encourage you to pop this open on your own machines and follow along with me."
          },
          {
            "time": "[00:06:25]",
            "text": "Because what you're about to see is somebody who's familiar with working with these kinda types, me. You're gonna see how I deal with this thing up here, which is nutty and complicated, and hard to debug. And you're going to see how I make progress towards getting it to work."
          },
          {
            "time": "[00:06:53]",
            "text": "Because as, if you've been playing with this throughout the course, there's no debugger for types. This is not really code that runs, you're just defining constraints. So when things get complicated, and this is the equivalent of having many things on the same line of code, right? Where it's just doing a lot, one higher order function that does everything."
          },
          {
            "time": "[00:07:15]",
            "text": "It's really challenging to troubleshoot. So you're gonna see how I peel this back and how I can start with breaking this up into simple small things. And layer my way up into the thing that eventually is going to work. Okay, so I'm gonna actually come and add our solution and create a copy of it."
          },
          {
            "time": "[00:07:40]",
            "text": "So the approach that we wanna take here is, we want to select those keys, whose value type is what I'm looking for, right? So, we wanna go and find query selector and identify that is what we want. Because document.query selector is matching the condition that we're filtering for."
          },
          {
            "time": "[00:08:09]",
            "text": "We're not just picking it because of its name we're picking it because it has a value. That is what we're looking for. And that value is this. And I'm actually gonna deviate from our written solution there for a second just to add some more verbose, a greater explicit set of information here."
          },
          {
            "time": "[00:08:33]",
            "text": "So we'll just call this, ElementFunction, Element, and it's this, right? Just so we can refer to it by name and we get some of that punctuation out of our way. So we can take ElementFunction, we'll put it here, cuz that was working, cool. So FilteredKeys, I'm actually gonna get rid of this for now."
          },
          {
            "time": "[00:09:09]",
            "text": "All right, so let's look at this here. So we're taking in a type, right? The fact that we see keyof T, here and T[P], this is gonna be the thing we're iterating over. So let's call it, We'll call it ToFilter, right? We're filtering this thing. And then you will call this, Condition, something like condition, right?"
          },
          {
            "time": "[00:09:50]",
            "text": "It's the type that represents what we're trying to match. So we're going to loop over all of the keys. And then this is our little i in our for loop, right? For each key, this is our parameter, see that parameter in the tooltip? P for parameter. We're gonna go and grab the value type out of whatever we're filtering from."
          },
          {
            "time": "[00:10:20]",
            "text": "We're going to check it against the condition, right? Is the value type assignable to whatever we passed in? It's gonna be this, right? Is it a function that returns an element or an array of elements? And if so, this is weird, we've never seen this before. We saw a whole bunch of code that would do this, Right, we're like, did it match the condition?"
          },
          {
            "time": "[00:10:47]",
            "text": "Let it pass through. No, that's not what we're doing. If it works, if it passes the condition, we're sending the parameter through. This is the key, not the value, otherwise, never. So look at what we get out here. And let me make a smaller type so we can see this more easily."
          },
          {
            "time": "[00:11:10]",
            "text": "So we've got this, and we'll call this RelevantColorKeys. And we're going to filter for, Actually those should be numbers, right? Just let's keep it consistent with way I've treated colors throughout the day. Look, green number, save, so FilteredKeys. So we've got this color, that's what we're filtering over."
          },
          {
            "time": "[00:11:43]",
            "text": "And let's just make sure that everything passes straight through the way it should. I mean, I expect this to of course work, great. So everything passes through when I remove that condition. And then if this extends this condition, I should see P, what if we did this? You know what, I'm also gonna comment out."
          },
          {
            "time": "[00:12:15]",
            "text": "No, I have no idea why this would interfere with anything. So, okay, so we're back on track here. Now I can explain what's going on here pretty easily now. So, we're iterating over all properties of Color, right? We're looking at red, we're looking at green, we're looking at blue, and we're comparing them against number."
          },
          {
            "time": "[00:12:41]",
            "text": "We're comparing the value types against number, right? So this is number, this is gonna be here. This will be red, and then this here, it'll end up being a number. So if we were to do this, string, string for red, And then string for blue, now we can see that our RelevantColorKeys."
          },
          {
            "time": "[00:13:06]",
            "text": "So green is gonna kind of pass through. And then look everything else turns to a never because they don't match. Now, what we want are the property keys. Right, so we're still getting this object type out, we want the property keys. Well, we can take advantage of the fact that an indexed access type, we can send, we can sort of project something through an index access type."
          },
          {
            "time": "[00:13:33]",
            "text": "So I get this object type out. What if I did this? I just get green. So, it's almost like I'm starting with this and then I'm saying, okay, if I pass in the key of, right, it's just gonna be never, or green, or never. And remember, whenever we or with never, the never disappears."
          },
          {
            "time": "[00:14:14]",
            "text": "Nevers disappear when you or with them. So if we just simply say keyof Color, we're basically saying, I'm gonna transform all of the keys of color, a union type of all of the keys of color. And I'm gonna project them through this. And I'll get a union type of all of the values, but not all the values of color, cuz we've sort of modified it a bit here."
          },
          {
            "time": "[00:14:40]",
            "text": "We'll get all of the values of this, in a union type, never, or green, or never. And that's why we get just green. Now, we can actually move this up here and say keyof ToFilter, And it'll still be green. So now if we uncomment this and these, I think there may be one last thing we have to do, and there is."
          },
          {
            "time": "[00:15:15]",
            "text": "So our last problem to solve here, we've hit this before when using index access types. And basically it's saying that, look, I see you have this thing here. It's all of these keys, but they've passed through a couple things by this point. How do I know they're still key of document?"
          },
          {
            "time": "[00:15:36]",
            "text": "If you're gonna reach into document and access, if you're gonna use this thing here, how do I know that that's gonna work out? Well, the way we handled that before, was we said, hey, look, if you don't trust me, I mean, I know if we look at the keys of document and we look at what I have, they overlap completely."
          },
          {
            "time": "[00:16:00]",
            "text": "Meaning, Everything I have is included in the set of possible keys. So I'm happy to do this. I know it's a no up, but if it makes you comfortable, all the better. And now we are, I believe, should be where we need to be. Key of document, yep, and there it works."
          },
          {
            "time": "[00:16:23]",
            "text": "There's our query selector, returns an HTML input element. And look at that, this is just what we wanted. It's like a subset of document that only relates to DOM manipulation. So imagine now if you have a React app and you've ever done server side rendering, you know that sometimes you have to do some node stuff maybe you register a service worker, or some code runs and it's like, you tried to reach into window and it's not there."
          },
          {
            "time": "[00:16:51]",
            "text": "Well, this would let you kind of put some confines around that API that you're not supposed to be accessing if you're trying to serve or render your React app. Another example, here it is, so I built a Chrome extension recently. And when I'm defining the parts of the extension API that I wish to talk to, I make sure that, I don't want to reach in and touch too much."
          },
          {
            "time": "[00:17:22]",
            "text": "Because although I can use a lot of things on the Chrome extension API, depending on what permissions my extension is asked for, things will error or they won't, right? Unless I have the user's permission to access their location data, I can't do that. This lets me put boundaries around what's gonna be presented to me in autocompletes, right?"
          },
          {
            "time": "[00:17:48]",
            "text": "Where I only want to see this stuff showing up to me. And if I need some other part of the API, well, I'd have to come back here and I'd have to add it. And that'll be the trigger for me to say, when I ask for permission from users, and in a Chrome extension that's gonna be here."
          },
          {
            "time": "[00:18:09]",
            "text": "When I say, I need to be able to access the active tab and the tabs thing, right, all these permissions, that'll be my signal. I'm changing the boundaries, because I set up this nice sort of confinement around what I was building. And furthermore, I think here, so when I have to stub out parts of the Chrome API, I only have to deal with those pieces that I've said I'm going to access."
          },
          {
            "time": "[00:18:44]",
            "text": "So when I'm stubbing things out, I know, look, I only need this ad listener thing. Here on this type I've said, look, I only have these properties on there. I plucked these things off and I only wanna see that subset of things showing up. Well, now I have this type safety that tells me whenever I go out of bounds, right?"
          },
          {
            "time": "[00:19:05]",
            "text": "I have this partial Chrome API instead of the full blown thing that will show me everything and who knows what you have to stub there? It kind of depends on where you're writing your code. So that's a practical use case. I'm going to write up the types for a little mini data layer using a variety of the concepts that we've seen so far."
          },
          {
            "time": "[00:19:35]",
            "text": "But I do want you to celebrate one thing at this moment. And that is, that this type here, this FilteredKeys thing and the stuff you saw here, if we go back to the very beginning of the course, we had a slide on the beginning of the course where we set this out as our goal."
          },
          {
            "time": "[00:20:05]",
            "text": "And we've now accomplished it. And the way we do it is just sort of piecing it together, chunk by chunk by chunk, and sort of expanding it out so that we're not maybe not trying to do so much on one line. But then when we get it right, we can put it all back together."
          },
          {
            "time": "[00:20:21]",
            "text": "So hopefully we're feeling a little bit more comfortable at taking complicated things like this and sort of slicing them up a little bit."
          }
        ]
      },
      {
        "name": "16-typing-a-data-layer",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> As a final kinda capstone to intermediate TypeScript, we're going to do a little bit of a practical exercise and that is to make a well typed data layer or a data store using the concepts that we've learned in the class today. So, and I'm just in the playground here, and you could copy this code if you like."
          },
          {
            "time": "[00:00:26]",
            "text": "But all I've got is three classes, one is called book, one is called movie, one's called song. And I've just chosen a different meaningful property, which we'll turn into a class field for each of these different classes. So if we did b is new book, we'd have to give it an author, maybe I'm the author."
          },
          {
            "time": "[00:00:50]",
            "text": "And we can see that b.authored it gives us this type back, and that's because we're using these nice little shorthand param properties, maybe you heard us talk about this in TypeScript fundamentals. So, ultimately, what I want is an API that looks kind of like this. I wanna be able to create a new store, this is like a data store, that's what I mean by store."
          },
          {
            "time": "[00:01:17]",
            "text": "And then I wanna be able to do something like store.get('book'), and this should return a book. And I wanna be able to do getAll, and this should return an array of books. And maybe create and this should take an arb if it's a book. Hopefully we get the idea here."
          },
          {
            "time": "[00:01:43]",
            "text": "We want a kind of a nice little crud, some portion of a crud like data store that gives me some good types when I retrieve things, and it gives me some type safety when I'm trying to work with things, trying to modify them. So let's actually, I created a book here, Let's pass that in, let's use this as kind of a little test case, right?"
          },
          {
            "time": "[00:02:15]",
            "text": "And let's see if we can do this one, we'll say update, and this is gonna be kind of a patch, where I'm gonna pass some incomplete subset of fields here, maybe I'm just editing the title or something, call it a partial. So this would be a book ID."
          },
          {
            "time": "[00:02:42]",
            "text": "And then, Something like that. So we want create and update and then get a collection, and we want good type safety around this. And none of this works yet, so we're gonna have to make it work. So, clearly, we're gonna need these methods here, right? The getAll, create, and update."
          },
          {
            "time": "[00:03:19]",
            "text": "So now the methods exist but they don't take anything, they don't take the right types of things. And they all return void right now, so we need to do some work. Now I do notice that we've got book, book, book, book, we're referring to kind of a record type by name."
          },
          {
            "time": "[00:03:36]",
            "text": "So what I'm gonna do here is create a map of my records, and by map I just made a type that gives me keys and values. We'll call this EntityMap, since we've talked about the word record before in a different context, and I don't want to overload it."
          },
          {
            "time": "[00:04:06]",
            "text": "Great, so we've got movie, book, and song. The keys are the names I'm gonna use to refer to this kind of entity, and then these are the follow on classes and, sorry, they will be interfaces, because they're in the type position. I mean, we're defining them as classes but they will be the interface part of it, meaning the type of an instance of these classes."
          },
          {
            "time": "[00:04:33]",
            "text": "So in all of these methods here, I could say, kind, by the way, if you ever see kind in TypeScript code, it's because we don't wanna write the word type. That's a special thing, that's like a type alias. Kind is a good alternative to use. So, and this will be, A key of EntityMap, great."
          },
          {
            "time": "[00:04:58]",
            "text": "So now this book thing is gonna be happy. Now I actually want this to be generic, right? So we'll say k for kind. And the reason is, I need to create a relationship between things. So if you remember back to the TypeScript fundamentals, when we talked about generics and type params."
          },
          {
            "time": "[00:05:28]",
            "text": "The whole point of this is we're defining some parameter that describes a linkage between things. So, in the case of get, the relationship is I'm asking for a book, and let's say we provide an ID. And I'm gonna return a book, or maybe like a promise that resolves to a book."
          },
          {
            "time": "[00:05:54]",
            "text": "Let's pretend this is all synchronous for now, you can make it async by just making all these promises instead. But we're gonna return EntityMap[k], this is an indexed access type here, right? We're saying, project the word book through this EntityMap. All right, here's book, grab the value, bring it back."
          },
          {
            "time": "[00:06:18]",
            "text": "And so over here, look at our return type, when we use this string book here, we get a book back. Watch this, when we use movie, check that out, we're getting a movie back. So depending on that word that we're using, we get the right type of entity returned to us."
          },
          {
            "time": "[00:06:42]",
            "text": "Now, we can do the same thing with the collection, it should be very similar. But let's say we don't need an ID here, since we're getting them all, and I'm just gonna put square brackets after this. And let's see what's happening here, getAll('book'), we get an array of books."
          },
          {
            "time": "[00:06:59]",
            "text": "So this is a great use of generics, a great use of an index access type. Create, so here, we want to take an object to create, right? And this is gonna be an EntityMap[k], and this will be a void. So here, if we were to say, I'm creating a book, and in here we get author, right, get some validation."
          },
          {
            "time": "[00:07:31]",
            "text": "If we gonna change this word to movie or to song, song wants artist, From Mark G's new album, right? So, we get that nice linkage between the first argument, which is a literal type, it's a statement of which record we're operating on, and that gives us some really great control over the second argument."
          },
          {
            "time": "[00:08:00]",
            "text": "What about update? So we can actually just borrow this from the create, and we will say to update, or actually we need an ID here, cuz we're referring to an individual record. So we need an ID because we're referring to an individual record, and the only thing we're gonna change is we'll say partial."
          },
          {
            "time": "[00:08:25]",
            "text": "So if you remember what partial is, if we look at the type, it's gonna loop over all of the properties in whatever it's given and make the value type optional. So this means that if we had, let's say, books have a title, In addition to an author, so this would let us say I'm gonna update this book, and I could just do the author, or actually, I could do nothing at all, this is sort of a no update."
          },
          {
            "time": "[00:09:00]",
            "text": "But we get some validation, but we may just have a piece, like I'm just editing one field, right? Whereas up here, if we said book, We need an author, And a title. Something like that. Now we could, implementing these, I would leave as an exercise to you. That's not about the types, that's about the JavaScript, the actual code that you would run."
          },
          {
            "time": "[00:09:38]",
            "text": "So, what we've used here are, within partial, right, we've used a map to type, we've used this little modifier here, we've used an indexed access type. This mapping here is really nice and important, and everything's sort of flowing through that. So this interface ends up being really important because everything sort of threads through it."
          },
          {
            "time": "[00:10:01]",
            "text": "Now, what if we had each of these types of records in its own file? I mean, this is common, right? Where if we have models for data, we have a JavaScript module that is dedicated for book and for movie. Well, watch this. And then delete this, everything's gonna start failing at the bottom, cuz it's an empty interface, right?"
          },
          {
            "time": "[00:10:32]",
            "text": "So key of that empty interface, there's like, nothing's gonna make it happy, and in fact, the key of an empty interface is never. So a no string will make it happy, but we'll get back there, no cause for alarm. So we would still need EntityMap to exist. I'm just gonna create a line here representing different modules, and you'll have to take my word for it that this will work across multiple files."
          },
          {
            "time": "[00:11:00]",
            "text": "So let's imagine that these are all different files, we could do this. We're gonna take advantage of the fact that interfaces are open. I see some head nods, people know where I'm going with this. So, if you maybe have some kind of library or framework that you're using that has like code generation, where it builds starting point files for you, all you need is to have this."
          },
          {
            "time": "[00:11:34]",
            "text": "This is part of your code gen, this little thing. So each record type we have here, a movie, a song, a book, they're all sorta adding themselves to this EntityMap. It's almost like they're registering themselves with this central thing. And it turns out everything ends up being added here and our code starts working again."
          },
          {
            "time": "[00:11:59]",
            "text": "I need a title here, A History of TypeScript, I can't help myself. So, basically, we get the same autocomplete that we had before. If it works. There we go, book, movie, and song, right? So, this has the same effect as if we defined that one interface upfront. So you can have your code split up across many, many different modules."
          },
          {
            "time": "[00:12:31]",
            "text": "You get to group each concern according to movie, and song, and book, right? According to what you're modeling, instead of saying, all right, here's where we maintain all the types, and here's where we maintain the actual code that runs. That to me is the wrong splitting point, I like being able to go to this one file and it's all here, everything having to do with this is here."
          },
          {
            "time": "[00:13:01]",
            "text": "And this shows us that this EntityMap thing and interfaces in general are kind of this cross cutting thing that, You can use to sort of make horizontal things across your app. Meaning, we can refer to this now and it relates to all of the different types of records we could work with, not just one thing in one module."
          },
          {
            "time": "[00:13:28]",
            "text": "Now typically, these will be in separate files, we can kinda simulate that. And we're gonna do this with what's called a module declaration. This is as if, so make TypeScript think that this lives in a library called fem-data. All right, this is actually gonna still work, because we've got these EntityMap things here."
          },
          {
            "time": "[00:13:59]",
            "text": "Sorry, we've got the individual interface declarations for each record, but let's copy this over. Let's see how this works. Cool, now EntityMap is not gonna be accessible here, maybe we can do this. [SOUND] Import, this may be beyond what the, May be beyond what the playground can handle."
          },
          {
            "time": "[00:14:43]",
            "text": "Actually, we may be getting the right auto complete behavior here, let's check one more time. Nope, it's all disappeared. So, beyond the bounds of what can be done in the playground, but this is exactly what you would want if you were breaking things up across many JavaScript modules."
          },
          {
            "time": "[00:15:06]",
            "text": "So you could say, you would define this here where this interface actually exists, some ts file. And then here you could say location/of/entity-map, right? Just like it's a local file of some sort. And that'll make sure that you're modifying the EntityMap that's in that other file. You're augmenting that interface rather than an EntityMap that's in this one module, if that makes sense."
          },
          {
            "time": "[00:15:39]",
            "text": "It's a really powerful pattern that scales nicely, because you can imagine as you add and remove different modules and things, this list of things you could retrieve from the database grows. You don't want one central collision point where they're just tons of git conflicts there all the time."
          },
          {
            "time": "[00:16:00]",
            "text": "This makes it so everything sort of has its own place with one central location of registry."
          }
        ]
      },
      {
        "name": "17-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Just to recap, we begin by setting some goals and talking about how this course is designed to help you understand tricky type information and to give you tips and tricks that you can put right into your app. Copy paste code out of this course, and it'll save you major headache."
          },
          {
            "time": "[00:00:18]",
            "text": "We talked a little bit about how different kinds of declarations stack on top of each other and came to the realization that classes are actually two things stacked on top of each other. It's the factory and it's the instance, right? We talked a bit about modules and CJS interop one of the trickier things where frankly, I have helped a TC 39 members, the people who are on the JavaScript standards body."
          },
          {
            "time": "[00:00:43]",
            "text": "They've had trouble with this and I've had to walk them through this the same way I walked you through it. So don't feel bad if if you get stuck there, and it's a little mysterious. We extracted type information from values using type queries, like type of, then we moved on to conditional types."
          },
          {
            "time": "[00:01:03]",
            "text": "And the built in type script utility types extract and exclude, which are just conditional types behind the scenes. And we saw how having one branch of your condition resolve out to never, that allows you to do some really interesting things. We introduced the infer keyword and we built a utility type to extract an argument out of a constructor."
          },
          {
            "time": "[00:01:31]",
            "text": "And we looked at the example of something like a Webpack config where it's a meaningful type that adds a lot of value to you. But if you didn't have access to it directly, you could kind of suck it up with a vacuum and put it where you wanna put it and refer to it just as if it were an export interface."
          },
          {
            "time": "[00:01:50]",
            "text": "Index access types, this was just a little square bracket notation for grabbing like a sub part of a type. And then finally, this was the big thing we were sort of working our way up to mapped types and that's the thing that looks like an index signature. But we can imagine like we have a lot more control, hopefully you see now where we can loop over all of the keys and a type or all of some other key, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "Any union type that is based off of allowable property keys. And we can combine this with index access types, with conditional types, with those template literal types. And in a very powerful way transform one piece of type information to another. So I hope by the end of this you feel more confident working with type information how to pick it apart."
          },
          {
            "time": "[00:02:42]",
            "text": "You know how to debug it a little bit. And hopefully this will set you on a great path for your continued learning around TypeScript."
          }
        ]
      }
    ]
  },
  {
    "name": "introduction-to-dev-tools-v3",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hey everybody, welcome to this course, I'm really excited about it. This is my third time doing a DevTools course. But this is a brand new format, which I'm really excited about. The DevTools have added a lot of new cool things over the last year, which I'm excited about."
          },
          {
            "time": "[00:00:14]",
            "text": "And this one's gonna be a little bit differently paced in that we're going for a nice introduction to DevTools. So we'll kind of cover it later, but I'm hoping this course will be a really good tool for people whether you're absolutely brand new, been using them a little bit for a little while or are pretty comfortable and just looking for cool kind of tips and tricks and ways to be more productive."
          },
          {
            "time": "[00:00:35]",
            "text": "This whole course is one single repo that repo it's a link here for github.com./jkup/mastering-devtools. Or if you're not able to click on that, you can just go to github.com/jkup. Let me close this. And you'll see it's right on my home page, this masteringdevtools link. And it should be, I've tried to make it as easy as possible."
          },
          {
            "time": "[00:00:59]",
            "text": "So it's got instructions on it. You just clone the repo, CD into it, npm install and npm start. And the only requirement is Node, which comes with npm. So kinda the way that the course works is these pages which you can have locally if you have the repo, I'm just running the repo here so you can kind of see, I have mastering Chrome DevTools."
          },
          {
            "time": "[00:01:19]",
            "text": "I did my npm install. And now I can just do my npm start, and it'll load up the server. Then I go to localhost :3000, and this should be the exact same course that you all have. Just some important links to kind of refer back to. This is the course repository where this course is hosted."
          },
          {
            "time": "[00:01:34]",
            "text": "The official docs to Chrome DevTools are always a really good place they've been especially over the last couple years. They've put a lot of good content on there. They've got cool demos themselves. When they do updates, they mark them in there which is really good. And if anybody needs to get ahold of me, this is my Twitter handle, Jkup and my email address."
          },
          {
            "time": "[00:01:53]",
            "text": "And I love talking about DevTools and the course so please feel free to message me. That'd be kind of an interesting to start because I feel like DevTools are an interesting topic where I'm really passionate about them. I feel like a lot of people find a lot of value in them but they're a little bit of an interesting topic because you won't necessarily find them on the job application, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "It wouldn't be like needs Chrome DevTools experience. So I thought it'd be kind of cool to talk about why I think it's important to learn DevTools. I do think it's just a level up in general, like it's a really cool way to better understand code, better understand performance, all those things."
          },
          {
            "time": "[00:02:33]",
            "text": "It's a great tool for finding bugs quickly. I think that if you're somebody who's really comfortable with the stuff that we'll go over today, so like using the console using a step through debugger, using the audit tools, performance, all that, you'll be able to find bugs at work and fix them a lot faster."
          },
          {
            "time": "[00:02:50]",
            "text": "It's a really cool way to start your journey down web performance. This is not a web performance class, but it really touches on a lot of web performance topics. So it helps you learn network requests, CPU, memory, all these things. And if you are a web performance expert, you will come back to DevTools a lot and use them when you're auditing sites when you're finding bugs or issue."
          },
          {
            "time": "[00:03:12]",
            "text": "And then one of my favorite things about them is it's like when I got started doing web development, my favorite thing was to browse the web, find a really cool website and then learn how it worked. That was what I did when I was beginning. And I feel like the DevTools are a really incredible way to still do that."
          },
          {
            "time": "[00:03:30]",
            "text": "I'll visit a website, and it'll have a really cool animation, and I'll really wanna know how it works. And of course back in the day, it was probably just like a single HTML, a single CSS, and a single JavaScript file. So I could download the whole site and play with it."
          },
          {
            "time": "[00:03:44]",
            "text": "But these days sites are a lot more complicated but DevTools make the complicated site very easy to understand. Like how an animation happens, what CSS they're using for a cool piece that you see, or how they're getting things to load so quickly, all sorts of stuff like that."
          },
          {
            "time": "[00:03:58]",
            "text": "So I think they can be really fun for just playing, exploring, learning too. I also kind of wanted to make a note if you look around, there's all these great courses that exist all over the web, especially on front end masters. And a lot of them come down to this idea of creating, right?"
          },
          {
            "time": "[00:04:16]",
            "text": "There are about how to create react applications or how to create angular applications. But there's not a lot of courses out there that teach you what to do, congrats, you have an app and it's launched and you have users. What do you do now? And I find that a lot of people for their day-to-day job are in that situation where they're debugging things that the users find, or they're dealing with user complaints about speed or they're trying to make the site load faster, something like that."
          },
          {
            "time": "[00:04:42]",
            "text": "And so I think this is cool because it works across all platforms, whether you have an angular site, react site, a node site, a Java site, whatever, you can really learn a lot and get a lot of value out of the DevTools. Cool. So kind of a general high level course outline."
          },
          {
            "time": "[00:04:59]",
            "text": "So we'll start with a little bit of history on how DevTools came to be and kind of leading from where we started up to now. Then we'll do a walk through the panels. I kind of like it so we'll open the DevTools together. We'll click on each panel and we'll do not necessarily a high level, a medium level view of each panel, what it's good for, what we can use it for all these kind of different things like that."
          },
          {
            "time": "[00:05:20]",
            "text": "So we'll walk through those. And then I break the course into different sections. So we'll do a section on editing websites, one on debugging websites, one on network performance, one on CPU performance, one on memory performance. And then we'll wrap up with doing full audits. If you were coming into a brand new site, or you're looking at an old site with fresh eyes, how would we do a top down audit."
          },
          {
            "time": "[00:05:43]",
            "text": "A little bit about me. I'm John Kuperman, an engineer at Adobe and I work on the Creative Cloud. Before that I worked on the brave browser and I worked on twitter.com. I blog over at JohnKuperman.com and I really like teaching workshops on DevTools and accessibility."
          }
        ]
      },
      {
        "name": "1-devtools-history",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this is the first section called the introduction. And what we're gonna learn in this is the history of the browser DevTools. We're gonna take a little bit of a walk down memory lane or maybe not for the younger folks watching, but what it was like interacting with the DOM in the early days."
          },
          {
            "time": "[00:00:16]",
            "text": "And then we're gonna kind of cover the groups that I think this course is really best to benefit. So again, this is an introduction course, so we assume very little knowledge of the DevTools. So if we start at the very beginning, the way to open the DevTools, you have kind of two options, keyboard shortcuts or using your mouse."
          },
          {
            "time": "[00:00:36]",
            "text": "And so you can right click on any website, and you can click Inspect, and it'll open this, typically, it starts as a bottom panel. You can also use keyboard shortcuts, I've got two of them here, so you can use Command+Option+C on your Mac, or Control+Option+C does the exact same thing, it opens the DevTools."
          },
          {
            "time": "[00:00:53]",
            "text": "So we get these open and we have this thing that we're looking at, typically, depending on the keyboard shortcut user on the elements tab. And one of the ways that I like to start this off is by having people just think for a second about, if you had to describe what are you seeing here, how would you describe that?"
          },
          {
            "time": "[00:01:10]",
            "text": "And it's interesting because I feel like a lot of people, and this is not a wrong answer, but a lot of people say, you're looking at HTML and CSS, right? I mean, that's kind of what you're looking at. But the reason that I think it's so interesting is cuz it's not necessarily true, right?"
          },
          {
            "time": "[00:01:24]",
            "text": "It is HTML and CSS for sure, I'm not gonna argue that, margin zero is CSS so that a body tag is HTML. But you're really looking at this fully parsed browser rendered DOM, right? If you think about looking at raw HTML, you would have a very hard time clicking on the body and learning that it had background color of this gray."
          },
          {
            "time": "[00:01:46]",
            "text": "Because you'd have to look at the body, then you'd have to search your code base for some CSS. And you'd have to look at see if there was any body tags and all that. So this is not source code, this is after the source code has been sent down, the browser has done all its work and we're gonna get into what that work is later, and this fully interactive DOM is what we get here."
          },
          {
            "time": "[00:02:05]",
            "text": "And that's an important distinction because, back in the day, we didn't have this cool fully interactive DOM, we literally did have just the HTML and CSS. And so, this screen still exists, if you right click on your browser, and instead of going to Inspect, you View Page Source."
          },
          {
            "time": "[00:02:22]",
            "text": "And so, if you view the page source, you actually get the text content that gets sent down with the page. So here's my CSS which is in line, and then here's my HTML down here. And so, this is interesting, you could still kind of poke around at it or you could copy it all and put it into an ID or something like that."
          },
          {
            "time": "[00:02:40]",
            "text": "But, one of the big things that used to be super painful back in the day, was like let's say that you wanna check something's value in JavaScript, right? That's something we all do, probably all the time, we're like, wait a minute, this link isn't working, what's the value of link right now or what is foo equal."
          },
          {
            "time": "[00:02:54]",
            "text": "So what we used to do back in the day was with a lot of stuff [LAUGH], and some people haven't even messed with alert before. So, if I right click and open up the DevTools, and I go to the Console tab, and I type alert, hi, this used to be the thing back in the day, and I hit Enter."
          },
          {
            "time": "[00:03:10]",
            "text": "You'll see you get this browser rendered thing at the top of your screen that says, hi. So this is pretty cool and at first it kinda looks like, okay, I get it, it's like Console log, but it comes on the top of the screen, that's fine. But alert has a lot of limitations, for an example, if you are to go back in the DevTools again, and go to console and you were try alert anything that's not a primitive, like let's say an object."
          },
          {
            "time": "[00:03:35]",
            "text": "So I do name, and we make this a little bigger, name, Jon, and I tried to alert that you'll see I don't get named Jon, I get this two string version of the object. So, it says alert Object Object. And so, the thing that we used to have to do back in the day if we wanted to read the values of an object, was we would put them in a loop, like a for loop."
          },
          {
            "time": "[00:03:56]",
            "text": "And then we would log out each key and value, and we'd alert each one of those. And so, then you'd reload the site and it would get like an alert, and you click OK, OK, OK, until the whole thing went through. And so, the DevTools offering this interactive DOM, this ability to console log complex statements and complex types, like objects and arrays, is a really gigantic improvement."
          },
          {
            "time": "[00:04:17]",
            "text": "So, yeah, back in the day we're working, we have view page source, we have alert, those are kind of our tools for debugging. And then this really cool tool comes out Hexie's Live Dom Viewer, so I'm gonna open this in another tab. So this was like, you can kind of see it's actually quite similar, in a sense to the DevTools."
          },
          {
            "time": "[00:04:35]",
            "text": "But this was this really great tool, we're able to do things, like make an h1 Hello world, and we're able to see not only the markup, but we're able to see what the DOM is, and we're able to see a preview of it, all in real time. It was like [LAUGH] this is really mind blowing tooI, I know it's something that we take for granted nowadays, but it was this great thing."
          },
          {
            "time": "[00:04:58]",
            "text": "So you could grab that view source, and you could put it in here, and then you could actually start looking at the DOM structure, what it looks like. All these different things you can mess with it and see updates in real time. So that was great, and then and this is like a very old school, this tool came out, Firefox Firebug."
          },
          {
            "time": "[00:05:14]",
            "text": "And it was the very first built in browser extension that was a DevTool. And one of the things I always like to point out is that, if you use your imagination a little bit, this thing that came out, whatever, 20 plus years ago or something like that. It doesn't look too different than what we have today, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "I mean, if you look at this, you've got your HTML structure over here and you've got the corresponding CSS over here. We've kind of moved things around and all that but, essentially, Firebug comes out and sets this gold standard for development experience. There's a ton of stuff I can't do, of course, cuz it's a long time ago, but this was a giant change in how people built and edited and debugged websites."
          },
          {
            "time": "[00:05:55]",
            "text": "And so, Firebug was this incredible tool, kind of first of its kind, and a few years ago back in 2016, they officially sunsetted it. A lot of the core got moved into Firefox itself, Firefox comes with its own DevTools now, but it was sort of this big moment for us."
          },
          {
            "time": "[00:06:11]",
            "text": "Where we had all of a sudden our efficiency sped up, like a hundredfold and we could debug complex things. And we could just do, all this stuff that we couldn't do before, that's a really cool tool. And I was very sad when it got sunset just cuz it's kind of the end of an era."
          }
        ]
      },
      {
        "name": "2-elements-network-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hello, I mean this course is made for anybody but who I think I have content in this course for types of people that I think will get the most out of it. So I think anybody with little to no experience using Chrome DevTools, I hope to be able to walk you through each panel, what they do what they're good for, all that stuff."
          },
          {
            "time": "[00:00:18]",
            "text": "Probably when I pull people the most common group that I get are people who have used the Network and the Console panel before. They console log stuff, they've checked it or they've looked at the network overview and they have seen what comes in. But they've really never clicked on any of the other panels before."
          },
          {
            "time": "[00:00:34]",
            "text": "Maybe they clicked on it and it seemed overwhelming so they clicked away from it. So I'm hoping this will be a really nice introduction to the rest of those panels as well as learning a lot more about network and console. And the third group is people that are comfortable with the panels, but working to learn some tips and tricks."
          },
          {
            "time": "[00:00:50]",
            "text": "One thing I always love, I love keyboard shortcuts, I love experiments, I love little known things, little things that I pick up along the way. So all my workshops that I do, I try to fill with as many little tips and tricks sections as possible. Cuz I find them just really fun and they kinda help me speed up."
          },
          {
            "time": "[00:01:08]",
            "text": "All right, so now we'll move into the next lesson, which is what can the DevTools do? And so this lesson really we're just gonna go through each one. And we're gonna start playing around with them on a very high level, but just seeing some actual stuff that we can do with the DevTools."
          },
          {
            "time": "[00:01:24]",
            "text": "And then we'll get down into the course format for the rest of the course afterwards. So I kinda have two things I wanna point out before we go into it. One is a little bit about not feeling overwhelmed with stuff. I find a lot of times when I sit through workshops, there's so much incredible information."
          },
          {
            "time": "[00:01:42]",
            "text": "And sometimes I start getting a little bit stressed that I'm not gonna be able to retain all of it, right? I'm like, I gotta remember that, and that, and that, and that. So if I were to give you advice, I would say that I think it's more important to know what they can do, then how they can do it."
          },
          {
            "time": "[00:01:57]",
            "text": "Cuz if you know what they can do, you can come back to this final masters course, or you can look at the Docs or you can even just look at the DevTools and try to figure it out for yourself. So if I were to ask for one big takeaway, it would be only just try to remember I've seen DevTools can do this really cool CPU thing now I know exactly how to read a flame graph, right?"
          },
          {
            "time": "[00:02:14]",
            "text": "Those are kind of differences. And the other one, which is something we were talking about a little bit earlier, is that the Chrome extensions like plugins that you add to your browser can and often do mess with DevTools data because they can and often do mess with how you actually render websites."
          },
          {
            "time": "[00:02:31]",
            "text": "And this can lead to really inaccurate reporting. And this has bitten me a lot of times at work before. So my suggestion is, if you're doing something important, like you're auditing a customer's website, or you're trying to find if there's a memory leak on your page, I would either go ahead and disable all of your extensions, which you can do up at this window extensions tab."
          },
          {
            "time": "[00:02:52]",
            "text": "Or just open a new incognito window for the site that you're viewing, incognito windows by default have the extensions turned off. So I think that's always a good tip because there's a lot of stuff going on with these Chrome plugins that you might see new scripts being added to the DOM."
          },
          {
            "time": "[00:03:08]",
            "text": "You might see network requests being rejected or new network requests, all sorts of stuff that can be really tricky to figure out why it's happening. And it's often just a Chrome extension that you have. Awesome. All right, so let's begin with walking through the panels. So I'm gonna go ahead and I'm gonna open the DevTools."
          },
          {
            "time": "[00:03:26]",
            "text": "And we're gonna kinda go down this little list of high level things, and we'll just play with a little example of them so we can kind of see them visually happen. So the first panel is the elements panel. And I guess actually, before I go into each panel, it should be worth noting that these tabs can be dragged and dropped, and they persist in whatever order they're in."
          },
          {
            "time": "[00:03:45]",
            "text": "So if you see yours in a different order than mine, it's probably just because I've dragged mine around, nothing to worry about. You can drag these around until whatever order you want. But on the website is the order that I'm gonna be going through them in. Cool, so the Elements panel."
          },
          {
            "time": "[00:03:59]",
            "text": "So again, you're able to play with all the HTML and CSS. I find it's really interesting when in doubt, try double clicking something cuz it's really interesting what you can interact with here. So for example, some things might be more obvious like we can go ahead and take the body element here, and I'll click on it."
          },
          {
            "time": "[00:04:17]",
            "text": "And we can kind of scroll through all the CSS that applies to it. And so, we could do things like you can see the background color is gray. So I could change the background color to red and in real time the background of the website will update or purple, something like that."
          },
          {
            "time": "[00:04:32]",
            "text": "You can also change the actual property though. So, instead of background color, you could change it to color entirely. And now you'll see this is getting crossed out because there's two colors. But I would say always try double clicking on stuff. You can even double click on the selector itself."
          },
          {
            "time": "[00:04:50]",
            "text": "So if we set this back to background color, and I'll go through this auto select here, and that's purple, we could change this from body to div, something like that. And now you see the body has gone back to being its default color but every div on my site is now purple."
          },
          {
            "time": "[00:05:05]",
            "text": "And so there's a lot of different stuff that you can double click on. Another one that surprises me the first time was that if you take an element over here, like let's say this h1, let me scroll up a little bit so we can view it together. This is this title element that says lesson 2 here."
          },
          {
            "time": "[00:05:19]",
            "text": "You can even double click on the element itself. And so you can change it from an h1 into an h2. So there's two cool things here, one that you can edit the HTML. But two, if you notice over here, I know it's quite subtle, but If you change an opening tag, Chrome DevTools will automatically change the closing tag for you."
          },
          {
            "time": "[00:05:36]",
            "text": "So you can just change the opening to an h2 and hit Enter and there we go, it gets smaller. So I'll change this back to an h1, and we'll scroll back down to the lesson. You can also change classes and IDs. Again, the thing that might be more obvious you can see here we have an article with ID of main."
          },
          {
            "time": "[00:05:53]",
            "text": "The thing that might be more obvious is that we can change the ID from main to app or something like that. And you can see that explodes a lot of the CSS cuz I was using main as a selector. So I'm gonna go ahead and set it back to main."
          },
          {
            "time": "[00:06:04]",
            "text": "But the thing that might be less obvious is that you can actually double click on the ID portion itself and change it to maybe a class name of main instead, which still breaks because my CSS is looking for an ID. So pretty much everything in here is double clickable, which is really cool."
          },
          {
            "time": "[00:06:20]",
            "text": "You can also do things like, we saw that you can update these styles. But you can also do a lot of cool things for example, you can add a brand new style so we can click on this plus sign over here. This is on the right sidebar. And we can create a new style rule."
          },
          {
            "time": "[00:06:38]",
            "text": "And so, if we had one, we wanted to be more specific than, ID of main, we could do the default one is article of main. And so you can see whichever thing you've clicked on when you click new style, it kinda tries to pull a very specific selector for you."
          },
          {
            "time": "[00:06:52]",
            "text": "But you can put anything you want in here, like class of foo or something like that. These are also drag and droppable. So if you grab on to one of these like the h3, you can move it above the h1. And that will see back up here my course is now out of order."
          },
          {
            "time": "[00:07:07]",
            "text": "The h1 down here and the h3 over here. Yeah, so I finally have done like a really good job of making this page, sort of like Apple does with their products where it's pretty intuitive or like the thing you'd wanna do. I would just give it a try."
          },
          {
            "time": "[00:07:20]",
            "text": "[LAUGH] Always give it a try if you wanna make a new selector, drag stuff around, move it anything like that. Cool, and we'll get into a bunch more stuff cuz the elements tab can do amazing things later, but that's kind of the high level view. The Network tab."
          },
          {
            "time": "[00:07:34]",
            "text": "So this one, the basic idea is if you go to the network tab and then you refresh your page when you're on it, the probably most common thing that we do and let me hide a bunch of this other stuff for now, is we look at the stack of all requests sent."
          },
          {
            "time": "[00:07:49]",
            "text": "And so this is pretty cool. It's basically if you think about how a webpage works, right? You hit the server and the server always gives you an index.html, right? Or whatever, a file name.html. It's always the beginning, right? Because HTML is what we need for the very first request."
          },
          {
            "time": "[00:08:04]",
            "text": "So always see the top one here being an HTML or they call it document type over here. And if you click on it, you can actually see what the response is. I do have inline styles which might be a little bit confusing, but this is an HTML file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then what it will do is it'll walk this file and it's looking for any references to external resources, right? So when we do HTML, we often put links to CSS or script tags to JavaScript. Those are two very common things we do. We also put image tags, right?"
          },
          {
            "time": "[00:08:35]",
            "text": "And so as it's walking this, it'll say every time it's like, you need a CSS file, it'll go out and it'll fetch that. And so you can kinda see the network sort of works that way where it fetches the document, it reads through it, eventually it sees that I'm linking to a script."
          },
          {
            "time": "[00:08:48]",
            "text": "So it goes out and fetches that script. This is called prismjs I use it for my code snippet styling. And then it'll keep reading and keep reading and then eventually it gets to a font tag. I use a custom font in here, so it goes out and fetches that."
          },
          {
            "time": "[00:09:03]",
            "text": "So yeah, this is basically in order every request that was sent, and a bunch of cool information about it, like the http status, who initiated it, what type it is, how big it is, how long it took all sorts of great stuff. And we'll get into some really cool ways that you can actually diagnose a lot of really cool things including server issues, all from the network panel the DevTools when we cover that in the network section."
          },
          {
            "time": "[00:09:29]",
            "text": "So yeah, you can measure all sorts of page load stuff, so you can look at how long each file took. But you can also look down here at these really important events. So when we use a tool like Google's Lighthouse, which we'll cover later or web page test, any sort of tool to measure the speed of our website."
          },
          {
            "time": "[00:09:45]",
            "text": "The two events that it's always looking for like when did DOMContent loaded file and when did unload file. And so those are both built right into the DevTools here where you can see when they filed. You can also watch your site load in real time. This is like a lesser known thing that they offer."
          },
          {
            "time": "[00:10:03]",
            "text": "So if you click this setting cog up here, not the top one for all Devtools, but this one over here for network settings you can do capture screenshots. And then if you refresh again with capture screenshots, you can actually see when we audit sites later we will actually be able to watch the HTML come in unstyled, and then an image load and then a font come in and restyle everything."
          },
          {
            "time": "[00:10:26]",
            "text": "So we'll actually be able to see kind of all that stuff happen in real time. So these are the screenshots of the site loading. And then we're able to inspect request and response data. So when you're working with JavaScript, and especially when you're working with API's, so if you're at work or if you're doing a side project and working with some API especially when it's not working, they'll often ask for data about the headers sent either by the API or to the API."
          },
          {
            "time": "[00:10:53]",
            "text": "And so if we take like this request for prismjs, and instead of looking at the response, I'm gonna make this a little taller. We go over here and we look at the headers, we can get a lot of information from it, so you can see what response headers were sent down from the server."
          },
          {
            "time": "[00:11:07]",
            "text": "And you can see what headers you sent in your fact requests. These are gonna be the default ones, cuz it's just a script source. But this comes in really handy where oftentimes at a job your service will have some kind of request ID, some way of identifying it."
          },
          {
            "time": "[00:11:22]",
            "text": "And the service team will often ask you for that ID, because they wanna be able to look it up in their logs and see what went wrong, something like that. So that's a really common example I face where I say, hey, this user status API is broken. And they're like, well, can you give me an example request and I give it to them."
          },
          {
            "time": "[00:11:38]",
            "text": "And they're like, okay, well, can you give me your request ID. So then I come into the DevTools, I refresh and I look for the request ID header. So that happens a lot."
          }
        ]
      },
      {
        "name": "3-performance-console-security-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, performance. So, I [LAUGH] had sent out a tweet a while ago about what people would love to learn more about web dev tools and like pretty much across the board I got that people are scared of the performance tab. That's like a very [LAUGH] common response that I found from people."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really not that scary, but it is very, very powerful. For a little bit of context, it used to be two different tabs. They've kind of combined into one, and it has a lot of data. And so, the kind of high level view of how to use this is you go to the Performance tab, you click on this record button."
          },
          {
            "time": "[00:00:33]",
            "text": "You interact with the site, doing anything you want, and then you click stop. Some top level advice is to keep your recordings as small as possible so they keep you from being overwhelmed with like ten seconds worth of data. So, I usually, if I'm nervous about like filling in a form, I'll click Record, fill in the form quickly and click stop."
          },
          {
            "time": "[00:00:53]",
            "text": "Try to keep it contained as much as possible. You can also deselect things depending on what you're looking at. So, right now I have memory showing down in this section. Let's say I'm not concerned with memory right now, I can just hide it. I also have the same screenshots from the Network tab, which can be really useful."
          },
          {
            "time": "[00:01:08]",
            "text": "You're seeing how your JavaScript causes stuff to render, but if you're not looking for it at the time, you can just deselect it. And so, what you'll kind of be left with here is a little bit of showing how the website painted itself over time. So, this is your frames per second across the very top."
          },
          {
            "time": "[00:01:24]",
            "text": "And this is the CPU usage across the bottom. And then, you'll see all these different frames down here. So, you can see almost everything is gonna happen in the main thread. But you can see stuff like when it's rasterizing, when it's using the GPU, all those different things."
          },
          {
            "time": "[00:01:38]",
            "text": "We'll have a full lesson on performance auditing and stuff like that. But the basic idea is you hit Record, you do something that you're worried about, and then you hit Stop. And you can come in here and you can look for like, is there page jank? Like is it lagging?"
          },
          {
            "time": "[00:01:52]",
            "text": "What's the main thread doing? How busy is it? What's the memory usage? Or what's my CPU usage? Is it getting too high? All sorts of things like that. I think it's best to come in here with a specific question in mind, that also helps reduce how overwhelming it can be."
          },
          {
            "time": "[00:02:06]",
            "text": "So, it'd be like, I really wanna know if I have a memory leak. That's what I care about. So, you can turn on the memory, you can do your thing and you can look for a memory leak and we'll do that in the appropriate section too. Console, probably the most popular one."
          },
          {
            "time": "[00:02:22]",
            "text": "It's really cool, it's a JavaScript repo. So, you can type stuff like console.log('hi'), and it'll type hi. You could do var foo = 'foo', and it'll save that. And then later, you can do foo. That's pretty straightforward. Anytime you put a console log in your code, it'll log out here."
          },
          {
            "time": "[00:02:42]",
            "text": "But there's also some really other cool things you can do. Like for an example, you can go into the elements tab, and you can find an element like let's say this article, you can click on it. Then you go back into the console tab and you can do dollar sign zero."
          },
          {
            "time": "[00:02:55]",
            "text": "And dollar sign zero is a shortcode for whatever I last clicked on in the elements tab. So, if you hit enter, you can see it brings this article into the console. So, now if I wanted to manipulate it, like I could do, addEventListener, click or something like that."
          },
          {
            "time": "[00:03:12]",
            "text": "You can take an element from the elements tab, you can bring it into the console, you can mess with it there, which is pretty cool. All right, next is the Security tab. Again, this one's pretty straightforward. It just gives you an overview on the security for your page."
          },
          {
            "time": "[00:03:25]",
            "text": "So, it is the de facto standard these days that all sites should load over HTTPS. There's all these really cool resources, like Let's Encrypt, which gives you Just free SSL certificates. And so if you go to any website and you click any open dev tools and click on the security, it'll give you an overview."
          },
          {
            "time": "[00:03:43]",
            "text": "And the reason that there's an overview is one, it'll tell you if the actual index dot HTML file, like the main request was served over HTTPS. But it'll also tell you if any subsequent requests were served over HTTP, which can be insecure. So, you could have a fully secure site, and then you add like an embed for a video or something like that."
          },
          {
            "time": "[00:04:01]",
            "text": "And that might be over HTTP, which still leaves you vulnerable. So this is cool. Basically, on the high level, you want to open it and you want to see green. That's what you want. If you open it and you see green, everything's good. If you see any orange or red, it'll give you appropriate instructions for why it's doing that."
          },
          {
            "time": "[00:04:17]",
            "text": "It also lets you view the SSL certificate itself if you have any reason to be viewing that."
          }
        ]
      },
      {
        "name": "4-sources-application-memory-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The sources tab, this is one that I feel like it's kind of underrated. It's basically a full ID and so over this course we'll learn how to do. We'll learn how to use the courses tab for step through debugging, which is really cool. So instead of just console logging, we'll be able to put a break point, we'll be able to pause the whole execution stack at that break point and kind of move around."
          },
          {
            "time": "[00:00:23]",
            "text": "We can check the call stack, like how we got there, what functions got called. We can keep an eye on certain variables, like watch a variable and see how it changes over time. But we can also use this really cool thing called work spaces, where we can drag our project into the dev tools, and after we set it up correctly, everything that we edit will actually persist to disk."
          },
          {
            "time": "[00:00:43]",
            "text": "So normally if you're in the elements tab, and you're messing with the CSS, I don't know who's gotten into this before. This happens me all the time, so I'll be like working on design I'll go into my elements tab and I'll get it perfect right. It's like the CSS look at the site looks like exactly perfect, but I've been working for like an hour."
          },
          {
            "time": "[00:00:59]",
            "text": "When I'm ready to ship it, I'm like, I don't even remember what all I changed at this point. Like I added so many classes and I added so many selectors and styles like, it's really difficult to figure out what you change. And so workspaces can be really cool cuz you still get that instant feedback of working in the sources or elements tab."
          },
          {
            "time": "[00:01:15]",
            "text": "But you can actually hit like Ctrl S or command S and it'll save it to disk, so we have a whole exercise on that for later. You got the application tab, I usually refer to this one is just storage as like a way of thinking about it. So this is where you'll come probably primarily to look at all the different ways we have of like caching and serving things locally."
          },
          {
            "time": "[00:01:36]",
            "text": "So that's like local storage, session data, cookies, index db, all sorts of stuff like that. It's also the place that you come if you have a progressive web app with a ServiceWorker. So if you have a service worker, it also has a service worker tab, where you can see is there a worker is it being registered, what it's doing all sorts of stuff like that."
          },
          {
            "time": "[00:01:55]",
            "text": "It's also maybe most commonly used to come into the storage and click clear all site data. That's probably what I use it for the most right so when you're like, you know you're in a weird state and you cache something or you're messing with sessions or cookies and it's everything's bad."
          },
          {
            "time": "[00:02:11]",
            "text": "You just come in here click clear site data, refresh the page and get a nice clean start. We've got the memory tab, so this one is very specific to your memory consumption. But it's really cool, so you can take a heap snapshot, which is like show how memory is currently being used in my app."
          },
          {
            "time": "[00:02:30]",
            "text": "You can do a timeline so you can like the profile or the performance page, you can record over time, and you can do stuff and you can see what you're doing that's using memory or not. And then there's this new tool which is like probably one of the things I'm most excited about, which is you can allocation sample."
          },
          {
            "time": "[00:02:46]",
            "text": "And that'll help you now that you have a memory leak hypothetically, it'll help you figure out what job script code you're using that's actually causing that memory leak. Because in the past it's been really easy to find out that you have one and it's been much more difficult to figure out why you have one."
          }
        ]
      },
      {
        "name": "5-lighthouse-device-emulation-element-finder",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Then we'll cover the Lighthouse tab. This one's great. This has been kind of a cool story to watch. So years ago, Chrome came out with this idea of Lighthouse. It used to have an audit tab, which kind of did similar things that came out of this idea of Lighthouse."
          },
          {
            "time": "[00:00:13]",
            "text": "It's like fully open source. It's contributed to by all these great people and it's just cool rules for, your site should have a first paint in this much time. Or if you say it's a progressive web app, it should work offline. Or if it should be accessible for people with disabilities or you should be taking advantage of Google's SEO recommendations, all this stuff."
          },
          {
            "time": "[00:00:36]",
            "text": "So they came out with this idea of Lighthouse and it used to live on its own website. And so in my last time teaching this course, I was use the audit if it's a local site. And if it's not a local site, go to Lighthouse and use Lighthouse."
          },
          {
            "time": "[00:00:49]",
            "text": "Lighthouse is awesome. But now Lighthouse is fully integrated with the dev tools itself, which is great. So you can do it all on a local site. Just to explain what I mean by that. If you have a great site like web page test is one of the best ways of like analyzing your site, but you have to a URL and hid it, right?"
          },
          {
            "time": "[00:01:05]",
            "text": "So if you haven't published your app yet, you can't use that website to measure it. So the dev tools are great, cuz even like we are if you're just on a local host, you can still run it. So I haven't published yet, but I wanna know how it's doing."
          },
          {
            "time": "[00:01:17]",
            "text": "So Lighthouse is this full page audits, we'll talk about all these great stuff its get. It's the place I'll always recommend starting if you're trying to gauge performance of a new app. Come here, it'll give you so much feedback before you have to dive into the weeds of network memory CPU."
          },
          {
            "time": "[00:01:34]",
            "text": "And also it can do other cool things, it can emulate devices. So this little button over here to the left,, you can click it and it will give you all these different options for exact screen sizes. So for folks that do a lot of front-end work and design, you can see exactly what your site will look like on a pixel two or something like that."
          },
          {
            "time": "[00:01:52]",
            "text": "And more than just shrinking your screen, this will actually send the appropriate headers. So if you have a server that reads in the request header and says, it's a mobile device, go here. Otherwise, send this. This will convince you that it is a mobile device. You can zoom in and you can actually test out."
          },
          {
            "time": "[00:02:08]",
            "text": "I hope you can see, but my mouse cursor is turned into a little touch circle. And so you can test out touch events too, which is which is really nice. Click that to go back and the last thing is this nice little element Finder. I use this a lot and I see people not using this a lot."
          },
          {
            "time": "[00:02:24]",
            "text": "So if you're looking for a specific element like this emoji or something like that rather than going into elements and trying to like drill down into it this way, you can click on this and then you can start moving around and it'll hover on different things. And whatever your click on, whatever it's hovering, it'll focus that."
          },
          {
            "time": "[00:02:40]",
            "text": "So I click on elements and it clicks it in here, and I can find that emoji really quickly. At the end, we'll go into a bunch of different settings and some experiments and some really cool stuff that you can do over here. But that's kind of the cover for the most part."
          },
          {
            "time": "[00:02:53]",
            "text": "The other thing that's important is you can choose where it's docked. So you can go to the right, to the left or pop it out. And one thing that's kind of interesting when we did the network tab, right, we did screenshots, but the screenshots you can see are really minor."
          },
          {
            "time": "[00:03:07]",
            "text": "And the reason is since we have the dev tools open here, Chrome only has to render this exposed part of the screen. So you won't get a full screenshot of your app, unless you go here. Pop them out and then you refresh. And now that Chrome actually has to render the full site, you'll get full size screenshots."
          },
          {
            "time": "[00:03:25]",
            "text": "So that's kind of the high-level view of each panel. We're gonna be spending a lot of time in each one. But just so when you see them, you can be, I know what that one's for. That one does memory stuff for that one checks HTTPS or that was the step through debugger, those kinds of things."
          }
        ]
      },
      {
        "name": "6-quick-edits-css-html-scroll-into-view",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's worth noting that there's a really cool feature that the DevTools offer. Which is if you own an Android device like an Android tablet or an Android phone, you can actually plug it into your computer and you can test your local apps on that Android device. It's not covered in this course but I do have a link to a really good doc on how to get that set up and going."
          },
          {
            "time": "[00:00:18]",
            "text": "That can be really good because, I think we've all seen it before where we use an emulator or like we control the screen to the right size and it looks perfect. And then it actually gets out on a user's device and it's not quite the same, they render a little bit differently."
          },
          {
            "time": "[00:00:32]",
            "text": "So being able to render your web app on a real android phone or Android device can be really valuable. And a lot of big companies will have device labs of some sort. Well, they have a bunch of old phones and stuff like that. So that can be really good."
          },
          {
            "time": "[00:00:44]",
            "text": "So quick edits, I'm going to go ahead and open my DevTools again. And this time, I'm gonna pin them back down to the bottom of my screen. So we've kind of seen this one already. We can go ahead and we can edit any CSS we want. So if we wanna change like the font color to red, or if we want to change the font family."
          },
          {
            "time": "[00:01:06]",
            "text": "Let me change this back to black so you can read it, I'm gonna change the font family to Arial or something like that. Anything we do over here will get reflected here. We can add new CSS rules. So I did show this already a little bit, but you can click this plus and you can make any rule you want."
          },
          {
            "time": "[00:01:22]",
            "text": "So you could do body nav or something like that. Or you could do a new ID of foo or a class of foo. You can do anything like that. You can edit the HTML. So we saw in the beginning that you can edit the tags by double clicking, you can edit the ID by double clicking."
          },
          {
            "time": "[00:01:41]",
            "text": "You can even edit the content here though by double clicking. So if we scroll up to the top here, I can change, Hello world, and I can hit enter on that, and that'll change. You can even for sometimes because you'll have a lot of content, you can right click on it and you can click Edit as HTML."
          },
          {
            "time": "[00:01:57]",
            "text": "And that will take the current element and it will give you this like really nice text editor. So maybe that's more comfortable and you can move around, add new lines, things like that. Depending on what you wanna do. Scroll into view is one of my favorite ones. So I work on a lot of infinite scrolling applications, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "And they get really long. And sometimes we'll have a bug, I'll be able to use the DevTools to figure out which, let's say we're working on Twitter, or we've got 100 tweets on the screen. And I can figure out the ID of the tweet. That's a problem, but I don't know where it is yet."
          },
          {
            "time": "[00:02:33]",
            "text": "So for an example, I'll use this inspector and I'll click on the Scroll into view, list item. And so here I have it in DevTools. So if I was to scroll all way down and I really wanted to mess with it, I can hover on it and I know this is subtle unfortunately can't make it larger."
          },
          {
            "time": "[00:02:49]",
            "text": "But, let me move to a clear area, when you hover on it, it will either show. If you put your eye up here, where my mouse is, it will show either a little arrow saying the items above where we are. Or if I was to go too far and hover on it, you'll get another little arrow here saying the items below where we are."
          },
          {
            "time": "[00:03:09]",
            "text": "So this used to be the best way we had to deal with it as you would hover it in DevTools and you would listen to the instructions. You scroll a little bit. It's still low, you'd scroll a little bit like I went too far. It's high now, all that."
          },
          {
            "time": "[00:03:19]",
            "text": "But now what we can do, let's say we're all the way at the bottom of the page is we can right click on a DevTool. And then click Scroll into view. And it'll actually move the view part right around the element that we have, which can be really helpful."
          },
          {
            "time": "[00:03:31]",
            "text": "Again, if you work on either just long or infinite scrolling websites. Console shortcuts, so I did cover $0 already. So if you click on an item and you go into the Console New $0, it also keeps some history. So we clicked on article, then we'll click on nav."
          },
          {
            "time": "[00:03:48]",
            "text": "So if we go back to the console $0 has now become nav, that's the thing that we clicked on most recently. But $1 will stay article. So it goes back through three so you can kind of keep some history of the different elements that you're working on. You can hide and show elements, which is kind of cool."
          },
          {
            "time": "[00:04:03]",
            "text": "So if I scroll up to this, Hello World, and I hit h it will hide or show the element, this can be really nice when you're kind of doing some design. You wanna move some stuff around, but the text is in the way or something like that. You can hide it."
          },
          {
            "time": "[00:04:16]",
            "text": "You can also, there's just times where you can just right click and just delete the item, right? And that will actually take it out of the DOM. So you notice the difference. Let me refresh the page. When I go to this h1, and I hit h, it sets it to display or visibility hidden, which means it stays so the space around it stays."
          },
          {
            "time": "[00:04:34]",
            "text": "But when I either hit the delete key or right click delete, it actually plucks it from the DOM and the DOM adjusts. Refresh again. You can simulate state. This is another cool one. So if we take this and we go find one of my links like this Quick Edits, so we've got Quick Edits down here."
          },
          {
            "time": "[00:04:51]",
            "text": "You can click this colon hov and you can simulate a lot of different state like hover active focus, all these things. This is really funny because I pair program a lot and sometimes I'll be pairing with someone who's working on a hover state. And they'll be like doing like this, like they'll be hovering over it."
          },
          {
            "time": "[00:05:08]",
            "text": "And then they'll be looking down here in the style section trying to see what's changing. So you can really just put the hover state on it. And now I can fully see what hover CSS is applied and I can edit it."
          }
        ]
      },
      {
        "name": "7-quick-edits-computed-styles-specificity",
        "timeFrames": [
          {
            "time": "[00:00:02]",
            "text": ">> All right, we can also get computed styles. I'm gonna cover this a little bit later. But CSS is kind of an interesting language because it doesn't have a compile time or it doesn't have errors in the same way that maybe JavaScript does. So for example, if we wrote some CSS that was, class of foo background red, and then right afterwards we wrote, class of foo background blue."
          },
          {
            "time": "[00:00:27]",
            "text": "How is CSS supposed to deal with that, right? We've got this kind of conflict. In JavaScript we throw an error or it would just assign the latest one that's been given, right? If you did like var foo equals red foo equals blue. It would just set it and it's just a constant with error."
          },
          {
            "time": "[00:00:42]",
            "text": "But CSS is a little bit weird. And it's also weird because, the CSS when you write it isn't aware of the structure of the DOM, what it will be when it actually renders. So that sounds complicated, but I don't think it really is. So let's say we write CSS where we write, all divs are blue and anything with the class of foo is red."
          },
          {
            "time": "[00:01:04]",
            "text": "That seems like pretty straightforward, right? Divs are blue things with foo are rad. But then let's say we make a div with the class of foo. Now all of a sudden CSS has a problem, right? Because you've told it now two different things apply. And so what it does is it follows these rules called CSS specificity, and it's basically a big giant fight, [LAUGH] right?"
          },
          {
            "time": "[00:01:24]",
            "text": "Where they all the selectors that exist on a given element fight. And so Estelle has this really great website, which I've linked to here called CSS Specifishity. And it's a little comic which kind of helps you understand how these CSS rules play out. And so you can see each type of selector in the top left, a cute drawing in the middle, and then it's kinda score down here."
          },
          {
            "time": "[00:01:50]",
            "text": "So you can see the weakest selector of all is the star, the asterisk, and that will apply to everything universally. So sometimes you'll see like asterisk, margin 0, padding 0 on a website. So just kind of by default, stuff doesn't have padding. And then we get into an element selector, and then we get into a double element selector, then more and more selectors."
          },
          {
            "time": "[00:02:10]",
            "text": "So if you have a ul with an li with a span in there, if you do span, blue, li span, red ul li span yellow, it'll be yellow cuz that's the most specific. Because it's got three in there. Then it goes into classes, then it goes into an asterisk with a class anyway kind of follows the whole way up."
          },
          {
            "time": "[00:02:31]",
            "text": "But what's kind of important to know is that element selectors are the weakest type of selector besides the asterisks. And then it classes are also pretty weak. And then as you get up IDs are pretty strong. And then inline styles like in your HTML so if you do div style equals background blue is really strong and the only thing stronger than that is an important tag."
          },
          {
            "time": "[00:02:52]",
            "text": "Which we all try to keep probably out of our sights, but they find their way in anyway. But that's just like, this isn't a CSS class. But that's a high level view which is needed for this next section because CSS has a really hard job where you author it, and it runs having no idea what DOM what HTML is gonna run on."
          },
          {
            "time": "[00:03:11]",
            "text": "And so it needs these are rules for when there's conflicting information. So computed styles back to where I was before, is really cool. So you can click on an element like let's go find this h2 here. And then instead of being on the styles tab, which is probably the one we spend most of our time on, you can click computed."
          },
          {
            "time": "[00:03:29]",
            "text": "And what computed is going to give you is a list of like okay after the fight happens, [LAUGH] I don't know how else to phrase it besides the fight. But after a CSS specificity rules are all applied, these are the things that won, right? These are the things, so if you had for an example, we can take the h2, and we can say okay, h2s are all blue, right?"
          },
          {
            "time": "[00:03:52]",
            "text": "And so that h2 turns blue. And then, but it's got an idea of quick edits, right? So we go ahead and we make a new selector and we do quick edits and we do okay. Well, quick edits, those are all red, right? And so as we'd expect, it turns red because an ID is stronger than an element, right?"
          },
          {
            "time": "[00:04:09]",
            "text": "But when you work on big apps with a lot of teams all contributing stuff, it's never quite this simple. It's like two selectors, right? It's like everybody's bringing selectors to the table. So you're like every component has its own stuff and different teams write different stuff. And, oftentimes people come up with these solutions like scoped styles or BAM or all these different things to try to deal with this cuz it gets really difficult."
          },
          {
            "time": "[00:04:33]",
            "text": "When I work at Twitter which is a massive web app, I can't tell you how many times I would get a ticket like extra boarder appearing on tweets when you're logged out and you are viewing this and reply. And I'm looking at CSS to try and find specific role, it's like ul li so the idea of tweets and class of active tweet, all that stuff."
          },
          {
            "time": "[00:04:51]",
            "text": "Really confusing. So computed styles can be really great because you can go to computed styles, you can try to find the thing you are looking for like, why is it red, right? You can find that color is red, that's fine. Then you can click this little caret here, and it'll say, look, here's a list of all the things that change the color, and here's the one that won out, right?"
          },
          {
            "time": "[00:05:11]",
            "text": "And so if you click on this little arrow next to the one, it'll take you back into the styles tab, right? So we've gone from key to back in the styles, and it'll show you where that is. So computed is really cool. It also shows you the full box model."
          },
          {
            "time": "[00:05:26]",
            "text": "Again, this is not like an HTML or CSS class, but I assume a lot of people have heard the term box model before, the HTML box model. And so it's basically it's like you have a thing and it has a size, but then it has padding potentially, then it has border potentially, then it has margin potentially."
          },
          {
            "time": "[00:05:43]",
            "text": "This is a really great way of visualizing it for any element. So you can see the element has a size 1200 by 38. It has no padding, no border and a margin of 33 on the top and 8 on the bottom. This is gonna be really cool too when you're just trying to visualize how stuff's gonna render."
          },
          {
            "time": "[00:06:00]",
            "text": "Yeah, and so this is a great tool, especially for big apps where you're trying to figure out why something is the way it is. You can just go ahead and refresh, you can be like why is this black cover on it? See there's only one rule, click on the arrow and it will take me right to the actual line that sets the color to black."
          }
        ]
      },
      {
        "name": "8-quick-edits-html-breakpoints-themes-accessibility",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> HTML breakpoints, these are another really, cool thing. So this is like an anecdote, but I had this job once where I was working on a tool. And the tool was essentially this giant table that was populated with data in real time. So like little cells of the table table would always change and I was really new on this team."
          },
          {
            "time": "[00:00:20]",
            "text": "And we had a bug where when one would change, sometimes it would go blank, it would like update and it would go white and the bug was to figure out why that was happening. And so this is like back to the very first slide of like dev tools can kind of help you level up If I was not good with dev tools, I would have done what everyone else would have done."
          },
          {
            "time": "[00:00:40]",
            "text": "I would have either asked around, or open the code and start trying to find what code populates the table, stuff like that. But knowing Dev tools, you can do these really cool things. So, just like we'll learn how to set break points in our JavaScript code in the next section, you can set break points on your HTML code."
          },
          {
            "time": "[00:00:58]",
            "text": "So, if I go to like the HTML element way up here, and I right click it, I'll get this break on drop down. And so, what this is doing is it says when one of these three things next happens, I want you to pause JavaScript execution. And I want you to show me what JavaScript caused the HTML to change, which is really very powerful."
          },
          {
            "time": "[00:01:21]",
            "text": "So you have three options, which is whenever the subtree is modified, and if you think about the DOM being a tree, so elements have children, elements of children elements all the way down, right? And so if you go to the HTML, which is the top element, and you say when the subtree is modified, that will mean anything on the app."
          },
          {
            "time": "[00:01:38]",
            "text": "But if you had a table like in my anecdote, you'd go to the table and do it there. You could also do when attributes are modified. So that would be if we did it, let's say on this h1. It wouldn't change if the text changed, but it would change if the ID changed like an attribute."
          },
          {
            "time": "[00:01:52]",
            "text": "And then the third option is break when a node is removed. Again, this can be really helpful, so as a little contrived example, I'll do break on for the HTML subtree modification, so anything changes in the subtree break? I think I have an old one clicking around here, which I'll get rid of."
          },
          {
            "time": "[00:02:09]",
            "text": "Okay, so now you can see this little blue breakpoint on the HTML. So then I can go into console, and I can do like document, get element by ID. Let me find one that exists idea main, so go back here. Grab this main, and I'll do main dot inner text equals high, something like that."
          },
          {
            "time": "[00:02:31]",
            "text": "So I changed the articles inner text to be high and before it even processed, I get this. I get this breakpoint here and my DOM where everything is, is paused. And if I click on the call stack, again, we'll get into debugging later. I just want people to be aware that they can do this cool thing it'll actually, show me the line that changed that bit of HTML."
          },
          {
            "time": "[00:02:52]",
            "text": "So I think this is one of those things that is really powerful for ultra specific situations. Like you'll be in a situation where the website is behaving strangely. And you have no real idea what's doing it in the JavaScript. Being able to figure out exactly what line of JavaScript is altering the HTML can be really useful."
          },
          {
            "time": "[00:03:09]",
            "text": "So I'll go ahead and play through here and go back to elements. As you can see the whole site turned into the word Hi."
          },
          {
            "time": "[00:03:09]",
            "text": ">> I followed along with the debugger example and mine is just stuck on when I updated the inner text to Hi,"
          },
          {
            "time": "[00:03:09]",
            "text": ">> Do you see up at the top of the screen a little I think it's like a yellow bar with a play button on it."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yeah,"
          },
          {
            "time": "[00:03:30]",
            "text": ">> You can hit that to play through. And I think it'll, get you there one more time and you hit play again and then it should go through."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Okay."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yep, and then the other way to do it. Yeah, that button should always be there."
          },
          {
            "time": "[00:03:42]",
            "text": "I think there's me we do this again, so you should have this play button up here. I think there's also a way to just like deactivate back here on the sources tab, you can deactivate all break points, and then if you hit play, it just won't stop again, which can be nice."
          },
          {
            "time": "[00:03:58]",
            "text": "So you can kind of leave them on, you can also then at any time go back to elements and right click breakout and then remove the thing and then the blue circle should go away. So then we have a finding event listeners to this is like very much in common with the HTML break points where we can see something going on with our app, but we're not exactly sure where it's coming from."
          },
          {
            "time": "[00:04:21]",
            "text": "So, like for example, you click on a button and it does something and you want to know where that JavaScript comes from. So that's what this third tab over here event listeners is for. And so you can see this is a static HTML site. So there is not really any event listeners except for this one that my code highlighter uses."
          },
          {
            "time": "[00:04:40]",
            "text": "But if you were to do some code like make a button and then add event listener, click to it or something like that or if you're in react and you did an unclick event or anything like that, those will all show up here. When you click on the items you could like click on different items and see if they have any event listeners this way."
          },
          {
            "time": "[00:04:57]",
            "text": "Color formats is another cool one, this one was added a few years ago, but I really like it. So you can see over here we've got border top and then it's like this reddish color. So we can pretty easily edit the hex codes, right, but another thing you can do is you can click on the color itself and it opens this like really nice color palette."
          },
          {
            "time": "[00:05:16]",
            "text": "You can drag it all around, so let's do something like, let me close this and let's take like the body and we'll do background color and we'll click on that. So now you can kind of drag it all around and really find the exact color that you're looking for."
          },
          {
            "time": "[00:05:32]",
            "text": "You can change all the kind of hue and saturation and transparency and all that stuff, and it'll give you the hex code. Another really cool thing is this section down here as the lower half which populates like colors themes. So for example is material UI, you can again, you can click on an element click on the actual square of the color, click on these this little toggle here, and then click on material UI."
          },
          {
            "time": "[00:06:05]",
            "text": "And now it'll populate this nice little section here. So as we're doing stuff, like we can choose the body background from material UI colors, which is Google's color theme, but the thing I use it for more than that, and let me refresh real quick, so I get rid of that yellow is I'll go to here."
          },
          {
            "time": "[00:06:20]",
            "text": "Click on this and then I'll click on page colors. And what this does is it's dynamically reading the colors on the current page and then generating a color scheme out of those. So this is like the actual blue that I use up here. You can also see that when you scroll off of this modal, it turns into one of those really cool like zoom things."
          },
          {
            "time": "[00:06:39]",
            "text": "And so you can like hover over if you wanted to get the hex for this blue, or this white or this red or anything like that. So these are all really cool, so it's got like an eyedropper. It's got all the kinda Hue Saturation stuff, it has multiple different formats RGBA, HSLA, hex and then it's got this really cool theme picker here."
          },
          {
            "time": "[00:06:58]",
            "text": "So there's like a lot here for when you're designing stuff. There's also a cool little Dev tools trick, which is you can go back to body and hover, you can shift click on any color box, and it'll instantly convert it between the color format. So I know some people at their jobs like we all use HSLA or we all use RGB or something like that."
          },
          {
            "time": "[00:07:18]",
            "text": "So you could just like Set it to a thing that you know like a hex, and then you can shift click on it to turn it into RGB other stuff that does it has this accessibility panel. The accessibility panel is really nice for when you're doing stuff like, we do a lot of stuff at work with making our sites keyboard accessible."
          },
          {
            "time": "[00:07:34]",
            "text": "So everything that you can do with a mouse you should be able to do by tabbing around with the keyboard. And so this can be really nice where it shows this accessibility tree. And you can see like what items have tab indexes or which ones have any kind of ARIA."
          },
          {
            "time": "[00:07:47]",
            "text": "Attributes on anything like that will be in here. And it can be really helpful when you're just trying to look at like, is this getting tap index or does this have my Aria label that I put on or anything like that will be in this tree."
          }
        ]
      },
      {
        "name": "9-quick-edits-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the first exercise. And this is all about the quick edits that we just learned. So it's to take this actual page here. And can you change this from an ordered list to an unordered list? Clicking on this link ,makes a pop up here. But can you find the JavaScript that calls this event, and then the third, one's like a little bit of a quiz, but there's a way to cheat."
          },
          {
            "time": "[00:00:21]",
            "text": "And like I said, dev tools helps you level up. So I have a button and when you click the button, this block quote gets rendered, right? And it gets rendered with this class, this ID and this inline style and I also have CSS on the page, which has an element selector, a class selector and an ID selector with important."
          },
          {
            "time": "[00:00:40]",
            "text": "And so the question on CSS specificity is can you guess what color it will be? But the dev tools cheat is let's say you forgotten all the specificity stuff already. Can you use dev tools that actually view what color it'll be before it gets rendered to the DOM?"
          },
          {
            "time": "[00:00:54]",
            "text": "And then the last one is there's a whole big list full of cards here. And when we wanna do is we wanna find the border color of the one with an ID of 12345678. And so can you use the dev tools to put in that ID and actually get to that card and view the border color."
          }
        ]
      },
      {
        "name": "10-quick-edits-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go through this exercise together, so the first two things we can do just via the elements tab. So the very first one, I'm gonna open up the DevTools, and use this selector to find the list that we're in and see that it is an unordered list and so you can just double click to edit it UL and then hit enter."
          },
          {
            "time": "[00:00:21]",
            "text": "That'll change it so you'll notice it goes from numbered to dots. The second one is interesting, it's probably the easy, there's a couple different ways you could actually do it. The easiest way probably would be to look for an event listener so if we again use this, select the link here, then go over to event listeners and we can see that there's two this one is this color scheme for my code."
          },
          {
            "time": "[00:00:45]",
            "text": "So that's not it this one's a click listener and so if we click on it, it'll take us to the sources and it'll actually take us to the actual function that's calling it. So the button in the block quote is kind of interesting. So if we remember from the specificity class, we would see that the element selectors, the weakest class, the next than ID, and then inline styles are the strongest, but the very, very strongest thing is an important tag."
          },
          {
            "time": "[00:01:18]",
            "text": "So it should be this yellow color the other way that we could do it though, because DevTools helps you cheat, which is awesome is we could just find the block quote in the DOM here. And then we could just go to the computed tab and then we can just see that yellow is the color that wins out here so we can actually see it before it's even rendered."
          },
          {
            "time": "[00:01:39]",
            "text": "So that's yellow and then for the last one, can you find out the border color, the one with this ID again, a couple different ways we could do it. You can always just scroll through them [LAUGH] and you can look for it that's no problem at all. You could also cheat a little bit by doing something like document get element by ID and then passing that ID in and this way we'll bring the element in here."
          },
          {
            "time": "[00:02:02]",
            "text": "And sort of like we covered before you can see right where my mouse is now that if I hover on it, it says it's down but we can also right click and we can scroll it into view. And we can see this is the card with that ID and it has a border of green."
          },
          {
            "time": "[00:02:17]",
            "text": "So any questions on this exercise? And then I had a couple questions that came in in between that I wanted to go through, but if anybody has anything on the this exercise itself, I'd love to hear. So the question was, how did we find the JavaScript for when you clicked this link up here?"
          },
          {
            "time": "[00:02:33]",
            "text": "How did we get there? So I open up DevTools and I'll go to the elements panel and I wanna be over here on the event listeners panel. And so what the event listeners will do is it'll show you any and all event listeners on the currently selected item over here."
          },
          {
            "time": "[00:02:50]",
            "text": "And so the easiest way to do it is to use the selector to get the link and now that the link is hovered we'll see that over here up here at the click listener. And this click listeners on the link, and it actually has the JavaScript file and the line number so if you click that, it'll take you into the sources right on that line."
          },
          {
            "time": "[00:03:09]",
            "text": "Again, a lot of these are easy with like the cleaner exercises like often you'll as your the code gets bigger and more complicated. It might be a little bit obscured away with like a helper function, but this is at least get you on the right track for finding it."
          },
          {
            "time": "[00:03:24]",
            "text": "And we work with debuggers later we'll see that finding the line can actually be super helpful once you set a breakpoint on it, which we'll do in another section. I had one really good question earlier too, which I wanted to answer, it's actually very similar to this one that we just covered."
          },
          {
            "time": "[00:03:40]",
            "text": "It was like the element breakpoints where you're resetting a break on over here. And the question was, okay, well, what if you're using some kind of framework like let's say you're using React, so won't be as simple as like, div enter text equals hello, could you do it that way?"
          },
          {
            "time": "[00:03:55]",
            "text": "The short answer is actually the same, which is you can set a breakpoint do the thing, yes, it will open a react function, but you can walk the call stack back to the your specific application code. And we'll do some really cool stuff with debuggers later but that's the short answer."
          },
          {
            "time": "[00:04:10]",
            "text": "The longer answer, though, is if you're using a framework and that framework has its own DevTools, which we'll cover at the end, that would probably be your best bet. So if you get the React DevTools, and then you look at the React elements panel, which would be a new DevTools over here, that can show you specifically why a component rendered, right?"
          },
          {
            "time": "[00:04:29]",
            "text": "So that would be like hey, this render because you clicked this thing like that, it'd be a lot more helpful but you can do it without the React DevTools. You'll just have to look at a big long call stack and you'll have to look at the file names and you have to walk back until it's not core react Jes dot j s anymore until it's your actual application."
          }
        ]
      },
      {
        "name": "11-workspaces",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So now we're kinda moving into the sources tab. And the thing that I always like I have these two screenshots here, like when you really think about the sources tab, it's sort of like your customer, your ID built into the dev tools. So, here's like the exact same file open in my dev tools and then open in my ID, which I use VS code."
          },
          {
            "time": "[00:00:18]",
            "text": "So you have like the center panel, which has the code in it line numbers and everything. You got the left sidebar, which is like a tree that you can kinda walk just like this one here. And the difference is you got all these great debugging things on the right, which will play within the debugging section."
          },
          {
            "time": "[00:00:33]",
            "text": "But you can even hide those and then just deal with this so you can really just use it as your ID Which is what we're gonna do in the next exercise. It's got a lot of your favorite things in it like so for example, if I open up dev tools here, and I go to sources, and let me get rid of this little console Jordan, if anybody's wondering about this, you can go to the data dot here."
          },
          {
            "time": "[00:00:55]",
            "text": "And you can do show console door or you can use the Escape key. And that'll give you a console overlaid on any non console panel. So you can be on the elements with the console or the network with a console or sources with a console and then you can just XOR escape to hide it."
          },
          {
            "time": "[00:01:11]",
            "text": "That's really useful sometimes if you just wanna log something out and see it. So if I go here, you get a lot of the things that work in your current ID. So for example, if I do a command P which in VS code will open a fuzzy search on the files, I get the exact same fuzzy search here."
          },
          {
            "time": "[00:01:27]",
            "text": "I can bring up any file like that. A lot of the same shortcuts for commenting and all that stuff will work. So I'd really encourage you to when you're in sources just to try whatever feels natural and see if it just happens to work here. Cool. So yeah, it's like your full ID and we're gonna play with that a lot as we play with workspaces."
          },
          {
            "time": "[00:01:48]",
            "text": "So workspaces are super, super cool. They're what let you persist your changes to disk, but it wouldn't be super cool thing without some super serious limitations on it. So before we get too far excited with workspaces, let's talk about what it can and what it can't do. And so the limitation if you think about apps, and you think about kinda what we're doing here, if there is a one to one correspondence between what you kinda send down over the server and what you author on the server and what you author and what you view in the website."
          },
          {
            "time": "[00:02:24]",
            "text": "And what I mean by that is like If you make an index at HTML, then when I hit your website, the same index HTML that you hand wrote is gonna come to me, right like it's the same file just automatically transferred. If you write a node app, and you use a templating language like moustache and you hand write a moustache file, the templating language, we'll turn that into an index dot HTML and send it to me, right?"
          },
          {
            "time": "[00:02:48]",
            "text": "That's kinda how that's working. So in the first example, you write HTML, it sends HTML. There's a one to one example that'll work great with a workspace no problem. And the second example, we're using a templating language. That won't work with a workspace because if I update my index dot HTML on my laptop inside the workspace, your server doesn't really have a way of knowing which template file to update."
          },
          {
            "time": "[00:03:12]",
            "text": "It's it's that would be too complex. So in those situations, you can still persist your CSS and your JavaScript changes to disk. But you cannot persist your HTML changes to this because you're not actually writing HTML. And this is also sadly true. With tools like react where again, you're not writing the HTML, you're writing JSX and react is turning it into HTML."
          },
          {
            "time": "[00:03:37]",
            "text": "So, in the dev tools, you'll see index HTML. But there as you know, there really isn't an index dot HTML on the server. It's like an index.js or like 20 js file. So there is a limitation there. Sometimes it's confusing, but it's basically, like if the thing that's on my dev tool laptop is the exact same thing that is in my code, then it's easy to persist."
          },
          {
            "time": "[00:03:58]",
            "text": "If it's not, then it's not gonna persist. So oftentimes, the sad reality is with like the current tech stacks are very pill chain heavy. Like I'm sure a lot of you at work or like, you use react and you use bubble and use a templating engine and all these different things or use a CSS preprocessor."
          },
          {
            "time": "[00:04:17]",
            "text": "That will mean that the workspace idea won't work for you. But if you are working with vanilla CSS, or vanilla JavaScript, or vanilla HTML, then workspaces will be awesome. So does that make sense? I'm gonna pause if anybody has questions, and I know that's like a very good, kinda a confusing concept."
          },
          {
            "time": "[00:04:34]",
            "text": "So let me just pause for a sec if anybody has any questions on that."
          },
          {
            "time": "[00:04:34]",
            "text": ">> Yes, I have. Can we just save the changes and for example from the website google.com and save the changes and reload the page so we can just load the external JavaScript but with our changes?"
          },
          {
            "time": "[00:04:57]",
            "text": ">> Yeah, you can. That's a great question. So it's like, can we, instead of like saving to disk, let's say and updating actual source code, can we set it up so that we can persist changes through a refresh basically. And we will cover that in another section. The short answer is yes, there are still some limitations."
          },
          {
            "time": "[00:05:14]",
            "text": "Some things we can't save. But for the most part, yeah, you can set it up so that like you can change the JavaScript and it'll survive a refresh, but it won't actually write to your local, the code bases file system. But yeah, we will be able to do that."
          },
          {
            "time": "[00:05:28]",
            "text": "And that's not using workspaces that's just built in with the dev tools networking tool, but we can do it there, which is cool."
          }
        ]
      },
      {
        "name": "12-workspaces-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're gonna move right into another exercise. This one's on workspaces. Again, we'll take like 15 minutes to work on it or, but I'll be here for any questions that people have. So, the idea here, there's full instructions. So you'll want and let me go through the instructions live and then you all can try it."
          },
          {
            "time": "[00:00:20]",
            "text": "So the idea here is I'm gonna go to my node app, which is running this local thing. I'm going to kill it for now. And then what we have let me open my finder to my Dev Tools repo. So we have this workspace folder here, and this just very simply has an HTML, JavaScript and CSS file."
          },
          {
            "time": "[00:00:39]",
            "text": "And so we want to do two things. One, I wanna open the index.html file with Google Chrome. So I right clicked on it and clicked open. And that you can see it's opening like a file, not a HTTP. So it's opening this file and it should look like this, this little to do list."
          },
          {
            "time": "[00:00:55]",
            "text": "And then the second thing we'll wanna do is we'll want to open up the Dev tools, inspect here, go to sources. And again, these are all written down step by step here. So we want to go to source and then I'll go back to my finder my file system."
          },
          {
            "time": "[00:01:09]",
            "text": "I'll grab this whole workspace folder here. And I'm just gonna drag it on to the sources, and it should change into this thing. And so the two things we're doing are one, we're opening the index file in Chrome, and then we're dragging our source code for it onto the sources tab."
          },
          {
            "time": "[00:01:25]",
            "text": "And that should prompt this little warning up at the top saying hey, Dev Tools wants to access your local file system. Is that what you really want? And we'll say yes allow. And when those steps are done, you should see that the workspace is synced by over here in the left, you should see these little green icons next to each one."
          },
          {
            "time": "[00:01:43]",
            "text": "So again, so kill the current node app. Go to your sources panel, go to your Windows Explorer or your finder if you're on Mac and get the project and open its index.html and then go back a level and grab the whole workspace folder and drag it into the sources panel here should prompt you with this."
          },
          {
            "time": "[00:02:02]",
            "text": "Do you want to allow you say yes and then you should see these things all green. And if you have any questions, let me know when it is set up. I have a couple of little things these little To Do List tasks that you can do and what you should be able to see."
          },
          {
            "time": "[00:02:16]",
            "text": "For example, if I go into my style.CSS, and at the same time I go into my Real ID, and I open my workspace style.CSS. So these are the same file wrapper you can see, I should be able to make a change here, like height 100 pixels and then hit Command S to save or Ctrl S and then go back here and actually see the real file has changed on my file system."
          },
          {
            "time": "[00:02:40]",
            "text": "That's what we're going for there. So again, the setup is kind of the part that I really want you to get the experience with. So, yeah, opening that new file, then taking the folder and dragging it into the Sources tab, and if you want to play around with the exercises, awesome, but the setup and getting it to actually persist is the big thing."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Can we save the changes in Sources panel html.css.javascript? Sometimes it doesn't work."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Yeah, so if it's sinking, like if it's green, and it says that it's linked, then it should absolutely work. But yes, sometimes they can get into, I've seen him get into a weird state before I used to be a lot more problematic."
          },
          {
            "time": "[00:03:23]",
            "text": "So, if you run into any problems, what I would do is I would on the left here, go to the File System tab. Then I would right click on the folder and remove it from the workspace entirely. Say Yes, I'd like to get rid of it and then I would just start over again just take the thing and drag it back in here, click Allow over here and it should go all all green like that."
          },
          {
            "time": "[00:03:44]",
            "text": "So you can see here I got into a weird state because I had an existing at it. Saved when I deleted it and grabbed it all over again. And so again, like I would just go in here, remove it. Okay close this out so it's not still with active changes, drag it back in here."
          },
          {
            "time": "[00:04:04]",
            "text": "Allow, and now they're all green again so if they're green they're persisting."
          }
        ]
      },
      {
        "name": "13-workspaces-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We had a couple of really good questions and comments. Important one was that, folks are finding, they open the dev tools. So I'm on my Mac and the the workspace is actually on my Mac. And so, when I do things if I do body back ground blue, or something like that, it live reloads in real time."
          },
          {
            "time": "[00:00:20]",
            "text": "But a couple of folks were doing things either via remote workspace or via windows subsystem Linux, and they're finding that the changes, they do persist. So if you go and you type stuff and you hit save, and then you look in your editor, it'll be there. But the live reloading won't happen over and WSL."
          },
          {
            "time": "[00:00:36]",
            "text": "Let me go through the kind of solving these and then we'll do pause for any questions that anybody had going through it. So yeah, so I kind of got everything all set up and got my green dots here. And then so the first thing was centering the page title."
          },
          {
            "time": "[00:00:51]",
            "text": "So I'll go and grab that and the elements over here. I can either do it there, or I can go into sources, the CSS, and I can do something like I'll add a new selector for h1s. And I'll do text align center. So I'll do that. Change the background color so I can kind of go into elements and grab the body."
          },
          {
            "time": "[00:01:14]",
            "text": "Maybe add a new selector or something like that, background color 333. That looks real bad, eee looks better. And then the last thing was some JavaScript. So what I was hoping was you would type in a new item, and you'd hit Enter, and it should add it to the list."
          },
          {
            "time": "[00:01:34]",
            "text": "So if we type in a new item, we hit Enter, nothing happens. We go to the console, and it's logging it, but nothing's happening. So we can go into the sources tab and we can look at the JavaScript and we can see, it's grabbing the form field, it's grabbing the list of items."
          },
          {
            "time": "[00:01:50]",
            "text": "It's pre-populating with these three items, and it calls this render function which will set the, HTML the list to empty. Then we'll go through each one of these items and it will create a new item and set the inner text to or create a new list item and set the inner text to the item."
          },
          {
            "time": "[00:02:11]",
            "text": "And so what we really want to do is when on the form when you add an event listener and you type something in, we check the key to see if the key is entered, which I already have in here. And we are logging the form value but we really wanna do is we wanna just push that form value on to the list of items here."
          },
          {
            "time": "[00:02:29]",
            "text": "And so we should be able to do something just like items, push and save that. And now when we come here and we hit Enter, I'm gonna close these, you can see you know, hello, something like that. It will add the item. So yeah, again not super important getting these things right but more important getting the workspace set up and actually playing around with the elements panel seeing what works, what doesn't."
          },
          {
            "time": "[00:02:50]",
            "text": "Playing around with the sources and then seeing that it actually updates your if I do workspace index or main.js. We can see my new items push code has made it to my file system. So that is workspaces. Again, the kind of TLDR there is it won't work for a lot of situations."
          },
          {
            "time": "[00:03:08]",
            "text": "But if you are in a situation where it'll work, it can be a really nice way of editing things really quickly and seeing the changes right there."
          }
        ]
      },
      {
        "name": "14-step-through-debugging",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we've kind of made it through the editing section, so we've learned how to do quick edits, we've learned how to do sources, and we've learned how to do workspaces. And now we're gonna move into the debugging section in the workshop. And so, this one will be different where we won't be altering any HTML or CSS."
          },
          {
            "time": "[00:00:17]",
            "text": "We will be altering some JavaScript but more importantly, we're gonna be looking at broken things and trying to get a better idea of why they're broken or how they're broken. So, one concept that's great is step through debugging, and I find the room is usually kind of split on this."
          },
          {
            "time": "[00:00:33]",
            "text": "Where some people are super familiar with it, and maybe they've even done it before or at least they understand the idea. And other people, especially people who haven't programmed in other languages aren't really sure what it is. And so the idea is that a step through debugger, so when you put a console log in your code, which is how a lot of people debug JavaScript."
          },
          {
            "time": "[00:00:53]",
            "text": "The code will run and then it'll hit the console log, log it out, and then it'll keep running the application state. So a contrived example of where that has shortcomings would be, you console log the link that you're about to do an API call to and it's wrong."
          },
          {
            "time": "[00:01:09]",
            "text": "And then you're like well wait, what set it to the wrong thing, but it's too late, the application states already finished. Then you'd have to refresh the whole thing or work through the whole workflow again, in order to get back into that application state. And the contrived example of a link being set wrong might not be great, but if you can imagine an app with a really big workflow."
          },
          {
            "time": "[00:01:26]",
            "text": "Like you have to go to the site, you log in, you add something to your shopping cart, you go to the coupon page, you enter the coupon, that's where the bug is. So if you console log something, and then you get the wrong value or not value we're expecting, now you have to go manually through that whole step again to get it."
          },
          {
            "time": "[00:01:43]",
            "text": "That differs a lot from step through debugger, so a debugger statement unlike a console log, will actually completely pause the application execution, it will not go forward until you tell it to. And so, that can be a lot more powerful because instead of just getting your console log right, you can pause and you can spend as long as you need."
          },
          {
            "time": "[00:02:03]",
            "text": "Looking around, changing things, walking back, walking forward, again, you can really just pause the whole app and look around. So, I guess the way I usually think about it is like, console log is great for a lot of tasks, like straightforward tasks, like if you're just like, what's the value of my post ID or something like that."
          },
          {
            "time": "[00:02:20]",
            "text": "There's no need to use a debugger for that, you can easily just console log it, but when something's really wrong and you wanna take your time and really explore it. Or when you've console logged three times and you keep getting the wrong thing, there might be a really good time to use a debugger instead and actually poke around, cool."
          },
          {
            "time": "[00:02:39]",
            "text": "So, this lesson is pretty short, but it's a little bit heavy, so I'll kinda go through it and then we'll take as long as we need for any questions before we go into the exercise. And feel free to have me go back through things, anything that's helpful. So, I'll go ahead and I'll right click, and I'll click Inspect, and we're gonna be in the Sources tab this time."
          },
          {
            "time": "[00:02:58]",
            "text": "So let me close all of these, so if I first go to Console before we get to Sources, we can see I have this function just for demonstration purposes that's just logging in the background, it's just an interval, and it's just logging things out. And so, if we click over here, we can go to this Debugging js file, and we can see I tried to make the whole workshop not very js heavy."
          },
          {
            "time": "[00:03:18]",
            "text": "So the basic idea is a set interval which we'll get called regularly, getting called every ten seconds. And it does this code where it's just got a couple things, so it calls function1. Function1 is here, function1 sets a constant then calls function2, there's an if else, then it calls either function3 or function4, that's like the whole thing, again, the JavaScript is not very important."
          },
          {
            "time": "[00:03:38]",
            "text": "So if I wanna figure out what's going on, let's say, I wanted to see if function3 gets called or function4 gets called, I'm not sure. I can start at the very beginning and you can really go anywhere you want. And if you hover over these numbers here, you'll see a little gray bar up here, and if you click on one, it'll turn blue, and that means a breakpoint is set."
          },
          {
            "time": "[00:03:55]",
            "text": "At the same time, you can see over here on the right sidebar, it keeps a list of all the breakpoints that you have currently, and you can see when is set. So the ten seconds have gone by, so the function gets called, and here we pause. So you can prove it's paused in a lot of different ways but, for an example, you won't see any more console logs here, because it's not getting called over, and over again, anymore, it's been fully paused."
          },
          {
            "time": "[00:04:16]",
            "text": "And if you had a more robust website with application state doing things, you would notice it was paused as well. So when something is paused, we use the left sidebar we're using for Workspaces, now we can kind of move that away cuz it's not super important. And then the center panel with our source code, we usually use that to set one or multiple breakpoints."
          },
          {
            "time": "[00:04:36]",
            "text": "But when those are set, then it becomes less important and the right sidebar becomes the important thing that we're looking at. So let me minimize all these and we can kind of go through because they're all very different, and we'll actually go bottom up. So, all the ones here are just different break points, right?"
          },
          {
            "time": "[00:04:53]",
            "text": "So we learn how to do a DOM Breakpoint, in one of the earlier lessons, that was when you right click on an element in the elements path panel. So if we were to go here, right click on body, Break on, subtree modification. Now we're to come back to Sources, we would see that there's now a DOM Breakpoint in here."
          },
          {
            "time": "[00:05:10]",
            "text": "So this is just keeping a list, cuz if you're debugging something really hairy, eventually you'll probably have breakpoints all over the place, and it's kinda nice to be able to have a central place for it. So I'm gonna go back to elements, and I'm just gonna remove this breakpoint, cuz we're not using it."
          },
          {
            "time": "[00:05:23]",
            "text": "Back to sources, XHR Breakpoints are really interesting, we can cover those in a bit. But the basic idea with XHR Breakpoints is that if you have an app, this used to happen to me all the time at Twitter, so we have twitter.com, and it's doing constant API calls, right?"
          },
          {
            "time": "[00:05:41]",
            "text": "It's getting your timeline, and it's getting your friends, and it's getting your following list, and who to follow, it's all these different things. And all have that would be wrapped in a single function, right? Like a helper function like fetch or Twitter API or something like that. And so, there'd be a problem with one of them that I really wanted to debug."
          },
          {
            "time": "[00:05:58]",
            "text": "But when I put a breakpoint in the helper function, as you can imagine, it would pause every single time, and so I'd be clicking play, waiting for my one to come. So what you can do is these XHR Breakpoints, you can click plus here, and it's really nice."
          },
          {
            "time": "[00:06:11]",
            "text": "It says break only when the URL contains, and so you could do tweets or something like that or at Adobe, you could call it, do something that's only the Photoshop service or something like that. And then the helper function you don't need a manual breakpoint in, it'll actually tell you when an XHR or a fetch request happens with that in the URL."
          },
          {
            "time": "[00:06:30]",
            "text": "That can be really helpful, again, it's very powerful but only in niche situations, right? If you have too many function or too many network calls, and you really wanna breakpoint on only one of them, you can use those. But for mostly today, let me pause this, for most today we're just gonna be in the regular breakpoints, and this will be a list of things where you have actually clicked."
          },
          {
            "time": "[00:06:51]",
            "text": "So if I go through and I click a bunch of stuff, you can see this list is populating. Go back down to just zero here, cool, then we'll see Scope here, so this is really nice. So, if you've done any of the great front end masters courses on advanced JavaScript or anything like that, you know there's a lot of talk about scope and how JavaScript variables are scoped."
          },
          {
            "time": "[00:07:16]",
            "text": "Var versus con scoping and this scoping, and all this different stuff like that. This can be a really nice way to see what this is set to, currently undefined, and what scope you're in for the different functions, like what's in scope. So you have the local scope, which is the set interval, and in it, you have access to four top level things, function1, function2, functions3, function4, and this is undefined."
          },
          {
            "time": "[00:07:38]",
            "text": "Then you have the Global scope, right? And that's gonna be the window in this sense, again, not a JavaScript class, but it could be really cool to go back and rewatch one of Kyle Simpson's JavaScript classes. And while he's doing the examples, open up this sources panel with your own example and actually be able to just see everything that you have access to in your Local and your Global scope."
          },
          {
            "time": "[00:07:57]",
            "text": "So this will just be all the stuff that's on the window object, right? So we'll go ahead and close that, close that, and close that. Now the Call Stack, right now you can see the Call Stack is one line item long. Because this is in the global scope, there's a single anonymous function, which is this anonymous function right here, which is this one, and that's the whole call stack."
          },
          {
            "time": "[00:08:18]",
            "text": "But as we go further stepping in, it can be really good as the Call Stack expands to see, watch it expand basically. And this kind of ties in earlier a lot of people were talking about how real world apps often use frameworks, they often use helper functions. And so, putting a simple debugger or an HTML DOM Breakpoint, might not get you exactly where you need to be."
          },
          {
            "time": "[00:08:40]",
            "text": "Because that event listener that DOM breakpoint it's being done by a helper function or it's being done by reactor angular. And so, this Call Stack is really great because while it will start with angular react, something like that. It will end up being really long and you can back trace all the way through until you see a file name that you recognize, right?"
          },
          {
            "time": "[00:08:57]",
            "text": "So, often it'll look like react.js, and then eventually it'll be my helper component.js, and then eventually it'll be current debugging view.js. I'm like, that's the one, so you can click on that. You can also do a really cool thing with these, when you're using frameworks and things like that."
          },
          {
            "time": "[00:09:15]",
            "text": "Which is you can find any script that's like a third party library, and you can right click on it, and you can click Blackbox script. And what that'll mean is your basically, I don't wanna see that in my call stacks anymore, and I don't wanna see it on my breakpoints anymore."
          },
          {
            "time": "[00:09:30]",
            "text": "So, I really recommend that if you're, again, if you're using one of these UI libraries, react or view or something like that, and you know the bug is not in the react library itself. So you don't wanna see 30 call stacks of react for your two call stacks of your application."
          },
          {
            "time": "[00:09:43]",
            "text": "You can right click on react.js and blackbox it, and then it won't show up here anymore. And then Watch is really cool, basically, you can add watch expressions at any time and we'll do this in a minute to keep an eye on any variable as things move through."
          },
          {
            "time": "[00:09:58]",
            "text": "So the equivalent of like, let's do this as an example, so the equivalent of going into our code here. So if we go into debugging.js, and what we wanna do is we wanna, what we used to do would be we would console.log(foo), right? That is a common thing we would do, obviously, it is just set to a string here."
          },
          {
            "time": "[00:10:19]",
            "text": "And then you would, let us say, you would hit play on it or remove this breakpoint, you would see when it gets called for the first time, it will set foo and then it will console log it, right? That is like a stuff that we do pretty often."
          },
          {
            "time": "[00:10:30]",
            "text": "So here it goes, it logs foo and then a log some other thing. So the equivalent in a breakpoint would be to go ahead and delete this console log and save it again. And then put a breakpoint in here, the same line where we added the console log, and then add a watch expression for foo."
          },
          {
            "time": "[00:10:45]",
            "text": "And so now it'll wait until it hits the breakpoint at which point, so we hit the breakpoint at which point, the watch expression fool is here, those are equivalent things basically. So you can see, this is like a lot more setup work than console logging. So, only use it when you have a need to use it, but it's also a lot more robust."
          },
          {
            "time": "[00:11:02]",
            "text": "So if I go ahead and remove this breakpoint set one back at the beginning, and hit play again, it'll go through and it'll stop here. And so, all of that has just been like what the UI is, so now let's get into what step through debugging means. And step through debugging has to do with these buttons over here."
          },
          {
            "time": "[00:11:21]",
            "text": "And so, basically, when you get caught in a breakpoint, and you can always tell up here there's this little thing that says we're paused in the debugger, you have a few options, right? One button is to be like, I don't care about that resumed script execution. So, if I hit this, it would go away it would finish cuz I have no other break points."
          },
          {
            "time": "[00:11:36]",
            "text": "And then nine seconds later when it triggered again, it would just break here, again, and I could keep hitting play every ten seconds. Some other options that you can step over to the next function call, so if you're on one, you can step over two or you can step into the current one."
          },
          {
            "time": "[00:11:51]",
            "text": "So, say I had function1 and function2 and I stopped at function1, step over would send me to function2 and highlight it. Step into actually take me as we can see here, into the guts of function1, so now we've stepped into this function. And so, you can basically walk down or walk back out, any application."
          },
          {
            "time": "[00:12:12]",
            "text": "Again, there's something to keep in mind because of how this works. So if you think about the JavaScript execution stack, and it's going line by line, it's executing things. You can always step over something, you can always step into something. But when you step back out, it can't time travel, it doesn't go back in time, it steps out and goes to the next line."
          },
          {
            "time": "[00:12:31]",
            "text": "So, if you're here on function1 and I step out, it will not take me back to function1, again, cuz it can't go backwards in time, it'll take me to the end of the function. And then if I hit play, I have to wait for another function when we get called."
          },
          {
            "time": "[00:12:43]",
            "text": "Just gonna pause for a second, if I can make that more clear, if anybody has any questions, I'd love to answer those now. Just on execution being paused and the choices that you have to step over into out of or play on. Yeah, the question was I still don't understand what's going on with watch."
          },
          {
            "time": "[00:13:01]",
            "text": "And so, watch lets you put any expression in here, so you can put a variable name or a function name or anything like that, and as it gets paused, you can see what it's set to. So let me make an example, let me deselect this and play on just, we get back to the screen and we go into the code here."
          },
          {
            "time": "[00:13:18]",
            "text": "So inside function1, we set foo to foo, right? And then we call function2 and we pass foo into it, and then we check if foo is foo, which it will be and we call function3. So let's take function3, we'll pass foo into it, and then we'll receive foo here, and then we'll do foo equals bar, and we'll set that here."
          },
          {
            "time": "[00:13:39]",
            "text": "Does that make sense to kind of the JavaScript level? So, we set a variable to something and pass it in, pass it in again, and now we change what the variable is set to. Does that make sense? Okay, so we'll save that and we'll restart, and we'll put our breakpoint back here."
          },
          {
            "time": "[00:13:56]",
            "text": "And we'll give it a couple seconds till it gets caught in the breakpoint. Okay, great. So as of this point, we have foo in our watch expression and it has not been defined, so it's unavailable, it would be undefined if you were to console log it. But we'll step into function1, and you see that on this line it hasn't executed yet."
          },
          {
            "time": "[00:14:18]",
            "text": "So as we know from JavaScript hoisting, the declaration has been hoisted but the evaluation hasn't happened, so it says foo is undefined. Into the next line function2, at this point foo has been defined, so now it's set to foo. So it's basically, it's like anytime the variable changes, the watcher updates here."
          },
          {
            "time": "[00:14:36]",
            "text": "So if we step into function2, we can see that foo is still foo, and then we step in, we can see that we get into this call a function3. Where we pass it in, step in again, and we can see again this line 18 hasn't executed yet. So as of this time, foo is still foo, but when we step into the very next line, now foo has been changed to bar."
          },
          {
            "time": "[00:14:55]",
            "text": "So the watcher is like anytime this variable updates, let me know, and that's really important because if we didn't pass it in, then foo would go back to undefined, because it wouldn't be in that scope. But it's basically, the watchers are the same, the watcher is basically the equivalent of wherever we currently are in, we have the blue line is of doing a console log of whatever you put in the watcher at that line."
          },
          {
            "time": "[00:15:20]",
            "text": "That's like the same thing, it's just the way of logging out values. Cool, and so, again, so the kind of thing to do when you're debugging code would be to figure out where the problem is. That's always the first thing that you wanna do, like what function has the problem or whatever."
          },
          {
            "time": "[00:15:37]",
            "text": "So if you're getting something like foo.bar is undefined, you're like, okay, and maybe you would see that in your console, you'd see foo.bar is undefined. And you'd click on the file name over here, and it would take you into the Sources tab where you're calling foo.bar. And then you can put a breakpoint on it, or you can put a breakpoint right after it."
          },
          {
            "time": "[00:15:53]",
            "text": "And you could watch all the foo and see what properties foo does have, does it have a bar? No, does it have a bar, maybe does have that those kinda things. So you can really take as long as you need paused in this execution state, and kinda when you're done, you can hit play and it'll play it through."
          }
        ]
      },
      {
        "name": "15-step-through-debugging-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let me walk through the exercise itself. So there's an unordered list here on this exercise debugging called ui id catfacts. So if we inspect the DOM and we go to elements and we go inside the article inside div. We can see here this URL of ID of catfacts."
          },
          {
            "time": "[00:00:21]",
            "text": "And what's supposed to be happening, we have this file public exercises debugging.js in our repo exercises debugging. So here it is. So it's supposed to be happening is it's fetching this API of catfacts. It's calling to JSON on, then it's taking the results. It's going through each of them."
          },
          {
            "time": "[00:00:43]",
            "text": "And it's making a new list item and appending it, but something's wrong. So what we're supposed to be seeing here under here is a list of facts about cats is a list of facts about cats. But something's going wrong with it. And so the idea is to start with the console, see if there's any errors and then from there, put a step through debugger and and figure out what's going wrong and and how to fix it."
          },
          {
            "time": "[00:01:05]",
            "text": "And so that's the exercise. Before we get started do we have any other questions on it? And again, we'll meet back afterwards and we'll go through the whole thing together. So the question is, you use the debugger and you end up with a lot of breakpoints, how can you get rid of a bunch of them, I don't know off the top of my head."
          },
          {
            "time": "[00:01:22]",
            "text": "So let me let me get in this console log here and see if I can find it. So let us see we have a bunch of them. So it is so you have them all in multiple files, everything like that. So you can't do it from here. You can come over to the sidebar with the break points over here."
          },
          {
            "time": "[00:01:36]",
            "text": "Then you can right click on one and remove all breakpoints, and that'll get rid of all of them from all the files and then you just hit play one more time and it'll play through with no more breakpoints."
          }
        ]
      },
      {
        "name": "16-step-through-debugging-solution-and-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we got some really good questions during the exercise. So I think I'm going to solve the exercise with everybody together and then I've got I think three that I saw and then if anybody else has any will go through those two. So yeah, so for the step 3 debugging Like usually when you have error, the console is always like a good place to start, like usually anything that throws will end up in the console."
          },
          {
            "time": "[00:00:28]",
            "text": "So the first thing I see is like this type error. So the console is a nice way to get to the sources tab as opposed to looking through the file yourself. So I'll go ahead and click on it and it'll take me over here and this specific error was documented, that new element is not a function."
          },
          {
            "time": "[00:00:44]",
            "text": "So if I go to my sources over here. Then maybe do like a Google search or something like document new element. I can see that the actual API is create element, not new element. So we can go ahead in our ID. We can go ahead and change that to create element."
          },
          {
            "time": "[00:01:04]",
            "text": "Then I'll hit save, and then I'll refresh. So now there's no more console error and I saw some folks kind of getting to here. It's like, okay, it's not a JavaScript error, but why is it rendering like this giant list of undefined. So we go back into our sources and we can just do something set a breakpoint."
          },
          {
            "time": "[00:01:23]",
            "text": "And so I'll set a breakpoint and then I'll refresh the page. So we hit this break point, it stopped here, I can use the watch over here. So for example, I can watch on li, and I can see that it is in fact, a list item. So that I mean that looks good."
          },
          {
            "time": "[00:01:38]",
            "text": "And then I can add another watch item and I can make it item. And so I can see as an object with a bunch of stuff. So what it looks like we're doing is we're setting li.innertext to item.fact. And we can see if we hover over the fact is set to undefined whereas item is set to an object."
          },
          {
            "time": "[00:01:57]",
            "text": "So I can go ahead and I can browse in here, trying to see what's going on here. I can see that there isn't a fact property, but there is a text property. So I can go back to my code here and change it from item fact to item text and hit save again."
          },
          {
            "time": "[00:02:14]",
            "text": "I'll remove this break point for now and refresh. And now we've got all these facts about cats, which I'll try very hard not to read and in fact move on with the rest of the content but a couple of things here. There's a couple different ways you could solve it."
          },
          {
            "time": "[00:02:30]",
            "text": "Again, I'm kind of just trying to highlight like, I think normally what I would have done was console logged item here, but it is kind of nice to combine like the debugger was like actually like take that second to breathe and look around at the function. Look around with the object, see what you have access to, what you don't."
          },
          {
            "time": "[00:02:46]",
            "text": "It's kind of a nice way to do it. We got a couple questions that were really good. So one question was about what you put in watchers. And it was like, do you have to specify what you put in the watch? Or can you just watch everything? So the answer is that you do have to specify what you put in the watch."
          },
          {
            "time": "[00:03:03]",
            "text": "You can't put like a wild card in. But if I go ahead and I refresh here, or maybe make a breakpoint here and play to it, I can close what's in my watchers and I can look at my scope. And so if you come down here into scope and you'll get local scope, you can see everything that you do have access to in this function."
          },
          {
            "time": "[00:03:21]",
            "text": "You can also see everything you have access to in the global function. So if you wanna browse what you have access to scope is the place to do that. If you want to keep an eye on a very specific one watch is the place to do that. We had another question was my extensions are getting in the way, and so you kind of have two options."
          },
          {
            "time": "[00:03:40]",
            "text": "If you notice a Chrome extension is getting in the way one is to open an incognito window and do the same thing there. The other one is you can go to Window and extensions. And then you can just deactivate all of them here so that that won't uninstall them, right like here, you can just deactivate LastPass and close it and then refresh the site again so you can kind of go either way."
          },
          {
            "time": "[00:04:00]",
            "text": "It is a tricky thing. It's bitten me a lot before in real life production cases where I'm experiencing something and it turns out to be a Chrome extension. So I think it's a good idea to either turn them off. One other cool thing you could do is I oftentimes, like I'll have Chrome as my daily driver for my browser."
          },
          {
            "time": "[00:04:17]",
            "text": "And then, I'll download Chrome Canary, which is their like, pre release, build. I'll use Chrome Canary with zero extensions. That'll be like my, what I use for dev tools, whereas like Chrome will be like what I use for browsing. So you have a couple of different options there."
          },
          {
            "time": "[00:04:29]",
            "text": "But it is good to keep in mind that that the extensions can break it."
          },
          {
            "time": "[00:04:29]",
            "text": ">> I have a quick question for the watch."
          },
          {
            "time": "[00:04:29]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:04:29]",
            "text": ">> If you're setting the watch do you also have to set a breakpoint on this specific element that you're watching where those specific variables that you're watching?"
          },
          {
            "time": "[00:04:43]",
            "text": "Or good at if you set it, let's say after the elements when you call it, would that still work?"
          },
          {
            "time": "[00:04:43]",
            "text": ">> Yeah. So basically what this is gonna do is every time a breakpoint gets hit, it will update the values in here. So like if you had like a function that set foo and then way later you put a break point it would still have access to foo because that's totally fine but as for like keeping track of, it'll update every time you either hit a break point or like you step in or out of a function that will update then."
          },
          {
            "time": "[00:05:19]",
            "text": "So it doesn't really matter where you place it but this will only post data when you've like hit a breakpoint basically. Somebody had asked, okay, without doing workspaces, is there a way to get your changes so that they will persist through a refresh, right? So not necessarily writing to disk and that whole thing, but I just want to be able to like change some JavaScript, refresh the page and see it execute."
          },
          {
            "time": "[00:05:43]",
            "text": "There is a way to do that. And so to do that, you come over here to the left panel, where we were on page before, and you click over here to overrides. And what you have to do is you have to create or give Chroma folder to store all these little diffs and it can be literally anything."
          },
          {
            "time": "[00:06:01]",
            "text": "So you can click Select Folder for overrides, you can make your own folder that's no problem. Like I can make a folder and call it like FUBAR or something like that. You could put it in your documents so you can make it, Chrome, local overrides folder, anything like that, it's fine."
          },
          {
            "time": "[00:06:16]",
            "text": "When you select it, you'll have to go through the permissions process or like allow and your OS might ask to. But once that is that, then we can do things like we could go to the body. We could do you know, like background color red or something like that."
          },
          {
            "time": "[00:06:31]",
            "text": "And now when we refresh, it'll stay red. And we can do that with our sources panel and our JavaScript, everything like that. So if you're that's, that's always good for like, if you're, especially with JavaScript that runs once, I think somebody had asked about this earlier to where it's like, you load the page and you make an edit and you want to see it and then you refresh which gets the page from the server again, so you've lost your edit, like that kind of thing."
          },
          {
            "time": "[00:06:52]",
            "text": "So if you go to sources overrides and set up an override, you'll be able to get that"
          }
        ]
      },
      {
        "name": "17-network-performance-network-waterfall",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this I have broken out into three sub chapters, because they're kind of three different ways of looking at performance. The first one that we'll cover is network performance. That's going to be like things coming over the network to from your servers to your users. The second section is going to be CPU performance."
          },
          {
            "time": "[00:00:15]",
            "text": "So that's going to be like the page has loaded. And now the users doing stuff and how slow is that? And the third one is gonna be memory. And that one is also gonna be kinda on page load. But it's gonna be how much memory your app is allocating, do you have a memory leak, things like that."
          },
          {
            "time": "[00:00:31]",
            "text": "So those would be the kinda three sections. So we start with network performance. One thing I always find really interesting Is every time some company does a study the metrics they come back on for how important page load is always kind of blows my mind. So I have like a couple of things that I was just able to find where it's like Walmart Amazon, finding that 1% increase in earnings for every 100 milliseconds that could shave off their webpage speed."
          },
          {
            "time": "[00:00:58]",
            "text": "Is like, hugely substantial amount of money, just things going faster. And I think we all know it at a certain end when it gets really bad. You go to a website and it's like spinning and spinning and spinning, like I'll just go find a different website. But I'm always amazed that when you look at the aggregate, like how many users that you just lose, with even small like barely perceptible slowdowns Yahoo saw a 9% increase in traffic for every 400 milliseconds they improved."
          },
          {
            "time": "[00:01:25]",
            "text": "That's like less than half a second. Huge increase. And Google's as it loses 20% of their traffic for every 100 milliseconds they take to load. That one makes a little bit more sense because you, you really expect Google to be instant like google.com, bing.com you expect those to be Really, really fast because you're not there to stay here or there to go to another place.And then these just interesting numbers like in the one to three second range as your page is loading people up."
          },
          {
            "time": "[00:01:54]",
            "text": "Probability of leaving goes up to like 32% as it extends to like one to five seconds. It's like 90% And then bounces just increased like over 100% more bounces as you go past that 5% five second range so you can really losing a lot. You can get a lot of this info if you use like Google Analytics or something you can see how many people bounce but, but it's a little bit harder to measure because Google Analytics like depending on where you put it in your script, People might even leave before it loads, right."
          },
          {
            "time": "[00:02:24]",
            "text": "And so it's it's probably even worse than that. So that's kind of the importance of this network stuff. And I think it's always important to, to have a little bit of like empathy for your users. This is really common where like, you'll be at some big company, maybe and you're like in."
          },
          {
            "time": "[00:02:41]",
            "text": "San Francisco in the United States on a brand new MacBook Pro. And you're like my site is really fast, right? Like it loads like right away and it's really good. And then, there's like so many places with worse internet connection and there's so many people on worse devices."
          },
          {
            "time": "[00:02:59]",
            "text": "And then you start thinking about well what about people using it on mobile devices on worse internet connection? I mean, it really, it really can be a very different experience based on where you are. And I think even people living in like very modern high internet speed cities like if you take the train somewhere and you go in a tunnel and you lose your connection, like we all know That frustration right or you're like at an airport, and all of a sudden everything is crawling like."
          },
          {
            "time": "[00:03:22]",
            "text": "So I think it's really important to not just test on, the maximum the best possible conditions, but to think about your user base. Again, with a good analytics tool, you can get a lot of this like, You actually have a lot of users in this region or that region."
          },
          {
            "time": "[00:03:37]",
            "text": "And there's tons of stuff you can do, which is kind of what we're going to be covering So yeah, we're gonna kinda learn network terminology, and then what the Network tab can do. So if I go ahead and I open the Network tab here, we've sorta seen it once already."
          },
          {
            "time": "[00:03:53]",
            "text": "And let me go ahead and click this cog and disable screenshots just for now because they take up a lot of room, and then I'll refresh the page. So Like we covered at the very beginning, you see like this list in order of every network request your app made."
          },
          {
            "time": "[00:04:06]",
            "text": "And the bigger the app, the more network requests you'll see, especially as there's like analytics and tracking code and ads and all these images and, everything's a network request. So you'll see the name of the request here. You will see the status, again this isn't like a web fundamentals class, but it dev tools kind of taps into everything, so, for those that know like network status is like 200 is okay, a 400 is usually like a client side error, 500 range is like a server side error, all these different things."
          },
          {
            "time": "[00:04:39]",
            "text": "It's nice to see these, they'll actually go red when the error and error as well. The type that it is documents, stylesheets images all that the initiators kind of interesting because you can kind of get this waterfall view of like, okay your document came in that called a JavaScript file and that called a JavaScript file and you can kind of like watch it."
          },
          {
            "time": "[00:04:57]",
            "text": "There's also a kind of a cool tip and trick which is you can hold Shift as you move around. And when you hold shift over an item, it'll turn everything that item called Red. And if that item was called by something, it'll turn that green. So you can see like this font here, the font was called by network dot html, that screen and it called two other files."
          },
          {
            "time": "[00:05:23]",
            "text": "Those are rad. It's just kind of a neat way of like visualizing what happened. You can also see the size. And when this is cached, like if you use compression and caching, you'll see that on this as well, and you can see how long it took to load."
          },
          {
            "time": "[00:05:36]",
            "text": "And then you get this really cool waterfall. So this is what happens when you hover over these here. You get this waterfall, And the waterfall like if you have a request that's taking a really long time, the waterfall can help you figure out where in the process that request is getting stuck."
          },
          {
            "time": "[00:05:51]",
            "text": "And we'll cover that in a second because that's kind of a pretty in depth one. But it's also worth noting that if you right click on any of these, there's actually a lot more columns that you can add So you can add like the path, the URL, what domain they came from, you can add cookies that were set the priority of it all those kinds of things."
          },
          {
            "time": "[00:06:10]",
            "text": "And again, just to give a bit of context here before we go into the waterfall terminology we've kind of seen like a script and or an HTML file, we'll call scripts we'll call CSS call images, all these things, but it's really important to know that on the browser level, you get like a certain number of requests, which is, I believe, either five or six depending on the browser that you can do at one time."
          },
          {
            "time": "[00:06:34]",
            "text": "So if you tried to call like 20 images, it would send out six requests, you know, for the six first images. And then as they come down, then it would start filling like a queue basically where I would call the next images. So it's worth knowing right away that you can't just do unlimited requests."
          },
          {
            "time": "[00:06:50]",
            "text": "And if you think about it, that's where we get this culture of like concatenating our JavaScript files or using CSS sprites instead of images. Because there's a performance gain to be had by having less total requests. So for those familiar with that, who have like bundled their JavaScript together or who have stuck images into a sprite or bundle their CSS, that's why it's because we're limited to the number of resources."
          },
          {
            "time": "[00:07:12]",
            "text": "But the other thing that's really interesting is that Rather than just going down your HTML, and just like in queueing everything it sees like script, CSS, CSS, CSS, you know, going through, the browser's really smart, and it tries to figure out things that it thinks will be higher and lower priority."
          },
          {
            "time": "[00:07:31]",
            "text": "And then it goes down a priority list which is like really great because otherwise. If you think about it, you could put like an image tag and then a CSS tag right after it and the CSS you need that styles your page and the images like I mean, it's you do need the image eventually, but it's usually more additive."
          },
          {
            "time": "[00:07:48]",
            "text": "So what chrome will do is it has this whole system in place where it'll be like, I think these are the top priority. I think these are medium. I think these are lower priority. And that way you don't have to restructure your HTML in a weird way just to get things to load."
          },
          {
            "time": "[00:08:00]",
            "text": "So you can actually right click here and you can do priority and it will add this new column. And it's kind of cool to play around with where you're like, like it views, my HTML obviously, and my CSS is the highest priority. Then it gets to this PNG here I've used that as low priority."
          },
          {
            "time": "[00:08:17]",
            "text": "And then back down here, these font files that are needed to render high priority these two PMGs low JavaScript, medium. It's kind of interesting to see how the browser thinks about it. And it sort of makes sense where usually the HTML and the CSS are like the vital things, like get the site to display and then JavaScript is like."
          },
          {
            "time": "[00:08:35]",
            "text": "Probably somewhat important, but usually it happens after the page load the JavaScript kicks in. And the images are like the lowest importance thing. It's just kind of an interesting thing to see. Does that make sense to everybody that kind of sucks. Six total requests at simultaneous requests and they're more advanced than you would think."
          },
          {
            "time": "[00:08:53]",
            "text": "Cuz Chrome and Firefox and Edge all have a system to figure out what the priority order is. Let me know if you have any questions on that."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Is there a way to change their priority order? Because I remember you can defer scripts."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:08:53]",
            "text": ">> And the head does that."
          },
          {
            "time": "[00:09:11]",
            "text": "What does that do to the priority order?"
          },
          {
            "time": "[00:09:11]",
            "text": ">> Yeah, so you can override it. You can You can make things like higher priority. Well, so there's a couple ways you can override it. Yeah, you can move things up to the head. So like Google Analytics will be like, for example, I want my JavaScript to be in the head please, which will make it a higher priority by itself."
          },
          {
            "time": "[00:09:31]",
            "text": "You can also do things like you can like preload images, you can be like, this one's really important. And then you can Yeah, exactly on the on the other side, you can defer and that says this is less important, right? So yeah, so you can go in and you can either preload or defer."
          },
          {
            "time": "[00:09:46]",
            "text": "And you can also move things around in the structure so that they're, you know, higher up or whatever. And that and that will override these. Yep. So the waterfall is interesting, because I feel like it's largely ignored. And then one day you'll have a thing like this happens to me all the time at work will be like, Hey, Why is this taking so long?"
          },
          {
            "time": "[00:10:03]",
            "text": "And I'll be like, it's this call this API call. And then my boss will be like, well okay, but [LAUGH] Whose fault is that? Right? Not that my bosses mean, but they'll be like, well, what's the problem? Is the problem like the response is too big, is the problem that the service is too slow or that we're too slow or, So this can be really interesting."
          },
          {
            "time": "[00:10:21]",
            "text": "So it provides this really nice colour coded timeline for things that can really help you dive in. And when you're making a ticket, especially if you're like a front end engineer making a ticket for a service engineer, it can help a lot and be really impressive. Again, like one of the themes of this is like Dev Tools helps you cheat a little bit."
          },
          {
            "time": "[00:10:37]",
            "text": "They can be really impressive where you're like, Hey, this is a DNS issue or like, Hey, this is an SSL issue. They're like, Whoa, How did you know that? It's like I'm really cool, so what I've done here because of [INAUDIBLE] I've sort of broken down the waterfall in order and the colours used here are the same colors that combatbtwo of these."
          },
          {
            "time": "[00:10:56]",
            "text": "So, the first colors you'll see which is at the top are white and grey and those are queueing installed. Queuing is exactly what we just talked about. Either there's higher priority stuff, or it's the same priority, but we've already hit our 6 total connections. So I gotta wait."
          },
          {
            "time": "[00:11:11]",
            "text": "Or and this is very rare. The browser is doing some work and just needs a second, that's fine too. And so then they'll show is stalled the entire time that they're stuck queuing so you can see how long they waited. Then the next three are kinda green and orange."
          },
          {
            "time": "[00:11:25]",
            "text": "Those are like setup things happening. One is DNS lookup. So we all know that we were crest like google.com. But that's not a computer's address, right. That's a domain name. So it has to go to the DNS service and find what server to actually reroute to. So if that's slow, that's something going on with DNS routing, not not our company."
          },
          {
            "time": "[00:11:43]",
            "text": "Then it sets up the initial connection, right? So the TCP connection SSL connection, there could be a problem in there. If you're using a ServiceWorker. Like if you have a progressive web app, you can see another orange bar for ServiceWorker setup like it's being bootstrapped. And then purple ServiceWorker has been set up, it's starting to respond."
          },
          {
            "time": "[00:12:00]",
            "text": "Now green is an interesting one green and blue are like the data has gotten on the server and it's coming to you finally, green is waiting time to first byte which is a metric that a lot of sites use to mark performance of their services, which is you know, I say give me food at PNG, and then I will my computer chrome will mark when I get the very first byte of data, the very first packet of data comes over."
          },
          {
            "time": "[00:12:24]",
            "text": "I can use that to kind of gauge how quick my connection between the server and the client are. And then content download is how long it takes for all the rest of the bytes to get over. This one's interesting because this can be largely a client issue, right?"
          },
          {
            "time": "[00:12:38]",
            "text": "If I have a JavaScript file that's like 100 kilobytes, it's going to take a very different time to download In that San Francisco, you know, high speed internet connection than it is if you're on the train, and you're going through a tunnel or something like that. But it can be really nice to kind of categorize things like the white and gray means that too many requests, right?"
          },
          {
            "time": "[00:12:57]",
            "text": "And we're just the browser's just stuck. Not even working on those requests, yet. So you can kinda concatenate your scripts, image sprites, all that cool stuff. The green and orange is like stuffs being set up on the service side. So maybe there's like a hiccup with the DNS registry or the SSL some Something like that."
          },
          {
            "time": "[00:13:16]",
            "text": "The waiting time to first byte is slow. It's a service issue. So you can go to your service, you can be like, hey, time to first byte is really slow. Maybe it's a database problem. Maybe the servers are overwhelmed or they're just slow, something like that. And when content download becomes an issue, you can't just blame the user."
          },
          {
            "time": "[00:13:31]",
            "text": "So you'd have to figure out what you can do to make the content smaller, right? If people are just you know, waiting and this is something that we see Lot of especially in this like modern world where it's so easy to go shopping for new JavaScript libraries, you just keep adding them to your code base."
          },
          {
            "time": "[00:13:44]",
            "text": "You know, you're like, I need a calculator app and I need this. I need that or whatever the things get really big and you'll see large content download times."
          }
        ]
      },
      {
        "name": "18-network-performance-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What is the correlation between priority and waterfall?"
          },
          {
            "time": "[00:00:00]",
            "text": ">> The waterfall will show the actual statistics for that particular request, right like that request. But the priority is how the browser chooses which order to fire things in. So if you have a lower priority item, you will see that it spends time either queueing or stalled."
          },
          {
            "time": "[00:00:23]",
            "text": "If you have more than six, both conditions have to be met. If you only have six total items, the lowest priority gets fetched at the exact same time as the highest priority. But if you have more than six requests, that's images, scripts, CSS, all that stuff, then you'll see lower priority items will spend time queuing whereas higher priority items will not spend time queuing cuz they'll go right away."
          },
          {
            "time": "[00:00:44]",
            "text": ">> So for the waiting, that's specifically an issue with the server side code, or it could be like you said something with the database, that's it, and usually you have to look there to find a way to speed it up?"
          },
          {
            "time": "[00:00:44]",
            "text": ">> Yeah, that's a great question, so time to first byte and waiting, are those always server side issues or could they be front end issues?"
          },
          {
            "time": "[00:01:02]",
            "text": "I mean, technically it could be front end if your connection is so bad that a byte takes a while, there could be some issue there, right? If you're on a really, really weak connection, your time to first byte will be slow as well."
          },
          {
            "time": "[00:01:02]",
            "text": ">> But typically, since it's such a small amount of data, if you see a slow time to first byte, it usually means that between the server getting the request and giving the very first piece of data back is taking a long time, something in there, whether it's server processing the requests or something in the database or something like that."
          },
          {
            "time": "[00:01:33]",
            "text": "It could potentially be something's slow for you, but for example, if other websites are loading great for you and then your website has got a slow time to first byte, that's almost guaranteed to be a server issue."
          },
          {
            "time": "[00:01:33]",
            "text": ">> And did any of these also take into consideration the user's machine?"
          },
          {
            "time": "[00:01:52]",
            "text": ">> So they don't normalize data, they won't say for you this is doing what, Lighthouse for the audits will do something kind of like that. They'll say, this is pretty good for a slow device, something like that. But these are just going to show simply the time taken."
          },
          {
            "time": "[00:02:09]",
            "text": "So if we do a refresh here, it's just gonna say, how many milliseconds it's spent at each phase. So it's spent six queueing, DNS lookup was four milliseconds, and then you can see that the time to first byte took 60, which is very fast, but you can see just pure milliseconds."
          },
          {
            "time": "[00:02:26]",
            "text": "So no, it doesn't normalize the data at all."
          },
          {
            "time": "[00:02:26]",
            "text": ">> I have an equation. What is the initiator columns about? Yep, so the initiator is who requested that. So if you think about you have an HTML file that has a script source main.js in it. So main.js' initiator would be index.html cuz index.html is what called that."
          },
          {
            "time": "[00:02:52]",
            "text": "And then if in that script source you did a fetch for food.jpg, then food.jpg's initiator would be main.js cuz that was who initiated it. So it's like, why did you call this thing? It's like, so it's like this one, we have this, give a refresh here, we have this network.html."
          },
          {
            "time": "[00:03:14]",
            "text": "So we have network.html, that was initiated just by the server, right? That's always the the main thing you get is an HTML file. But then if you look at all these, you can see the initiator network called the JS, network called the PNG, network called this CSS file."
          },
          {
            "time": "[00:03:30]",
            "text": "But the CSS file called these other two CSS files, so you can see the initiator is different for that."
          },
          {
            "time": "[00:03:30]",
            "text": ">> I just had a question. So if we do a cmd F on the network panel, there is a joy version opens up to the right. I was wondering how can we use that, this one, yeah."
          },
          {
            "time": "[00:03:49]",
            "text": ">> So this one's kind of interesting. So you have kind of two options here, you have one is the option just to filter, to kind of filter this list down, right? And so you can do things like if you search for net, you can do something like that."
          },
          {
            "time": "[00:04:03]",
            "text": "You can also do, I think it'll support some amount of regular expressions or whatever. Yeah, the other option that you can do is you can do this kind of more advanced search by cmd+F or ctrl+F. And now when you search for things in here, it'll actually parse all the response data as well."
          },
          {
            "time": "[00:04:21]",
            "text": "So you can like a lot of these will have headers. So basically the filter here is gonna search your names, right? That's what it's gonna search. The search bar here is gonna search the names, all the response headers, all the request headers and the resulting response body itself."
          },
          {
            "time": "[00:04:37]",
            "text": "So you can really kind of filter through. We're almost done with the network, but I do have one call that I like to do which is rightfully, we obsess about network performance. It's a good thing to obsess about. And the faster you get your site, the happier users will be."
          },
          {
            "time": "[00:04:51]",
            "text": "But I do feel like sometimes we get really carried away with this idea of, and actually the jesup question is a great segue of, well, if we can just really compress everything and send it over, then we've solved our problem, right? So we'd take this gigantic thing of JavaScript and we compress it and send it over the wire and that's great because it's fast over the wire."
          },
          {
            "time": "[00:05:11]",
            "text": "But I do want to always caution people that as we compress more and more and as we send more and more JavaScript specifically instead of images over the wire, parse time becomes a really big bottleneck as well and it's something to keep in mind. So the idea with compression being you take a JavaScript file, it's 10,000 lines long, you run it through Gzip, and you get a much smaller file, which is great, cuz smaller files travel faster over the wire, but they have to be uncompressed on the client's machine, right?"
          },
          {
            "time": "[00:05:43]",
            "text": "Their browser will uncompress it. And they still have to parse that giant amount of JavaScript. So I do think that compression is great, we should compress everything. There's a lot of websites that are gzip everything or whatever and they'll check a website to make sure that everything is being compressed and broadly is even faster."
          },
          {
            "time": "[00:06:00]",
            "text": "But we need to keep in mind that at the end of the day, we really should be trying to limit the amount of JavaScript that we send over the wire too. Those are always huge wins because even if we can get the network request quick, the parse time is really substantial."
          },
          {
            "time": "[00:06:15]",
            "text": "There's this post by Addy Osmani here that I linked to, which is well worth the read on itself, but it's called JavaScript Startup Performance. And it's just all about kinda like the cost of JavaScript. So I took this picture from it, which I really liked for people that want a better idea of how kinda these things work like after the JavaScript makes it over the wire and is uncompressed."
          },
          {
            "time": "[00:06:37]",
            "text": "It still has to get parsed and turned into the DOM tree and it gets compiled and optimized. All this stuff has to happen on this large amount of code. So while we shrink our images and bundle and shrink our JavaScript, all that, trying to send less JavaScript over the wire is vitally important to speed."
          },
          {
            "time": "[00:06:54]",
            "text": "And you can do really cool things. You can asynchronously load bundles if there's a web pack front end masters course where Shawn shows how to split your bundles up and only load what you need at page load and bring stuff in. So there's a lot of different ways we can think about it."
          },
          {
            "time": "[00:07:08]",
            "text": "Network's really important but parse time is really important too. And there's a little graph, the same JavaScript file. So you're on your nice desktop computer and it takes 200 milliseconds, which is well within a fine range for everything to parse, but you move over to a mobile device that has a worst CPU and it can take over a second to parse the exact same file."
          },
          {
            "time": "[00:07:26]",
            "text": "So just to call out on that stuff. Cool, any questions about that?"
          },
          {
            "time": "[00:07:26]",
            "text": ">> When you go to the size, right, when you're in your Network tab, you're looking at the size column. If I were to refresh this page right now, and not a hard refresh, but just a refresh, I don't see it on your screen, but I see some assets showing up as dis cache [CROSSTALK] memory cache?"
          },
          {
            "time": "[00:07:54]",
            "text": ">> Yeah, I have this cache disabled. So if I unclick that, yeah, so these are just things that the browser has been able to optimize for you. So these items that are just CSS file items that are just being cached on your disk, so they won't have to load."
          },
          {
            "time": "[00:08:11]",
            "text": "So you can see the page load time goes down to zero milliseconds. This is similarly true, you'll see it if you cache responses to yourself, right? So if you set cache headers on your network requests, then you'll see those reflected there as well."
          }
        ]
      },
      {
        "name": "19-measuring-real-user-performance",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the very last thing I wanted to cover as network stuff is the idea of measuring real user performance. So this is a really cool idea. It was actually something I didn't get into until later in my career. So what we would always do is we would like, again, we are like authoring a web app, and we look at it on our machine and we are like, it is pretty fast or whatever."
          },
          {
            "time": "[00:00:22]",
            "text": "We know the amount of milliseconds that it takes. And then somebody even asked a question earlier about like, but does it normalize that data based on your network conditions? And it does not. But I think that's hinting at a really a larger question, which is like, okay, but how fast is it for your average user or like how fast is it for the bottom 10% slowest user computers?"
          },
          {
            "time": "[00:00:43]",
            "text": "Or something like that. And so this idea came around a long time ago of shipping some code that would like sort of get the time that it actually takes on their actual computer and send it back to you. So at its like absolute simplest, you could stand up a service that takes like maybe a username and event like the page to load and a time, right and you could have a database that stores all that."
          },
          {
            "time": "[00:01:07]",
            "text": "Then you could ship some JavaScript in your actual app that looks like this. And let's say this for loop that's doing nothing is your page to load or whatever. So you could do like a start time using date time. And then you could do some expensive thing and then you could do an end time."
          },
          {
            "time": "[00:01:21]",
            "text": "And then you can figure out the difference yourself by doing n minus star and then you could send that to this cool service. You can be like, whoa, like most people, it takes one second. But look at this, a few 100 people, it's taking 30 seconds what's going on there."
          },
          {
            "time": "[00:01:35]",
            "text": "And you can learn all sorta cool stuff like, we have our data centers in the US. But we're getting a really big, African bumping users. We should get a data center out there. We should do something like that. So this happens to us a lot like at Twitter at startups."
          },
          {
            "time": "[00:01:49]",
            "text": "You'll see your app will go big in a new place that it hasn't been big before. And all of a sudden everybody's kind of crossing over the the data takes a long time. So this can be really cool to A, see what how it performs on slower computers but B, to recognize when something has changed, like you have a new country city zone that's getting really popular and you wanna go add some resources to it."
          },
          {
            "time": "[00:02:12]",
            "text": "So this is what we used to do. But then we got this really cool thing called console time, which is way better. So instead of doing the math ourselves, we could just console time we could pass in a string. Now we do the thing when it console time and the same string and then it keeps track of it."
          },
          {
            "time": "[00:02:28]",
            "text": "It prints it out for us, which is like super cool. And it's also more accurate it prints it out down to a more finite number. So then that was the cool thing to do for a really long time. And now we have an even cooler thing, [LAUGH] which I get really excited about, which is the performance API."
          },
          {
            "time": "[00:02:46]",
            "text": "And so, again, these are all doing the exact same thing, right? But it's like, instead of console time and console time, and you do performance which is a global.mark, and then performance.markend, and then you can print out, mark and measure is the technology, so then I print out a random string, and then which two things to compare."
          },
          {
            "time": "[00:03:05]",
            "text": "So this is very much the same as, up here where I would do like console and start. But the cool thing about doing it this way is not only do you get that time, but it actually is like a standardized thing that other browsers recognize. So if you run some code like this, and let me see if I have some going, Yeah, so if you run some code like this and you do a performance measurement, which is what the tab we're gonna cover next."
          },
          {
            "time": "[00:03:34]",
            "text": "But if you do a record, and then you refresh the page, and then you stop the recording, we can ignore a lot of stuff. But we can see that my mark and measure actually made it into a brand new section called Timings in the Performance tab where I can actually see how long it took."
          },
          {
            "time": "[00:03:48]",
            "text": "I can interact with that. So it's like way cooler than console logging out, and minus start or whatever you do a performance mark and a performance measure, and it'll actually show you in the Performance tab, exactly how long it took and what it was doing and cool stuff like that."
          },
          {
            "time": "[00:04:02]",
            "text": "So these are really cool to add something like this, whichever approach you take is fine. And to stand up some kind of service that receives all of it. And you can really see how long it's taking your actual users to load your actual code. The performance API also has a bunch of really cool stuff."
          },
          {
            "time": "[00:04:18]",
            "text": "I'm not gonna cover it in depth, but I did just wanna show you so just on any random site, you can do something like Performance get entries by type, and then you pass in a type. So I'll print this get entries by type of resource. And it'll actually show me all eight of the resources at grab, which is the exact same stuff that you see over here."
          },
          {
            "time": "[00:04:37]",
            "text": "But you can start like brainstorming like as you get more into this stuff that you could totally build your own Tooling, around, for example, you could just take this, and you could send it to your service. So your user sending it in, and now you can see the network waterfall, for your users in real time, as opposed to just you using your app."
          },
          {
            "time": "[00:04:55]",
            "text": "Things like that. You could do paints. So every time the browser has to do a repaint, and you can see what was it called? What did it? What triggered it? How long did it take? All these really cool things. So it's basically the same API that Dev Tools is using to do its like network stuff and things like that."
          },
          {
            "time": "[00:05:11]",
            "text": "But now you can not only harness it by making custom scripts where you can actually grab that user data and send it to a service, you can re better understand how long all these things are taking. This was really cool. I would just if I were you, I just do like a performance."
          },
          {
            "time": "[00:05:26]",
            "text": "And then do a dot and just check out all these like very, very cool things that it can do. And MDN has really great docs on the performance API, which I've linked to up here. It really opens up like a whole world of stuff you can do."
          }
        ]
      },
      {
        "name": "20-on-page-performance",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the on-page performance or the CPU lesson, and so we're gonna be messing with the performance panel. We're gonna learn about how to read the flame graph, how to find page jank, we're gonna learn about a bunch of really cool little tools that it has to kind of help out along the way."
          },
          {
            "time": "[00:00:19]",
            "text": "And before we get into that, I kinda wanted to talk about the way that we're viewing performance these days, so Google has this rail philosophy which I really like. It's the rail performance philosophy, and it's kind of four different things to think about, four different considerations. One is general app response time, so that would be, we've all been there, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "Where we met on a website and we click a button and it doesn't interact in any way, I have no idea, what did it get my clicked and not get my click, these kind of things. So some type of response really quick for the user, so they know that you've received what they've done, the second category is animations."
          },
          {
            "time": "[00:00:57]",
            "text": "So whether it's a cool scroll animation, or something moving, or something really vital you're making a game or whatever, animation speed is really important especially cuz it gets really choppy. Idle time too, I'm sure you've all heard or people say this a lot, but JavaScript is single threaded, we're not going into too much JavaScript detail, basically it can't do multiple things at once."
          },
          {
            "time": "[00:01:24]",
            "text": "And so what we often do in our application code is we just, send it I need to do this and this and this. I have all these ideas of stuff I wanna do and we just in a big file, just do all this stuff, but if you keep the thread really busy, it's hard for your app to be interactive, right?"
          },
          {
            "time": "[00:01:41]",
            "text": "Your app is not interactive when the thread is busy and so, making sure that you batch up your work, which we'll cover a little bit. You can go a long way with making it so, I don't know if you've been there before, been on a mobile site and it's loading you try to scroll it."
          },
          {
            "time": "[00:01:53]",
            "text": "And you can't even scroll it, cuz everything is so clogged up it's so busy you can't even move it? That's what idle time is, and last one is load, so both the on page load, we covered with the network stuff, but also as you're changing things up, make sure the loading time is smooth."
          },
          {
            "time": "[00:02:08]",
            "text": "And Google's kind of broken it down in this cool way, so the zero to 16 millisecond, which is really, really small, everything feels really good to a user. Once you get 60 to 100 milliseconds, I think under 100 milliseconds they still can't tell the difference between immediate and 100 milliseconds or under."
          },
          {
            "time": "[00:02:33]",
            "text": "As far as the way our eyes and brains perceive things, but once we get up above 100, you can immediately feel it, right.? And so, I think one thing that's fine if you stick under 1,000, then it still feels like 1,000 milliseconds so one second, you still feel engaged in that task maybe."
          },
          {
            "time": "[00:02:53]",
            "text": "But you're definitely feeling that there's been a change, some requests and some perceptible amount of work happening. And then kind of over 1,000, it's a problem, things are taking too long, people lose focus and then once you get over 10,000, which is 10 seconds, you can see a lot of abandonment."
          },
          {
            "time": "[00:03:09]",
            "text": "So I think that the 0 to 16 is amazing, that's for our animations that should be our goal. 0 to 100 is totally fine for actions, if I click, add to cart and it takes 100 milliseconds to update the cart, totally fine it still feels good. 100 to 1,000 starts feeling, okay, maybe I asked a lot I can see that it's taking a while but it's still enough for people to keep focused, and I want you to go over that, people start losing focus a lot."
          },
          {
            "time": "[00:03:34]",
            "text": "So it's basically kind of the same thing that we did with network, except this is different because they are on the page at this point. But, with a lot of these very modern single page apps, the slowest loads sometimes aren't the initial load sometimes it initially loads fast and then you click something and it takes a long time."
          },
          {
            "time": "[00:03:51]",
            "text": "There's a terminology one, but I find this a really good educational terminology so, people mentioned page jank a lot on web performance talks. And it's interesting cuz it basically just means lag, or stuttering, or jittering, what the official definition is any stuttering, juddering or halting that user see as a site is not keeping up with refresh rate."
          },
          {
            "time": "[00:04:15]",
            "text": "But I remember a long time ago, I would always hear about refresh rates, hertz or frames per second or whatever, and I sort of get that you want more frames per second? You don't want less frames per [LAUGH] second, but I didn't fully understand, what's going on here?"
          },
          {
            "time": "[00:04:34]",
            "text": "And so I got this definition that I found on the Google Docs that I really like, so it's, okay, it starts with your display refresh rate. And so, most of the devices today refresh their screens 60 times every second. And in order to always look very smooth, the screen is hi, I'm about to refresh browser do you have anything, and the browser needs to be able to serve up a frame."
          },
          {
            "time": "[00:04:59]",
            "text": "So that's you can kinda think about constantly happening, your monitor is like, hey, I need to go. What do you have in the browser cool, here's a frame and that's happening 60 times a second. And so if you do the math on that every 16.66 milliseconds, you have to have a new frame ready to go, that is how often one new frame will go out the door, and so it would be tempting to say."
          },
          {
            "time": "[00:05:20]",
            "text": "So you need to never do so much work with an animation, that you don't have a new frame ready every 16 milliseconds. But the reality is there's actually, you don't get the full 16 because the browser has housekeeping work and stuff to do. So really, each animation needs a new frame to serve up in ten milliseconds, and if things get too blocked, where every 10 milliseconds, it doesn't have a frame to show."
          },
          {
            "time": "[00:05:43]",
            "text": "So for example, you're just asking for a full repaint constantly in the browsers trying to get it done. It won't have one for the monitor so, it won't give one and that results in dropped frames basically, so you'll be losing frames there. And so this seems like a lot if you're not doing heavy video game animations, but it's worth thinking about even if you're just doing a cool wave of animation, or a background, or a parallax scroll or something like that."
          },
          {
            "time": "[00:06:08]",
            "text": "There's all these ways that we can be pragmatic and we can try to be better about making sure that there's a frame to go every 16 or every 10 milliseconds, cool. So, think at that point, we can kinda open up and kind of peek in, just before we get into talking about jank and things like that."
          },
          {
            "time": "[00:06:26]",
            "text": "I just kinda wanted to explain, how we should think about it with the rail model, and what these kind of times mean as far as losing frames. So the Performance tab, so go over and we'll click on it, and there's kind of two options here, option one is to this one where you do a refresh and that'll show you the actual creation of the page performance."
          },
          {
            "time": "[00:06:48]",
            "text": "And option two, is just to start a Recording where you can do whatever you want, interact with something and then hit Stop, and those are four different use cases, right? One you wanna know, especially if you have a react or angular app, how does it assemble the app."
          },
          {
            "time": "[00:07:01]",
            "text": "What's the page performance like when it's bootstrapping, the other one is man this add to cart button takes a long time what's going on here? And so, if we do one here a Refresh and Profile and then hit Stop, we can kind of see all these different things happening."
          },
          {
            "time": "[00:07:15]",
            "text": "So, the screen is always for sure the scariest cuz there's just so much happening, but I wanna try really hard today to make it a little bit less scary, a little bit more understandable. So, I think if we view it in sections, that's one of the best ways we can do it, so I'm gonna try to kinda minimize, toggle up a couple of things here, okay?"
          },
          {
            "time": "[00:07:34]",
            "text": "So we sorta have three sections, we have this summary view down here, which I'm gonna minimize I'm gonna get to that one last. Then we have up here, this is a section I know it's a little bit hard to see my mouse, but above my mouse. And up here is a separate section, and that's showing three things layered on top of each other, one of them is the frames per second."
          },
          {
            "time": "[00:07:57]",
            "text": "So we'll be looking for big jumps in that if we lose frames, the other one is what the CPU spends its time doing. We'll see a bunch of different colors in there, which will relate to the summary section, and then the third one is just network traffic, and so that's one thing."
          },
          {
            "time": "[00:08:13]",
            "text": "So if you ignore all of these, and we just focus on this top thing, we can kind of, I'm gonna click here and I'm gonna drag an area to kind of Zoom in and focus on it. So I click and drag there, so we can kind of see that there's three different things going on, you can see across the bottom that the network is busy the whole time is our site's loading."
          },
          {
            "time": "[00:08:31]",
            "text": "It's doing stuff with this blue bar, you can even see right here, it stops being busy, as soon as everything is loaded there's no more blue bar. You can also see that there's two little seconds where we actually go up in high frames per second, there's two little jumps here, right one here and one here."
          },
          {
            "time": "[00:08:47]",
            "text": "And for the most part it's completely clear, and those frames per second jumps, tie in very nicely to the CPU doing work, and that's almost always going to be the case, right? The CPU is telling the browser to re-render stuff and you'll see stuff at the same time, and then the last part for this section is the colors."
          },
          {
            "time": "[00:09:06]",
            "text": "So if we zoom in even closer here, we can see there it might even be a little hard to see. Unfortunately I can't make this bigger but there's yellow, purple and green, then mostly yellow, little purple and a tiny bit of green. And if we go back to the Summary tab, we can kind of see what the colors mean, so the color yellow is script running."
          },
          {
            "time": "[00:09:24]",
            "text": "So if you had a for loop or Fibonacci generator, some JavaScript that's running, blue is network, so we don't see any blue that would be waiting on something to load. And then we get into rendering and then repainting, and so the rendering is heavy math that the browser is doing calculating."
          },
          {
            "time": "[00:09:40]",
            "text": "If you say this needs to be 200 pics by 200 pics and float left, then the browser has to figure out how to size it and where to put it. And then once it's figured that out, then the browser actually repaints that area of the screen so, I'm gonna take a little pause there."
          },
          {
            "time": "[00:09:54]",
            "text": "So we haven't gotten into the the big middle area, but we've looked a little bit at, okay. So we can reload or we can Record while we're doing stuff, and we get these kind of three sections up here, showing the frames per second. What work the CPU is doing and the network traffic, how are people feeling about that so far?"
          },
          {
            "time": "[00:10:13]",
            "text": "I know this is for years I just ignored this tab because it was too overwhelming for me so, if you're feeling pretty good about that, then you can see we did a refresh. And the page starts loading all this network stuff, you can even see back here it was just doing system work."
          },
          {
            "time": "[00:10:29]",
            "text": "Something the browser's doing as refresh happens, then we get into here and you can see, okay, now some work happens. There's some scripts running, frames per second shoot up a little bit, there's some rendering and painting that happens, and it kinda goes back down to just hanging out."
          }
        ]
      },
      {
        "name": "21-performance-panel-page-jank-tips",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so I think that sort of sums up this top area, which is like a pretty nice kind of high level view, what's going on? Are we having any issues? And we'll see in the exercise that the dev tools are really good when there are issues like when you're having page jank they just start highlighting stuff with red both up here and in the main section, which is really nice because you can just kind of open it up and see if there's problems."
          },
          {
            "time": "[00:00:25]",
            "text": "So now moving into this section, this one used to be less complicated, but I think it's way better now. It used to just be a single column for all the different stuff going on, but now you can see that all of these little columns are titled by different things that are happening."
          },
          {
            "time": "[00:00:43]",
            "text": "And so you can see like the network requests as like I request my fonts and things like that. And it has a lot of the data that we saw on the previous one like you can see the time it took and the priority it had which is really nice."
          },
          {
            "time": "[00:00:55]",
            "text": "That was the exact same stuff we saw on the Network tab earlier. You can also see all the frames and we'll take a look specifically that when we start doing some real GPU heavy stuff. The timings one we had already seen, right? That if you do any performance marking measure, the stuff will show up here which can be really nice."
          },
          {
            "time": "[00:01:16]",
            "text": "Actually don't know what the experience one does [LAUGH]. I've never used that one before. I think it's part of this. Yeah, I'm not sure. And then we can see the main thread here, right? So again, JavaScript being single threaded, this is where all the work will kick off."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we had like a big for loop or if we have, calculating something or you have react, parsing the JSX tree and generating stuff, see all that going on in here. We can check out all the rasterizing that happens on the site as it loads. We can see if any work that the GPU is doing, what work it's doing."
          },
          {
            "time": "[00:01:47]",
            "text": "And then we've got a couple of other things here that I honestly I'm not sure exactly what they do, but this like child IO thread and the compositor. So for the most part we're just going to be we use timings when we do our own performance market measure."
          },
          {
            "time": "[00:02:00]",
            "text": "The network, one is really helpful to associate. A big request came in and then I started getting page jank, but it's not as helpful when you wanna see what's what's really going on. But for the most part, we're going to just stick in this main thread. This is where we're going to be able to see a lot of stuff as it's happening."
          },
          {
            "time": "[00:02:20]",
            "text": "So let me close this for a second. So as we kind of get into things, I think it's, it's important to look at specific examples, which we'll do and we'll kind of figure some stuff out but it's also important to know understand some high level concepts. And the high level concepts are both things that you can do to avoid page jank and performance problems."
          },
          {
            "time": "[00:02:41]",
            "text": "But they're also they explain a lot about what frameworks do and like why these frameworks exist and how they work under the hood and things like that. And so the first thing that you can do is there's an API on the window object called requestAnimationFrame. This is really great."
          },
          {
            "time": "[00:02:56]",
            "text": "And the basic idea is that instead of doing a thing, like changing the size of something right? By doing like dev.style.width equals 500 pixels, you can take that and you can pass it in as a callback to request animation frame, that same thing. And what that says is I do want you to do this, but you don't need to interrupt everything and do it."
          },
          {
            "time": "[00:03:18]",
            "text": "Before you do the next window, repaint, please do a request animation, please do this piece of task. So like an idea of how things can go really awry is this code up here. So this looks like pretty normal where you're like, you grab a thing from the DOM, you grab its height, and then you change its height and then you grab another things height and you change its height, and you just kind of like doing your work, right."
          },
          {
            "time": "[00:03:39]",
            "text": "You're just like grabbing three things and changing their heights or whatever, but the order that they happen in really matters because when you do read that it can cache that. So now anytime you refer to h1, it's got that value cached, right? So it doesn't need to hit the window again."
          },
          {
            "time": "[00:03:55]",
            "text": "But then you do a right it invalidates the layout right now we have no idea how tall this thing actually is rendered to be. And so when we if we write vanilla code that interacts with the DOM, we can get into this bad habit of like doing reads and writes back and forth."
          },
          {
            "time": "[00:04:09]",
            "text": "And we're never able to cache those values like we're always just wiping out the or invalidating the cache. And then rereading and rereading and rereading. So one approach that you could do is you could like pump all of these reads and writes into a request animation frame. So the kind of way I like to look through it is like let's say you have a site by yourself and you're aware of this."
          },
          {
            "time": "[00:04:31]",
            "text": "So you write this code, you're like, This, this won't do. I kind of wanna do all my reads together and then all my rights that's like a that'll make things a little better. So you do that. But then you add a bunch of other people onto your team."
          },
          {
            "time": "[00:04:44]",
            "text": "Now it's gonna get really annoying. It's like no, you can't just read the DOM, you got to go over here. And this is where we do our DOM reading. This is where we do our DOM writing, it gets really obnoxious. So what you could do is you could put all of those reads and writes into a request animation frame so that way, you're only invalidating the layout right before it gets repainted anyway for another frame."
          },
          {
            "time": "[00:05:04]",
            "text": "But the important takeaway here is maybe not to use requestAnimationFrame all the time. But the important thing is, this is one of the really cool benefits that using a front end framework will do is all of these frameworks will do this stuff for you. So if you're like in react and you say, Set the height on something or rerender, a new component, it won't interrupt to do it."
          },
          {
            "time": "[00:05:22]",
            "text": "It'll wait until the next animation frame fire, so I think the bigger takeaway here than using this API all the time is that this is one of the really cool benefits from using some open source front end framework is they'll do stuff like this for you. Another thing you can do web workers, so if we load a page and we see in kind of, this like center area here, if we see a bunch of big yellow JavaScript stuff like I had an example here of like, calculating Fibonacci or something like that, where it's like, it's really busy, the process is really busy."
          },
          {
            "time": "[00:05:56]",
            "text": "You can offload that stuff to a web worker, which essentially gives JavaScript the main thread back to handle the actual website. There's a lot of cool talks on web workers and stuff like that I have a very basic example. So you can like grab two things like you can grab an input form and a feet on a div to display some stuff in If you can check if the window dot worker API exists, like if this browser supports it, and if it does, you can instantiate a new one."
          },
          {
            "time": "[00:06:23]",
            "text": "And then you can basically send messages with a post message command and you can receive messages with an on message command. So for example, like a contrived example, if you have a bunch of cool animations on your screen, but you have to calculate a really big number If you don't use a web worker when the calculation's happening, those animations are going to just stop, right?"
          },
          {
            "time": "[00:06:41]",
            "text": "They're gonna freeze there because the main thread's being used to calculate the number. And as we mentioned a little bit ago, you could also get around this by moving all those animations into CSS, which would free you up there. But in lieu of that, you could take the big calculation, you could toss it to a web worker that'll split off another thread, do your calculation and then answer back."
          },
          {
            "time": "[00:06:59]",
            "text": "Meanwhile, the animations go smoothly. Web Workers are a whole separate topic. They have restrictions like they can't mess with the DOM. But they're really great for kicking off any kind of big tasks like If you do any kind of Frontend processing for your ads or something like that, which ones got clicked on, which ones got seen and you have all this math to do."
          },
          {
            "time": "[00:07:17]",
            "text": "That's a great example of when to use a web worker to free up the main thread. The next one use a framework. I meant to put an asterisk here, this is a warning. I'm not a gigantic framework proponent. I'm not like you should always use some framework for your apps."
          },
          {
            "time": "[00:07:32]",
            "text": "Not at all. But I do think if you're getting into a problem where you're trying to do something like anything with animation heavy working on a game working on a really flashy website, and you start seeing these page jank problems, then using some kind of framework and doesn't have to be a react style."
          },
          {
            "time": "[00:07:49]",
            "text": "It could be like a D3 style or something like that. One of the big benefits is they will batch up this work for you and do those things. And then the last thing is just like again, kind of back to the Network tab, the idea of reducing complexity."
          },
          {
            "time": "[00:08:03]",
            "text": "So this is like, you can be amazed at all the things like even like a long, CSS selectors like, DIV UL Li span ,or something like that take more processing power than shorter UI like, selectors like a class name or something like that. Just like kinda a million things that ,you could do."
          },
          {
            "time": "[00:08:19]",
            "text": "But I think the big ways to do it are,using web workers for expensive stuff and using requestAnimationFrame for batching up all of your writes and, reads and things like that. I know those are a little weird because they're covered but not covered in depth like this isn't going to be on web workers or RIF."
          }
        ]
      },
      {
        "name": "22-layout-thrashing-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We have an exercise here. This one starts to get a little bit harder. So if folks are struggling with it, there's like absolutely no problem with just waiting until we go over the whole thing together. But this is like a really cool opportunity. I would just suggest to at least play around with the Performance tab and start looking at it."
          },
          {
            "time": "[00:00:21]",
            "text": "So the [LAUGH] idea is it's about layout thrashing. Well, we've been talking about it's about page jank, and things like that. So you can see right now, we've got these ten little Frontend Masters logos, and they're just animating around, on the screen here. And they're really smooth, at least for my screen."
          },
          {
            "time": "[00:00:35]",
            "text": "They're very smooth. And as you start adding more, and more, and more, I have a very new laptop, but, it gets to the point where they're very not smooth. I'm not sure how it's coming in, but like on my screen, they're like very jittery. And so, this is a kind of a multi part task."
          },
          {
            "time": "[00:00:52]",
            "text": "I'm going to remove some sort of back down. So the first one is to make it jittery, keep adding 10 or 100 until it gets jittery. And when it's jittery, like we'll add a couple like this, we'll open up the dev tools. We'll go to performance and we'll record like just one second, let's say."
          },
          {
            "time": "[00:01:08]",
            "text": "So another like tip for when you're doing the recordings is there's a lot of information to process. So the shorter that you can keep your recordings to the better. If you try to record like 10 or 15 seconds of stuff, you'll just have way too much data it'll take too long to parse, and it'll be too much to look at."
          },
          {
            "time": "[00:01:26]",
            "text": "So the exercise here is to get it to the point where it's janking to do a performance recording on it. And then we'll want to one, look at all the ways that Dev Tools tells you. There's page junk, which I'm sort of kind of giving away here with like these big red bars and things like that."
          },
          {
            "time": "[00:01:45]",
            "text": "So that's one, see if we can figure that out. And then the other thing is, can you figure out from just the main thread view, what function is causing the page junk? Just to look at, read through it, scroll up and down. One thing I should mention is navigating is a little bit tricky here."
          },
          {
            "time": "[00:02:01]",
            "text": "So let me go back and record again. So I'll just record for one second and stop it. So we're just gonna be looking in the main thread. But navigating is really hard to do. So if you scroll like up and down, you'll see that it doesn't actually move you up and down."
          },
          {
            "time": "[00:02:17]",
            "text": "It moves you like you're zooming in. I don't know if you can see these bars up here. So as what I would think would scroll me down actually zooms in and zooms out over a specific section of time. And so what you'll wanna do if you wanna actually scroll up and down, like here or something like that, you'll wanna hold Shift while you scroll, and that'll allow you to actually move up and down the call stack."
          },
          {
            "time": "[00:02:39]",
            "text": "So you can see this whole thing, this is the whole second of me running. You can zoom in on a little bit. We should be able to see what type of stuff was happening here. This is on the optimized example still, but there's only ten of them. But you can see that the frames per second are high, they're looking pretty good."
          },
          {
            "time": "[00:02:57]",
            "text": "You can see that there's a lot of free time, that's those slashes through, and the time that is spent it looks like it's spent between, if we go back to this summary, and drag it up. Between scripting and rendering looks like it's pretty evenly spent. So the idea here will be to do the exact same thing, but after you've hit add 100 enough times so that there's actual junk happening and take a look at how different it looks."
          },
          {
            "time": "[00:03:18]",
            "text": "How you can identify that there's definitely a problem here and see if you can kind of figure out just by peeking around in this main thread, what tasks are happening when the page jank is starting to happen?"
          }
        ]
      },
      {
        "name": "23-layout-thrashing-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we already kind of looked at what it looks like on normal. So let's add, I think for me, it's adding 400 or maybe 500, I start seeing some really significant junk. So I'll do the recording for one second, again, always recommend keep the recordings as small as possible cuz there's just so much data."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really cool, so, hopefully this should look very different this time, with all of that stuff, than it did the last time. And there's a couple of things I wanna draw your attention to one, is the red lines across the top, in the frames per second. So, those red lines are where it lost a frame, right?"
          },
          {
            "time": "[00:00:32]",
            "text": "Or it dropped a frame, so, it should be really obvious when you load up a worksite or something like that, get it in that state where you're worried about it, do a recording. And you should see, Chrome is like telling you hey, there was some serious issues here."
          },
          {
            "time": "[00:00:46]",
            "text": "In a very similar vein, under the experience panel here, you see this layout shift in red, which I'm not 100% sure on what it means, but it definitely relates to the frame dropping in some ways. Something's going on there, another thing that you can see is that whereas before, the chart here for the CPU was mostly small mountains with a lot of free time, though white and gray slashes."
          },
          {
            "time": "[00:01:12]",
            "text": "And now it's basically 100% CPU for the entire time it's running the app. You can still see it kind of comes in these waves, there's little bounces, but it's just a massive amount. So if we go ahead and we expand the main tab, we can kind of see every app has its own very unique personality, right with how things are working."
          },
          {
            "time": "[00:01:35]",
            "text": "And so you can kind of see here that what keeps happening is every 100 milliseconds some tasks is getting fired, and something is going on that's causing again, you can see more red saying that the task took too long. There's probably junk or whatever. When you're looking at the thread, what you don't care about is how tall things are."
          },
          {
            "time": "[00:01:57]",
            "text": "That's fine because that's complexity of your code is all it is. So if you have, my example with debugging where you have function one calls, function two calls, function three, let's say you just had 100 of those, you would have a really long execution stack, but it would happen really quickly cuz all it's doing is calling another function."
          },
          {
            "time": "[00:02:15]",
            "text": "So when you're looking at this thing, if it goes up and down 100 or something like that, that's nothing to worry about. What you do wanna worry about is the ones that are too wide, because as we said before, every 16 milliseconds it needs to have a new frame to send basically."
          },
          {
            "time": "[00:02:31]",
            "text": "And so you're looking for long wide ones or the problematic ones and the really long call stacks are not a problem. And so you can see here, we only had 16 milliseconds to produce this frame. And this animation itself took 129 milliseconds so that is a lot of drop frames happening there."
          },
          {
            "time": "[00:02:50]",
            "text": "In a similar way, the way that you can find the problematic function or the problematic code is to go down the call stack and find the last long one before they get really small. So if you think about it, it's if you have a if you have a function called Fibonacci, and it takes forever to generate a Fibonacci number."
          },
          {
            "time": "[00:03:10]",
            "text": "And you wrap it in a function called foo, and all foo does is call Fibonacci, foo will look long too even though it's not really doing anything cuz it's the parent of a long function, right? And so you'd see foo Fibonacci but what so you wanna do is you wanna keep looking at the long ones until you get to the last long one who itself only called a bunch of short ones, because the short ones, aren't gonna be a problem."
          },
          {
            "time": "[00:03:34]",
            "text": "And then you know the last long one is going to be the closest that you can get to the problematic function. Does that make sense, I know that it's kind of a confused, so in this example, we see that the task took too long. And we wanna know what caused and so we can see this is long, long, long then we get to App update long."
          },
          {
            "time": "[00:03:51]",
            "text": "And then after app update, if we were to zoom in here, we would just see that it's calling a million tiny any little short ones. So, if we wanted to know what function was the problem here, app update is the last long one before a bunch of the short ones."
          },
          {
            "time": "[00:04:06]",
            "text": "And then you can do cool things, so you can click on app update if we wanted to kinda see what's going on. And we can bring back up this summary view here, once we click on any cell you can see this is changing. So we can click on the last long one and then we can go and open the actual file where the function got called boom here."
          },
          {
            "time": "[00:04:25]",
            "text": "So again, from the performance, you find whichever cell that you wanna investigate, and then you look at the summary, which you might have to drag up a little bit and then you click on the file name. So one thing that you'll notice that's really cool is after you've done a performance audit, when you look into sources, Chrome will save how long the function took to run in the sidebar here, of all the stuff that it was able to see."
          },
          {
            "time": "[00:04:48]",
            "text": "Which is really cool, so you can see this app update took a super long time, took like well over a second, almost 1.5 seconds. And then as you start looking into it, so that basically gets us to the JavaScript code that's causing our problem. In this case, we can see that it's doing a lot of reads and writes right, where it's going through each one of these little Chrome Dev Tools things and it's looking to see so it's reading them to see if it has a class name."
          },
          {
            "time": "[00:05:16]",
            "text": "And then if it does have that class name, it's reading them again to get the offset from it. And then it's reading the current position against the max height of the screen that it's in. So it's doing really, really heavy calculation right and it's doing them in an inefficient order where it's like read, write, read, write, read, write, just like we saw before."
          },
          {
            "time": "[00:05:35]",
            "text": "And what's really cool is that there's this optimize button on here and literally all this is doing is it's batching those things so that they're done without invalidating layout just like we were talking about in the example before. And so even with this many hundreds and hundreds of them, if you click optimize, you can see that they instantly smooth right up."
          },
          {
            "time": "[00:05:54]",
            "text": "So it's not just don't do heavy lifting, the web is very capable of doing heavy lifting. But it's important to know how these layouts happen because if you optimize around them, like do all your reads and then do all your rights, and you put both of those in request animation frame you can get a really smooth animation even though it's still doing a lot of really heavy work."
          },
          {
            "time": "[00:06:13]",
            "text": "How are folks feeling about that? Any questions?"
          },
          {
            "time": "[00:06:13]",
            "text": ">> You said something about getting the opportunity to dig into the call stack. So, cuz when we clicked on thrashing.js that did take us to sources."
          },
          {
            "time": "[00:06:13]",
            "text": ">> Right."
          },
          {
            "time": "[00:06:13]",
            "text": ">> But there was nothing in the call stack on the right. So, I think I'm missing a piece of the puzzle."
          },
          {
            "time": "[00:06:32]",
            "text": ">> Yeah, no, absolutely, no, that's great. So yeah, the question was about that I mentioned earlier that when we're looking at performance, we'll be able to look into the call stack of how it got there. But when you clicked on one like we did, and you clicked on the link, which is what we had done earlier, it didn't actually take you to sources with a call stack, right?"
          },
          {
            "time": "[00:06:52]",
            "text": "We got to App update and we clicked on this and it was not paused at a debugger. So we've got two options here, option one is we can now that we've gone to sources, we can set a debugger, right? We can set a breakpoint there and then let it hit again and when it hits again, we'll get the full call stack over here."
          },
          {
            "time": "[00:07:08]",
            "text": "So that's option one, option two is back over here on this performance panel, where we can actually see where these things came from, this one's not a good example because it's literally just animation frames are firing. Every time, but If this was wrapped in a function or something that you would still see the call stack here as well."
          },
          {
            "time": "[00:07:30]",
            "text": "So it's kinda up to you if you just want to peek at it, the call tree can be really good for that if you just wanna see where it came from. If you really wanna understand it better then I would recommend clicking on the file name and then adding app update is here, so then adding one here and then you're able to see."
          },
          {
            "time": "[00:07:46]",
            "text": "But again, this example is not great for that because it's just request Animation Frame firing. But if you did have something calling other stuff like react generating, you will see that all here in the call stack."
          }
        ]
      },
      {
        "name": "24-running-node-js",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Last thing I wanted to show before we move on, which is really cool and people have asked about this is that and this used to be much harder but since node.js is just a wrapper around the js. Which is the same JavaScript engine that chrome uses, you can actually very very easily run your Node.js apps through the devtools as well So I'll demo that."
          },
          {
            "time": "[00:00:20]",
            "text": "So basically, I'm just going to go to my terminal and I'm going to kill the app that I currently have and clear the page. And then instead of running, so I was running NPM start, which is set to run node server.js. This is how I've been running the app."
          },
          {
            "time": "[00:00:36]",
            "text": "You can now go and you can change it to do node dash dash inspect. And do the same thing. So it'll still load the site just like normal, but now when we open up the devtools, we'll see this little node.js icon up here. And if we click on that, we can actually see it pops out its own."
          },
          {
            "time": "[00:00:52]",
            "text": "Kind of got two devtools, right? You've got devtools inception going on. But you can click on like profile, for example. And you can do a full profile and then we'll like refresh the app and then we'll stop the profile or something like that. And so you can do all of these."
          },
          {
            "time": "[00:01:08]",
            "text": "Let me move it over to the flame chart that we're used to. You can do these things. You can actually watch my little Node sample app started up right where it's like it's a fast defy app. And it's like walking ASDs as it walks the mark down all this like really cool stuff."
          },
          {
            "time": "[00:01:21]",
            "text": "So doing it with like a web server is like pretty cool, but like one thing you could do that would be really interesting is if like you're using Web pack, and your build times are slow. You could actually do run node inspect and then call web pack and then you could open it up in here with a profile and like do the same exact thing, right?"
          },
          {
            "time": "[00:01:38]",
            "text": "You can walk any kind of node command line application and see it. So I have like a little example that I'll just do with you all, but you can feel free to follow along with but in the server.js file, I have this like silly little function commented out, which is FUBAR so you can uncomment it."
          },
          {
            "time": "[00:01:55]",
            "text": "And then you can go up and in the get lesson page, you can uncomment it being called. Now save that, now go back to my terminal, and I'll start node with the inspect flag. And then I'll go back to my devtools. And I'll click the node icon again here and I'll start recording then I'll go back here and I'll refresh the page and then I will stop recording."
          },
          {
            "time": "[00:02:18]",
            "text": "And we can actually see like inside this fast defy which is the framework I'm using get this like FUBAR function, so we're actually seeing like the node server trying to process stuff. And you can see it's it's reading and markdown, and then it hits this thing. So you can do a really nice, just like we did with the front end code."
          },
          {
            "time": "[00:02:33]",
            "text": "You can do it with all your back end code. Here's my server.js file. Here's how long it took to do this silly thing, all that stuff. So this is really cool, because when you start looking into it, there's like a lot of stuff that we use day to day that's just a node app."
          },
          {
            "time": "[00:02:45]",
            "text": "And so just the idea of being able to run, the Chrome devtools that you're used to on the node app can be really cool."
          }
        ]
      },
      {
        "name": "25-memory-leaks-memory-heap-snapshots",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the last lesson around performance is going to be on memory. Another call out that I just wanted to make before we go too much further is that I can't remember exactly when I think very soon there's going to be another course coming in front end masters."
          },
          {
            "time": "[00:00:15]",
            "text": "It's on the work schedule for advanced dev tools stuff that Omar is going to be running, he does all sorts of good stuff. So if you are like these are meant to serve as kind of like your introduction into like, okay, I get what the performance tab does and I know what I'm looking at and I see paging and stuff like that but if you're interested in finding out a lot more on like, he's going to do I think real life case studies and like a bunch of really cool intricate stuff into like memory, CPU, network, all that stuff."
          },
          {
            "time": "[00:00:40]",
            "text": "Stay tuned for his class because it's coming pretty soon. So yeah, the basic idea with memory. So JavaScript as a lot of people know has garbage collection to it, right? So you don't need to actually declare and purge your memory. But with garbage collected languages, you can end up with what we call memory leaks, but they're basically like stuff that you've forgotten about."
          },
          {
            "time": "[00:01:04]",
            "text": "So like, one example would be if you make too many DOM nodes, and you don't clean up after them, so if you're like making a table, a lot of people use like virtual scrollers. And what those will do is they'll render like 20 frames of the table and then as you scroll, it'll reuse the top ones and replace them in the bottom, things like that so you don't end up with a huge DOM."
          },
          {
            "time": "[00:01:25]",
            "text": "But if you didn't use a virtual scrolling, you just tried to render like a million table rows or something like that. It would take a lot of memory and you'd start noticing a real performance hit after a while. Another thing that can get you is, this one's a little bit tricky."
          },
          {
            "time": "[00:01:38]",
            "text": "But when you think about code, like you're often interacting between the DOM and JavaScript, like we've been doing it a lot today. So for example, we'll like in JavaScript will do document.create element LI right? And so we have a list item but it's in memory only it hasn't been attached to the DOM yet."
          },
          {
            "time": "[00:01:58]",
            "text": "And then we'll do that LI that we did, we'll do like body.add child and we'll pass that and now LI it's in the DOM. And so one thing that can happen is that those references to the in memory ones that you never did put in the DOM or you put in you took out if you don't know those out or delete them somehow those can just grow and grow in memory as well."
          },
          {
            "time": "[00:02:18]",
            "text": "And so the kind of most important thing that you want to do is like, establish like, if you have a memory like that's like the first step right? Before we go diving too deep into it, so we really have like three tools for it. And one of them is a caveat of the course because it is in Chrome, but it is not part of the Chrome Dev Tools, but it is a very cool tool that Chrome offers."
          },
          {
            "time": "[00:02:40]",
            "text": "And so that one is the Chrome Task Manager. So if you go up to the top right, then you click on the three dots, and then you go to more tools Task Manager. You get this really cool thing that I didn't know existed for a super long time."
          },
          {
            "time": "[00:02:53]",
            "text": "And so this is basically like your activity manager, but just for what Chrome's doing. So it'll show all the tabs that you have open. It'll show all the services that it's running everything like that. Now, it doesn't work right off the bat because it just shows its memory footprint and its CPU."
          },
          {
            "time": "[00:03:08]",
            "text": "But what we really wanna know is do I have a JavaScript memory leak, so we can right click on the headers here, and we can go over to JavaScript memory and we can add that new column here. And so now we've got JavaScript memory so we can see that the right now my front end masters tab with the chat is taking up a lot of memory."
          },
          {
            "time": "[00:03:26]",
            "text": "And then my Google search is taking up some memory. My tab is taking up less memory, those kind of things. So one thing that's cool, let me kind of reorganize stuff a little bit here. So I'll close these just to kind of simplify stuff. And then I'll drag, let me grab hold of my browser here."
          },
          {
            "time": "[00:03:45]",
            "text": "I'll drag this over, and then I'll kind of set this up. So what I want to be able to do is kind of do both at the same time, right, I want to see my tabs. And I also want to see the memory usage. So if we take like this tab here, it's using two megabytes of JavaScript memory basically."
          },
          {
            "time": "[00:04:01]",
            "text": "And then I made all these buttons that make a bunch of DOM nodes or make a bunch of detach nodes or something like that. So we see that it's at 2700. And as I start kind of clicking on it takes like a second or two, we can see it spike up really high right to 6000."
          },
          {
            "time": "[00:04:16]",
            "text": "I know that's really small. I can't find a way to make the text bigger. But this is like one cool thing you can do. So to be a memory leak, you would open up the task manager, enable JavaScript memory, highlight the tab that you're worried about. And then do whatever you're worried about."
          },
          {
            "time": "[00:04:30]",
            "text": "Are you worried that it has a memory leak is it just sits there, are you worried about that has a memory leak as users interact, do whatever it is, and kind of keep track of this because ideally, all the memory that we allocate, we should also be purging, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "So if we're creating DOM, we should destroy DOM. If we're creating a big array, we should get rid of that big array, those kinds of things. So you should always be able to find it that way. Another way that you should be able to find it ,let me fullscreen this again and refresh, is actually back on the Performance tab from the CPU one."
          },
          {
            "time": "[00:04:57]",
            "text": "One of the reasons I think that it seems so confusing is because it's just doing so much, but when we're on the Performance tab, we can click on memory here. So if we do a recording, and let's say we go back to our page and we do some stuff and clicking on these buttons that I know use a memory then I stop it."
          },
          {
            "time": "[00:05:15]",
            "text": "We can see down here these kind of gains in memory and so memory usage like if it goes up and over and back down is never a bad thing because it's there for us to use, that's totally fine. What you always want to look for is this kind of jagged, like sawtooth."
          },
          {
            "time": "[00:05:29]",
            "text": "If it's like climbing, that means it's seeing kind of using something, it's not purging, and then it's using more and more. So you can see this kind of pattern every time I click the button, it consumes more memory. It also gives us kind of a nice breakdown. So it'll show us what memory is used by the JavaScript heap, what of it is documents, what of it is like DOM nodes being created, event listeners or GPU memory being used."
          },
          {
            "time": "[00:05:51]",
            "text": "So that can kind of start getting us in the right direction. We use the task manager to see if we have a leak, just watching the JavaScript memory. And then we can use the performance profile to see what type of thing is causing this issue. And then the third thing we can use is, of course, the memory panel itself."
          },
          {
            "time": "[00:06:09]",
            "text": "So let me dock these back to the bottom. So we've got three options here for viewing memory. One of them is just to grab a heap snapshot. So it just grabs everything that's in memory at the time and shows it to you. So for example, I could do a snapshot like this, it takes a second and it shows this big list of items."
          },
          {
            "time": "[00:06:30]",
            "text": "So this list we're going to be looking at in a couple of different ways, but the basic idea is that we'll see the type of item like what it was constructed by like a UL list item or just an internal system stuff or an array, things that should be familiar and then it'll show these couple of things that show shallow size, distance, and retain size."
          },
          {
            "time": "[00:06:50]",
            "text": "Distance for the most part we can ignore. It means distance from the window object, from the global, basically like how far deep it is. But shallow and retain size are really important. So the shallow size is like, how big is that thing? So if you have an array of a million, how big is an array of a million?"
          },
          {
            "time": "[00:07:09]",
            "text": "Retain size is important because of how garbage collection works. So garbage collection works via this mark and sweep process. I don't know if anybody's ever heard of mark and sweep before. Basically it grabs everything that there is and it gives it like a flag like false. And then it starts from the window and it walks every single thing that the window is pointing towards and everything it's pointing towards and everything all the way down the tree."
          },
          {
            "time": "[00:07:32]",
            "text": "And everything it touches, it flips the false to a true. So it's like I've seen you, I've seen you. And then at the end of the pass, anything that still has a false flag can be deleted, right? Because nothing's pointing to it. And so the idea again being if you have an array of a million and you have a function called foo, and all food does is it points at that array of a million."
          },
          {
            "time": "[00:07:53]",
            "text": "So it's like array equals another big array of a million, then array of a million is the big thing, but since foo is pointing to the array of a million, the array of a million will stay as long as foo has something pointing to it. So it kind of like it's basically you can have like an object, and the object can be pointing to a key that has an array that's really big."
          },
          {
            "time": "[00:08:17]",
            "text": "As long as that object stays in memory, it has to keep everything the object points to in memory too, because it doesn't know when those could be accessed. And so what can happen, with these DOM nodes that I talked about earlier, as you can accidentally still have a reference to something that you don't care about anymore."
          },
          {
            "time": "[00:08:33]",
            "text": "So like a good thing would be like you create the LI, you stick it in the DOM, but you still have that LI. If you never know it out, it'll just stay in memory like forever basically. And so, that's all a long winded way of saying that you'll get two different things, one of the shallow size is the actual size of the thing, the retained size is how much memory could be free if that thing were deleted."
          },
          {
            "time": "[00:08:55]",
            "text": "And the difference being like you could have an object with just two keys on it so very small shallow size, but one of those keys points to a gigantic array of like a million so the retain size is very big, because the only reason that array is sticking around is because of your object."
          },
          {
            "time": "[00:09:10]",
            "text": "Does that make sense, I'm gonna pause for a second on that. So that's like basically as long as something has a pointer, it stays in memory. So if you add anything to the window object, as long as the window object stays, which it always will, that thing stays."
          },
          {
            "time": "[00:09:22]",
            "text": "And so you can kind of get this difference in like how big is the thing? Okay, but how much memory kind of clear up if I deleted that thing, meaning that thing and anything that it's the only pointer to, so yeah, back onto the memory pad. So we've got the heap snapshot, which is great."
          },
          {
            "time": "[00:09:36]",
            "text": "Another tool that we have, which is really useful is allocation over time. So we can basically see when memory is being allocated over a period of time, sort of like the performance or we're measuring across time. So like you could demo this pretty easily by starting a time allocation, starting record and then hitting one of my buttons and will see that every time I hit a button a whole bunch of memory is allocated."
          },
          {
            "time": "[00:09:59]",
            "text": "And we can also see that it never goes back down. It's not like a shape like that. And so if I stop my recording here, I can see, let me make this a little bigger. That things are getting bigger. I can sort by shallow size I can see."
          },
          {
            "time": "[00:10:12]",
            "text": "So the system in parentheses that's like its own stuff. But I can see that these arrays are really big and they're full of these detached HTMLLIElements. So if I were to look into the code just so we can kind of get a picture of what we're doing that's causing this it shouldn't be too much of a surprise that we're making a whole bunch of UILIElements and we're never knowing them out."
          },
          {
            "time": "[00:10:32]",
            "text": "So like we're attaching them but we're not getting rid of them in memory, they just stay in memory. Is that kind of making sense? So I know it's contrived, like a for loop of 1000, where you're creating elements or whatever, but the idea being that you can kind of start in the memory panel, see if you have a leak or how much is being used."
          },
          {
            "time": "[00:10:50]",
            "text": "You can also see what's taking it up over time. Cool. So the last thing, which was probably like the most common question I got, last time I did the course. But Chrome has added a really cool feature for it is like, people would always ask, okay, like I see I have a leak."
          },
          {
            "time": "[00:11:06]",
            "text": "I know that there's a problem. How do I figure out what it is, like what's causing it? Where's it coming from, because you have these big complicated apps. And so chrome added this really cool thing, this allocation sampling. And so what this does is it lets you kind of record again over time down here, but what it's going to do is instead of, just let me go ahead and stop that, it's coming up."
          },
          {
            "time": "[00:11:32]",
            "text": "Let me delete this, let me start one and then do something that takes up memory. I think the problem I keep running into is, if no memory is being used, then the profiles will be empty. And this is just a flat page. So start one, click one of the buttons."
          },
          {
            "time": "[00:11:48]",
            "text": "Now this is actually going to tell you instead of just all there's a bunch of arrays, or there's a bunch of UlLIEelements, it's going to tell you what function is causing that problem. This is like great. It's like something I've been waiting for years and years because a lot of times complicated apps are like, yeah, I see that I have event listeners."
          },
          {
            "time": "[00:12:06]",
            "text": "And there's a bunch of detached event listeners, but I don't know what's creating them or something like that. So being able to go from memory allocation to actually pinpointing you in the sources panel which function is causing things is like a superpower. It's really convenient. So yeah, I think the kind of TLDR with memory is the first way to do it is get the task manager to even see if you have a problem."
          },
          {
            "time": "[00:12:31]",
            "text": "Like is it allocating a lot of memory, and if so, is it going up over time? If it does having a problem, then I would go into the Performance tab and do a performance recording and then I'll get you a little bit of like a visual on like what type of problem is it?"
          },
          {
            "time": "[00:12:43]",
            "text": "Is it like JS heap? Is it DOM nodes? Is an event listeners? That kind of thing. And then coming in here and actually taking a look at like, what's allocating? How much is it eventually going for the allocations snapshot so you can see what JavaScript is causing those things."
          },
          {
            "time": "[00:12:59]",
            "text": "It won't always be this clear obviously, usually you'll have a couple different things that are big and taking up room. But this can really help you like narrow down what's causing stuff and what's not going away. One thing I forgot to mention that you can do too, is there's a forced garbage collection button here."
          },
          {
            "time": "[00:13:14]",
            "text": "So another thing that would probably be useful because sometimes you allocate memory for a long time, but you do get rid of it eventually when garbage collection happens. So for example, if we go back to the heap snapshot, we can start a recording. And then we can like generate and then we can try to garbage collect and we should see it go back down to zero, but since it's not, that's like a way we can be sure that there is a leak, right that there's not stuff."
          },
          {
            "time": "[00:13:40]",
            "text": "We're not using it and garbage collection doesn't take it away. That's a problem. Yeah, so the question is when you're looking at memory in the Performance tabs, you're looking at kind of the chart at the bottom, are you looking to see if the JavaScript heap goes up and down or if any of them are not going down?"
          },
          {
            "time": "[00:13:57]",
            "text": "And it's really if any of them are Jiggs sign up, it doesn't matter which one, then that's some sort of problem because they should all go back down to a stable level after any big allocation should always go back down. Or at the very least, it should go up and go flat."
          },
          {
            "time": "[00:14:13]",
            "text": "Like, let's say you have an app where you just rendering like 10,000 things and that's just what you're doing. So it should go up and then it should stay, but it should not keep climbing like the only reason it would be climbing is if it was miss properly allocated or it's just not being garbage collected."
          }
        ]
      },
      {
        "name": "26-what-can-slow-down-a-website",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's always fun, like it's fun to go to a new site and just give it like some kind of audit, like a very high level view of like, what's going on with it, i remember this one time as an antidote, i was doing an interview. I was interviewing for a job and one of the questions was what can slow down a website [LAUGH] I've only guys ranted for like 45 minutes I was like kind of disappointed when the interview was over."
          },
          {
            "time": "[00:00:23]",
            "text": "I was like I still have more things, so it's kind of wanted to talk through some of the things that I've seen very commonly slow down websites, and I always kind of group it into like back end and front end stuff. Obviously, those groups they don't really hold true today as things have gotten very complicated [LAUGH] when you have server less sites or you have a front end service team and then a back end service team, but I really mean you have the user's computer and then you have where your code is stored at your data center and kinda one or the other side."
          },
          {
            "time": "[00:00:55]",
            "text": "So when you think about back end things that can slow down websites, Database calls can happen a lot like me the database is an index property. I properly I know Brian Hall just did like a huge course on front of masters on introduction to databases. Sure it covers a bunch of great stuff on like being efficient queries, but I've seen it often where you have a lightning fast server but a really slow my SQL database and that's just going to slow down the request."
          },
          {
            "time": "[00:01:19]",
            "text": "The server can be slow Or there can be not enough servers, it's just overwhelmed and it's having a hard time responding. The network can be bad, this can kinda both into front end or back end, so either some calls between services can be too slow network connection or from the client to the server can be slow."
          },
          {
            "time": "[00:01:40]",
            "text": "And those are really interesting to fix because there's lots of different things you can do, you can put your static assets out on a CDN can be great. There's also all sorts of cool serverless technologies that let you host your code in multiple places, basically like a CDN for dynamic stuff."
          },
          {
            "time": "[00:01:58]",
            "text": "A lot of bigger companies will have data centres located strategically all over the world, or they'll buy like a small presence like a pop or something like that in certain areas to make connections faster. There's a lot of interesting stuff you can do there, and then the last thing which you talked about a little bit is compression."
          },
          {
            "time": "[00:02:16]",
            "text": "I wanted to give like a quick shout out to jesup and brotli here because they also kind of belongs in the network section. But there's two compression formats that browsers actually understand which are g zip and brotli. Which means that if you use them to compress your code and send that compressed code over the wire."
          },
          {
            "time": "[00:02:36]",
            "text": "The browser doesn't need any extensions or anything special to be able to uncompressed your code and read it back out, which is great. So it's Think of it as like a zip format that all browsers understand, which means that you should be probably compressing everything that you use, so for example, if you have like a node app, let's say use Express node or whatever, then you would just wanna look for like unexpressed node, compress, plugin, right, some kind of middleware."
          },
          {
            "time": "[00:03:03]",
            "text": "They all have these, whether it's like a Java app or a Ruby app or whatever, you just want something that's gonna jesup all of your requests that gets sent over and all your static assets as well. So compression is great, on the front end, we see a lot of things these days, one of the things I see most often are really large JavaScript bundle sizes."
          },
          {
            "time": "[00:03:23]",
            "text": "That's probably 90% of the cases that I diagnose, come down to that where it's like people say like, can you try to stick under like 2,3, 4 100 kilobytes of JavaScript and then you go look at some of these sites, and you're looking at like 5 6 7 megabytes of JavaScript."
          },
          {
            "time": "[00:03:40]",
            "text": "And it's just, it's so easy, i mean, it's so easy to get set up, you need a cool thing and you go to NPM and you find the cool thing and you NPM install it and you just add it and like before long you've got, just so much code."
          },
          {
            "time": "[00:03:56]",
            "text": "This could be its whole own class, so I'm not gonna go too deep into it, but reducing the dependencies you have is great. Making sure that you're your bundler is optimized is great and another thing is taking advantage of all the modern things. I said Webpack is very flexible, you can say, hey, I need this, but I don't need it on page load, so just download it asynchronously."
          },
          {
            "time": "[00:04:18]",
            "text": "There's lots of really cool things you can do with bundlers to make the site faster, too many files we kinda covered this already. I always like doing audits at the end even though audit is the easiest on a technical level. It also kinda nicely wraps up all the stuff that we've been learning as you're like, yeah, we kind of covered that, so we covered in the networking section that you can only do 6 synchronous requests at a time."
          },
          {
            "time": "[00:04:41]",
            "text": "So if you have Like 700 images that need to come down, it's just gonna be queuing installed for a really long time. Again, with images, just like JavaScript, you can make a lot of them asynchronous if you don't need it for the actual page load, like if it's just presentational or if it's below the fold, like down, scroll lower, just make a may synchronous."
          },
          {
            "time": "[00:05:00]",
            "text": "It can be a huge savings, Images also are tricky like, they can be uncompressed they can be too big. So I we see this a lot where in your CSS you'll have like image style, width 500, height 500 great, and then you hover over the image, and it'll be like, well, the natural size of this image is like 2600 by 1400."
          },
          {
            "time": "[00:05:24]",
            "text": "And it's like, well, why are you sending this like giant image over the network if you're only going to render it in a very small way. The other thing is that images have all of this metadata, so if you open as someone who works for one of the largest Companies that puts that metadata [LAUGH] there."
          },
          {
            "time": "[00:05:39]",
            "text": "When you open something and like Photoshop or whatever, it's gonna save all this really, really handy stuff so that when you open it again, you know has all this history and what file or what program it was last edited with all this stuff. It's really good for keeping local files but it's really bad for the web, so if you use something like image optimizer, or any number of cloud services do the same thing they'll like trim all this metadata off."
          },
          {
            "time": "[00:06:04]",
            "text": "One, it can be a security issue, we often read about hacks where like Exif, data was left on images and people could find where they were posted from. Number two its file sizes, you don't need all that metadata just makes the image bigger, so would they call that as lossless image compression."
          },
          {
            "time": "[00:06:19]",
            "text": "That's the thing to look into, which is making the image smaller without losing any quality, that's basically what it means. So images to large images on compressed, unused JavaScript and CSS, this one could be another kind of workshop, so Chrome dev tools can tell you unused code. But the story is like never really that simple, right, because you'll often have CSS that's there to style a modal that the user just hasn't clicked on yet."
          },
          {
            "time": "[00:06:45]",
            "text": "So it's not really unused, it just hasn't been used yet, so I think the better thing to do is to use the bundle async stuff. So like use your Webpack, like dynamic imports or whatever bundler you're using to be like, hey, my that modal the JavaScript and the accompanying CSS does not need to come on page load."
          },
          {
            "time": "[00:07:04]",
            "text": "It can come later, is a good way to do it, CSS in the document body, that's another one is where you put stuff will trigger when, so if you put stuff in the head versus the body the CSS and the body will be like an asynchronous, like a lower priority loads, then it'll cause everything to kind of warp in afterwards."
          },
          {
            "time": "[00:07:27]",
            "text": "But then a lot of JavaScript libraries, like analytics ones always want you to put that in the head, which will then block a lot of the thing. So you are like waiting on Google analytics before your page loads, so really tricky and last one, browser caching. So setting cache headers on your server, and then respecting them in the browser is great, i actually over the break I had seen some questions over E tags which I think now is a good segue into."
          },
          {
            "time": "[00:07:55]",
            "text": "So I mentioned E tags earlier is like a standard, that people use for, caching something until it changes basically, and so they're not necessarily for free though. So the E tag is a header that your server will need to set, and you can look it up on MDN, but it's just E tag, and so your server will send an E tag header with a unique hash to like the file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then the client also needs to do some work, the client will need to with the fetch request send an F non match header itself and this is all you can find this on MDN. But basically the server will need to send the unique hash, and then the client will need to send only give me a new file if it's not this hash and and that's how they can kind of communicate very quickly together."
          },
          {
            "time": "[00:08:39]",
            "text": "So these things are a little confusing but there, hugely important when you're, working on a big site that has like user uploaded images that can change but they don't change very often. So ideally, you would cache them all but sometimes you need to purge that cache."
          }
        ]
      },
      {
        "name": "27-simulating-network-conditions",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Another thing, before we get into Lighthouse, is that dev tools can do some really cool stuff simulating conditions. So I'm gonna go ahead and open the Element Inspector. So on the Network tab, if we go to these settings down here, I'm sorry, where is this? There it is."
          },
          {
            "time": "[00:00:16]",
            "text": "Sorry, it moved it. So on the Network tab, this little drop down here, you can throttle network conditions. So you can look at, for example, all the way to offline, but you can look at a slow 3G connection or a fast 3G connections. So we can see my site loads pretty quickly almost instantly, but then on a slow 3G connection, you can see it kind of spinning and spinning here."
          },
          {
            "time": "[00:00:36]",
            "text": "So that can be a really cool thing. You can simulate these connections and see, well what is somebody going to experience if they're on a really bad network? The other thing they can do is in the Performance tab, under their settings, you can actually do CPU throttling, too, which is really cool."
          },
          {
            "time": "[00:00:51]",
            "text": "If you remember in the network lesson we talked about how bites over the wire isn't the only thing. Parse time can also be hugely important for page load. So what if you are worried about parse time? You can come into the Performance tab, you can set a CPU throttle, and then you can reload the page there, and you can see how long it actually takes to parks all your JavaScript on a slower connection."
          },
          {
            "time": "[00:01:12]",
            "text": "So that's really cool. So you can, yeah, you can throw out the network and you can throw out all the CPU. Very, very useful if you want to get a little bit of that empathy of what users will see on slower connections. Another aside I wanted to make is that let's say you have kinda trimmed your code down, so it is what you need it to be."
          },
          {
            "time": "[00:01:35]",
            "text": "Moving things around so that, while it will load slowly it loads well, can be very important. So, for example, sites that are entirely client side rendered, like a react site where you just render a div main from the server with nothing in it, then React boots up and then React populates it."
          },
          {
            "time": "[00:01:52]",
            "text": "What if you put a nice static HTML file and instead, so that was a really slow connection, while React is parsing, the user at least get some good HTML and some CSS, stuff like that, and this can be done in a number of ways, but the network throttling can be really cool to watch how your site loads, and it can give you some ideas into things that you can do to at least make the experience better, even if people do have to wait a few seconds for the whole thing to load."
          }
        ]
      },
      {
        "name": "28-lighthouse-audits",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is really, really cool. So, Lighthouse is the last tab we're gonna kinda cover here. When I did this talk last time, Lighthouse wasn't in the panel, and was it's own separate website. It's a open source initiative that came out of Google. It's really well maintained with all these rulesets and tests for web performance."
          },
          {
            "time": "[00:00:24]",
            "text": "And I used to have this advice where I was like, if you're doing a local app, you got to use Audit. But if you have an app on production, go check out lighthouse. It's like the best. And now Lighthouse is here in the tabs, which I'm like, just very giddy over because it's just so good."
          },
          {
            "time": "[00:00:38]",
            "text": "All the rules are open source and online and a ton of people contribute to it. And it has all these different categories, which are somewhat self explanatory. They're maybe a little complicated, but so performance is going to be initial page load performance, very similar to what we've been doing manually with the network stuff."
          },
          {
            "time": "[00:00:57]",
            "text": "Progressive Web App is going to check, does it service worker does it work offline. Does it have a manifest? All these great things for progressive web apps which we're not building right now, best practices is gonna be just a lot of normal stuff about the images and compression and all those different things."
          },
          {
            "time": "[00:01:15]",
            "text": "Accessibility is hugely valuable, I have an accessibility course on front of masters but making sure that interactive elements can be done via the keyboard, making sure that color contrast works well for people with different vision impairments. All sort of things like that making sure screen readers are going to have an easy time reading your content, to non sighted users."
          },
          {
            "time": "[00:01:35]",
            "text": "And then SEO, just making sure that you're doing kind of the basic things for Google to be able to track your website well and for other search engines to track as well. So I think for now, let's just go through, let's just generate a mega report. And this is keeping in mind that we know that we're not a progressive web app."
          },
          {
            "time": "[00:01:50]",
            "text": "We know we don't have any of those features. So, you click what you want, and then you click Generate Report and it's gonna do a bunch of stuff in the background. It's going to refresh the page and stuff like that. And so you get this very, very nice easy to parse, 0 through 100 score on all the different categories."
          },
          {
            "time": "[00:02:08]",
            "text": "So you can see it's pretty cool. I found that we're not a progressive web app and instead of giving you a bad read score, it's just kind of grayed it out. We get 100 number Performance, 90 on Accessibility, 93 on Best Practices, 78 on SEO. So let's just start looking through."
          },
          {
            "time": "[00:02:23]",
            "text": "These are like, sometimes I think about things that I'm like, you could probably just make money just by offering people who have business websites and aren't super tech savvy, probably just honestly like run Lighthouse, print it out and go talk to them about it. It's so valuable even though it's free, it's just so cool to be able to see."
          },
          {
            "time": "[00:02:43]",
            "text": "So on the Performance tab, that's the onload performance. We can see all these great things like how long it took for the first contentful paint, how long it took before the site was interactive. For those of us that work at big companies, we probably have a few of these metrics that are mandated, like time to first byte or first contentful paint."
          },
          {
            "time": "[00:03:02]",
            "text": "Those will be things that we need to keep the app on a certain time. So first contentful paint is like we talked about on there when the page renders the first time and time to interactive. I've seen this on some slower sites where it's loading that is blocking the main thread where you can't click on things, you can't scroll, you can't click on a button."
          },
          {
            "time": "[00:03:20]",
            "text": "So that's time to interactive before. The main thread is free enough that you can do stuff again. Largest contentful, paint, layout shift, all these different metrics. And what's really cool with these is if you get one red or yellow, it'll flag you with a page for each and every one of them where you can click on the page and go to this really nicely maintained dock for like, well, why am I getting that?"
          },
          {
            "time": "[00:03:43]",
            "text": "What can I do? What's the problem here? I know I'm gushing over it, but it's just so awesome. Lighthouse is such, such a great resource. Cool, so kinda scrolling down. You can also see, I know these are all mini. Remember I said that if you have the Dev tools not popped out, the screenshots will be really tiny."
          },
          {
            "time": "[00:04:01]",
            "text": "So here is just little tiny screenshots of what's going on up there. And then it has suggestions. So here it can says the only suggestion normally you get a lot is that you could save 100 milliseconds or something like that if you eliminated render blocking resources, and specifically if I extend that it's the custom font that I use."
          },
          {
            "time": "[00:04:22]",
            "text": "So I have a custom font. It's pretty small. But if I got rid of it, then I could speed things up a lot. The other thing you could do is, you can do that. Have you ever loaded a site and it loads with a system font and then it changes into being a custom font."
          },
          {
            "time": "[00:04:36]",
            "text": "You guys do that. I mean, it's gonna be a lot faster or not maybe a lot, but it'll be somewhat faster but at a worse user experience. So kinda your choice. And then here's all the things that, these are not marked red. So, if they were I could go and read into those more, if I was messed something up."
          },
          {
            "time": "[00:04:53]",
            "text": "And then here are the ones that are passed audit. So you can see these two. These are all the things that would flag, if you're on a production site, and it had any of these issues. Next one accessibility. Same thing, it just gives you immediately useful, very helpful stuff."
          },
          {
            "time": "[00:05:07]",
            "text": "So it's like, this HTML element doesn't have a Lang attribute. And it has this whole important thing about screen readers. If you don't set a language on the HTML element, they will use the user's default language. So if you are a Spanish speaking user on a Spanish screen reader, and I have an English website, but I don't set the Lang, it's going to try to read it in Spanish because I haven't set the Lang."
          },
          {
            "time": "[00:05:29]",
            "text": "So, immediately very, very useful stuff that you honestly could just go, just follow along and kind of fix all these things. Then again choose all the passed audits that we got. I will give a caveat here. Accessibility testing like automated testing has come such a long way. And I know that sounds a little cliche, but it's especially true with accessibility, like really nothing beats the real thing."
          },
          {
            "time": "[00:05:52]",
            "text": "Nothing beats actually getting a user on and trying to tab around and make sure, because things might have tab index, but they might be unintuitive or clunky. And Chrome Dev Tools won't be able to catch that. So this is a really good starting point. These are easy things to fix, but accessibility is very subjective."
          },
          {
            "time": "[00:06:10]",
            "text": "For making a good experience, it's a little bit harder to Lindt and better to have somebody on your team that knows how to use a screen reader and knows how to tab around and make sure that it feels good. That feels nice. Another thing, best practices, missing one where there's no doctype set."
          },
          {
            "time": "[00:06:28]",
            "text": "So again, on the HTML, you might how you usually do like doctype HTML, or whatever, sort of a relic back to the old days where we had, before HTML5, we had all these specific doctypes and these specific modes that browsers would. But again, you can go to the Learn More and it'll just tell you to put doctype HTML at the top of your page."
          },
          {
            "time": "[00:06:47]",
            "text": "And then here are the audits I passed. Coming to SEO, I don't have a meta viewport tag. And so this helps mobile devices know how to scale so they don't have to pinch to zoom. Have you ever loaded a site on your mobile device and it's like super mini, and you're trying to zoom into it?"
          },
          {
            "time": "[00:07:02]",
            "text": "So this meta viewport can help with that. And there's no meta description. Again, not an SEO class, but these are things that help the search engine know more about the page so that they can index it better. Cool, and then PWA. I failed a bunch of things, but it's not a PWA."
          },
          {
            "time": "[00:07:19]",
            "text": "That's okay. So it said, hey, we went offline and we expected to 200, we didn't get one. It doesn't have any service workers at all. There's no web app manifest. I mean, these are things we know because it's not a progressive web app. But if you do have one working on mobile@twitter.com, and you want it in the App Store and you want to, make sure that you pass all these PWA tests as well."
          },
          {
            "time": "[00:07:40]",
            "text": "Cool, and then it's got a bunch of meta information, just about what slowed down at use, what site it was, all these kinda great stuff."
          }
        ]
      },
      {
        "name": "29-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Two things that are sort of outside scope for this course I didn't want to go too long, but I think are very cool. Puppeteer for all those that don't know Google's chrome can be called from node in a headless way. So folks that do like, what's it called end to end tests on your websites."
          },
          {
            "time": "[00:00:18]",
            "text": "So, maybe you'll have one actually opens a tab logs in does stuff like that? Puppeteer is a great tool for that. There's also some other tools like WebDriver, and things like that. But when you think about the performance API that we covered earlier, you can do some really cool things with puppeteer WebDriver, where you could have it log in and record some metrics and save those metrics or I like to do like CI workflows."
          },
          {
            "time": "[00:00:41]",
            "text": "I always have this like philosophy that If you can't lint it, test and make a CI rule for it, you shouldn't bother somebody on their code review about it. You know, it's like let the computer do that. Don't you change? So, one thing that I like to do is I have a few I called my performance budget."
          },
          {
            "time": "[00:00:58]",
            "text": "I think Alex Russell from Chrome, maybe coined that term. So, I have my performance budget. And we use puppeteer, puppeteer logs of performance API. If they're greater than certain numbers, it flags the PR. So when you go to put a PR up, things are a little bit too slow."
          },
          {
            "time": "[00:01:13]",
            "text": "And then it's not a person yelling at you. It's just a simple rule there. So, there's a lot that you can do there, combining the performance API with Puppeteer. Similarly with Lighthouse, they have a CI that you can call from node as well. So, you can do a very similar thing where you could say, on every PR spin up the website, hit it with Lighthouse, and if it gets less than 100 flag PR, you could do something like that, which is very cool."
          },
          {
            "time": "[00:01:36]",
            "text": "I think that would be a little bit more going into like Jenkins or CI jobs and that's a little outside of scope, but it's just something cool to think about.cool. So, basically the last thing that I just wanted to talk about kind of in Lieu of Puppeteer and lighthouse."
          },
          {
            "time": "[00:01:51]",
            "text": "CI are just some other cool like parting notes because we've kind of gotten through all the heavy stuff. One thing that's really cool our Chrome Dev Tools experiments, so if we right click and we go into inspect and then we go to the settings cog up here. You'll see a lot of different stuff which is cool that you can kind of control the display."
          },
          {
            "time": "[00:02:09]",
            "text": "You can do light mode, dark mode, you can control how the panels are defaulted laid out. Remember in the sources debugging, I said you could right click and you could black box a script if you didn't want it seen. If you want to remove one that you've black box, you can come here and do so, the devices over here is where you can emulate different devices."
          },
          {
            "time": "[00:02:30]",
            "text": "So you got all sorts of cool defaults that you can set, but one that I wanted to bring attention to is experiments. So, before things launch, they always come out here in this experiments tab. And so you can take a look through there's always really neat stuff in here, It's like use as is enable at your own risk [LAUGH] all this stuff so they're not documented."
          },
          {
            "time": "[00:02:52]",
            "text": "A lot of times you have to poke around to see where they even are, you'll enable somebody to get on the memory tab. No is on the performance. I see it now. But there's always a really cool stuff. Some of this stuff doesn't make it in to Dev tools."
          },
          {
            "time": "[00:03:06]",
            "text": "But this is really neat stuff that you can kinda play around with and see. There's another little one that I wanted to show which is, if we go to the dot.da and show the console drawer, and then we go to its dot, dot, dot, there's a bunch of little stuff that you can see here."
          },
          {
            "time": "[00:03:25]",
            "text": "And so one thing that I always like to do is, you can like click on like rendering for an example. And there's all this endless cool things that you can do, but you can do something like paint flashing. That's one of my favorite things to do. Then anytime Chrome is repainting like as i over things, it'll show you in this cool green outline."
          },
          {
            "time": "[00:03:49]",
            "text": "And so this could be really cool. You have a big react app and it's going kinda slow. Sometimes it might be repainting the whole site just when you're trying to change a really small thing. And this would be a really great way to figure that out. So you just go into it."
          },
          {
            "time": "[00:04:03]",
            "text": "Dev Tools, open the console drawer and then data dot here and you can see all sorts of just really neat stuff. Yeah, there's all sorts of amazing things that you can add. But each one of them each one of these just has a list of checkbox. Here's another one that I really like."
          },
          {
            "time": "[00:04:18]",
            "text": "This frame rendering stats. It just shows the frames per second as I scroll around and the performance of it, things like that you can see how much GPU memory it's using. So, I can just like very high level, get an idea of cool stuff like that. So, those are probably the two I use most often paint flashing and the frame rendering stats, but just be aware that there's a whole bunch of cool little extra things that you can add."
          },
          {
            "time": "[00:04:40]",
            "text": "You know, to the bottom drawer as well. The other thing we got a lot of good questions earlier in the workshop about, does this work react with Angular? So the answer is always going to be yes. Like for example, if you do an HTML break point, it will show you what JavaScript caused, but we talked about, it's going to be very deep inside the react reconcile."
          },
          {
            "time": "[00:05:03]",
            "text": "Whatever. So, I really recommend checking out these, the separate Dev Tools. So react has one view has one, angular has one. So, these are Chrome extensions that you can use and there. They're so good like I use this just every day at work so for react I this is not a react focused class by any means, but you can instead of you have your regular elements tab."
          },
          {
            "time": "[00:05:26]",
            "text": "But then you get a components tab and in that it shows the actual whatever you named your react components over here, and shows what props they get what hooks they have, like all this like amazing stuff. So, while the answer is always yes, you can use the elements and the elements, break point, even if it's a react app."
          },
          {
            "time": "[00:05:44]",
            "text": "The longer answer is, but look how cool it is. If you use the specific framework Dev Tools you can get so much information. And then we looked at the Performance Tab, it has its own what they call profile. It's a specific react Performance Tab. It works the same way a recording and you stop it, but it'll specifically show you this is a heavy render and it's caused by this hook, it speaks the language a lot better."
          },
          {
            "time": "[00:06:10]",
            "text": "So, if you're working on a big angular app or react app whatever it is check out their Dev Tools, because they're I'm this just seems to me so much time every day. I worked on a project ones back in the day that was too big. For the react Dev Tools they'd crash and it was such a hit to my productivity where I was man."
          },
          {
            "time": "[00:06:28]",
            "text": "I would open it every day and they'd crash every day. So, they've fixed that since then. But these are a really great way to kinda work around that. Awesome, and my very last lesson is just kinda where to go from here. Another huge shout out, I think I'll be able to find it on when it's scheduled for."
          },
          {
            "time": "[00:06:47]",
            "text": "Because unfortunately, I forgot, but there's an advanced web tools course coming on May 17th. From humor, he's been like for years we've been I don't know him, but I've known him as the other Dev Tools content creator in this space. There's the two of us. So, I'm really pumped that he's gonna be coming on."
          },
          {
            "time": "[00:07:06]",
            "text": "He's really in depth performance audits and all these like real world cases. He's just such an expert. So that advanced class is going to be super cool. The official Dev Tools Doc's are always a good place to look for things. They're all linked here in the project. And then I've also linked my Twitter."
          },
          {
            "time": "[00:07:24]",
            "text": "I love talking about stuff. If any of you have reached out to me in the past on stuff, I'm always geek to DM about cool Dev Tools stuff or whatever. The Chrome Dev Tools have a Twitter link as well. And then my very last shout out is there's this new initiative web dot Dev."
          },
          {
            "time": "[00:07:37]",
            "text": "I'm not sure if people have heard of it. It's like this big web community. I think Google kind of owns it but a lot of open source contributions from a lot of people. It's so cool. They have all these topics, on such a playground like all this cool stuff."
          },
          {
            "time": "[00:07:55]",
            "text": "Web vitals progressive web app is all free, really high level content they worked with, the framework teams when react and angular and they work with a web host teams like netlify universe, and they. They just worked with like everybody to get these extremely high quality articles out there."
          },
          {
            "time": "[00:08:12]",
            "text": "So, if you're looking to learn something new, I just love this, I read new articles on it all the time. Otherwise, thank you so much. I love doing these workshops and I love meeting people and hanging out and talking about Dev Tools. So thank you very much for hanging out with me today."
          }
        ]
      }
    ]
  },
  {
    "name": "typescript-fundamentals-v3",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to TypeScript Fundamentals V3. My name is Mike North, and I'm a senior staff engineer at LinkedIn. I work in a part of the company called the developer productivity and happiness team, where I'm an infrastructure user experience expert. As well as the company's lead for TypeScript infrastructure and how we roll TypeScript out across all of our JavaScript code bases."
          },
          {
            "time": "[00:00:27]",
            "text": "So we're gonna start with some real talk, I can't make you a TypeScript expert at the end of a one day workshop, it's just not possible. But what I can do is make sure that by the end of today, you have a well formed mental model that will hold up even when things get complicated."
          },
          {
            "time": "[00:00:46]",
            "text": "And then you can learn more and you can try these things out that we're going to introduce today. And I can guarantee you that by setting you on the right path, you will find it easier and easier to take in that new information on your own as you continue your TypeScript adventure."
          },
          {
            "time": "[00:01:05]",
            "text": "So first, let's talk about what TypeScript is. It's a syntactic superset of JavaScript, meaning it sort of starts with all of the JavaScript syntax you know as its starting point and then layers additional concepts on top. It's an open source project maintained by Microsoft, and the goal is to add types to JavaScript."
          },
          {
            "time": "[00:01:32]",
            "text": "So through the use of the compiler, TypeScript compiles out to readable JavaScript, and it comes in three parts. There's the programming language, the language server, and that's a piece of software that's sort of behind your editing environment. It feeds your editor like VSCode, all that great information that powers autocompletes."
          },
          {
            "time": "[00:01:56]",
            "text": "And then there's the compiler, and the compiler is what performs that analysis on your code base and makes sure everything lines up the way it should. TypeScript is incredibly popular. So this is the third version of the TypeScript Fundamentals course that I'm teaching for Frontend Masters. And 2019, this is where I taught the first version, and I brought out a chart like this."
          },
          {
            "time": "[00:02:22]",
            "text": "And I was really proud to be able to show, look, React's a very popular library and TypeScript is on par with React, look, it's so popular. That trend has obviously changed, React looks sort of like it's been left in the dust here. I mean, these are two completely different projects but just in terms of the things we think about with ubiquitous pieces of tooling, things that are sort of always in your Node modules for one reason or another."
          },
          {
            "time": "[00:02:52]",
            "text": "TypeScript is one of those things that is increasingly part of what you're already doing, even if you're not using it directly. And to me, it's starting to look like exponential growth, not even linear growth here. So, everybody is using this, people are really excited about it, why? I'm gonna give you a couple reasons why you might care about TypeScript, why it might be an appealing thing for you to look into."
          },
          {
            "time": "[00:03:23]",
            "text": "And we're obviously gonna learn more about this throughout the day, you'll have many reasons by the end of the day. First, it allows you as a code author to leave more of your intent on the page. So if we look at a function like this that you could find in a regular JavaScript application, this, it sort of is a function that just runs a + b, right?"
          },
          {
            "time": "[00:03:47]",
            "text": "This could be string concatenation, it could be numeric addition, I mean the function name in this case gives us sort of a clue here, but if you use this to combine strings, it would work. Imagine in the future if somebody came along and made what they thought was a non-breaking change and they add the ability for a third upper end to be part of what's happening here."
          },
          {
            "time": "[00:04:12]",
            "text": "If you were using this with string concatenation, you'd end up with zeros at the end of every string that you're combining through this function. So intent matters here, and whenever there are multiple interpretations of what are the constraints, and what's going on, and what was this designed to do, you're kinda asking for trouble."
          },
          {
            "time": "[00:04:31]",
            "text": "In the TypeScript world, we can have something like this where we say a is a number, b is a number, this function returns a number. And even though theoretically a + b could be used to combine strings, it's very clear what the author intended for this to do."
          },
          {
            "time": "[00:04:49]",
            "text": "And not only is the code more clear as we read it, but we are alerted to any use of add that deviates from what the author originally intended. And this little pop up here, this error message, is the kind of thing you would see right in your editing environment like VSCode."
          },
          {
            "time": "[00:05:09]",
            "text": "So baking in more of that intent is a huge win for TypeScript. Reason number two of many, TypeScript has the potential to allow you to move some kinds of errors from runtime where they affect users to compile time, which is maybe before you even open a pull request."
          },
          {
            "time": "[00:05:32]",
            "text": "Examples of these kinds of errors that you can catch include values that might or might not be there. Incomplete refactoring where maybe you should have changed something in seven places but you only caught six. And then internal contracts within your code base. Maybe it's the properties you thought you were passing to a component, right, and now it requires that you give it something new, TypeScript will help you catch that kind of thing."
          },
          {
            "time": "[00:05:58]",
            "text": "Finally, TypeScript serves as the foundation for a great code authoring experience. And I am of course referring to not just the validation of making sure we're passing functions the right things, but this great auto-complete where we sort of get code documentation brought right into our editing environment. Really, really cool stuff and in my opinion this is sort of catching up with the rest of the software engineering world where we finally get a rich editing environment instead of basically a lightweight text editor that does syntax highlighting."
          },
          {
            "time": "[00:06:33]",
            "text": "That's kind of where the JavaScript world has been for too long. So, the last time I taught this workshop, this is TypeScript Fundamentals V2, we spent a lot of time uncommenting code, looking at small examples. Inspecting tooltips to understand what's going on, how is TypeScript understanding our code, we have leveled things up for this course."
          },
          {
            "time": "[00:06:59]",
            "text": "So the only things you're going to need in order to follow along are this website that we're looking at right now and the official TypeScript website. You won't even need to crack open your code editor, why? We've brought VSCode into the browser, so we're gonna be able to see examples and get hands-on without having to set anything up, some really cool stuff."
          },
          {
            "time": "[00:07:25]",
            "text": "Let's look at how we're going to spend our time during this course. First, we will look at compiling our first TypeScript program and we will talk about variables, objects, and arrays. We'll take a quick break, and then we're going to get into some theory. And we'll talk about how TypeScript's type system is different from what you may have seen in Java, or C#, basically anywhere else in the programming world."
          },
          {
            "time": "[00:07:51]",
            "text": "TypeScript is sort of a unique beast in some ways. After lunch, we're going to collaboratively work together to define some of our own type information. And after tackling some of the last core concepts in the JavaScript world, functions and classes, we'll talk about these top and bottom types, right?"
          },
          {
            "time": "[00:08:12]",
            "text": "These are things that can hold anything or nothing. Sounds abstract but they're very, very useful. Finally, towards the end of the day, we're gonna slow things way down and tackle one of the most mysterious and abstract aspects of the TypeScript programming language. And that is generics, or defining types in terms of other types."
          },
          {
            "time": "[00:08:37]",
            "text": "This is one of the great conceptual walls I can help you get over, and generally one of the biggest sticking points that people hit as they're trying to start working with this programming language. Here's a question, in a design system how can I support consuming apps that don't use TypeScript as well as those that do, and do I need to provide type definitions as well as prototypes?"
          },
          {
            "time": "[00:09:05]",
            "text": "Well, this is one of the great aspects of TypeScript, one of the core principles is that it needs to be able to work with regular JavaScript code. So even if your consumers are using regular JavaScript, they'll still get a lot of the benefits of that type information that comes from a library written in TypeScript, right?"
          },
          {
            "time": "[00:09:30]",
            "text": "So if you write the TypeScript, all of your users will get that better developer experience to varying degrees but they're all going to benefit to some degree. A very, very good question. We'll learn more about that very quickly, actually, in the next chapter of the course. So Nita asks are there any open source projects for beginners where we can apply and practice TypeScript after this course?"
          },
          {
            "time": "[00:09:58]",
            "text": "I'm gonna have to look back on that one, I'm sure there are some, one I can tell you for sure is the TypeScript website. So there are a lot of issues on the TypeScript website that are marked as good for new contributors, and by its very nature, it has a lot of small examples."
          },
          {
            "time": "[00:10:17]",
            "text": "And as people who are just learning the language, that's kind of a superpower in that case where you can use your lack of experience in this specific area to speak to what's confusing and what's not. And you can really help make the documentation, the little small projects that are part of that TypeScript handbook and the website."
          },
          {
            "time": "[00:10:38]",
            "text": "You can make those a little bit better so that they work for you because you're the intended audience, right? So we have another question, are there any plans to introduce aspects of TypeScript into the JavaScript programming language? I would have to say, no, but don't worry. So JavaScript is kind of strange in that code that we wrote in 1995, 1992, it still has to run as JavaScript, right?"
          },
          {
            "time": "[00:11:06]",
            "text": "The Internet has to remain backwards compatible. And for that reason, it's unlikely that we'll shift from sort of a dynamically typed or duck typed model to a statically typed model. So don't expect anytime soon for types to become part of what most people can run in their browser."
          },
          {
            "time": "[00:11:31]",
            "text": "Now, however, [LAUGH] we do see examples where something is sort of piloted in TypeScript, right? TypeScript adds a feature by itself and then those become part of the JavaScript programming language but it doesn't include the types. Examples of this include decorators, which are likely to be part of JavaScript soon."
          },
          {
            "time": "[00:11:56]",
            "text": "Private fields, so TypeScript has this concept of class fields that only that class itself can see. Well, that's now part of JavaScript. So there are a few situations where, aside from the typing aspect of things, language features sort of prove themselves out in the TypeScript world. And then that allows TC39, the standards body that decides what is part of JavaScript, right, it allows them to see hey, there are a lot of apps that got a lot of value out of this."
          },
          {
            "time": "[00:12:29]",
            "text": "How can we bring this to everybody, people who write JavaScript and TypeScript? And then sort of we merge everything together, right, where we make sure that once it's standardized, everyone can make use of those kinds of features. Well, let's jump in and look at how we might compile our first TypeScript program."
          },
          {
            "time": "[00:12:53]",
            "text": "Now, if you wanted to, you could check out this repo, if you click Edit on GitHub, it'll take you to a page in this repo. I would encourage you not to for this video course because we're gonna move kinda quickly, and I'm gonna show you everything you would see if you were to compile it yourself."
          }
        ]
      },
      {
        "name": "1-compiling-a-typescript-program",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first thing we're gonna do is compile a basic TypeScript program. And this is gonna be about the simplest program that we can think of, consisting only of three files. Our goals in this chapter are to learn a little bit about how to use the TSC compiler command."
          },
          {
            "time": "[00:00:18]",
            "text": "We're going to learn and understand how JavaScript language level and module type affect the kinda thing that comes out of our compiler. And then, finally, we're gonna look at other things that come out of the compiler than JavaScript, right? We're gonna see some type information that we could potentially publish along with this code."
          },
          {
            "time": "[00:00:41]",
            "text": "If it were a library and this is called the declaration file. Which has the extension .d.ts. So let's consider a simple project, as I said, it'll consist of three files. So we've got package JSON, which is the normal package JSON you're used to seeing in JavaScript project. We have a tsconfig file, which contains all of the instructions, and options, or passing to the compiler."
          },
          {
            "time": "[00:01:07]",
            "text": "And then, finally, we have some source code. So let's look at these three files one by one. In package JSON, we can see a couple of things. We have only one dependency, and it's a dev dependency, and that is TypeScript. In addition to that, we have an NPM script."
          },
          {
            "time": "[00:01:25]",
            "text": "So that we could run something like yarn Dev, or NPM, run Dev, and we would see the TypeScript compiler start up and watch our source code. So that every time we save a file, it'll incrementally kind of update the build result. If you've used Webpack-dev-server or something like nodemon, this will give you similar behavior."
          },
          {
            "time": "[00:01:49]",
            "text": "And preserve watch output this just make sure that every save does not clear your console's output. You kind of wanna keep that council output, in my opinion, I don't like things erasing my terminal history. So let's look at our tsconfig, the second of the three files. We have only three properties in this file, and we're gonna start from the bottom."
          },
          {
            "time": "[00:02:18]",
            "text": "So include tells the compiler where to find our source code. In this case, we're going to end up compiling all ts files that we find in the source folder, that's just index ts. We have two compiler options that we're defining here. First is, where are we going to put our output, right?"
          },
          {
            "time": "[00:02:38]",
            "text": "Everything that the compiler generates. By default, TypeScript will create JavaScript files that are side by side with the TypeScript source that created them. I don't like this because it kind of mixes my build result with my source code. I like having everything in a folder like dist or out, something like that."
          },
          {
            "time": "[00:02:58]",
            "text": "So that if I ever wanna clear everything away and build again, I can just rm rf and be rid of the built stuff. Finally, we have a target property, and this helps us describe the language level of our build output. By default, it's ES3, which is kind of like Internet Explorer six level of JavaScript."
          },
          {
            "time": "[00:03:22]",
            "text": "And we're gonna start there and see the garbage that the compiler spits out. And we're gonna crank that language level up to more and more modern JavaScript. Let's say we were only supporting modern browsers, and we'll see that things get cleaned up quite nicely. So it's important to understand that everything we described in this compiler object can be passed to the TSC command, as a COI flag."
          },
          {
            "time": "[00:03:49]",
            "text": "So here's an example of outDir. Now, I don't typically like using VCLI flags except in very, very simple situations. I'm very quick to sort of set up a tsconfig and have this nice, you know, configuration that I can check in with my project. And I can be sure that I'm gonna be running exactly the same command over and over again."
          },
          {
            "time": "[00:04:15]",
            "text": "The last of the three files we're gonna at, is the source code, right, this index.ts file. And it's not a big program, but it contains a couple interesting things that will present us with some clear signals about how the compiler responds to that target property, this here. As well as the type of module we instruct the compiler to make for us."
          },
          {
            "time": "[00:04:40]",
            "text": "So you're going to see that it includes the use of a promise, which only came with JavaScript 2015 edition, right, ES2015. Then we'll see that a sync and await are used, which kind of had partial support through generator functions in ES2015. But it only got real clear support like using a sync and await as keywords that came in ES2017."
          },
          {
            "time": "[00:05:07]",
            "text": "So we should start to see things kind of disappear and become the more normal code that we're used to reading modern JavaScript as we crank that language level up. And here is the source code. So all this program does, here's the entry point. It console.log something, and what is it console.log?"
          },
          {
            "time": "[00:05:27]",
            "text": "Well, it's whatever addNumbers returns and that gets awaited. So addNumbers, just waits for half a second and then adds a and b together. So effectively we should see like a half second wait and then seven printed to our console, not too complicated. This is a good opportunity for me to show you one of the features of this website that we're gonna be looking at today."
          },
          {
            "time": "[00:05:58]",
            "text": "You can hover over various symbols in these code samples and see what you would be seeing in Visual Studio Code. So this is a little bit like a read only VS Code frame where you can really understand the types of everything that you're touching. This is really, really important because the tooltips don't lie, this will tell you why something is failing and it helps, you understand what's going on within the code."
          },
          {
            "time": "[00:06:28]",
            "text": "So the vast majority of the code samples, you'll see today allow you to do this. Additionally, if we want to see this code run in the TypeScript playground, you could hit this try button. And it would take you right here and you'd be able to actually click logs, and run this, and right now, we can't run it."
          },
          {
            "time": "[00:06:47]",
            "text": "But because we have an expert in this playground, which it's not designed to handle. But you're gonna be able to actually, play with each of these examples and I encourage you to poke at them and to understand them, and to maybe try to break them try to fix them."
          },
          {
            "time": "[00:07:05]",
            "text": "So let's go back to what we were just looking at. So this is our small program and here I'm cluing you into hovering over tooltips. So how might we run the compiler? Well, if you were to check this program out this this repo out what you could, you could run yarn dev, and you would see that TypeScript is starting to watch your code."
          },
          {
            "time": "[00:07:26]",
            "text": "And immediately you would see a dist folder created, which would contain an index.js file. And we can look at what that code would be and shield your eyes because it's a mess. This is like all the polyfills, right, this is a sync and await and promises and just a bunch of junk here, right?"
          },
          {
            "time": "[00:07:51]",
            "text": "Remember, this is really dumbed down JavaScript for IE6. So we're gonna close this, be done with it. And that'll be our starting point, just a bunch of junk. So let's change the target language level, we can simply go from ES3 to ES2015. Leaving everything else intact, and the compiler output would change."
          },
          {
            "time": "[00:08:17]",
            "text": "So now we start to see some more modern language features, but not everything we're used to seeing. So there is a promise constructor which is nice, we do see a yield keyword. Interesting that we got this in ES2015, but we didn't get a sync and await yet. So we have a generator function which makes the polyfill for a sync and await makes it much cleaner."
          },
          {
            "time": "[00:08:44]",
            "text": "Because that's a very important thing to be able to use to define a sync and await. But it doesn't yet look like our source code with the type stripped away. That's where we're sort of working our way towards. So this is ES2015 if we step up to ES2017, this is what it would look like."
          },
          {
            "time": "[00:09:07]",
            "text": "So we're going to see actual use of the a sync and await keywords. And this a waiter helper, which is this thing up here, that will have disappeared and here we go. Now, this looks like our TypeScript code with the types removed. So if you're interested in how to define your output, target is a really important thing to define."
          },
          {
            "time": "[00:09:32]",
            "text": "One of the questions we got during the break had to do with multi target output, right? What if you're building for modern browsers and you have a legacy browser you need to support. So typically what I would do is have TypeScript output something like this, which by the way, still is in ES modules."
          },
          {
            "time": "[00:09:53]",
            "text": "And then you could use something like Babel to make a legacy build for IE11 if you need to. So in your dist folder, if we had run the compiler, we would have found a file called index.d.ts, and this is a declaration file. Now, there's a new keyword here that I'm gonna ask you to ignore for the time being."
          },
          {
            "time": "[00:10:18]",
            "text": "Cuz it's not the most interesting thing going on here. The most interesting thing is this appears to be a function with no implementation. It's just sort of a semi colon at the end of the arguments list, right? So you can think of this almost like the types that were stripped away from our source code."
          },
          {
            "time": "[00:10:37]",
            "text": "So you start with TypeScript, which is code that runs and types, and then your compiler almost separates those out. So you get a js file that runs and you get these dts files, which contain only the type information. Why is this good? Well, it lets people who are just using JavaScript who aren't writing TypeScript."
          },
          {
            "time": "[00:11:02]",
            "text": "They can compile those js files and just call it a day. And people who are writing TypeScript, they can kind of reassemble that together and have the JavaScript that runs and the types that describe the constraints. So this is what will allow you to remain compatible with users who depend on your code regardless of whether they themselves are authoring TypeScript."
          },
          {
            "time": "[00:11:27]",
            "text": "So one more thing that's important to understand are the types of modules the compiler is emitting. If we tried to run this code that we generated up here, right this code here, specifically with this export keyword. If we tried to run this with node, we would get an error right at that line with the export keyword, why?"
          },
          {
            "time": "[00:11:47]",
            "text": "Node wants common j s modules right this is node js is module system predates a standardized JavaScript module. And even today, although they are moving towards these standardized modules, even today, node wants to run a common j s module. And you can read more about that if you click this link."
          },
          {
            "time": "[00:12:11]",
            "text": "But if we wanted to make something that runs with node, it's just as easy as adding a module property to our compiler options in the tsconfig file. And what this is gonna generate for us is it will change this export add numbers and we'll change that into exports.addNumbers equals addNumbers."
          },
          {
            "time": "[00:12:33]",
            "text": "So this is the kind of output that we expect in the node js world. This represents the easiest and simplest possible TypeScript program that you could compile. Now we're going to pivot and talk about the programming language. Now that we kind of know how to use the tool"
          }
        ]
      },
      {
        "name": "2-variables-values",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about variables and values. In this chapter, we're gonna talk about simple let and const declarations and the very basics of typing functions. And that will serve as a good foundation for us to start building other more complicated types on. So variable declarations in JavaScript, kind of look like this, right?"
          },
          {
            "time": "[00:00:21]",
            "text": "We have let and const hopefully nobody's using bar anymore, but we can just say something like, let age = 6. And you may note that TypeScript is kinda figured out this is a number. This does not seem like an impressive trick, because obviously 6 is a number, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "Well, what you're seeing is inference, where TypeScript can contextually understand the situation. It can see that yes, we have a variable declaration with an initializer, right? Where we're assigning it to 6 right away, clearly that should be a number, right? And not every programming language has this by the wa,y if you work in the Java or the C++ area, every variable declaration typically comes with the type up front."
          },
          {
            "time": "[00:01:11]",
            "text": "You have to say like int age =6, you'd have to say it's an IT. This up here seems like regular JavaScript. But down here, you could totally do this with JavaScript, but TypeScript is unhappy, why? Age was the variable that was born with a type and that type is number."
          },
          {
            "time": "[00:01:31]",
            "text": "And we can see that if we attempt to give it a value that's a string, it's going to yell at us. This is the kind of thing that TypeScript is designed to catch. I want you to remember that in TypeScript variables are born with their types. So there are things we can do, which we'll learn about later to make these types more specific."
          },
          {
            "time": "[00:01:54]",
            "text": "But it's hard to make them more general, once they're declared. So, it's important to make sure that when you define your variables, they have the types that you need them to have. And if you ever need to generalize them, usually you go right back to that variable declaration, and that's where you have to make a change."
          },
          {
            "time": "[00:02:13]",
            "text": "So let's look at a similar example, but with const. So if we just change our let to const, we can see that we get a different type here, and that type is 6. And you might think, well 6 is a value, right? Number is a type 6 is a value."
          },
          {
            "time": "[00:02:29]",
            "text": "What we have here is called a literal type and it's a more specific kind of type. It's not just any number, it's any number that is 6. You can think of it that way, right? So the reason that changing let to const has done this thing, that we see before our eyes has to do with two things going on."
          },
          {
            "time": "[00:02:56]",
            "text": "One, it's the nature of const's declarations, they can't be reassigned. So we know that once we point it at a thing, it will forever pointed that thing, age will always point to whatever it is assigned to. And then the second is that, numbers in JavaScript are immutable value types."
          },
          {
            "time": "[00:03:17]",
            "text": "Unlike arrays, where that's a value type where you can push things into it, right? 6 will always be 6, right? We can create a new number, but we can't change an existing number. So basically, this whole thing is poured and concrete, where it's a variable that can never point to something else."
          },
          {
            "time": "[00:03:39]",
            "text": "And the thing it currently points to cannot change. So we know very specifically that this is 6 and it will always be 6. So TypeScript can make a safe more specific assumption here. And that's a theme we're going to see over and over, by the way, where TypeScript tries to make the most specific assumption, that it can without risking getting in your way."
          },
          {
            "time": "[00:04:06]",
            "text": "So 6 is called a literal type, meaning it is literally the number 6 and if we think about why we were able to make this assumption more specifically, like we said in our two reasons there. But imagine if we made that same kind of very specific assumption with a let declaration."
          },
          {
            "time": "[00:04:29]",
            "text": "So if we go back up here, what if we assumed age was always going to be 6 that would get in our way, right? Like the nature of let declarations we're probably going to assign them to something else in the future. And that's why you get that the more relaxed constraint there, where normal code that treats this as a number is going to behave nicely, right?"
          },
          {
            "time": "[00:04:52]",
            "text": "Don't want TypeScript to get into your way. We're gonna see literal types over and over, but you can just think of them as a set of allowed values. So sometimes we end up in situations where we have to declare a variable, and then the variable gets its value sometime later."
          },
          {
            "time": "[00:05:17]",
            "text": "So let's look at this piece of code which begins with a timestamp, and it ends up measuring a startTime and then sometime later when it finishes a random wait, and it record an endTime. So maybe we wanna have access to this endTime in this outer scope. But clearly like within this set timeout function, that's when it's actually going to get its endTime."
          },
          {
            "time": "[00:05:48]",
            "text": "So you could end up with something like this. And if we look at the way this is defined, we can see that this is of type any that's what this notation means, by the way. EndTime is a variable, it's a let declaration and it has a type called any."
          },
          {
            "time": "[00:06:04]",
            "text": "Any is the most flexible type in TypeScript. And you can think of it kind of like JavaScript variable rules, where we could set it equal to a string and then a number and then a function and then null and then whatever, there's no constraint. It can be anything, any value that is allowed in the JavaScript world."
          },
          {
            "time": "[00:06:28]",
            "text": "So it's not necessarily bad, but it's often much more flexible than what you want. And in this case, we can see that there's just not enough information for TypeScript to make a guess as to what this should be. Because types are assigned to variables when those variables are born."
          },
          {
            "time": "[00:06:49]",
            "text": "And when this is born, we don't know when the set timeout is gonna be invoked, and we don't know what value it's going to get. So in this case, we need to add what's called a type annotation. And that is our colon type syntax, right? Where let here, what we're saying is, endTime is a Date, we're not giving it a value yet, but it's going to get a Date and you should treat it as if it's going to get a Date."
          },
          {
            "time": "[00:07:22]",
            "text": "And now when we for some reason we're setting this to = to 0 before we give it its real endTime. We're told that we can't give it a number. This is a slot that's designed for a Date. This is exactly what we should give it. So now we're seeing enforcement of types."
          },
          {
            "time": "[00:07:40]",
            "text": "I only add type annotations like this when I have to, because it's just extra stuff in your code, and it tends to make things a little bit more difficult to refactor. If you start adding types all over the place, but in this case it's absolutely appropriate and absolutely necessary."
          },
          {
            "time": "[00:08:00]",
            "text": "So let's look at functions. This same syntax that we saw with this variable up here, right? Colon Date this can be used with our add function here that we saw in the first slide of the course. It can be use to state that a and b are numbers."
          },
          {
            "time": "[00:08:20]",
            "text": "And this function add returns numbers. You can see that by default, everything ends up being any. This is because like imagine we were converting this from a JavaScript file to a TypeScript file. Maybe we start with everything loose and then we wanna crank things up and define the types as we go."
          },
          {
            "time": "[00:08:40]",
            "text": "That's probably not what we want in the end now, right? So why is any gonna be a problem in this case? Well, look here. This we know is gonna be 7 based on the implementation of the function a+b. So we know promise doesn't accept 7 as its constructor argument, but TypeScript seems to be happy about this."
          },
          {
            "time": "[00:09:05]",
            "text": "This is not the same point that I was making before, where the return value doesn't have a type and therefore we could use it. We can reach into it in unsafe ways. If you have an any that's floating around. If that value enters well typed code, it will break that well typed code, so the guarantees I have around promises don't matter right now."
          },
          {
            "time": "[00:09:27]",
            "text": "Because I have this any, so having something like this floating around can weaken your guarantees that you have around your code. It's kinda dangerous thin, now I say dangerous. It's only as dangerous as a regular JavaScript variable, which is dangerous. So let's add some type annotations here. We can say that a and b are arguments, each of them is a number."
          },
          {
            "time": "[00:09:52]",
            "text": "And here it's very clear that the result that's returned is a number. And if we attempt to use this, I mean, we already saw this example, we can't pass a string in that's not compatible with a number. You may notice that, the return type of the function is also inferred so that number on the right side of the tooltip, the compiler is smart enough to figure out that a + b, the result of adding those numbers together is a number and that's what's returned."
          }
        ]
      },
      {
        "name": "3-typing-functions",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So I prefer to explicitly state return types. And I'm going to show you why, it has to do with where problems are surfaced. Do you want those problems to be surfaced at the place where you declare the function? Or do you want them to be surfaced where you use the function?"
          },
          {
            "time": "[00:00:21]",
            "text": "So my preference is this, and we can see that once we define a return type we get an additional benefit there. And that is, every code path that goes through the implementation of this function must live up to what you state will happen. Meaning, even if you had like six or seven different branches that happened based on different conditions, lots of complicated logic for adding two numbers together."
          },
          {
            "time": "[00:00:46]",
            "text": "Every one of those has to return a number or throw but you can't return null and one of those cases, this will give you guarantees that everything is handled down every path that that could possibly be taken. I want this error here, surfaced at the function declaration. Not at where I'm using it, so I'm gonna pop up in the TypeScript playground and we can look at the alternative here."
          },
          {
            "time": "[00:01:20]",
            "text": "So I can add 3 and 4 here, let's get rid of this. Yeah, this is a great example. So what's happening here is add, it has a return type void, meaning it doesn't return and rather than talk about void now, let's return null, right? Add returns null, so right now let's say I use add a bunch of different places in my program."
          },
          {
            "time": "[00:01:53]",
            "text": "They're all gonna light up, and the errors happening at the point of invocation. If I state my intentions up front with a return type that's explicit, Now, all of my usage is fine, because I mean, it's not gonna run the way I would want it to run. But it returns a number that's what I've stated, should happen, will happen."
          },
          {
            "time": "[00:02:23]",
            "text": "And now this is one thing that I need to fix, so it just reduces the noise. You're not seeing like 15 different things light up, you're seeing 1 thing light up, and it's taking you to the location of where you need to make a fix. This is better, in my opinion, that's why I like explicit return types."
          },
          {
            "time": "[00:02:41]",
            "text": "Let's you state your intentions upfront, make sure you follow through with them. And it surfaces problems where you need to fix the problems."
          },
          {
            "time": "[00:02:41]",
            "text": ">> Mike, this seems, kinda like local preventative medicine, almost like when you were, that last thing you did, I'm sorry. When you are declaring, I guess what the output type should be?"
          },
          {
            "time": "[00:03:05]",
            "text": ">> Yep."
          },
          {
            "time": "[00:03:05]",
            "text": ">> So that you don't leave locally in your code and you can detect the error before it happens, I suppose, just trying to, in simple terms for me,"
          },
          {
            "time": "[00:03:05]",
            "text": ">> Sure, let me tell you the way I think about this. So test driven development isn't for everybody, but I like type driven development, meaning, sometimes I will state what I'm trying to do and put the usage of the function I have not implemented yet in place."
          },
          {
            "time": "[00:03:40]",
            "text": "And I can define what I think I need in terms of inputs and outputs, and then I can implement it later. So I like to use this as a tool and frequently I'll end up doing this. Write the code that I want to be able to run and then fill in all of my functions."
          },
          {
            "time": "[00:03:58]",
            "text": "Now, you talk about this as local preventative medicine. I think about this as local boundaries, where instead of validating that your whole program works by running an extensive test suite that tests everything all together. You can on a per function basis, ensure that within this function, I am returning the right thing, I am accepting the right thing, and then you can move on to another function."
          },
          {
            "time": "[00:04:29]",
            "text": "Now, TypeScript is not a replacement for tests, it's not a replacement for unit tests. But this does give you the ability to shift between micro and macro. Is this function doing the right thing, is it returning the right thing? Do I have the right guarantees around it and then shift out, and let's test the whole program, and let's make sure that things work the way they should."
          },
          {
            "time": "[00:04:56]",
            "text": "And I say TypeScript is not a replacement for tests because all it does is checks types, right? It doesn't actually ensure that a and b actually gets summed up together. So if you were writing tests that specifically validated only the type information, yes, you can eliminate those. But, I think it's kind of a dangerous statement to say, You no longer have to write a lot of unit tests."
          },
          {
            "time": "[00:05:24]",
            "text": "TypeScript has nothing to do with behavior that's still left to JavaScript. So, hopefully we're writing those kinds of unit tests to begin with, don't stop writing this."
          }
        ]
      },
      {
        "name": "4-typing-functions-q-a-and-objects",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Why does TypeScript not complain in that example, where I'm passing a number into the promise constructor whether the result is any? Yeah, it's kinda mysterious, right? So I'm gonna go back to that example because it is quite shocking, right? Let me let me take us back here."
          },
          {
            "time": "[00:00:20]",
            "text": "It's this one right here. Like the reason I show this to you is because n E's are dangerous. And the fact that in this case, just to recall, like what stage of the code we were at here, we had not given arguments a type and therefore, like what is a plus b even mean when a or b theoretically could be anything right?"
          },
          {
            "time": "[00:00:44]",
            "text": "We don't know. So result ends up being in any. Now, the point here is that an any does not just cause problems that have to do with itself. When an enemy is passed into well that flexibility will compromise that well typed code. So in this case, an any variable can hold anything, and they can also masquerade as anything."
          },
          {
            "time": "[00:01:18]",
            "text": "That's a useful way to think about this. It's a wild card It can accept anything, but it can also present itself as anything. And in this case, that's gonna cause problems, even if your types are really, really good about where that any goes where it enters into. So that's the liability of having something like this."
          },
          {
            "time": "[00:01:45]",
            "text": "Hopefully that makes sense. It can masquerade as anything. Louise making a comment about my unit test remarks. Yes I agree with you that, the guarantees and the checking that type script gives you in a, in a declarative way, right? These constraints, they help avoid defensive programming to some extent, but when we start building type cards, you may accuse me of defensive programming again."
          },
          {
            "time": "[00:02:11]",
            "text": "So I wish to withhold your judgment for the time being. All right and he says much of the job of TypeScript is about type annotation. The JS doc introduced way before TypeScript was inter invented. Let me rephrase this question. So, Annice you're basically asking, like, why do we say that there's so much value that comes along with TypeScript."
          },
          {
            "time": "[00:02:36]",
            "text": "When you could have done some of these things in the JS doc world. That's a very fair point. But let me show you this. Let me show you what you could have done in the JS doc world. So Annice is referring to the fact that I could have done."
          },
          {
            "time": "[00:02:57]",
            "text": "Sorry I always forget the ordering of this. Let's hover over these tool tips. Oops maybe I'm doing this wrong. I think it's like that. Let me try one of each, see if it works. I think the fact that it's running in the type playground is hurting us a little bit here, But take it from me, I really think it's this B and A number."
          },
          {
            "time": "[00:03:34]",
            "text": "So you could have done something like this. And if this were a more normal environment, we would have seen that like a and b are regarded as numbers. But here's something that JS doc would have also let you do something like that right where you forget to add a type for one of your variables and defining more complicated types in JS Doc is really complicated, things with type params and stuff like that."
          },
          {
            "time": "[00:04:00]",
            "text": "So really what JSDoc was missing was strong enforcement of alignment. Between the comments that you're writing and the code that they were documenting that that was hard, and for that matter within your function, JS doc was probably not helping you much unless you're being extremely vigilant about saying like result equal saying Something like this."
          },
          {
            "time": "[00:04:33]",
            "text": "This level of JS doc might have gotten you a long way, but I don't come across too many code bases to do this. It's a lot of vigilance required to keep all this up today. Okay, I am actually gonna proceed because a lot of these other questions I know we're going to get to later on."
          },
          {
            "time": "[00:05:06]",
            "text": "Nita asks what is a use case for any. We're gonna talk about that in the section called Top and Bottom tyes, dedicated discussion around any and it's kind of a part of network and unknown which is kind of like a special program. So with that let's pick back up."
          },
          {
            "time": "[00:05:25]",
            "text": "Now that we've covered variables and basic functions, it's time to talk about collections. These mutable value types. And in JavaScript, these are objects, arrays, and something called Tuples which are a special type of array. So we're gonna learn how to type all of these different things. And let's begin with objects."
          },
          {
            "time": "[00:05:50]",
            "text": "So when we talk about the types of objects, they are two things, what properties are on this object? And what are the types of these properties? And that applied recursively could describe deeply nested objects, or very small objects. I mean that that's the core principle. Some people refer to this as a shape, right?"
          },
          {
            "time": "[00:06:15]",
            "text": "What properties do you have and what kinds of things can I store under each of the properties? So let's just start with a conceptual model of a car, which we could describe as like a 2002 Toyota Corolla. It has a year a make and a model, the make and the model are going to end up being strings."
          },
          {
            "time": "[00:06:36]",
            "text": "And the year it's gonna end up being a number. So we can describe the type of this object as follows. And again, we're seeing the same syntax, value, or like property name or variable name, colon type, and we're creating something that looks a lot like JavaScript objects syntax."
          },
          {
            "time": "[00:07:01]",
            "text": "But instead of key value, we have key type. We can actually use this colon type syntax with this structure that we've created. If we hover over a car, we can see that it's stuck, right? So just as before where we were saying, age colon number, or end time colon date, we're seeing car colon and then this big thing that we've created and that's a type of object."
          },
          {
            "time": "[00:07:35]",
            "text": "If we wanted to use this to describe an argument, we can do this. And we can see that as we reach into this object and we do car.make, make as a string, model is a string, and year is a number. So this is where we're getting that nice validation and these would show up in autocomplete as well."
          },
          {
            "time": "[00:07:57]",
            "text": "If you did car.m, you would see that making model drop down."
          }
        ]
      },
      {
        "name": "5-optional-properties",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So what about optional properties? Let's extend our model of a car and we'll say, sometimes we have an electric car and they wanna charge at a particular voltage. So what is that chargeVoltage? Is it 240 volts, what is it? Now, chargeVoltage doesn't make any sense for a car that runs on gasoline."
          },
          {
            "time": "[00:00:23]",
            "text": "So, Let's say that for electric cars we will find this value, but for non-electric cars this value will be missing. So this is an optional property that may or may not be there. It's sometimes there, and it's a number. So we're going to use this question mark to state that chargeVoltage might be there, but if it is there it will be a number."
          },
          {
            "time": "[00:00:54]",
            "text": "And if we hover over this, the type of chargeVoltage, its number and then a pipe and undefined. Can someone make a guess as to what the pipe means? When do we see a pipe in JavaScript? Maybe two pipes next to each other."
          },
          {
            "time": "[00:00:54]",
            "text": ">> Means or?"
          },
          {
            "time": "[00:00:54]",
            "text": ">> It means or, very good."
          },
          {
            "time": "[00:01:16]",
            "text": "So you can think of this as or for types. I see a lot of people in the chat got it as well. So we'll talk more about and and or, it is possible with types. But here we're seeing something that conceptually aligns with what we set out to do."
          },
          {
            "time": "[00:01:30]",
            "text": "And that is, it may or may not be there. So here we can see we regenerate our string. Here's our chargeVoltage, and this is interesting. So, what we're doing here is we're gonna make a basic string, and then I've just put this line here to kind of reveal the type of chargeVoltage that has this undefined."
          },
          {
            "time": "[00:01:57]",
            "text": "And then we have this condition. And at run time, if we think about what this will do, we're checking to see if chargeVoltage is defined or it's not. So we're creating a branch of code that will only execute if something is there for chargeVoltage. And sure enough, we can see that we've eliminated the undefined possibility here, right?"
          },
          {
            "time": "[00:02:24]",
            "text": "If we go down this branch of code, TypeScript seems to be able to understand that we're gonna have a number there, and we can use it. We can print it as a number, right? This is what's called a type guard. It's where you typically will combine some sort of predicate, like a check true or false expression, right?"
          },
          {
            "time": "[00:02:50]",
            "text": "You'll combine that with some control flow tool like if or a case switch. And in doing that, you'll create branches of code where the compiler can understand that like we'll take a left turn if we're undefined, and we'll take a right turn if we are defined. And that allows you to kind of consume these things safely."
          },
          {
            "time": "[00:03:17]",
            "text": "By the way, this is one of those key points I talked about where people love TypeScript. Every time I convert a JavaScript code base to TypeScript I find a bunch of these, where somebody was sort of betting on this value will probably be there. And it turns out, there's no code that guarantees that, TypeScript is gonna demand that we put this line here in order to start using it."
          },
          {
            "time": "[00:03:39]",
            "text": "We can go out to the playground and give this a shot. So if we were to take this away, and let me make this a little bit more obvious, we'll say, toFixed, right? So I'm just trying to use this in a way that's gonna really break if it's something other than a number."
          },
          {
            "time": "[00:04:03]",
            "text": "If we got rid of this type guard, it's just gonna say, look, you can't do that. This could be undefined, you can't just reach into it and call toFixed. So the type guard serves that purpose. And I guarantee you write JavaScript code today that is missing these in important places."
          },
          {
            "time": "[00:04:24]",
            "text": "I know, I do it all the time. Like every time I convert, I find a bunch of these. So, because we have this optional property, we can either pass this value in as we are down here, or we can omit it. Now, some of you may wonder what if here, For this chargeVoltage, what if I did this?"
          },
          {
            "time": "[00:05:00]",
            "text": "And let's try to use it. So something's not happy here. And if we look at this error, it's a little hard to read. I read TypeScript errors from the bottom up cuz they're kind of like stack traces, especially in this case where we have a problem with the whole object."
          },
          {
            "time": "[00:05:34]",
            "text": "That lowest line and the error message will tell you the property that caused the problem. So we're seeing, okay, chargeVoltage is declared here, chargeVoltage is missing in type, and then it lists the type, but it's required in type, and then it lists another type here. So what we're saying here is if I didn't have a chargeVoltage, I actually have to do chargeVoltage is undefined."
          },
          {
            "time": "[00:05:58]",
            "text": "I have to pass in an undefined, that's kind of weird. There's a difference between an optional property and a property that has the potential to have an undefined value. Optional properties can be left out, but if you do this, someone's gonna have to pass an undefined, which is really weird."
          },
          {
            "time": "[00:06:19]",
            "text": "I don't like passing undefined in as a deliberate argument, right? That's kind of strange, or deliberate property value. So, that's the difference. And I see some face palms in chat. This is a justifiable facepalm. So, yeah, you wouldn't be able to do this. So optional is more than simply adding that or undefined."
          },
          {
            "time": "[00:06:45]",
            "text": "It means that it can be present, it can be absent. There is another type of error that TypeScript catches for us called excess property checking. And again, I'm gonna illustrate this with an example that builds potentially one more thing onto our car model. So we have our make, model, and year."
          },
          {
            "time": "[00:07:06]",
            "text": "And let's say that someone got really eager and they decided they want to describe the color of their car and pass that into this function. So we're getting what's called an excess property error, and the keywords to look for here is object literal may only specify known properties right here."
          },
          {
            "time": "[00:07:34]",
            "text": "And color is not one of those properties. So it's saying, you gave me this thing and I didn't ask for it. And if we eliminated it, everything would be fine, why? Why is TypeScript mad at us? This won't break your code. The fact that red's there won't break your code, so why are we being alerted?"
          },
          {
            "time": "[00:07:55]",
            "text": "Well, If we started to use car in here, there's no way to safely access that color property. So it's a case where when we're changing, when we have that color property there, we're setting ourselves up to never be able to safely access that extra thing. It's like an appendix, it's this vestigial thing that serves no purpose can safely be eliminated, we know conclusively."
          },
          {
            "time": "[00:08:26]",
            "text": "So there are a couple things we could do if we wanted to handle this case, and I'm going to show you a couple of them. First, we could certainly say oops, we can make it optional. This would make this thing go away cuz potentially in here, we could use the undefined check, we could access color, it's no longer a pointless thing to pass in."
          },
          {
            "time": "[00:08:52]",
            "text": "So that's one thing we could do. And here's another thing that sort of makes the point as to how the compiler is trying to help us. Let's, myCar, let's give it a value, or variable, rather. So here, we're also not getting an error, why? Well, conceivably, something else other than printCar, could reach into this my car thing, And get color."
          },
          {
            "time": "[00:09:23]",
            "text": "That's totally fair. It's no longer definitely pointless to have that color property on there. And when we talk about object literal, like access object literal property checking, it had to do with the fact that we were just passing this thing in directly to the function as an object literal."
          },
          {
            "time": "[00:09:46]",
            "text": "And that's why we were guaranteed that like nobody is ever gonna be able to make use of this color property. No one else has access to it. It just lives in the argument list of this one invocation of print car. It lives in a stack frame. And so definitely no one else is gonna be able to use it."
          },
          {
            "time": "[00:10:10]",
            "text": "So you will see errors like that when you convert something from JavaScript to TypeScript, and you'll solve it a number of ways. As you're doing your early conversions, it's gonna be because your types were missing something like, yeah, color, we need to handle color. And then you're gonna start to find things where there's like a misspelling or something weird."
          },
          {
            "time": "[00:10:31]",
            "text": "So we saw three different ways to solve this. Remove the property, add the property to the type, or create a variable. Because conceivably, something else could access color through that variable."
          }
        ]
      },
      {
        "name": "6-index-signatures-object-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So great, we learn how to type rigid objects. What about dictionaries? So let's imagine an address book situation. I know the address book and my phone lets me store multiple phone numbers where I could say, home, work, fax, pager, whatever apparently grew up during the 80s. So might look something like this, right, where we have a consistent type of value that is stored under an arbitrary key."
          },
          {
            "time": "[00:00:31]",
            "text": "So we have this nice way to easily look up values by key, just give me the work number. In order to type this properly, we need something called an index signature. And here's what that looks like. We have these square brackets and you should think of this almost like box notation for accessing a value off of a property, like dictionary square bracket and then a string for the property key."
          },
          {
            "time": "[00:00:57]",
            "text": "That's a good mnemonic device here, right? So you can pass in any string, you can call this k whatever you want. It's sort of arbitrary, cuz you're not really consuming k elsewhere. And then this is the type of value that you will find under each key. And here we're starting out with an empty dictionary but you can see we can reach in and we will get this object out."
          },
          {
            "time": "[00:01:20]",
            "text": "Now, I'm showing you this flavor of a dictionary for simplicity. What I like to do is add, and I'll go out to the playground here. I like to do this because it's bothersome that we know this is empty, and yet we're reaching in and assuming facts will be there."
          },
          {
            "time": "[00:01:42]",
            "text": "Do I really wanna be able to do this? Which this will happily let me do. I kinda want that extra rigor of being asked to check whether fax is actually present or not. But it's up to you different patterns work for different use cases. You pass a variable with extra property to a function that does not use that property and it'll be okay."
          },
          {
            "time": "[00:02:12]",
            "text": "It does sound like you're describing the excess property erroring case. TypeScript is basically trying to discourage you from adding extra stuff to object literals which it can guarantee you will not be able to safely access from within the body of the function. And Theresa asks, why does storing that object as a variable get rid of the error?"
          },
          {
            "time": "[00:02:45]",
            "text": "Let me take us back to that little screen. So why is it that if we take this here, cut my car. So, when we weren't using this through a variable we went in here and we said, well, let me just copy this. So we've got a variable right now we're not currently using and we're passing this in, we get this error message."
          },
          {
            "time": "[00:03:22]",
            "text": "So I suggest that there is no way to safely access color. No way, within the print car function. Like first nobody can see this object other than print car. It's an argument that you're passing to the function, out here there's just no way for me to access that object that I've created, to pass into the function."
          },
          {
            "time": "[00:03:49]",
            "text": "The only place we can access it, is from within print car. And within print car, we've stated that, this is the type of object we receive. So, if I do car.c colors not appearing on this list. We can't access that color property. So based on the fact that only print car can see it, can see the object, and print car won't be able to access that color property that's why you're getting that error."
          },
          {
            "time": "[00:04:18]",
            "text": "Let's see if those same conditions hold true in the case where we're using the variable. So I'm gonna replace this with my car. And print car still cannot access a color property because it doesn't state upfront that color might be there. However, down here, We can see color, right?"
          },
          {
            "time": "[00:04:48]",
            "text": "We have this variable and conceivably we could use this variable in other places, in other ways, maybe for a different function that wants to see a color there. So, in the case where we're storing this as a variable, you cannot prove that the color property is a waste."
          },
          {
            "time": "[00:05:10]",
            "text": "You cannot prove that it's pointless and that's why we no longer get the error. You only get the error when it can be proven that the property is pointless."
          }
        ]
      },
      {
        "name": "7-arrays-tuples",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about arrays. So we've talked a little bit about object types. Obviously, arrays are the other main type of collection that we work with in JavaScript. And sort of key value storage we have positional storage. So, typically, for at least simple types of arrays, all we have to do is add a pair of square brackets after the type of the member of the array."
          },
          {
            "time": "[00:00:27]",
            "text": "So this would be an array of strings. And you see the inference works here, just as we would hope where we don't have to explicitly write a type annotation. TypeScript understands what's going on. We could use our object type here as well to say we have an array of cars and we could start with one car in there."
          },
          {
            "time": "[00:00:47]",
            "text": "So this you can think of it as like this is just as much a type, as the word string is a type and it can be used in all the same places. So that's simple arrays. Let's talk about tuples. So tuples are, I mean, you could have used tuples in regular JavaScript if you wanted to."
          },
          {
            "time": "[00:01:09]",
            "text": "There's no special treatment. It's more like just a pattern. Where you have some meaning of positional ordering of different pieces of data. So if we wanted to store our 2002, Toyota Corolla, we could just have a convention that says, the first member the first element of the tuple is the year followed by the make, followed by the model."
          },
          {
            "time": "[00:01:37]",
            "text": "So we could store it like this. And then this makes destructured assignment really nice because we can then pull out the individual little parts of this compound value. And do something interesting with your making model. So, unfortunately, inference is not going to be our friend here. And again, we're back to the theme of TypeScript making."
          },
          {
            "time": "[00:02:04]",
            "text": "We're trying to make a reasonable and safe assumption, that will stay out of our way most of the time. And in this case, it's decided that what we're trying to do is create a mixed array of arbitrary length that contains some mix of strings and numbers. And that's gonna be a problem for us, why?"
          },
          {
            "time": "[00:02:30]",
            "text": "Well we could add an additional element, right? Like this is a sedan versus a coupe. The year is not in the right place, right? The year should be the first element and this is in the second position here. So it's just not describing things as tightly as we really want."
          },
          {
            "time": "[00:02:51]",
            "text": "I invite you to think about this question. What do you want most of the time? So sometimes we return an array that has two things in it and it's always two things and there's always a number and then a string. And other times we use arrays of arbitrary length."
          },
          {
            "time": "[00:03:07]",
            "text": "So show of hands, who uses arrays as like arbitrary length collections more often than like, just a pair of things? Like I know I do. And in the chat, you can just type y or n, yes or no. Yeah, I see some hands up. So TypeScript is designing around this."
          },
          {
            "time": "[00:03:28]",
            "text": "They don't want to mess with your regular array use case. And this is not a big problem, but all it means is that you're going to have to explicitly state when you intend for an array to be treated as a tuple. And you're gonna just need to define a type annotation in that case."
          },
          {
            "time": "[00:03:46]",
            "text": "Again, it's running with the theme of type strip trying to stay out of your way while providing you with safety. And here is what that tuple might look like. So within the square brackets, we're simply indicating with each position what type of value we expect to find there."
          },
          {
            "time": "[00:04:10]",
            "text": "In this case, we're being shown that or being alerted to the fact that two things seem to be out of place, TypeScripts, not happy with the first or the second element here. And that's because they need to be switched in terms of position and then here we're seeing that source has 4 elements, the target only allows 3."
          },
          {
            "time": "[00:04:30]",
            "text": "It's basically saying the right hand side has 4 things on the left hand side, you have my car and you told me I should have 3 things. Therefore I object, right? So this is how you define tuples. They're, really useful in cases where you want to return multiple things."
          },
          {
            "time": "[00:04:50]",
            "text": "But maybe it's not a type that's so formalized that you wanna store things under property keys, like often, maybe for form validation case, right? I don't want to throw errors. I kind of want to return errors. I'll return a tuple that has in the first position, a string that's like success or okay."
          },
          {
            "time": "[00:05:10]",
            "text": "And then data, or the first position it'll be like error and then followed by the error. But this is a pattern you see often in languages like Python or Elixir. Where you return these things? So, you do want to be careful here and TypeScript 4.3 it's the latest release."
          },
          {
            "time": "[00:05:38]",
            "text": "So I'm leaving this immortalizing this comment saying that, something might happen in the future, but today there are limitations. There is not a whole lot of support for stopping you from treating this like an array. So in this case, you can see that during assignment, we get the error messages we would hope to get."
          },
          {
            "time": "[00:06:04]",
            "text": "But in this case, you can see that we start with a two element tuple. We can push the third one in, we can pop them all out and TypeScript is not going to stop us from doing anything here. I can give you a hypothesis as to why TypeScript letting us do this."
          },
          {
            "time": "[00:06:22]",
            "text": "And it's because there is no type equivalence check on num pair that happens when we invoke methods on it. There's no concept in TypeScript yet of like, I'm calling this thing push. Therefore, the thing that I was invoking it on, like numb pair, it's type should change. There's no concept like that in the language yet."
          },
          {
            "time": "[00:06:49]",
            "text": "So you have to be aware that you only get that validation on assignment and you can still shoot yourself in the foot by messing with your tuple using push and pop. And Luis points out there's a proposal for real records and tuples and JS. That's, great. There are a lot of proposals for things in JS."
          },
          {
            "time": "[00:07:16]",
            "text": "So I wouldn't wanna represent that this is coming or even likely, until these proposals advance to like at least stage three. Seems like the kind of thing that might work though cuz it's to be reasonably performant. All right, and Niche has a question that I need to read for a moment."
          },
          {
            "time": "[00:07:38]",
            "text": "Okay, I'm just gonna sort of boil that question down and Niche asks a question about is the JavaScript community, and really it's like TC 39, the committee that decides what JavaScript is. Are they going to make JavaScript a statically typed language? I think it's extremely unlikely. I'm gonna say less than 1% chance, probably much less."
          },
          {
            "time": "[00:08:08]",
            "text": "And the reason is, this works pretty well, having sort of JavaScript be a compiled target. Now, what's more likely to happen is something around WebAssembly where you have other typed languages that compile out to WebAssembly bundle. And maybe that includes some runtime type checking. But remember this runtime type checking does not come for free."
          },
          {
            "time": "[00:08:37]",
            "text": "And we still have a lot of JavaScript to run in the world. So I do not expect types to be added to JavaScript directly. But that shouldn't get in your way because you can use this and treat JavaScript as a build target."
          }
        ]
      },
      {
        "name": "8-structural-vs-nominal-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we're gonna take a little bit of a step back here. So far we've talked about variables, simple function argument types, and return types. We've talked about objects, arrays, and tuples. And now I want us to step back and consider different kinds of type systems. And more specifically, how do we categorize different kinds of types systems?"
          },
          {
            "time": "[00:00:23]",
            "text": "Because we hear a lot of words to describe these things, right? Static, dynamic, duck typing, some people use this term strong types. What does it all mean? And what is the way to describe what we're seeing type scripts do? So first, we need to understand, what is type checking?"
          },
          {
            "time": "[00:00:43]",
            "text": "Type checking has to do with answering a question about type equivalence. As in, when we're using a foo, a function here, is the value we're passing in, equivalent to what the function is designed to accept? It's a comparison, right? Does this align with the constraints of where I'm trying to use this value?"
          },
          {
            "time": "[00:01:11]",
            "text": "That is type compatibility or type equivalence. That's the question that we're evaluating when we analyze this code, and think about whether we should have an error on this line here. This happens when you pass a value into a function. This happens when you assign things. So in this case, let's say x and y are both variables."
          },
          {
            "time": "[00:01:34]",
            "text": "And here we'd be wondering is the value that y holds type-equivalent to what x wants to hold? And if so, this assignment may proceed without objection. But if x wants a number and y hold the string, problem. Type equivalence checks happen on return types, especially when you have this explicit return type here."
          },
          {
            "time": "[00:02:00]",
            "text": "Is my strings an array of strings? That's what we said we would return. Are we returning it? Is the value I'm returning equivalent to the type this function says it's going to return? So this is the same question, it's just sort of asked in several places. You can check this footnote out if you wanna see another example that's weird."
          },
          {
            "time": "[00:02:27]",
            "text": "But this is most of what you wanna think about. So, with that question in mind, let's think about different kinds of type systems and how they answer this question. So the first way to categorize different types systems is static versus dynamic. Static type systems have you write types in your code."
          },
          {
            "time": "[00:02:54]",
            "text": "And that's TypeScript is one of these things, right? Java, c++, C sharp, any of these things are static type systems. It could be argued that Python with type hints also kind of fits into this category, but there's not much enforcement there. So it'd be a hard thing to defend."
          },
          {
            "time": "[00:03:16]",
            "text": "But TypeScript is definitely a static type system. Types are in your code and they're evaluated as part of the belt. Dynamic type systems perform their type equivalence check at runtime. So, this includes a bunch of languages here, where typically, you're just gonna see variable declarations that just say, I have a variable name and its value is Mike."
          },
          {
            "time": "[00:03:43]",
            "text": "And there are no types there, right? There's no support really for adding types in a formalized way. We can also think about type system as either nominal or structural. This is a weird one, because TypeScript is a structural type system. But just about every other thing you see in the programming language world, they are nominal type systems."
          },
          {
            "time": "[00:04:09]",
            "text": "So nominal type systems is all about a name. That's what nominal means. So here's a sample of Java code. And you can see here, similar to TypeScript, we have some properties, they are associated with some types. We have a class that contains these properties. And we have a function here, print car and it takes a car as an argument."
          },
          {
            "time": "[00:04:36]",
            "text": "The type equivalence check that is evaluated down here, it's really did myCar come out of a constructor called Car? Is your class named Car? That's a nominal type system. Everything is about what is the name of your class? And the reason that this wouldn't work so well in the JavaScript world is there's a whole lot of code out there that's not written with classes like this."
          },
          {
            "time": "[00:05:08]",
            "text": "We pass objects with properties around all the time. And if we had to convert everything to classes, that would be a very substantial change to our code bases that if required as part of migrating to TypeScript, it would just be a lot of extra work. So a nominal type system won't really fit existing JavaScript code, structural type systems just care about shape."
          },
          {
            "time": "[00:05:35]",
            "text": "So here we have similar other classes here, we can even have Car and Truck which kind of share some properties. We've got make model and year, they exist both on Car and Truck. And we've even got an object here, it's not an instance of a class, it has make, model, and year."
          },
          {
            "time": "[00:05:58]",
            "text": "Turns out, everything's gonna work with printCar. All printCar cares about here is do you have make, model, and year? It doesn't matter if you're an instance of a class, or you're just a regular object, or maybe you're some weird function with some properties hanging off of it. I mean, that's a class, right?"
          },
          {
            "time": "[00:06:19]",
            "text": "But [LAUGH] it'll work with any of them. All it cares about is look, I intend to reach into whatever you give me and I'm gonna use make, I'm gonna use a model, I'm gonna use year. I don't care about the other stuff going on around it, here's what I need."
          },
          {
            "time": "[00:06:38]",
            "text": "That's a structural type system. And these words here, Car and Truck, they're just around for our convenience. They're around so that we as code authors can make sense of what our code is doing. They play no role in any sort of type-equivalents checking. You could make something that might simulate what's happening in Java."
          },
          {
            "time": "[00:07:06]",
            "text": "You'd have to say give me a value that has a constructor property, which is a function that returns cars. Okay, you've defined the structure of something that is a factory of cars and that is the car class. Okay, you could do that but normal TypeScript code will not, right?"
          },
          {
            "time": "[00:07:31]",
            "text": "Normal TypeScript code, it's just do you have what I need? The properties and the types those properties can hold. If so, we're good to go. Duck typing. We hear about duck typing. I mean, people describe JavaScript as a duck typed programming language. And this gets its name from the duck test, which means if it looks like a duck, swims like a duck, quacks like a duck, it's probably a duck."
          },
          {
            "time": "[00:07:58]",
            "text": "And this is kind of another way of saying dynamic typing, where we kinda attempt to go ahead and use something, and if it works out, okay, and if it doesn't, we'll throw an error at runtime. That's how JavaScript works. You can think of it as having similarities to structural typing."
          },
          {
            "time": "[00:08:21]",
            "text": "In that, you just care about having what you need, right? You don't care about who created it. It's similar to structural typing in that way, but it's also dynamic typing, in that there is no type information at build time to evaluate. So all of these errors are popping up at runtime."
          },
          {
            "time": "[00:08:39]",
            "text": "Does that make sense? I mean, it might be a little bit of a stretch to say it's similar to structural typing. But what they do have in common is they have no concern for whether you came out of a class or whether you're an object literal. As long as you have what is needed in order to carry out the operation, we'll try to do that."
          },
          {
            "time": "[00:09:01]",
            "text": "But structural typing usually goes with static types as well, right, where you have that type information. Okay, finally, we have strong versus weak types. These terms don't really have good definitions. There's no such thing I'm aware of that's called strong typing. When people use the word strong typing, I think they usually mean, static types, types that are in your code."
          },
          {
            "time": "[00:09:27]",
            "text": "And when they say weak types, I think they mean dynamic types. But there is no consensus around a definition for any of these terms. So you won't hear me use strong types in this course, except right now? Static and dynamic, right, are the types in the code, or do we attempt to sort of YOLO it and figure out if things are gonna work at runtime?"
          }
        ]
      },
      {
        "name": "9-union-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're going to talk about today is union and intersection types. And these conceptually can be thought of as logical Boolean operators, and by that we mean, and, or. There are other operators that have no representation in typescript but we do have this concept of and, and or."
          },
          {
            "time": "[00:00:24]",
            "text": "So this is a hard concept for people to wrap their heads around sometimes. So we're just gonna use a very kind of explicit example here. Let's imagine that we have two sets of things. We have things that are fruits, and then we have things that are sour, and there is some overlap those fruits that are sour."
          },
          {
            "time": "[00:00:47]",
            "text": "So a union type, you can read up on the sort of set theory definition of what a union type is, if you wish, but you don't need to know that in order to be successful with that trip. You can think of a union type as OR, for types."
          },
          {
            "time": "[00:01:07]",
            "text": "And by union, we mean it could be something that is in either of the two circles, including the overlap between them. So if you think of a union like in terms of this logical Boolean operator, I'll show you go to the wiki page. Just to show you this one diagram here, right, it's everything."
          },
          {
            "time": "[00:01:30]",
            "text": "Everything that could be in either category. So that's the OR. Intersection types are only the intersection and that's the end, meaning, the only things that are allowed are things that are in the left side and the right side. That is an intersection type and, so in that case we would be only looking at, lemon, lime and grapefruit and that's because they are both fruits and sour."
          },
          {
            "time": "[00:02:05]",
            "text": "So let's look at how these two concepts are represented in the TypeScript programming language. Union types can be described using this pipe operator. For example, if we had a string, maybe it's like a property on some response object that a function returns and it could either be success literally that one string, or it could be the string error."
          },
          {
            "time": "[00:02:30]",
            "text": "So it's not just any string, it's one of these two specific strings. Here's another example. Let's flip a coin, do a math.random. If it's more than 0.5, let's call that heads otherwise we return tail, so it could be one of these two. And the outcome, you can see it's heads or tails, one or the other."
          },
          {
            "time": "[00:02:52]",
            "text": "And in this case, by the way, note that there's no possibility of it being both heads and tails at the same time. So a union type doesn't have to involve a potential overlapping area here. It could literally be a string or number and there is nothing that is both a string and a number at the same time."
          },
          {
            "time": "[00:03:15]",
            "text": "Sort of two separate circles, but a union type would represent anything that is in either circle, regardless of whether there's an overlap or not. So let's make this a bit more interesting using the tuples concept that we talked about earlier. And this is actually a common pattern that people like to use whenever there may be collecting errors and returning them instead of throwing an error and sort of interrupting the execution of the program."
          },
          {
            "time": "[00:03:44]",
            "text": "So let's say that we are trying to get some user information and that's what we're returning here, is a name and an email address. And we're wrapping that in a tuple, right? So the name and the email address, that's an object and we're storing that object in the second position of the tuple and the first position we're calling success, right?"
          },
          {
            "time": "[00:04:11]",
            "text": "See that string success to the extreme right of this tool tip. So that's like our success tuple, it starts with the word success, and then it gives us some data. And then in case of an error, we've got a string error and then an error object instead of throwing it, we're just gonna return it here."
          },
          {
            "time": "[00:04:27]",
            "text": "So what that lets us do, Is we have this thing, right? It could be either option, we can choose how to handle it and we will know what's in the second position of the tuple based on the string that we see in the first position. So we're gonna look at how we can deal with this value now, right?"
          },
          {
            "time": "[00:04:50]",
            "text": "It's either this, or it's that, or this piece here, one or the other. So here's how we might consume that value. First, I want you to see that if we look at either element of this tuple by itself, this union type concept has sort of propagated through each member of the tuple, right?"
          },
          {
            "time": "[00:05:21]",
            "text": "Our first element here, it's one of these two strings, and then our second element is either an error or this object. So each by themselves, they sort of have this duality until we straighten out what's going on. And I'm going to open this up in the TypeScript playground really quick, because part of the motivating use case here, we can get rid of this output here."
          },
          {
            "time": "[00:05:45]",
            "text": "But part of what's interesting is, why would we need to narrow things down? Why can't we handle this value directly? So if I look at this first thing, right, it's either error or success. And I have a lot of stuff on here that indicates that yeah, this is gonna be a string."
          },
          {
            "time": "[00:06:06]",
            "text": "It's one specific string or another specific string, but definitely a string. This second value down here is a bit more complicated, right? It's an error or this special object and it turns out that all we can access on this is name, why is that? Because error has a property called name, and this object has a property called name, and in both cases, they are strings."
          },
          {
            "time": "[00:06:31]",
            "text": "So all that we're able to access here is the guaranteed behavior, the guaranteed stuff that will be there, regardless of whether it's an error, or whether it's this object with a name and email property. We have a name in either case, but we're very limited in terms of what we can do as long as it's sort of in this state where we're not sure what it is."
          },
          {
            "time": "[00:06:54]",
            "text": "So to access email, for example, I'm not gonna be able to do that, why? Because email does not exist on type error, right? We have to arrive at a conclusion that this is not the error case in order to safely access email, and that motivates what we're about to talk about now."
          },
          {
            "time": "[00:07:14]",
            "text": "So here's the autocomplete we would get for the letter S, like clearly we access sub string behavior. Here we can only access name as we saw. And the bottom line is, when a value has a type that includes a union, we're only able to use this common behavior that's guaranteed to be there, no matter which circle we're in our Venn diagram or two separate circle in our case."
          },
          {
            "time": "[00:07:44]",
            "text": "So the way we address this is through a process called narrowing. And we've already seen this one, so we didn't give it a name but it's this process of using some condition with control flow. So we define a branch of code that will only be taken if we're in our success case and another that will only be taken if we're in our error case."
          },
          {
            "time": "[00:08:10]",
            "text": "And this will be done via this concept called type guards. So later in the course we're going to define our own type guards. These are called user defined type guards. And I like to think of these as where build time validation and runtime behavior meet. We saw one for example that was using type of."
          },
          {
            "time": "[00:08:36]",
            "text": "Here, remember when we were talking about our charging voltage. It was this optional property, it could be there it could not be there. So this is a type guard, it connects build time validation with runtime behavior in that, at runtime, we know that we will only enter this branch of code if charge voltage is defined."
          },
          {
            "time": "[00:08:58]",
            "text": "At build time, we can operate with the assumption that this is defined, right? So it it does serve as glue between these two worlds, runtime check that happens with a compile time narrowing down an increase in specificity of the type. So here in this case, is how we could make use of a type guard."
          },
          {
            "time": "[00:09:24]",
            "text": "So this same function, maybe get user info has two types of things that might return. And we can see that still each element of the tuple has this, maybe could be this, maybe could be that, which is kind of what a union type is all about. And we can narrow things down, we can use instance of, for example."
          },
          {
            "time": "[00:09:50]",
            "text": "So if second is an error, well, this branch of code will only enter it for the arrow case. And then in the else clause of this condition, we get everything that's leftover. After the if is handled, you can kinda think of it like slicing up a pie, where there are two things that this could be."
          },
          {
            "time": "[00:10:12]",
            "text": "And will handle the portion of possible futures where this is an error, and then all that's left is everything that's not error and that's what ends up happening in the else clause, right? So there's still a benefit to being in this else thing. So that's great, it's even better though."
          },
          {
            "time": "[00:10:31]",
            "text": "And this narrowing up here, this would work with just the return object. It's either an error or it's this object, but we can talk about how this tuple gives us some benefit via this concept called discriminated unions. And what this is telling us here, well, let's first look at what we're dealing with."
          },
          {
            "time": "[00:10:53]",
            "text": "We're looking at the first element of the tuple, we're seeing if it exactly matches our specific string. And then look, in this case, the entire tuple is in the error case, right? That's the string error and then the error object and then down here we have our success tuple."
          },
          {
            "time": "[00:11:13]",
            "text": "So TypeScript behind the scenes, clearly understands that if this string is found in the first position of the tuple, we know what's going to be in the second position. It understands that these are not two shifting values either of which could be one or the other, there's one scenario, and then there's another scenario."
          },
          {
            "time": "[00:11:35]",
            "text": "We could never end up with this object here accompanied by the error string. It's clear that TypeScript understands that because our check is on the first part of the tuple and what we're seeing as a benefit is the whole tuple is either in one category or the other."
          },
          {
            "time": "[00:11:51]",
            "text": "This is what's called a discriminated union. And what makes it a discriminated union is we have a convenient key of some sort to use in combination with the type guard that lets us in a broader sense switch between many different possibilities. And this could be a property on an object, or it could be a value in a tuple but usually it's gonna be something where you can have a type guard that looks like this where you can handle one of a number of cases."
          },
          {
            "time": "[00:12:22]",
            "text": "If there were 57 different possible tuples we could return as long as each had a specific key like this. A specific string as the zeroeth element. You could make a nice case switch that would handle each one of those cases, and TypeScript would cooperate with you. And you'd get that nice well formed whole tuple with both the sort of label for it and that second position which is where the deeper information is."
          },
          {
            "time": "[00:12:54]",
            "text": "Another word for this by the way, just in case you see it in the wild, it's a tagged union type, and the tag is error or success. It's whatever that word is, which is the indicator of what should be found in the other position."
          }
        ]
      },
      {
        "name": "10-intersection-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Great, so those are union types. Let's talk about intersection types, and as we get into intersection types, I should be clear that you're going to find union types far more often. And I want you to think about why that might be, well, we'll leave that as a mystery for now."
          },
          {
            "time": "[00:00:17]",
            "text": "Intersection types are substantially more rare. And conceptually, what an intersection type is, just to remind you, it is an END operator. And this is where in terms of the values allowed, if we go back up to the top here, we're talking about only the overlap between these two sets of things."
          },
          {
            "time": "[00:00:43]",
            "text": "Let's use an example here, and let's imagine a case where we wanted an instrumented promise. And by that I mean a promise that sort of measures the time at which an async operation began, and then a time at which things finished. Maybe you want to print this to the console or fire some sort of tracking event, so you can understand how your code's performing."
          },
          {
            "time": "[00:01:10]",
            "text": "In any case, it could look something like this. Well, sorry, I described a use case here and actually changed my mind and made it a similar use case. Let me describe what this use case does. Just cuz the promised one turned out to be tricky, this is something I've actually used it for to be clear, this is something I can make a concise example around."
          },
          {
            "time": "[00:01:34]",
            "text": "So, what we're doing here is we have a date, and we want basically date to have a new property on it that's called end. Now we're not changing all dates by reopening the prototype and tacking on a new function, we just want a date with extras, a date with some extra stuff on it."
          },
          {
            "time": "[00:01:55]",
            "text": "So this is what this could look like. So we've got makeWeek, and it'll use today as the start date, it'll add a week to today's date in order to establish the end. And I'm using this spread operator to basically get everything that's on date, or everything that's on start, rather, and then tack on the other day at the end of the week to the end."
          },
          {
            "time": "[00:02:23]",
            "text": "The type I get back is everything that you know and love about date, and in addition to that, an end property where you can find another date. I'm just gonna open this in the playground. So we've got all of this stuff, the regular date API, and there's the end, and there's the other date."
          },
          {
            "time": "[00:02:46]",
            "text": "So it's sort of like mashing these two things together, right? That's what this end operator does. It's almost like a merging together of two types. This being one and this being the other."
          },
          {
            "time": "[00:02:46]",
            "text": ">> Doesn't this look more like a union than an intersection? Because when you say, this way it doesn't have all the properties of the data option."
          },
          {
            "time": "[00:03:11]",
            "text": ">> So if you look at the behavior that's available to you, it like feels like the labels for these types are kind of reversed, right? But if you think about these in terms of the values that you're allowed to have, that's where this makes sense. So let's go back up to our diagram at the top, let's say that we have a set of a bunch of different values here."
          },
          {
            "time": "[00:03:41]",
            "text": "On the left, instead of fruit, we have all things that are dates. And on the right, we have all things that have an end property whose value is a date. The only thing that we're happy with here, the only thing that matches our type with that intersection type operator, the end, it would be things that meet both categories."
          },
          {
            "time": "[00:04:06]",
            "text": "So, depending on how you look at it, you could see at one of two ways. If you're thinking about this in terms of the the set theory, meaning, I have a variable of this type, what values is it allowed to hold? Then it's this slice in the middle, it's the intersection."
          },
          {
            "time": "[00:04:24]",
            "text": "But if you're thinking about it in terms of the resultant object, what can I do with it? Well, that's where you see everything. If we changed our mental model to like, on the left, we've got things that can be done on date, and on the right we've got things that can be done on this object with an end property, now we can do everything, right?"
          },
          {
            "time": "[00:04:46]",
            "text": "It's the whole thing. That is not what this kind of type derives its name from. It's not about what you can do with it, it's about what types of values may it hold. But I feel your pain in that, I get these things mixed up a lot, because it's tempting to think of it in terms of what may be done on this thing."
          },
          {
            "time": "[00:05:14]",
            "text": "But where they get their names has to do with which set of values are allowable to be type equivalent to this thing. Does that make sense? It's really tricky, I used to teach this and say, look, I want you to push intersection and union those words, push them out the door and just remember end and or."
          },
          {
            "time": "[00:05:35]",
            "text": "Cuz we know we've got the two symbols, they match up with the way we use them in JavaScript conditionals, that level of understanding will take you a long way. But in terms of the way we think about these sets, it's really mostly about what can this value hold, and it's only the things that are both."
          },
          {
            "time": "[00:05:54]",
            "text": "And as a result, you get everything that's available on either type, right? Hopefully, that makes sense, I'm always looking for better ways to explain this to folks. But it's a common dissonance that people experience when they learn TypeScript. All right, so I am stating, I'm postulating that there's a 50 to 1 ratio or more of when you'll see there we go, I'm searching them already."
          },
          {
            "time": "[00:06:34]",
            "text": "A 50 to 1 ratio, when you'll see the or types versus the end types. And as you think about why this might be, consider control flow. So, we can have functions that branch, right? You have a condition and in one case you do one thing and the other case you do another thing."
          },
          {
            "time": "[00:06:56]",
            "text": "The return type of the function ends up being path A or path B. So a lot of these or types originate from things that look kind of like this. Right? As a result, we get this or, this will happen a lot in your code. Branching is something that happens a lot."
          },
          {
            "time": "[00:07:27]",
            "text": "Control flow happens a lot, it's a very, very common phenomenon. This sort of merging of two things together, much less common, so that's why you're gonna see this or thing far more often. It's because control flow results in many possibilities, depending on what the inputs are, and thus you get the or, or union type out."
          },
          {
            "time": "[00:07:59]",
            "text": "And that's it, that's the end and the or. The devil's in the details here, and when used in conjunction with other things gets more complicated, but you can just think of it as end and or. With that, it's about time for us to talk about interfaces and type aliases."
          }
        ]
      },
      {
        "name": "11-type-aliases",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Interfaces and Type Aliases are a way you can give a friendly name to your types. Remember, we're still operating within a structural type system here. So the fact that you call your interface, car, or fruit or whatever it is, that's for you, and other people that contribute to your code base, it's just a friendly name."
          },
          {
            "time": "[00:00:25]",
            "text": "In many cases, you're going to be able to be free to choose whether you wish to use an interface, or a type alias. So we're first gonna talk about type aliases because they're the easier of the two concepts. Then we'll talk about interfaces. In particular, we're going to talk a little bit about how they work with classes and how they work with inheritance."
          },
          {
            "time": "[00:00:48]",
            "text": "We'll talk about what it means to say, interfaces are open in TypeScript. And then finally, I'm gonna give you a little guide about what are the cases where I do have an opinion about which one you use, and finally, defining recursive types. After this, we're gonna do our first collaborative exercise and build types that describe any valid JSON value."
          },
          {
            "time": "[00:01:17]",
            "text": "We're gonna write some code until the tests pass. So let's get to it. Type aliases. So, we've dealt with types that look like this, be they a piece of user information or a car. Colon and then a bunch of stuff. And you can imagine I'm sure you don't have to imagine too hard that as we add a third, fourth, fifth, sixth property to this, it starts to get very, very cumbersome."
          },
          {
            "time": "[00:01:45]",
            "text": "You're gonna end up making a spelling error or if you wanna add one more thing to this, maybe you have to update seven different places, it's just gonna become a lot, right? So, Type aliases help with this. Three things they do for us. They allow us to give our type a more meaningful name, something that is semantic, right, where the name of the thing describes its purpose."
          },
          {
            "time": "[00:02:14]",
            "text": "We're going to be able to declare a type alias in a single place and imported and exported it just as if it were a value the same way we would import an export functions or constants or anything like that from other JavaScript modules. So we can centrally define at once and refer to it in a bunch of different places, which is great."
          },
          {
            "time": "[00:02:35]",
            "text": "That's gonna make our lives much easier as things get more complicated. So, this is the first multifile example I'm showing you. Please just trust that imports and exports work reasonably well. So this is like a hypothetical filename. Here's an export from the file name. And then you can see it's imported down here."
          },
          {
            "time": "[00:02:57]",
            "text": "And the type information does sort of flow through. Here you can see that instead of just to saying I have this type and using this for every variable, every function parameter I care about, we're saying, I'm gonna create an alias for this type. So I'm gonna use this type keyword."
          },
          {
            "time": "[00:03:17]",
            "text": "I'm gonna give my alias a name. And then we're gonna set it equal to some type information. And it's important to understand a couple things here. One, this is a very rare situation where we can see type information appearing on the right hand side of an assignment operator."
          },
          {
            "time": "[00:03:39]",
            "text": "Usually it's all on the left. Almost always it's all on the left, right? The second thing this declaration we're making, this user contact info. This will disappear as part of your build process. It'll just compile straight out. So it doesn't add any asset size or anything like that."
          },
          {
            "time": "[00:04:05]",
            "text": "Alright, so this is how it's defined and we can export it just as if it were, function or something else. So let's look at how we can use it. So we import it. And then we can use it in place of explicitly stating the type itself. And we could use this in a bunch of different functions in this file."
          },
          {
            "time": "[00:04:25]",
            "text": "So we're really just giving a Type a name. That's all in it. That's why they call it a type alias. And you can use a type alias for any type you wish to define, there are really no limitations beyond what TypeScript itself can do. I'm just simply making the point here that we don't need things to be labelled with this specific type, we're just describing a structure here, right?"
          },
          {
            "time": "[00:04:50]",
            "text": "User contact info, anything that has the right properties will make this happy. So here's an example of something that it does have this access property. We're storing it as a variable, so it's fine, but it's totally fine to use it even though the variable doesn't explicitly have user contact info as its type."
          },
          {
            "time": "[00:05:10]",
            "text": "All that matters is the structure lines up So, we already talked a bit about this declaration syntax. Type information on the right side of the equal sign. The convention is to use title case for names of type aliases and interfaces for that matter. And Just like variables, you can only have one type alias of a given name in a given scope."
          },
          {
            "time": "[00:05:43]",
            "text": "Seems weird for me to say that but that limitation does not exist for interfaces. So this would break for type aliases, but it would not break for interfaces. So we're gonna look at how a type alias can clean up some code that we've seen before. And in this case, we're back to our coin flip where we return an error sometimes, a success case in time."
          },
          {
            "time": "[00:06:17]",
            "text": "A success case if the coin lands the right way, we're gonna look at how this code can get cleaned up. And remember, this implementation is gonna be the same in both cases. So we're really gonna focus on this function signature. This is how we could clean it up with type aliases."
          },
          {
            "time": "[00:06:38]",
            "text": "So we could say here is the tuple for our error case. Here's the tupple for our success case, and then below here, we can define the third alias that describes the union type, right, the or between the two. By the way, this pipe here, this extra pipe, that's just auto code formatting, doing its thing."
          },
          {
            "time": "[00:07:04]",
            "text": "It is not harmful, but it does. It's also not necessary. Doesn't make things a little bit more readable because you can sort of just go, follow the line straight down. Look how much nicer this return type is compared to this whole thing. It's just a little bit more easy to read."
          },
          {
            "time": "[00:07:29]",
            "text": "All right, let's talk about, I'm calling it inheritance, it's pseudo inheritance, right? But how would we take an existing type alias and create something that sort of builds on top of it? So in this case, it's very similar to what we saw with when we were studying this and the intersection type."
          },
          {
            "time": "[00:07:52]",
            "text": "Special date has everything date has. Analytics effectively extends although we're not using an extends keyword, but we're accomplishing something equivalent, right? We're saying date is a type. And I'm gonna take everything that it's giving me. And on top of that, I'm doing some other stuff. So this is a good use case of this."
          },
          {
            "time": "[00:08:13]",
            "text": "This intersection type operator, not truly inheritance but has the exact same outcome."
          }
        ]
      },
      {
        "name": "12-interfaces",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What about interfaces? So interfaces are more limited than type aliases, in that they can only be used to define what we call object types. And object types are things that are conceivably look kinda like a class instance are an object with properties. Important to realize that union type operators anything like this, make something not an object type."
          },
          {
            "time": "[00:00:31]",
            "text": "That's a little bit more complicated than an object type, right? Because it's like, it has these two possibilities, it could be one or the other, and interface cannot describe that. It could describe what's being used within something that uses one of these operators for sure, but not this whole thing."
          },
          {
            "time": "[00:00:52]",
            "text": "You could not describe that with an interface, so it is more limited. Just like type aliases you can import and export interfaces from modules, just like type aliases, they completely compile away and disappear as part of your build process. Inheritance has a lot more formality around it with interfaces."
          },
          {
            "time": "[00:01:14]",
            "text": "So TypeScript calls, keywords like extends, and we're gonna talk about another one in a moment. Implements, calls these things heritage clauses, and that they are used to describe ancestry in an object oriented hierarchy of some sort. Extends is used to describe inheritance between like things. Implements is used to describe inheritance between unlike things."
          },
          {
            "time": "[00:01:46]",
            "text": "So we can see that classes can extend from classes, right? We've seen this in JavaScript. Interfaces can extend from other interfaces. But when working with classes and interfaces, that's when you're gonna wanna use this implements keyword. And what you're saying here is I have this interface, and it describes the properties."
          },
          {
            "time": "[00:02:14]",
            "text": "And potentially the methods, like this is the way you would type a method, right? I'm gonna eat some food. We'll talk about void a little bit later just for now it's doesn't return anything. So we'll eat some food. When you say Dog implements AnimalLike, what you're saying is, Make sure that my Dog class does everything that an animal like interface requires."
          },
          {
            "time": "[00:02:44]",
            "text": "Every instance of dog should make AnimalLike as an interface happy, right? And we're missing this eat method. So this is a good way, interfaces are a great way to define contracts between things. And to say maybe I have these five or six different classes, maybe they all have some support for logging or for, I don't know."
          },
          {
            "time": "[00:03:13]",
            "text": "Some common like cross-cutting thing that your code base needs, it could define an interface, you could use that interface for many classes. And you're assured that TypeScript will make sure each of these has what it needs. So we can see that the error we saw above goes away as soon as we add the method."
          },
          {
            "time": "[00:03:31]",
            "text": "So now our class is complete, it implements everything that AnimalLike demands. Now, if you've ever worked with a programming language that supports true multiple inheritance, you'll understand that it's probably a good thing that JavaScript doesn't allow us to do this. By that we mean subclasses that have multiple base classes that may mix with each other in funny ways."
          },
          {
            "time": "[00:04:00]",
            "text": "Multiple inheritance makes things wildly complicated. This is a way to have multiple facades. To have a class that aligns with multiple contracts. I'm calling these contracts, right? It's a commitment to do everything the interface says you must do. You can implement many interfaces. So here we've got a class called LivingOrganism, we've got AnimalLike we've got CanBark."
          },
          {
            "time": "[00:04:28]",
            "text": "So these are both interfaces here. And we can see that the dog can have a base class. And it can implement as many interfaces as it wants down here. No problem, no problem at all. So it is possible. And I'll pop this out in the in the playground here so I can play with it a little bit."
          },
          {
            "time": "[00:04:50]",
            "text": "It is totally possible if you had a type alias that looked like this, You can extend or you can implement, [LAUGH] right? A type alias, we're seeing that right here. However, you're kinda asking for trouble here. Because as soon as this type alias becomes more complicated, the compiler is going to object."
          },
          {
            "time": "[00:05:16]",
            "text": "So I prefer to exclusively use interfaces with this implement keyword, because the rules that interfaces demand that you align with guarantee that they will work nicely with classes. Imagine a case where you're using this type in a bunch of different places. Sometimes with the class, sometimes to define the argument of a function, you may find it useful to add something like this but your object oriented inheritance is not gonna work there."
          },
          {
            "time": "[00:05:52]",
            "text": "Basically if we had this here, it would kind of imply that your constructor for dog, like I'm gonna run new dog and I might get a number back, that's weird. It was theoretically possible in JavaScript with like proxies or some other exotic stuff. It's not what you want, [LAUGH] it's not what you almost certainly trying to do."
          },
          {
            "time": "[00:06:18]",
            "text": "So yeah, you could use a type alias here as long as it's not something like this, right? It would have to just be an object type. So I recommend, just use interfaces with implements. All right, interfaces are open. You may have heard about this. You may have read about this."
          },
          {
            "time": "[00:06:36]",
            "text": "What does it mean? It means that unlike with type aliases, we can have multiple declarations here, right? Where we've got interface AnimalLike, interface AnimalLike. We have a twice in a file. If this were a class or a variable or function, something like that, we would be screamed at saying, look, you already defined this thing, I already have something by this name."
          },
          {
            "time": "[00:06:59]",
            "text": "You can't do that again. You can't write on top of it or whatever, whatever you're trying to do, you can't do it. Well, with interfaces, you absolutely can. And what effectively is happening here is up here we're saying we have one method it's called isAlive and down here, we're augmenting the interface."
          },
          {
            "time": "[00:07:20]",
            "text": "We're basically saying, look, there exists this AnimalLike thing add on top of it, an eat method. And note that the fact that we're doing this down here, It's a pervasive change that's happening. It doesn't matter that we're doing it lower down in the code, the eat method is clearly available right here."
          },
          {
            "time": "[00:07:42]",
            "text": "In fact this would have ramifications throughout your project. If you had this in one file your eat method, as a result of this would pop up everywhere. This is not a localized thing. This is a holistic across your app change potentially. Anywhere that you're using this AnimalLike type, you would see this change."
          },
          {
            "time": "[00:08:07]",
            "text": "You would see this eat method. Why is this useful? Why would I care about this? Where and how is this useful? I've highlighted it for you because it's probably a burning question. Well, sometimes we pin things on the globals, right? Like we add stuff to the window object."
          },
          {
            "time": "[00:08:27]",
            "text": "Maybe there's some emerging thing that will soon be available in JavaScript and you wanna code as if it's their promise that finally might be an example of this. It was only recently standardized, right? So you may have to tack some things on to an interface that already exists."
          },
          {
            "time": "[00:08:47]",
            "text": "And you can see that we're able to do that here. So window, this is like the window that's available in your web browser, right? Window.document, you're used to running this, right? So by just having this little piece of code here, we're augmenting window, we're changing it, such that, We've got all of this stuff on here, right?"
          },
          {
            "time": "[00:09:13]",
            "text": "But we've also got our example property, so we're sort of tacking something on. You'll find little things like this. You may think of like, globals are bad, right? We don't wanna do this, but you'll find that you're consuming some library. The type information is incomplete, you just wanna tack this one thing on, this is a way to do it, this is a good way to do it."
          },
          {
            "time": "[00:09:38]",
            "text": "Augmenting an interface. Because they're open, you can always add to them. So which one to use and when? Most of the time to be honest, it's completely up to you. There are fewer and fewer advantages as time goes on to fewer and fewer places where one makes any more sense than the other."
          },
          {
            "time": "[00:10:03]",
            "text": "However, A couple clear, Choices to make in some scenarios. Number one, if you're using anything that does not align with this idea of an object type, right? Where if you're using this union type operator, you must use a type alias, you cannot use an interface. Number two, this is my recommendation not a hard constraint."
          },
          {
            "time": "[00:10:32]",
            "text": "But if you want to use something that it's designed for a class to consume, like class dog implements, can eat food, or something like that. I would advise strongly that you use interfaces for that because you will by making that decision never find yourself in a place where the type you're creating becomes incompatible with object-oriented inheritance."
          },
          {
            "time": "[00:10:58]",
            "text": "Number three, if you deliberately want consumers of your types to augment your types, you must use an interface. Cases like this will become more clear in the intermediate TypeScript course. But there are situations where, A user of your code might sort of inject stuff into your interfaces so they can describe the code that they've written, which may be interacts with a library that you've written."
          },
          {
            "time": "[00:11:32]",
            "text": "But interfaces because they are open and type aliases are not, interfaces are the tool for this job. Finally, let's talk about recursive types. So by recursive types, I just simply mean types that are self referential. So if we look at this, let's pretend we just want nested arrays of numbers."
          },
          {
            "time": "[00:11:53]",
            "text": "How would we describe the type for this? Well, you could do it as follows. We could say, nested numbers is either a number or an array of nested numbers. So recently this is a TypeScript 3.7 feature. Type aliases started to support this. You used to have to use a combination of interfaces and types in order to accomplish this, but now, this becomes a lot easier to write."
          },
          {
            "time": "[00:12:22]",
            "text": "You're just saying it's a number or an array of myself. And as a result, we can do something like this. And you can see that .push is validated as it should, because it wants numbers or arrays of numbers, or recursive arrays of numbers. Thomas asks the question, kinda going back to interfaces here."
          },
          {
            "time": "[00:12:47]",
            "text": "Does augmentation of interfaces persist across files? Yes, type checking should be a holistic operation that's performed on your entire app at once. So, there is no such thing as local augmentation of an interface. It's a whole set of constraints for all of your code as it all fits together, including your dependencies."
          },
          {
            "time": "[00:13:13]",
            "text": "And that's type checking is all of that at once."
          }
        ]
      },
      {
        "name": "13-json-types-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we're going to begin a collaborative exercise. And what I would like to see us do here is, write some types using interfaces or type aliases, and then what makes sense to you. But we want these types to describe any valid JSON value. And I have for your convenience brought a portion of the JSON specification, and so we wanna make types that describe what we're seeing on the screen here."
          },
          {
            "time": "[00:00:36]",
            "text": "So a value can be an object, an array, a number, a string, false, true or null. So you can I mean, I've taken these words right out of the spec document, but we can take false and true that's Boolean, right? So it's numbers, strings, Booleans, No, and then arrays and objects that include those things, but we couldn't have a function for example, functions don't belong in JSON."
          },
          {
            "time": "[00:01:04]",
            "text": "Make sense to everybody. If you've worked with JSON before, I'm almost certain. So, this is your starting point code, and what you have here are some positive test cases, all these should pass the TypeScript should be happy with these and then negative test cases. So these should fail and the errors you're seeing here are because they're not currently failing."
          },
          {
            "time": "[00:01:29]",
            "text": "This Ts expect error this special comment, this tells the compiler that it should yell at us, if it doesn't find an error here. So the fact that they're not failing, because right now we're saying, look these things are anything right? So it's happy with a function when it shouldn't be, that's why we call these negative test cases."
          },
          {
            "time": "[00:01:53]",
            "text": "We got to suppress the errors we're seeing here by making it so that this does not type check. So how are you going to attempt this exercise, and we can work on it as a class together for sure. But I'd like you to have a local copy of this and play with it so that you can sort of poke around and help us get to an answer."
          },
          {
            "time": "[00:02:20]",
            "text": "Just hit this try button and we can see the same errors right here in the TypeScript Playground. So, basically, your job Is to make it so that these three types become the right thing that describes JSON. So here's how I want you to think about this, and I'll go one step further and I'll say it's important for this task that we're looking at right now."
          },
          {
            "time": "[00:02:51]",
            "text": "So, the way TypeScript parses this file, it's a Java's functions, it'll go down and it'll say, JSON object noted for that. Let's keep scanning down and let's keep looking. Look, there's a JSON array, there's a type like that. All right, well, I know where to go if I need to know about that, and it keeps going down and keeps going down and it sort of finds the fact that all these things exist."
          },
          {
            "time": "[00:03:22]",
            "text": "And then later on, it goes back and it starts looking at the right hand side of the equals. So as a result, there's no, it's almost like there's a hoisting effect here in that as long as you're on the right hand side of the assignment operator here. You have access to any type alias that exists in scope, and that by the way is also how the recursion works, right?"
          },
          {
            "time": "[00:03:47]",
            "text": "A lot of implementations of Recursive structures like these, they have to do with sort of scanning through and separating, declaring that something exists from how it's implemented. That's a common way to address circular referencing cuz the core problem there is, well, how can we know what it is when it's referring to things that haven't been defined yet."
          },
          {
            "time": "[00:04:12]",
            "text": "But if you do it in two pieces, so, you're good to go. Okay, let's get started here. So, I really like failure driven development. I like to have a bunch of errors and I can sort of SWAT at them and make them go away piece by piece. And right now, we're in this situation where we're just like way, way, way too flexible."
          },
          {
            "time": "[00:04:37]",
            "text": "We're letting anything pass through, that's why our positive test cases are all passing and our negative test cases are largely failing with the exception of this big int thing, which apparently is fine. Apparently that it's already failing, interesting, so cool. Let's just tighten things up a little bit more and let's start from sort of the narrowest, the most specific constrained side of things, and then add things until we get all of our cases passing."
          },
          {
            "time": "[00:05:16]",
            "text": "So for now, I'm gonna define a new type here. We'll call it a primitive, and let's just say for now it's a string. So JSON values, they can be strings, they can be numbers, or Boleans, or No. So here we're making good use of our union type operator, string or a number or Boolean or No, those are valid JSON values."
          },
          {
            "time": "[00:05:54]",
            "text": "And down here we can see our negative test cases about they are happy because without this comment, this is failing type check. So with the comment it's now happy, but we're missing our array case and our object case. And certainly the nesting aspect we won't even know until we address these two, I don't think we have much hope of addressing nested raise, object, strings, and numbers."
          },
          {
            "time": "[00:06:27]",
            "text": "That's sort of the most mixed of our cases. And I'm just gonna say so we have an object and an array, I'm gonna say that primitive or an object or an array. Cool, now we're back to failing, why are we back to failing? Can someone guess, when we have this code here, why did all of our negative test cases light up?"
          },
          {
            "time": "[00:06:56]",
            "text": "So function, somehow functions happy now, anyone have a guess, in chat or on Zoom, what if I did this? Like we're back to Eddie, somehow we're back to Eddie. Yes, Joshua. And Teresa, very good, both of you. So what we've done is we've performed, we've used this union type operator with an any."
          },
          {
            "time": "[00:07:29]",
            "text": "And I want you to think about it kind of like multiplying by zero in that, we were fine here when we just had it as a string or a number or a Boolean or no. But as soon as we do this, it becomes an any because it's almost like zero times anything is zero."
          },
          {
            "time": "[00:07:49]",
            "text": "Well, whatever type you like, or any, is any sort of just eclipses all of the other type information that you have there. Very good Joshua and Teresa, so okay, well we'll have to solve that, how would I type this JSON array? Like anyone have any ideas? No peeking at the answer, I know it's on the website but don't ruin my fun."
          },
          {
            "time": "[00:08:24]",
            "text": "Conceptually, what is an array in JSON? What kind of values does it contain, okay. Bala's got number, number or string, Teresa, you've got another good one. So we couldn't do this, we could try to exhaustively do this but remember we've also got arrays of arrays like a JSON array of JSON arrays, that could be objects in my array."
          },
          {
            "time": "[00:08:54]",
            "text": "So really, I wanna just say, look, a JSON array is an array of JSON values. There are many ways to implement this, this is just the way I'm choosing to do it, so JSON oops. It's an array of JSON values, and now if I were to take this JSON object thing out, cuz that's still an any at this point, look, our array case got happy, so that's great."
          },
          {
            "time": "[00:09:28]",
            "text": "Even if we nested this, even if this became a string it's still happy. So really we just need to describe these objects somehow, how would we describe an object like a JSON dictionary maybe. Anyone have ideas?"
          },
          {
            "time": "[00:09:28]",
            "text": ">> Index signatures."
          },
          {
            "time": "[00:09:28]",
            "text": ">> Index signature, very good. So that looks like this."
          },
          {
            "time": "[00:09:59]",
            "text": "And then we can bring it back into the fold, and there we are positive cases happy negative cases happy. So I saw some other things in the chat. I'm not gonna call any names cuz I don't wanna I like that people are collaborating, even if the answers aren't quite there, if we had this so this was one of the answers I saw in chat."
          },
          {
            "time": "[00:10:24]",
            "text": "What are we saying here? What's the difference between this and that. This is a tuple of length one that contains a JSON value, it's always gonna be one long, which means this case here would fail, but this case here would pass. So we wanna make sure that we use this double box, square bracket notation right double square bracket to say this is an array of arbitrary like not a tuple."
          },
          {
            "time": "[00:11:07]",
            "text": "But there we go, and this is definitely a recursive type because an array is expressed in terms of values and values expressed in terms of arrays. It's looping and looping all over, but it's fine because remember all the compiler does is it goes through and it says noted these things exist types of the following names."
          },
          {
            "time": "[00:11:29]",
            "text": "And then it sort of has a placeholder for those in memory and then on the right it says, okay, well, I have a placeholder for this, I don't know what It is yet, but okay, whatever JSON value is you'll have one here. And then it kinda goes through and sorts things out."
          },
          {
            "time": "[00:11:47]",
            "text": "But there you go, this would be suitable if you use the fetch API and you have a wait fetch that JSON something this, right? Maybe you could say, instead of returning any promise, maybe the value that comes out of this promise is a JSON value doesn't contain functions, only JSON."
          },
          {
            "time": "[00:12:19]",
            "text": "All right, if you want to look at the solution it's down here behind the spoiler warning. So if you wanna look at it later and poke at it, maybe on your own time if you like try different implementations. See if you can make this work with interfaces or a combination of the two, this is a really useful thing, everyone needs types for JSON."
          },
          {
            "time": "[00:12:43]",
            "text": "But maybe one day it'll be part of what TypeScript ships part of the standard stuff that comes with it."
          }
        ]
      },
      {
        "name": "14-functions-function-overloads",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's time for us to dive a little bit more deeply into functions and there were a couple of these early topics we needed to tackle first. The union intersection operators for sure and these named types, right? Like interfaces, type aliases, so now we're ready for this and we already talked about argument types and return types."
          },
          {
            "time": "[00:00:24]",
            "text": "Now we're gonna go deeper, so we're gonna talk about defining Callable types, by that I mean, interfaces that describe functions. Interfaces are type aliases rather, that describes something that can be invoked, or something that can be constructed using the new keyword. We're gonna talk about function overloads and I won't even attempt to give you a sneak preview of what that is because it's, if you've never seen it before, it's kind of a wild concept."
          },
          {
            "time": "[00:00:58]",
            "text": "We'll talk about typing this, If your function has a special need for making sure that whenever it's invoked, it's, this scope is a specific thing. And then finally I think we covered this a little bit, but we'll touch one more time on function return types, and best practices, so let's jump in."
          },
          {
            "time": "[00:01:24]",
            "text": "Type aliases and interfaces, they both provide some capacity for defining a call signature. So this is an interface we're used to seeing instead of this thing that I've highlighted, we're used to seeing a bunch of different property names, right? Instead we have parentheses and within them what appears to be an argument list, and then a colon, and then a return type."
          },
          {
            "time": "[00:01:48]",
            "text": "So, this is a callable thing, in a type aliases form, this is what it would look like and note that we're using a fat arrow here kind of like an arrow function, whereas up here we're using a colon. These are totally equivalent, these top two and we can see here, we benefit when we do something like this to define functions stored on variables, we benefit from having defined these call signatures."
          },
          {
            "time": "[00:02:21]",
            "text": "We don't need to have type annotations on function arguments. Usually you always need to, well that's not gonna use usually an always in same sentence, but with regular function declarations, you must include argument types because there's no way to infer them. In this case, all of the type information you need is on the left side of the assignment operator."
          },
          {
            "time": "[00:02:47]",
            "text": "So we know this is a number, we know this is a number and we know we should be returning a number, you don't need to state that information again. This is great for things like callbacks, right? Where it just saves you from having to add more and more type annotations."
          },
          {
            "time": "[00:03:04]",
            "text": "Sometimes we don't return anything from functions and so, scream in the chat or on zoom. What is the function return if we have no return statement in JavaScript, like if we capture the return value and try to use it, what is it? Is it 42? Undefined, great, it's undefined, so functions if they don't return, what we get when we attempt to use their return value is undefined."
          },
          {
            "time": "[00:03:31]",
            "text": "Well, JavaScript has a way of, sorry, TypeScript has a way of describing this and it's with a void return type and this means specifically that the return type of this function should not be used, it should be ignored. So we could type these functions as undefined, right? So, here's our callback, we have this is a higher order function to run some function in four seconds and here's the thing to run, right?"
          },
          {
            "time": "[00:04:02]",
            "text": "It returns undefined and then here's another one invoke in five seconds, and its return type is void. So, note that this little arrow function here, it happens to return something, why? Because, although we hardly ever use it Array.push actually returns a number that I mean, I don't even know what this number represents."
          },
          {
            "time": "[00:04:32]",
            "text": "We think of it almost like an entirely state modifying method that doesn't really return something useful, it happens to return something. So, the void case is quite happy with this, the undefined cases not, so there's a difference between saying the return value of this function should be ignored."
          },
          {
            "time": "[00:04:56]",
            "text": "Versus, I promise I will always return undefined, a void callback here you're fun, returning whatever you like, you will be encouraged to not use that value within the body of this function. But it's fine if you happen to return something, whereas in this case up here, you may not return something versus here it's like do what you like."
          },
          {
            "time": "[00:05:22]",
            "text": "Void is happy with whatever because we're not going to use it, right? So, that's the difference and important difference between void and undefined, void should only appear as a function return type. You should not be using it anywhere else because what it means is the return value of this function should be Ignored and left unused."
          },
          {
            "time": "[00:05:44]",
            "text": "Let's talk about construct signatures for a moment, this is another area that is sort of rare, cuz oftentimes we just define classes which kind of have this sort of functionality built in. But we have the ability to do this, so here's an example of a Date constructor, and it looks just like a call signature, except we've added this new keyword in front of it, that's it."
          },
          {
            "time": "[00:06:10]",
            "text": "So now, if I were to create something that I'm calling, my Date constructor, set it equal to the date, class itself, not a new instance of date. Now you see the TypeScript perfectly happy to let me instantiate, you probably won't come across this very often, but if you see it, I want you to know what you're looking at."
          },
          {
            "time": "[00:06:29]",
            "text": "This, you should come across function overloads, so, because this is a Kind of abstract concept, I wanna motivate the existence of this thing, function overloads with a potential use case. So, let's imagine a situation where we wanted to create a function that allows us to register what we're calling a main event listener where that means, the primary event of whatever DOM element we appear to be referring to."
          },
          {
            "time": "[00:07:03]",
            "text": "So, in the i frame case, if we're past an i frame, I want us to be setting up a post message callback, like we're communicating with the i frame, right? That's the main event you care about for an i frame, if you don't believe me, let's pretend that it is and then form would probably want submit, right?"
          },
          {
            "time": "[00:07:26]",
            "text": "That's a big, meaningful event that's associated with the form, so we could give it a shot by creating two types that represent sort of our event listeners, one that receives form data, one that receives a message event and this is for the i frame. And we could say, all right, so my first element here my first arg it's one of these two types of elements, it's either the form or the i frame and then here we've got the handler for the form or the i frame, right?"
          },
          {
            "time": "[00:08:01]",
            "text": "We certainly can handle both cases and I can get the zeroeth i frame on the page and I can try to handle this event. So here's the i frame, something's already looking a little bit off here, right? Because we're not getting any type hint, we're just getting an any, so that's not good, we're allowing a lot of possibilities here."
          },
          {
            "time": "[00:08:28]",
            "text": "Basically, we don't have any sense of saying the first argument passed to the function has any effect on which second argument we should accept. So, to put this more concisely, what we want, is when we get a form to strictly be dealing with submit, and when we get an i frame to strictly be dealing with post message, not a combination of the two, that might not make any sense."
          },
          {
            "time": "[00:09:01]",
            "text": "So, function overloads help us solve this, and effectively what we're doing here is we're saying I have one implementation in my function, but I wanna define types for two specific entry points. One that does the form stuff with the right element and the right handler, and one that does the i frame stuff with the right element and the right handler."
          },
          {
            "time": "[00:09:29]",
            "text": "This ensures that I have two specific prescribed ways of doing things and I'm not left with all of the flexibility that I really don't want to handle such as this in combination with that, that would be sort of like crossing our wires. So, we can see here if we get our frame and get a form, this case works for handling the frame, we can see we have type information here, there's our message event and then in the form case, this works as well."
          },
          {
            "time": "[00:10:07]",
            "text": "Let me show you what a failing case look like, basically, like let me show you what we can't do anymore, and that would be something like this. Actually a better way to Illustrate this is just to show you what the autocompletes look like. So, normally we just get autocompletes like this and when we open this up we would just see like, here's what you should type, but, look, we got one of two and two of two, we kind of have two options."
          },
          {
            "time": "[00:10:36]",
            "text": "For what we can do here, the form way, or the i frame way and note that we don't actually, we're not offered the arguments that are described on lines 14 and 15 of this piece of code. No one's showing us In a union type, right? Not for option one, not for option two, right?"
          },
          {
            "time": "[00:11:02]",
            "text": "It's one or the other, we have two choices for the function, we're not allowed to mix. And what we're seeing here is that we can see this, we can see this, this here is effectively hidden, that's part of what is allowing us to do this. It basically means that this is sort of what's invoked behind the scenes, we can make this whatever it needs to be in order to handle all of the cases we care about."
          },
          {
            "time": "[00:11:29]",
            "text": "But we can have very specific entry points that allow us to avoid handling these combinations of things that we have no intent of allowing. So, we would call these two heads of the function and then this often is referred to as an implementation of the function and this is the only thing that has the braces, right?"
          },
          {
            "time": "[00:11:51]",
            "text": "So, an important thing to think about as you consider using function overloads, is that the implementation has to be compatible with the heads. So, the problem I've created here is I think I just deleted the first argument for this middle bit here and basically what the implementation is the error message that we're getting is that there's just no way for all of these to line up."
          },
          {
            "time": "[00:12:23]",
            "text": "They kind of need to be specific case one, specific case two for the heads, and then an implementation that's general enough to handle anything that might come in. But in this case it's sort of broken, right? Meaning, we're only accepting one element here, it's, we need something else, if we were to, for example, just say look, I'm gonna take another argument, And we need to see the fact that, we have this type here, we need to allow for a possibility that an i frame element might come through."
          },
          {
            "time": "[00:13:01]",
            "text": "So, this almost, it has to be general enough that it could type check against any combination of the head above it. So, these are almost like specific cases that live within the type described by this hidden piece. It's a really powerful tool that lets you have greater opportunities for code reuse, because you can have something that is very carefully designed with specific entry points, while having some very general shared logic that backs all of those function signatures."
          }
        ]
      },
      {
        "name": "15-this-types-best-practices",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, when we talk about this types, what we mean is the type of this within a function when it's invoked. And this has the most relevance when talking about freestanding functions because methods on classes, they kind of already have this wired up in a convenient way. Here is example of what we might care about this, so a button or a DOM element of any kind."
          },
          {
            "time": "[00:00:28]",
            "text": "If we wire up a handler, like a click handler of some sort, when the buttons clicked, this function will be invoked and this within the function will be whichever DOM element emitted the event. So, if we tried to operate on that, we would kinda be busted on it because what we're being told here is look, I don't know that you wired up my click handler to a Dom element."
          },
          {
            "time": "[00:01:00]",
            "text": "Like you could be using it that way or a different way, but you can't start consuming this, unless you tell me what it should be, so I can help you stay on the tracks, right? And use it responsibly, so in this case, we happen to be fine, because we have no opinion about this, right?"
          },
          {
            "time": "[00:01:25]",
            "text": "We can directly invoke it takes the argument as it should, but it's the use of this that's kind of causing an error message to pop up. So what we need to do is define what's called a this type and it's sort of just an argument that's passed behind the scenes, which makes sense to me because that's kind of, when you think about how function apply, function call works, right?"
          },
          {
            "time": "[00:01:52]",
            "text": "We pass this along with the arguments there, it's part of the information that goes to the function when we want to invoke it, so it kind of makes sense that it's included alongside the arguments. And now we can see that we're fine and, in fact, that's the type of this it's an HTML button element."
          },
          {
            "time": "[00:02:13]",
            "text": "And down here now we're busted on that, because the only safe way of invoking this click handler It would be either using function call like that, or creating a bound version of the function. And if we look at this bound handler, it may not show it on the tooltip, no, it does show it on the tooltip, so now notice that my click handler has this HTML button element."
          },
          {
            "time": "[00:02:42]",
            "text": "While the act of binding this, it means that we're creating a new function that doesn't care about which this, is being used because we're baking the right context into that function that bind returns. So it makes sense that this bound handler, you can just pass it in an event, because it's already got the right this."
          },
          {
            "time": "[00:03:08]",
            "text": "If anyone here have seen this pattern before, where you're doing function bind, to hook things up to DOM elements, maybe in a react component, right? This is kind of a common way of like you pull methods off of your class and you say this dot action equals this dot action dot bind, so there you go, this is the kind of thing we're talking about here."
          },
          {
            "time": "[00:03:37]",
            "text": "And bind call and apply, at least for modern versions of TypeScript, should work very very nicely with the concept we just talked about. So, let's end our section on functions by talking about best practices, I already asked you to explicitly define return types. So, here's an example of a piece of code, where if we made what appears to be an innocent change, so you see here we're fetching some data and then if the promise resolves, we'd like to log it to the console."
          },
          {
            "time": "[00:04:12]",
            "text": "What if over here, when we decode the body of our response, we start to only do that for successful responses only, right? We add a guard around it. Errors would start to pop up, where we consume the result that the promise resolves to, right? You start to see these errors where they break as opposed to where you need to fix it, right?"
          },
          {
            "time": "[00:04:44]",
            "text": "This is the change, right? Get data now has the possibility of returning undefined, you can see it right in the tooltip or promise that resolves to undefined. I'd like my errors to pop up closer to where I must fix them, we did talk about that a little bit."
          },
          {
            "time": "[00:05:04]",
            "text": "And so, this is what you would see if we had this explicit return type and this error right on the function, and it's really clear how we can address it."
          }
        ]
      },
      {
        "name": "16-classes-access-modifier-keywords",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> TypeScript takes the JavaScript concept of a class and layers, some really useful stuff on top of it. We're going to talk about access modifier keywords, private, public protected. We're gonna talk about private fields. And then I'm going to show you how properties work, which is a shorthand that will come in, t's very useful because without it, TypeScript classes can get really verbose as you define class fields that sorta originate from constructor arguments."
          },
          {
            "time": "[00:00:38]",
            "text": "So let's talk about class fields for a moment. In the JavaScript world, you've probably seen code like this where we take in arguments to the constructor, and we kinda tack them on to each instance of the class. Part of what we get as a result of this is like, the instance of the class isn't a well defined type, meaning we don't know necessarily what's on it."
          },
          {
            "time": "[00:01:04]",
            "text": "We're very used to knowing upfront, like what's gonna be here, these are the things that I can expect on this interface. And that's not true if we can write arbitrary logic in the constructor and just start tacking things on. As a result, if we look at the way TypeScript analysing this, we can see that yes, it knows that this is an instance of a car, but it's not gonna provide us any kinda type safety around which methods we can invoke."
          },
          {
            "time": "[00:01:30]",
            "text": "And furthermore, all the arguments, the constructor arguments end up being any as well. So we need to add type information to this situation and get into a world that's providing us with that useful feedback we have seen so far in the course, where the wrong types of arguments will start to present error messages."
          },
          {
            "time": "[00:01:50]",
            "text": "So this is what the equivalent code would look like in the TypeScript world. And I want you to notice a few things. First, we state the possible class fields and their types up front. Second, obviously, just like a function call signature, we have types for all the arguments passed to the constructor."
          },
          {
            "time": "[00:02:15]",
            "text": "And then this code remains unaltered, where we sorta take everything the constructor received and we can now safely tack it onto the interface, or sorry, on to the instance of the class. We are now rightly stopped when we try to invoke a method that doesn't exist. And we're rightly stopped when we attempt to, like pass arguments to the constructor in the wrong order or just otherwise fail to meet the demands of what this wants to receive."
          },
          {
            "time": "[00:02:45]",
            "text": "On top of this,TypeScript adds access modifier keywords. And here what I'm saying is, I just want to acknowledge this code is getting very verbose. Like the word make is here, here, here and here. So it's like four times for each property. We're working our way up towards a simpler way to write this."
          },
          {
            "time": "[00:03:07]",
            "text": "We need to talk about access modifier keywords first. So access modifier keywords, you can find these in Java and C#, they all mean the same thing broadly across a wide range of programming languages. Public means everyone can see something. Protected means a class can see something and also subclasses can see it and then private means they're only visible to the class itself."
          },
          {
            "time": "[00:03:37]",
            "text": "And when I talk about something can be seen, I mean class fields or methods. So we use these words to indicate the visibility of class fields and methods. So, here you could see, all right, we're exposing these class fields to the outside world. Maybe we have a VinNumber that the car class can see and any subclass of the car can also see."
          },
          {
            "time": "[00:04:02]",
            "text": "But maybe there's this door lock code that we can unlock all the doors of the car. We wanna keep that private to the car, not even subclasses can see that. So I want you to see a couple things here. First, this pattern, right? So, doorLockCode is private. But you can certainly provide, you can sorta open up access to subclasses by defining a method or sometimes people define like a getter and a setter property, it's not just about keeping things hidden so that people don't peek at these values."
          },
          {
            "time": "[00:04:42]",
            "text": "I mean, if you're running your app in a browser, you can't keep secrets there coz you're sending all your code to your user. But you can control the pathways that people will take in order to get certain things done. So if you wanted to unlock all the doors and use your door lock code in a specific way and not expose that directly, you could do that."
          },
          {
            "time": "[00:05:06]",
            "text": "And you could say this is a private thing, but I allow it to be used in some form through protected method. Let's look at a subclass here. So sedan extends car, sit in can see a VIN number just fine. That's protected. It cannot see this door lock code because it's private and it's only accessible within the class car."
          },
          {
            "time": "[00:05:36]",
            "text": "And here, we're kinda applying the same pattern again. So we have a public function that's called unlock, which calls this protected method unlock all doors. So you see we can use this way to control visibility into what's available on instances of this class as a mechanism of providing a nice surface for people to interact with, where they're not able to get a directly modify state."
          },
          {
            "time": "[00:06:08]",
            "text": "And this might lead us if we have a different locking mechanism on this car, we can now safely change that up here, right? Nobody can possibly see this. So we can feel confident that if we change it, we're not going to break anybody, as long as this method still does what it's supposed to do."
          },
          {
            "time": "[00:06:28]",
            "text": "So it's a great encapsulation tool. A lot easier than just sorta overloading your constructor and using that scope as private, which is another common pattern. And obviously, from the outside of this class, so here Here's our sidin class. This is the ending brace of our class declaration. And here we're creating a sedan, we can see this public thing, but we can't see this protected thing, and we can't see this private thing, right?"
          },
          {
            "time": "[00:07:06]",
            "text": "So it's saying this is protected, and it's only accessible within the car and its subclasses So that's private, public and protected. And this limited exposure concept is really what I just described. The ability to take something that is hidden and provide controlled access to it. Through, you know something that is more visible, like exposing a private thing through a protected method, something like that."
          },
          {
            "time": "[00:07:41]",
            "text": "Just a warning. JavaScript is least client side JavaScript things that run in browsers. Please don't use this as a mechanism for storing like auth tokens or encryption, keys, anything like that. This is really just about encapsulation, not not security right? And furthermore, these access modifier keywords they disappear as part of the build process."
          },
          {
            "time": "[00:08:14]",
            "text": "So anyone who puts like a debugger in your program, they'll be able to see all of your fields there. So it's not, this is again, just fancy linter. This is not really private at runtime. JavaScript recently got the concept of private class fields. You can recognize these because their name begins with the hashtag as of TypeScript 3.8."
          },
          {
            "time": "[00:08:37]",
            "text": "These work really nicely in TypeScript. This is private at runtime. They're a little more difficult to access. But again, I would not advise you to put encryption stuff here. There's one last thing that's kind of like an access modifier keyword. I say kind of because it can be used in combination with other keywords."
          },
          {
            "time": "[00:08:59]",
            "text": "It's called read only. And this will yell at you if you attempt to reassign. Values. It's not about mutability, it's about reassign ability. So think of it more like const and less like a frozen array of some sort. It's really about not pointing year to a new number in this case."
          },
          {
            "time": "[00:09:28]",
            "text": "Keep in mind, giving it an initial value in a constructor is totally fine. After it receives its initial value, that's when it starts monitoring, and watching, and making sure that you don't assign it to something else. Great, we've made it through access modifier keywords. Now let's talk about puram properties."
          },
          {
            "time": "[00:09:52]",
            "text": "The more concise way to write classes in a way that doesn't involve the word make 1234 times each property we have, that will become a class fields four times we have to write that word So this is the abbreviated, well, this is not the abbreviated syntax, but this is the before, and here's the after."
          },
          {
            "time": "[00:10:20]",
            "text": "Put them both on the screen at the same time. So it looks kinda strange, but the key thing is we have an access modifier keyword. Before our constructor arguments. And it means exactly the same thing. The code on the bottom is going to compile to exactly the same thing as the code on the top."
          },
          {
            "time": "[00:10:42]",
            "text": "I can prove it to you. Let's go to the TypeScript playground. Let's pop this out and look at the JavaScript that it creates So what's happening here is we're saying, I have a constructor argument, and I'm going to call make. I also have a class field of the same name."
          },
          {
            "time": "[00:11:06]",
            "text": "And in my constructor, please store what I received. In my class field puram properties to constructor parameter, and it becomes a class property. And this is the only time you'll see an access modifier keyword like this next to something other than a method or a class field So, the most important thing I can tell you, this is like a common snag people hit is we have to study what happens around constructor logic."
          },
          {
            "time": "[00:11:47]",
            "text": "Class field initialization, these puram properties, right? There's a lot of stuff that's sort of going on as we instantiate things. So I've created for us an interesting situation here. Where we have a class field with an initializer oops. And don't don't worry about console log like not returning anything."
          },
          {
            "time": "[00:12:14]",
            "text": "We just want to see when the console log happens. Right? We have a super call. We have one of these which sort of that involves an assignment to a class field. So understanding the order of operations here is really important. Right? When is this going to get invoked?"
          },
          {
            "time": "[00:12:34]",
            "text": "What happens before what? Well, when we compile it out, we can kind of see. And thankfully, I've written. Class field initializer here, custom constructor stuff. So we should hopefully be able to recognize this when we see it in the compiled code. So, let's look at this. So first what happens is super, then we have these puram properties, followed by class field initializers."
          },
          {
            "time": "[00:13:01]",
            "text": "And only then does our constructor code actually run. That's right here, right? This is the last thing to run. So that's the order of operations. Prim properties, other class fields, and then our custom constructor stuff. And before everything, the absolute first thing, Is the super call. When in doubt, write a small example pass it through the TypeScript playground."
          },
          {
            "time": "[00:13:30]",
            "text": "That's all I basically did here. So that you can see that this happens, right? So, when in doubt, make a small example and kick the tires. And although it's possible to put stuff before super. You can't combine it with these parameter properties, or class field initializers. Once you have those super must be the absolute first thing in your class or in your constructor So I can prove that to you."
          },
          {
            "time": "[00:14:10]",
            "text": "If I take this away, And that now we're fine. So it's it's these things this automatic constructor behavior that Makes it so that pre super logic is forbidden."
          }
        ]
      },
      {
        "name": "17-top-types-any-unknown",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're gonna discuss is honestly one of my favorite in TypeScript and it's this chapter and the next one. So we're gonna start with top and bottom types, which are types they can hold anything and types they can hold nothing. And then type guards and narrowing."
          },
          {
            "time": "[00:00:17]",
            "text": "So we saw a little bit about type guards already, like type of, instance of, but we're gonna learn how to write our own type guards. So the first thing I want us to talk a little bit about is thinking about types in terms of what is called set theory."
          },
          {
            "time": "[00:00:39]",
            "text": "And this might sound a little bit scary cuz set theory gets very complicated. But I just want you to think of it from the simple idea that we can think about types as defining a set of values that a variable or a function argument might be. So if we were to say that x is of type boolean, what we're really saying is, you may select anything from the following set of values, true or false."
          },
          {
            "time": "[00:01:16]",
            "text": "It can be one of those two things and the set describes all allowed things that x could be. That's as far as we need to go with set theory. So let's think about y being a number. So we could use what's called set builder notation. Hopefully, this is human readable enough."
          },
          {
            "time": "[00:01:39]",
            "text": "But we could say there exists a thing y such that y is any number. And if we imagine the same kind of concept is dealing with a boolean, which only has two possibilities, y you could think of as having a similar set. But within that set is any number that's allowable in the world of JavaScript."
          },
          {
            "time": "[00:02:04]",
            "text": "So just a couple more examples to sort of hit this point home. Here is a union type that could be one of three specific numbers. So there's the set of things that it could be. Null, actually is its own type, at least with strict null checks turned on, which you should make sure that remains turned on."
          },
          {
            "time": "[00:02:29]",
            "text": "But that's one thing that that could be. And here's an optional variable or an optional property on some object type that could be exactly the string pineapple or it could be undefined. Hopefully making sense so far. So type just describes a set of things that you could find in the variable that type describes."
          },
          {
            "time": "[00:02:56]",
            "text": "Great, so let's talk about top types. Top types are types to describe anything and we've already seen one of these, any. So the set of things that any could be it's any value allowable in JavaScript. It could be a function, a number, a string, a big int, a symbol, null could be absolutely anything, right, anything allowed in JavaScript."
          },
          {
            "time": "[00:03:32]",
            "text": "And that's what makes it a top type. It's the most general most flexible thing that exists in this type system. There's another top type called unknown. So we're gonna talk about any first and then we can go and look at unknown. Obviously, any is quite flexible. You can just think of it as playing by the same rules as regular JavaScript."
          },
          {
            "time": "[00:03:58]",
            "text": "Obviously, there are risks around using any. This is clearly at runtime going to be a number, but I'm reaching into it as if it's got many, many nested things and they're not going to be there. This will result in a runtime error. Now I got this question earlier, is it wrong to use any?"
          },
          {
            "time": "[00:04:18]",
            "text": "Is there any time where it's the appropriate thing to do? And my answer is yes, there are times when it's absolutely appropriate. A good example is console.log. If we look at the type of console.log, it has a rest parameter here. So it takes any number of arguments you like, each of which is an any."
          },
          {
            "time": "[00:04:41]",
            "text": "This is appropriate because console.log can log just about anything to the console. There's no reason to impose additional constraints here. Any describes accurately what you should be doing here. So it's the absolute right thing to use. This is not something that should be tightened up. This is correct."
          },
          {
            "time": "[00:05:00]",
            "text": "All right, let's look at unknown. Just as with any, you can see that I can put a number in it, a string, document, a function like set timeout, seems a lot like any. But here's the key difference. Unknown can't be used unless you narrow it, right? Unless you use a type guard with it to check it out, to make sure that it's acceptable for use."
          },
          {
            "time": "[00:05:33]",
            "text": "So it's almost like it comes with a warning label that says, you must verify that this is what you think it is before you go ahead and do something with it. So in this case, you can see, yeah, we can put any value into it that we like, but we can't reach in and start accessing it directly."
          },
          {
            "time": "[00:05:53]",
            "text": "We must do something like this. So you see my unknown, right at the time that we're checking it before we established that it could be a string, it's an unknown. And then down here, it's a string. So we're free to use it as a string. And then here's another condition where it's an unknown."
          },
          {
            "time": "[00:06:14]",
            "text": "But as soon as we make it into this code block, hey, it's a number, and we're free to use it as a number. So it's as flexible as any in terms of its ability to hold things, but it places an extra responsibility on whoever uses this value to kind of check it out first with the type guard."
          },
          {
            "time": "[00:06:33]",
            "text": "So those are the two top types. So practical uses for a top types. One key place where you will make heavy use of this is if you convert a project from JavaScript to TypeScript. I do not advise that you go straight from untyped or dynamically typed JavaScript code and then try in one big pass to convert everything perfectly, to have really strong, I just used the strong word to describe types, shouldn't do that."
          },
          {
            "time": "[00:07:09]",
            "text": "To make a very specific well articulated constraints with types and just try to convert the whole thing in one big code triage, that's dangerous, right? Your odds are you're gonna break something cuz it's just a lot of potential to change behavior while you're doing that. It's common to define some reasonable types where it's easy, where it makes sense, and to leave a lot of anys in there, and to sort of clean those up in successive passes as you sort of tighten things up, tighten things up."
          },
          {
            "time": "[00:07:42]",
            "text": "So any is really useful for sort of work in progress mid conversion states. And it's also useful where you frankly just don't have any idea what's going on. Like you have no compile time ability to verify things. An example would be you just received a fetch response and you decoded it from JSON."
          },
          {
            "time": "[00:08:06]",
            "text": "And you might think you know what it is based on the endpoint, but can you really be sure? What if that API goes down and it starts sending you error messages? You might wanna verify that. That might be a great use for unknown, values received at runtime from your data layer."
          },
          {
            "time": "[00:08:24]",
            "text": "This works really well with discriminated unions by the way. Remember where we had that tuple where there was the success and there was the error. So maybe you receive an API response and on every API response, there's a little key where if you see that property there, that's a strong signal that you know what the rest of the object looks like."
          },
          {
            "time": "[00:08:43]",
            "text": "So you can receive it as an unknown, check for the presence of the key. Okay, now we know what it is and you have a nice type for that thing. It's a great thing to use for data layers."
          }
        ]
      },
      {
        "name": "18-bottom-types-never",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, let's talk about the opposite of top types, a bottom type. Bottom types describe things that can hold no possible value. So you can think of it almost like you're free to choose anything within an empty set, that this variable will be happy to hold, right?"
          },
          {
            "time": "[00:00:25]",
            "text": "It's like anything you want, and you may pick it from this perfectly empty box, [LAUGH] that is never. Sounds like a really abstract concept, and if you're like me, if this is the first time you've heard about never, you're wondering what is the point of this thing? Is it here just because somebody loves math, and because they feel like they want some great symmetry in the universe?"
          },
          {
            "time": "[00:00:50]",
            "text": "Or is there something that I can actually do with this that is useful? And I'm pleased to tell you, it's the second one, there is something very useful you can do with it, and that thing is exhaustive conditionals. So let's look at this situation. We've got a class called car, a class called truck, and then a type called vehicle, which can be either car or truck."
          },
          {
            "time": "[00:01:18]",
            "text": "And let's say that we wanna do something with our vehicles. And we just have a vehicle, we don't know whether it's car or truck, in fact, behind the scenes I have something called obtain random vehicle, but just for now, say, it's one of the two. So, what we can do is say, okay, we got the type car here, we're gonna handle the truck case."
          },
          {
            "time": "[00:01:41]",
            "text": "Great, it's a truck we can call the tow method. If it's a vehicle, sorry, if the vehicle is a car, we can call drive, and that's something that's only available on the car, okay, like class. Apparently trucks can't drive, apparently, I don't have a truck. So, great, what's left?"
          },
          {
            "time": "[00:02:02]",
            "text": "What's left after we've eliminated the possibility that it's car, and we've eliminated the possibility that it's a truck? What else could this thing be? It's kind of a trick question, the answer is nothing. There's nothing else that could be, nothing, all that's left is never, there's nothing else that could be."
          },
          {
            "time": "[00:02:34]",
            "text": "We've taken care of 100% of the cases of things we know about, right? Like cars and trucks, and there's nothing else this could be. So the fact that we're saying this ends up as never, that's another way of saying we've handled all of the cases. We have an exhaustive conditional that handles every possibility of this vehicle being one of the things, right?"
          },
          {
            "time": "[00:03:04]",
            "text": "So, let's see what happens if someone comes along and adds boat. So what they've done is they've created a class boat, and they've added boat as one of the things of vehicle could now be, could now be a car, or a truck, or a boat. And I haven't touched the rest of the code."
          },
          {
            "time": "[00:03:28]",
            "text": "Look what happens here. We see, wait a minute, this vehicle, when it gets into this last else clause, there's something left over, it could be a boat, right? This isn't a never, there's not nothing left over after we handle car and truck, there's boat leftover, and we're alerted to this now."
          },
          {
            "time": "[00:03:52]",
            "text": "So, imagine a world where this stuff here, the car, the truck, the boat, the vehicle type, this might be defined in some other file, maybe in a project with 10,000 JavaScript files. Someone alters this, and now all of the conditions, all of the different places and the rest of the code base, where they're looking through, they wanna make sure they handle every case that this thing could possibly be."
          },
          {
            "time": "[00:04:18]",
            "text": "Now you see all of these nice errors light up, where you know you have to go in, and handle the boat case now. Either deliberately handle it or deliberately not handle it, but attention is needed, right? These are places if they have something down here that says, basically, like up here my vehicle had better be a never, right?"
          },
          {
            "time": "[00:04:43]",
            "text": "Or saying, I'm gonna create a variable of type never, and the only thing that can fit in never is never, it's the most specific, finicky type there is in TypeScript. It's only happy with other nevers. So, this is only gonna work if there's nothing left, and down here, there's boat left, and so this conditional is no longer exhaustive."
          },
          {
            "time": "[00:05:12]",
            "text": "The way I like to handle this is I create, and I have the same code, if you look for this code like my GitHub account, you probably see a couple dozen projects pop up. I should really just put it in the library so I can use it that way."
          },
          {
            "time": "[00:05:28]",
            "text": "But I use this unreachable error all the time, and it takes as an argument and never, and it has a message as its second argument. So, the purpose of taking a never as the first argument is, I wanna be able to pass something into it that will have a compile error unless it's a never, right?"
          },
          {
            "time": "[00:05:51]",
            "text": "So that's about creating a compile error at the right spot. The message is so that if for some reason, maybe have been lying in my types like cast something, something was an any, and it's like weekend my types in some way. If I ever reached this line and I ever actually throw this error in code that I didn't think I could ever reach."
          },
          {
            "time": "[00:06:14]",
            "text": "I get a very clear indication that something was really weird here, and my assumptions about being unable to reach this line of code, had been broken. And I have to take a close look at what actually is going on here. And the way I would do this, is I would say, instead of up here where we create a variable and we set my vehicle equal to something, down here in this last else block here, I would throw the error, right?"
          },
          {
            "time": "[00:06:44]",
            "text": "And in this case, I get a compile error because boat is leftover, and I'm alerted to it. So by kind of wrapping this in an error subclass, we know that one of three things will happen, depending on whether things break and how they break. So, first, we've written our types, well, everything is handled before we even reach that else clause, we never entered the else, right?"
          },
          {
            "time": "[00:07:16]",
            "text": "And everything's happy, so that's great. Another thing that could happen, we catch this code change at compile time, which is the example we're seeing in this error message here, right? Someone added boat, this piece of my code needs an update, I'm alerted to it, and I can give it some attention, that could happen, that's what we're seeing here."
          },
          {
            "time": "[00:07:41]",
            "text": "Finally, if somehow something slips through, I at least get a good error message and I at least know that I thought I could never reach this thing. And I get a description here, I mean, maybe be more descriptive than this, but I could say, I didn't even think this was a possible vehicle."
          },
          {
            "time": "[00:08:05]",
            "text": "Maybe you log out what this thing is, so that it becomes more actionable for you and you'd go back to this code and you'd say, where did boat come from? My types don't suggest that boats possible, how did we end up with a boat? And you would track that down."
          },
          {
            "time": "[00:08:20]",
            "text": "So, it's also important to remember this works really well with switch statements. And the only difference is you would throw your unreachable error in your default case clause, right? That's it, whatever it is, it's sort of the fall through. If any of your specific cases with type guards aren't met, this is the thing you thought could never happen, but if it does happen, you get a nice error message."
          },
          {
            "time": "[00:08:46]",
            "text": "Exhaustive conditionals, this is cool stuff and if some programming languages support a more formalized version of this, like rust, I believe, it demands that every conditional you create is exhaustive, right? You have to write in your no ops explicitly. So this gives you the ability if you choose to use this never concept in this way, you can do the same thing for your code."
          }
        ]
      },
      {
        "name": "19-type-guards-narrowing",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, we've talked about top types, bottom types. Let's talk a little bit about type guards, and narrowing. So we have already addressed a bunch of different kinds of built in type guards, right? So I've created a value here that could be it's not quite an any but it could be a bunch of different things."
          },
          {
            "time": "[00:00:20]",
            "text": "And we can see a bunch of different ways that we can narrow it down, get a branch of code that will execute only in a specific scenario. And then within that code block, we can treat it in a more useful way, right? Like, as it stands, there's not much you can do with value given that it's so varied like what it might be."
          },
          {
            "time": "[00:00:42]",
            "text": "So here we could say, okay, it might be a date, so we use instant serve as a type guard. Type of, right? That works just fine. Checking whether something's undefined or not, the type of is great for that. Checking against a specific value that's a perfectly fine type card to use."
          },
          {
            "time": "[00:01:00]",
            "text": "Truthy, falsy checks are fine. Just beware, of course, empty strings and zero and false are all false II values. So if you have something like it's Boolean or undefined, truthy, false, you might catch something you're not intending to catch, right? Some built in functions have type card capabilities like array.is array, right?"
          },
          {
            "time": "[00:01:25]",
            "text": "So we can see that value comes in could be a bunch of things. But within this block, it can only be a couple of length one that contains a number. Property presence check with this in keyword, right? That's saying is does there exist an owned property called date range, within value."
          },
          {
            "time": "[00:01:54]",
            "text": "And then of course, you can always like make a couple checks and then whatever's left over, that'll be what's left over. So that's sort of like a reverse type guard, right? Can carve away the parts that you don't want. And all that's left is what's left. So those are built in type guards."
          },
          {
            "time": "[00:02:12]",
            "text": "And I think this is an exhaustive list. But let's talk about user defined type guards because often, we want to operate on a much higher level than simply saying, is this a string? Is this a number? We more want to think about if you're building the front end masters website, you'd want to say is this a learning path or is this a course?"
          },
          {
            "time": "[00:02:35]",
            "text": "Or is this an instructor or is this a user account? And that's a lot more complicated. It's harder to think about how you might squeeze these kinds of things together to achieve that same level of creating a branch and knowing that it's this more complex object as you go down that path."
          },
          {
            "time": "[00:02:54]",
            "text": "So that's where user defined type guards come in handy. And here's an example of how ugly things could potentially get, right? So if we wanted to see, is maybe car doesn't look like a car. Well, in order to do this safely, given that it's an unknown, right, remember, we can't use this unknown until we narrow it down with a type card and check it out and make sure it's what we think it is."
          },
          {
            "time": "[00:03:22]",
            "text": "So you'd have to see okay, does it? Is it knowledge like Could it be null or undefined? Well, we eliminate that with this. And then Okay, does it have like is it an object of an object type? Does it have make model and year our make model and year strings numbers."
          },
          {
            "time": "[00:03:40]",
            "text": "Do you could do this. Let's say you were willing to do this, right? I would argue, you're already out of your mind if you want to write a bunch of code that looks like this. But let's pretend you're out of your mind. So, even if this did work, Eventually, you're gonna wanna refactor this."
          },
          {
            "time": "[00:03:59]",
            "text": "You're just gonna wanna take that same code that's sort of a bunch of different stuff in your conditional. You move it out into a function just so that your code can look like this, right? But the problem here is, even though these are all type guards, there's nothing about his car like there's nothing about this function that says, hey, TypeScript, you should regard the true or false value that this function returns."
          },
          {
            "time": "[00:04:29]",
            "text": "As an indication of what the type the argument is, right? Like, right now, even if we added type annotations here, right? Even if we said this returns a Boolean instead of an any there's nothing that tells TypeScript that something special about that Boolean that it has any bearing on what should be assumed about the argument we passed in."
          },
          {
            "time": "[00:04:56]",
            "text": "And so even the imperfect narrowing effect that we had when we had all this stuff up here, like at least we saw that it was an object, right? I mean, really, that just came from this here. But we don't even get that here. It's back to unknown. We're like back to square one."
          },
          {
            "time": "[00:05:14]",
            "text": "So user defined type guards are the solution to this problem. And the problem we're trying to solve is TypeScript has no idea that the return value of his car like has anything to do with what we passed into it. So here we go. We're going to make this a user defined type guard."
          },
          {
            "time": "[00:05:36]",
            "text": "And we're going to start by talking about an is type card. Value is foo, right? So we're going to see that syntax somewhere in a moment. So here we go. It's a function is car-like. It takes an argument. Typically, you're going to want this argument to be something very flexible."
          },
          {
            "time": "[00:05:56]",
            "text": "Why? Because you're going to reach into it. And you're going to check for the presence of things. You're probing, right? You're inspecting it, you can't assume that you know what it is yet, but you need it to be flexible enough to perform the validation, that makes sense. And then what makes this a type guard is the special way of writing its return type."
          },
          {
            "time": "[00:06:19]",
            "text": "So we can say effectively that like Yes, his car like it returns a Boolean. But that Boolean should be taken as an indication of whether value to test conforms to the type car like. And we can write our same implementation here. But look at this. Out here, it's unknown."
          },
          {
            "time": "[00:06:49]",
            "text": "And within this block, it conforms to the interface. And it's only because you're telling TypeScript to trust you. So, this is very important. This type guard can be your best friend or it can be your worst enemy. Because let's just completely do something crazy. What if we did this."
          },
          {
            "time": "[00:07:19]",
            "text": "Just anything you give me, I'm just gonna say it's always car like. Well, there it is, I'm not narrowing the value anymore if that's what's happening. So there's our -19. It'll be change this to x. Like apparently -19 is a car like, like I can access make model and year on this thing."
          },
          {
            "time": "[00:07:49]",
            "text": "No errors, None, no little red dots in my scroll bar here. So the type car is only as good as your alignment between the actual checking logic that you implement and the claim you make, about what that logic means means in terms of the type, of what's passed in."
          },
          {
            "time": "[00:08:16]",
            "text": "If your logic here is flawed, you're gonna run into big problems, because type scripts got to do exactly what you say. Right now I'm saying everything's carlike. And so -19 apparently has a property called year on it, TypeScript doing what I'm telling it to do. So just be really careful about these."
          },
          {
            "time": "[00:08:40]",
            "text": "These are again, I said this before I want to say one more time. These type guards are the glue between compile time validation and runtime behavior, you got to make sure that your compile time validation and your runtime behavior match up. And if they don't, you're gonna be lying to yourself here, right?"
          },
          {
            "time": "[00:09:01]",
            "text": "You're gonna be allowing yourself to comfortably reach in and pull things off and operate on values that should be erroring. Let's look at the other type of user defined type card. And it follows this format, asserts value is foo. So, here's what the return type looks like. I've changed this very slightly, right?"
          },
          {
            "time": "[00:09:25]",
            "text": "But that the return type is changed a little bit. The type guard itself if the check is the same check we were performing before, if it is found to not be car like we throw. So if you pass through this function and we haven't thrown your car like that's what we're saying here."
          },
          {
            "time": "[00:09:52]",
            "text": "If this function finishes without throwing, that means value to test his car like so effectively this function asserts that the value to test is car like. As a result, we can do something really cool here. We don't have to use a conditional because we're sort of using the return versus throw branching, well, I don't necessarily agree that that's control flow."
          },
          {
            "time": "[00:10:20]",
            "text": "It is definitely a true statement that will only reach this line down here if we pass through the function without throwing, right? But this is great for modeling, things that are in test suites or things that really are exceptional validation where if, like you don't even know how to proceed unless this is car like."
          },
          {
            "time": "[00:10:45]",
            "text": "So we want to get something more specific like we get we can't operate on this waltz and unknown and we legitimately do want an error to be thrown if this is some weird value. So in a might be the right thing to do here. But this is the other kind of type card that you can use."
          },
          {
            "time": "[00:11:02]",
            "text": "I commonly will use both where I would create something that's like is car-like and then I would consume this and kind of wrap it in something that'll throw it in error. So I get both of the funding is typed guard. And then I'll use that same little Boolean returning function in my asserts type guard."
          },
          {
            "time": "[00:11:29]",
            "text": "So here's a terrible example of type guard. And you can see like, well, I already showed you an even more terrible one. But here I'm assuming that all false things are no. Well, this will make you think zero is now an empty string is now like the false Boolean value is no, obviously, there are false things that are not no."
          },
          {
            "time": "[00:11:50]",
            "text": "But again, TypeScript will. It will follow your instructions, right? So in this case we have empty and we have zero. And we're here saying, if this value is no then log and unfortunately, we're just catching way, way, way too much with this type card. And we're never going to be able to get here, right?"
          },
          {
            "time": "[00:12:14]",
            "text": "It's claiming that It's impossible that we'll get here."
          }
        ]
      },
      {
        "name": "20-nullish-values",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're going to discuss is nullish values and the three specific kinds of values that I'm talking about are null, undefined and void. So we're gonna talk about each of those three when I advise you use each of them. And then we're going to discuss the non-null assertion operator where you cast away any possibility of something being undefined or null."
          },
          {
            "time": "[00:00:26]",
            "text": "And then the definite assignment operator which can be used in some interesting edge cases around class initialization, or instance initialization, so null. Null indicates that there is a value for something and that value is nothing. I wanna be clear that different people have different opinions about this, when to use null, when to use undefined."
          },
          {
            "time": "[00:00:55]",
            "text": "But this has served me well, so for example, if I receive a null return value from a function or I find null on a class field, I take that to mean it's almost a 404, right? Like a not found, nothing's there or nothing's there yet, well really just nothing's there, like something's arrived and that is nothing."
          },
          {
            "time": "[00:01:22]",
            "text": "Undefined, I take this to mean that either we haven't gotten to providing something or we're not ever going to provide you with something. So here's an example of a form, maybe we're like monitoring how long it takes for a user to complete this form. And completedAt is a property that is undefined because they haven't completed it yet."
          },
          {
            "time": "[00:01:50]",
            "text": "And when they complete it, we will get a value so I prefer to use undefined for cases like this. Void as we said before, this should be used explicitly for function returns and it means that the return value of the function should be ignored. If you wanna learn or refresh yourself more about how to use void, you can look at the functions chapter where we show the impact of using void versus an undefined return type on callback types."
          },
          {
            "time": "[00:02:25]",
            "text": "So that's null, undefined and void, so now let's talk about these two operators. First, there's a non-null assertion operator and you may think of this as kind of similar to optional chaining, if you've ever used that, this sort of dot, I think it's click. Yeah, it's like dot question mark, something like that, I don't use it very much, to be honest."
          },
          {
            "time": "[00:02:51]",
            "text": "But that sort of allows you to reach deeply into an object and if at any point in accessing a chain of property something is found to be undefined, it will sort of just give up, just evaluate out to undefined and just sort of skip it. Non-null assertion operator is sort of the last or the less forgiving variant of this."
          },
          {
            "time": "[00:03:15]",
            "text": "Here's an example, so let's say we have a grocery cart which can contain fruits and vegetables. We initialize it without either and we try to kind of reach into this and say like, okay, I hope fruits is there because I want to treat it like an array and push stuff into it, but this array might not be there."
          },
          {
            "time": "[00:03:38]",
            "text": "In fact, it's not there, because we initialize this to an empty object. We're correctly being busted, on trying to use something that might not be there. Well, if we use this non-null assertion operator, this exclamation mark right here, we're telling TypeScript to disregard. Got Glenn Marth, I think I actually might have a typo, I do have a typo, this is the typo."
          },
          {
            "time": "[00:04:08]",
            "text": "That's a good catch, so it should not be dot bang, it should be bang dot. [LAUGH] Yep, very good catch, thankfully, my code example works because it's actually running TypeScript behind the scenes and it compiled. So this is working in front of our eyes, but I'll make that correction, thank you."
          },
          {
            "time": "[00:04:28]",
            "text": "So we can see that the possibility of fruits being undefined has sort of been thrown out, we're just saying please disregard TypeScript. I know what I'm doing, I'm the software engineer here, just do what I tell you to do. And as a result, we can kind of proceed through, I use this a lot, but never in app or library code."
          },
          {
            "time": "[00:04:52]",
            "text": "I use it like crazy in test suites because I prefer test frameworks and assertion libraries to be clear that will regard a throw as a test failure. So if this is my test case, where I have nothing, I don't have a fruits array in my grocery cart, and this throws."
          },
          {
            "time": "[00:05:15]",
            "text": "That's a failed test and that I'll treat it as a failed test, it's almost like a little mini assertion I think this is beautiful in a test suite. I don't like it in app code because it's a pretty hard failure to hit and I would much rather use a type guard and set and check to see if this is undefined."
          },
          {
            "time": "[00:05:35]",
            "text": "And then let's reach into it, I think that is a more fault tolerant way of handling this kind of situation. Because this in almost every case like this is this could have a real possibility of being undefined. I don't even like the idea. If we were to do this, I don't even think that this is justified because you're like I slightly inattentive refactor away from moving this somewhere else where you might not have that guarantee."
          },
          {
            "time": "[00:06:15]",
            "text": "I prefer to have my guarantees by way of type cards that will actually do some runtime thing to evaluate whether something's there or not there. Compared to this, which is just saying force the type system to forget about the possibility of undefined. That's a dangerous copy paste away from creating problems for you."
          },
          {
            "time": "[00:06:38]",
            "text": "But great in test suites because throwing errors in test suites, when things turn out in an unexpected way. That's a test failure, that's great, that will tell you something's wrong, you can go and fix it. All right, definite assignment operator, it's the same exclamation mark syntax used in a different place and that place is on class fields."
          },
          {
            "time": "[00:07:06]",
            "text": "So here's an example of something, essentially a slightly relabeled piece of code that I have in production right now. And it's a class that has to do something asynchronous as part of its setup procedure. So constructors can't be async but they can kick off an async method as they finish."
          },
          {
            "time": "[00:07:31]",
            "text": "And so what I do here is when the constructor is invoked, I say I've got this setup promise and I kick that off. And I say, we begin in a non setup state and I'm going to, Chain in the promise returned by this method here, right? So that means that this setup promise will only resolve once this thing is done."
          },
          {
            "time": "[00:08:00]",
            "text": "And then when everything's done, I'll flip that, his set up flag and say, okay, we're now ready to go. So I'm getting an error here and I'm seeing that this property has no initializer which is true. And it is not definitely assigned in the constructor, what does definitely assigned mean?"
          },
          {
            "time": "[00:08:22]",
            "text": "It means that TypeScript wanted to see, it wanted to see something like this, which I guess I could have done. It has no idea if or when this is going to be invoked. And so it's not willing to, doesn't wanna give me a guarantee that this property, this class field will get its value."
          },
          {
            "time": "[00:08:47]",
            "text": "Now if something's directly in a constructor, TypeScript can understand that. It can analyze it and it can say, if we instantiate this thing and then we say, here's a thing with async setup. Well, by the time I give it to you, it will have a Boolean value there because I saw you set one on the constructor but down here, it's not so sure."
          },
          {
            "time": "[00:09:07]",
            "text": "Now, in this situation, I know something that TypeScript doesn't and that is that the callback you pass into a promise constructor, it is invoked synchronously. Which means that by the time we actually get that new promise, this thing that I've selected, that little callback, it's already been invoked and it's already finished."
          },
          {
            "time": "[00:09:31]",
            "text": "And I will definitely have my Boolean value there but TypeScript, It doesn't have a way of saying, well, this is a synchronous callback. And this is an async callback and I know about the runtime behavior here. It just has no way of describing that but in this case, this code, it's actually okay."
          },
          {
            "time": "[00:09:50]",
            "text": "So, We could add something here, I'll just have to show you in the example. All we'd have to do is add the exclamation mark. This right here, the definite assignment operator, it's saying, look, I will assume responsibility for making sure this thing gets its value. A great place to use this is component lifecycle hooks."
          },
          {
            "time": "[00:10:22]",
            "text": "So no matter what component library or framework you use, there's often like there's the constructor logic. And then there's some initialization process that happens later, maybe it's when the component's initially rendered or when it's about to render and maybe you take care of setting some stuff up there."
          },
          {
            "time": "[00:10:44]",
            "text": "So realistically, you're not doing much with this thing, Until it's set up, and maybe it's rendered. So you might say, I know yes, after your constructor runs, this thing is not gonna be there. But realistically, for all things I care about, we can act as if it'll be there, so that's the kind of time where you might wanna use this."
          }
        ]
      },
      {
        "name": "21-generics",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We have now reached the culmination of TypeScript fundamentals v3, and that is generics. So generics are a way of creating types that are expressed in terms of other types. And the benefit of doing this is it allows for a greater opportunity to reuse code across your app."
          },
          {
            "time": "[00:00:23]",
            "text": "And that'll become clear as we get deeper into this topic. Because this is an abstract concept, I want to begin by leading us up to why we should care about this? What's the scenario we can see where we're missing something from TypeScript? And that will help us understand why should we even care about this thing?"
          },
          {
            "time": "[00:00:46]",
            "text": "So let's go back to an example that we've used before in this course, and that is a dictionary, right? We have this dictionary called phones and under an arbitrary key, we can store a three part phone number. And we can see that all of these properties look very, very similar."
          },
          {
            "time": "[00:01:06]",
            "text": "So sometimes it's convenient to organize our data in dictionaries and sometimes it's convenient to organize data in arrays. So it would be nice if we had some sort of utility that let us transform data that was in one type of collection into the other. So let's deal with this as our starting point for our data."
          },
          {
            "time": "[00:01:29]",
            "text": "It's a object that has three parts for a phone number. It's kind of customerId now, so it's just a ten digit phone number. But we've got a customerId, areaCode, phone number, and we have a list of them. What we want in the end is something that looks like this, where effectively we have this key value data structure, a dictionary, where each member of what was in the array, it's stored under a particular key."
          },
          {
            "time": "[00:02:00]",
            "text": "In this case, it's the customerId. Now we're gonna start by implementing a very specific solution that works for exactly this use case. And then as a second step, we're gonna see if we can make it more generalized and kinda get a feel for where we're at at that point."
          },
          {
            "time": "[00:02:19]",
            "text": "So we wanna go from this to this. So we will need one thing along the way and that's the the mechanism for producing a key that we use for storage of each object on the dictionary. And in order to make sure that we're on our way to a generalized solution, we're going to want the color of this function to provide us with the mechanism of obtaining that key."
          },
          {
            "time": "[00:02:46]",
            "text": "So part of what we're gonna ask for here is a little callback function, sort of a higher order function approach to solving this problem. So our function signature could look like this, we've got this PhoneInfo type and then a function that we can use to transform a list of these PhoneInfo things to a dictionary of the PhoneInfo things."
          },
          {
            "time": "[00:03:16]",
            "text": "Here's that little id callback that I mentioned earlier, where in addition to being provided the list, we're also provided with this function that can be used given a PhoneInfo, obtain a string. And we will use that string as our key. This is throwing an error right now for obvious reasons like we're not returning anything."
          },
          {
            "time": "[00:03:40]",
            "text": "We said we'd return a dictionary, currently we're not returning anything at all, quite understandable. So implementing the function itself is not really the point of what we're talking about here, it is pretty simple. We can start by defining the dictionary and we'll start with it empty. We'll iterate through each member of the list will generate a key using the function that were provided."
          },
          {
            "time": "[00:04:07]",
            "text": "And then we'll use that key to store that member of the array in the dictionary and then ultimately at the end, we return the dictionary. So that's the whole algorithm, loop, find the key, shove it on the dictionary, and then return the dictionary at the end, not too bad."
          },
          {
            "time": "[00:04:28]",
            "text": "So we can actually run this in the TypeScript playground and convince ourselves that this works. So the way you do that is you go click on Logs. As in Console Logs, that's where this will show up, and then hit Run. So here we go, this is our input."
          },
          {
            "time": "[00:04:48]",
            "text": "And then down here is where we're doing the log and we're seeing each of these objects stored in the dictionary under a key. So we can see that it appears to work, great. So let's attempt to make this a little bit more general. And the approach we're gonna take is find every reference to this PhoneInfo type and let's replace it with the most general type that we have, an any."
          },
          {
            "time": "[00:05:17]",
            "text": "So we used to have an array of PhoneInfos here, so it's an array of any. Our idGen callback used to take a PhoneInfo as an argument, now it takes in any. And then we used to return a dictionary of PhoneInfos, but we return a dictionary of any's now."
          },
          {
            "time": "[00:05:36]",
            "text": "Nothing else in this function has changed, none of this has changed, it's all the same. So really it's just about the any's that appeared in the function signature. Now if we wanna try this out, we can, now I'm going to comment this last line out because it's really just to illustrate a point."
          },
          {
            "time": "[00:05:57]",
            "text": "But if we run this, go to Logs and Run, we can see that now we're able to use this on a different type of array, right? These are not PhoneInfo objects, these are just objects that have a name property. And I have my little callback that describes what am I using as my key?"
          },
          {
            "time": "[00:06:18]",
            "text": "How am I storing these on the dictionary? So we obviously get the correct result at runtime, but the problem is we've lost all of our useful type information. Everything that comes out is in any, so in making this more flexible, we've had to relax our types, so much, that we don't get any of that validation."
          },
          {
            "time": "[00:06:44]",
            "text": "That is basically the point of TypeScript, right? In relaxing this so that it can handle anything, we're back to JavaScript level type safety, which is not much. That's the problem, we need a mechanism of allowing flexibility without giving up all of our type information and generics provide the ability to do that."
          },
          {
            "time": "[00:07:19]",
            "text": "So the first thing we'll need to do is define a type parameter. You can think of type parameters as arguments for types. They're kind of function arguments, but there are four types. Just like functions can return different values given different arguments passed to them, type parameters can influence what generic types end up being."
          },
          {
            "time": "[00:07:45]",
            "text": "So we're gonna go ahead and do a couple things here. This is gonna be our new function signature, so there are some things that have been added here. And we're gonna talk about exactly what each of those pieces of syntax mean, just so we slow way down and we understand what's going on."
          },
          {
            "time": "[00:08:07]",
            "text": "So first, we have this angle bracket t thing to the right of the name of the function, right? It's this thing right here, so what is this, it is the type parameter list with one type parameter in it. You can think of it like the equivalent to the round parentheses for a function argument list."
          },
          {
            "time": "[00:08:32]",
            "text": "So if we had many type parameters here, it might be t,x,y, something like that. The convention is like a common convention you will see but it's not a limitation by any means. It's to use capital letters, often the letter T is used. And this you can trace that back to the use of a similar feature set in C++, where they would call these template classes."
          },
          {
            "time": "[00:09:03]",
            "text": "It's the same thing, you could remember T for type or T for template, so that's what this is, it basically says there exists a type parameter t. The second thing, right instead of receiving a list of PhoneInfos or an array of PhoneInfos, we're receiving a list of T's."
          },
          {
            "time": "[00:09:27]",
            "text": "So what's that all about? Well, what's going to happen is on a per invocation basis, you might end up with a different type T. So if we were passing this, a list of PhoneInfos, T would be PhoneInfo. If we were to pass it a list of strings, T would be string."
          },
          {
            "time": "[00:09:51]",
            "text": "So what we're gonna see is that every time we use this function, TypeScript's going to use the type of the array. This first thing that the function receives, it'll use that to figure out what T should be. So it's gonna infer what T is on a per usage basis depending on the array we pass in."
          },
          {
            "time": "[00:10:20]",
            "text": "This is a much simpler example that kind of boil things down to the absolute most small atom that we can talk about here. We could define a function here that takes an argument and just wraps it in an array, like it's a tupple of length 1. And whatever we give it, it's gonna return a Tupple of 1 with that thing in it, that's all it's doing."
          },
          {
            "time": "[00:10:52]",
            "text": "So let's look at the return types of this function. Up here you can see it's like wrapInArray<T>, right, arg is T, and it returns this. While we pass it a number, look, the T turned to a number. We received an argument of type number, we return a tupple with a number in it."
          },
          {
            "time": "[00:11:13]",
            "text": "Here's the date, here's the date, and here's the date. I could do a RegExp, we could do whatever we want. This type, it's almost like it's morphing to accommodate our needs depending on the argument we pass to it. So it's like auto detecting what T should be, and returning the right thing to us as a result."
          },
          {
            "time": "[00:11:38]",
            "text": "So let's go back to our example again, our listToDict example. So we talked about this type parameter list, right? Just saying T exists, we talked about how we're saying, I'm going to receive a list of arguments. I'm gonna receive an argument and it's defined in terms of T, that's gonna help TypeScript infer what we should get for T."
          },
          {
            "time": "[00:12:01]",
            "text": "So now we have this line here, that's our id generating callback and we're using T here as well. So this means a couple of things. First, that we're going to get the use of type checking within this callback. And the second is we're going to effectively ensure that the type of thing or callback is designed to work with is the same thing that the array has within it."
          },
          {
            "time": "[00:12:31]",
            "text": "So if we had something like this, here's our array, it's an array of dates, this arg is a date, we'd better be treating it as a date. We can't give it a function that's designed to generate ideas for anything else, its gotta be happy with working on dates."
          },
          {
            "time": "[00:12:59]",
            "text": "The last thing to look at is the return type. So we can see that here, it's just a dictionary of T's. And similar to how in our tiny, tiny example, right, we had a return type that looked like this. And we can see that the type of what comes out of the function changes depending on what we pass in."
          },
          {
            "time": "[00:13:23]",
            "text": "Similarly down here, we're gonna get a different kind of dictionary out. So let's put all of this together and take a look at our original example. So all we've done is we've brought the algorithm back in, it's a very simple little looping process here. And let's look at our tool tips as we attempt to use this."
          },
          {
            "time": "[00:13:47]",
            "text": "So here we're getting a dictionary out and we're passing in just objects with a name property. And look at the dictionary we get out, it's got an index signature, where each value that's found in the dictionary, it's just an object with a name. Let's look at a different example, here's our phoneList, right, a array of customer ids and phone numbers."
          },
          {
            "time": "[00:14:16]",
            "text": "Well, you can see that the type has sort of adapted here. It's inferred what T should be, and it's gonna return the right kind of dictionary. So now, unlike our example where we used any, and where we lost all type information as we pass through this function, we tried to make it flexible enough that it would work for any list to dictionary transformation."
          },
          {
            "time": "[00:14:45]",
            "text": "Unlike the any based approach, we're actually maintaining all of our type information. It kind of passes straight through. So we can run this in the TypeScript playground and we can convince ourselves that it works. So up here, this is our first dictionary, that is this right here and then down here this is our second dictionary."
          },
          {
            "time": "[00:15:14]",
            "text": "What we're doing here, I'm just gonna look back at the function signature here. What we're doing here is we're saying on a per invocation basis, we will figure out what T is and for that invocation T serves as a way of defining a relationship between things. Meaning, the dictionary I will give you is related to the list you gave me."
          },
          {
            "time": "[00:15:42]",
            "text": "The callback you'd better give me must be related in terms of type to what's in your list. It serves as sort of a linkage between all of these things and it allows us to remain flexible without basically widening our type and making it so general, so nonspecific that we lose our safety."
          }
        ]
      },
      {
        "name": "22-dictionary-map-filter-reduce",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this is a little exercise. And our motivation is as follows. So we have a dictionary here. It's a bunch of a bunch of fruits. They have a color, and they have a mass in grams. We have an interface, the type parameters can be used with interfaces here."
          },
          {
            "time": "[00:00:24]",
            "text": "You see I'm saying it's a dictionary of type T. Well, what can I find in this dictionary? A bunch of Ts, right? So you can use this however you like. So what we want to do is create array.map array.filter and array.reduce, but for dictionaries. And below this, I have a test suite similar to what we saw for the JSON types exercise."
          },
          {
            "time": "[00:00:54]",
            "text": "So I'll give you, I'll say, two minutes, just to read through this. And then I would like your help in implementing this. But just look through the test cases so you can try to understand where we're going with this. So at the bottom of the starter code, of course, we have the usual Try button, when we click that, we should find ourselves on the TypeScript playground."
          },
          {
            "time": "[00:01:27]",
            "text": "And I would like you to click this Logs tab, and we can run the code. And right now, nothing is gonna be able to run cuz we haven't really defined these functions. But once we have something a bit more reasonable as our starting point, we should start to see some good feedback there."
          },
          {
            "time": "[00:01:47]",
            "text": "So, really, around these lines here, this is what we want to change. We don't wanna modify anything above or below this point, just these three functions here. And the way these are defined, they're the absolute most generalized functions that we could possibly have. Meaning they take any number of arguments, which could be anything, and they return anything."
          },
          {
            "time": "[00:02:14]",
            "text": "So, if it's our job to implement these, I think I'm just gonna pick one to start with. And filter seems like a good place to start. So I'm gonna begin with that one first. So this is going to need to have a type parameter, and we'll call it T."
          },
          {
            "time": "[00:02:36]",
            "text": "In fact, all of these will need at least a T, possibly a second parameter. And let's just think about these in terms of like what they take in as arguments and what they return. And we can worry about sort of filling in the algorithm once we have that pinned down."
          },
          {
            "time": "[00:02:52]",
            "text": "So filter, it's going to take in a dictionary, Of type T. And it's gonna return a dictionary of T, as well. It's just gonna have fewer properties on it. It's gonna be the subset of properties on the dictionary that meet some certain condition. And it's the caller's job to state what that condition is."
          },
          {
            "time": "[00:03:23]",
            "text": "And for now, we can just return an empty dictionary. And we'll also define the filter. Call it filterCb, for callback. This is going to take in an argument of type T and return a boolean. And we can move these onto multiple lines to make it really easy to see everything."
          },
          {
            "time": "[00:03:55]",
            "text": "So there's our first argument, there's our filterCb. Now we may need more callback arguments here, I know from using array filter, array reduce, sometimes you get the id here. Let's only worry about that if we absolutely need to. So that's filter. Map, so map is used to transform a collection of one thing to a collection of something else."
          },
          {
            "time": "[00:04:21]",
            "text": "And the transformation is defined by a mapping function. So we might need two type parameters here to represent the before and the after. So we could have T, and then let's say U.. U comes after T. So, like filter, we're going to take in as an argument, input, A dictionary of Ts, and what we're gonna return is a dictionary of Us."
          },
          {
            "time": "[00:04:56]",
            "text": "And our mapping callback is going to take as an argument, a T, and return a U. We'll start out by just returning an empty dictionary, which is technically the right type to return, it's just not a meaningful thing to return right now. Reduce is a little more tricky, let me just see if the test suite works without me defining the signature for reduce."
          },
          {
            "time": "[00:05:27]",
            "text": "Nope, we're gonna have to do reduce as well here, no problem. So the point of reduce is to iteratively, while processing a collection, build up and eventually return a singular value of some sort. And the iterative assembly of that value is to be defined by a reducer function."
          },
          {
            "time": "[00:05:53]",
            "text": "So, again, input, a dictionary of Ts, and then we have whatever value you're looking to arrive at, let's call it V, ffor value. So we're gonna actually return a V, not a dictionary. And we could have a reducer. And let's do a multiline, as we did before, Just to spread things out."
          },
          {
            "time": "[00:06:19]",
            "text": "So this is going to take a current value, which will be V, And then an item from the dictionary, which will be a T. And it'll return V, right? So sometimes reduce is great for a summation, where you have a running total, you add each item to the total, ultimately return the whole total."
          },
          {
            "time": "[00:06:46]",
            "text": "So this is gonna take our running total, the thing that we might factor into the total. And then here's the new total that would be returned by the reducer. We also have an initial value, which will be a V. We can get away with just returning the initial value right away here."
          },
          {
            "time": "[00:07:13]",
            "text": "Let's go back to filter and tackle this. So what we're gonna do is iterate over the dictionary, so we'll create a new dictionary that we aim to return. And then we'll iterate over the dictionary we're given, see which values pass the filter, and if they pass the filter, we'll add them to the new dictionary."
          },
          {
            "time": "[00:07:32]",
            "text": "So we end up returning the subset of properties that pass through the filter. So call this toReturn, eventually will return it. This will start out empty. Great, and we can take advantage of the for of loop. That's a really nice thing to use when iterating over an object like this."
          },
          {
            "time": "[00:08:14]",
            "text": "We can verify that this is the right thing to do. Let's see, input. Maybe it's the for in loop that I'm thinking of. Yep, it is. Yeah, for us is for an iterable. This is iterating over the properties of an object. So here we've got our input. Here we see that key is a string, that's a good signal that it's probably the dictionary key."
          },
          {
            "time": "[00:08:42]",
            "text": "Great, so we could say thisValue is the input dictionary, And retrieve an item by key if the filter callback passes when we give it this value. We're gonna add this to the dictionary. toReturn[key] = thisValue. Great, so that filter, that should work. Let's look at map. So I'm gonna start with the same code as we use for filter, cuz a lot's gonna be similar."
          },
          {
            "time": "[00:09:28]",
            "text": "The difference here is we have just a mapping callback that transforms from original dictionary to whatever, it transforms each item from A to B, whatever those things are. So the thing we'll eventually return, it's a dictionary of Us, not a dictionary of Ts. So we'll just make that little adjustment there."
          },
          {
            "time": "[00:09:49]",
            "text": "We're still gonna iterate over the input dictionary. We're still going to grab the value for each key. The difference here is we're always going to append things to the new dictionary. It's not a condition, it's a transformation. So we'll say toReturn. And then this is gonna be a map, mappingCb."
          },
          {
            "time": "[00:10:20]",
            "text": "So effectively here, for each, We're going to get value and then perform the transformation. I wanna look at my type errors here and see what's going on. So it looks like our map dictionary, one of our tests, it wants to be provided the name of the item, the key, rather, right?"
          },
          {
            "time": "[00:10:47]",
            "text": "So we can go back up top and make sure we accommodate that. So key is a string. And we'll just pass that along here. Great, no more errors. Seems like that was the only little extra feature of a callback we had to add. Let's run this code. Great, now we're starting to see some tests passing, and see where we're at."
          },
          {
            "time": "[00:11:14]",
            "text": "So we have a failed assertion here around reduce. Makes sense, we haven't really implemented reduce yet. But let's check out, so map, sorry, let me zoom in here, somehow I got scrolled, there we go. So we're passing all of our tests for map, we're passing all of our tests for filter."
          },
          {
            "time": "[00:11:36]",
            "text": "We're actually passing some tests for reduce already. We have only one test that hasn't passed yet. And that's because reduce is just first making sure that we return something, if it's a truthy thing. So this is the meaningful test that we still have to pass. So let's look at reduce."
          },
          {
            "time": "[00:11:57]",
            "text": "So we're gonna start out with an initial value. This is gonna be a let declaration, Because we'll keep writing over it with every loop over the array, or the dictionary, rather. So we'll first initialize the value with what we're given, we'll return it at the end. We're still going to loop, so I'm gonna borrow some of that code from filter."
          },
          {
            "time": "[00:12:25]",
            "text": "Just the for in loop. And this actually, while conceptually a bit abstract, it is implementation wise pretty simple. So the new value is reducer. And we'll pass in the last thing we had for the current value and the item. Let's try to run this and see where we're at."
          },
          {
            "time": "[00:13:05]",
            "text": "All right, looks like we passed all the tests. So we just wrote higher order functions for dictionaries using generic types. These will work for any dictionaries that you might have in your code base. And you'll preserve all of your type information as your collections pass through these functions."
          },
          {
            "time": "[00:13:29]",
            "text": "Hopefully this illustrates why type params and generics are an incredibly powerful tool. We get the ability to use these flexibly without giving up all of our type safety."
          }
        ]
      },
      {
        "name": "23-generics-scopes-restraints",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The last topic we're going to talk about in TypeScript Fundamentals V3 is generic scopes and constraints. So these are some final details I want to add to the concept of generics, so you can start to make use of them in practical applications. Scopes and constraints have to do with where you can use type parameters depending on where they're defined."
          },
          {
            "time": "[00:00:28]",
            "text": "And minimum requirements you can impose on type parameters such that you can consume them within your function. And that will make a little bit more sense what I mean by that as we get into that topic. So again, I want to begin with a motivating use case, why would we care about scopes and constraints?"
          },
          {
            "time": "[00:00:53]",
            "text": "What would be missing if we didn't have these things? So constraints allow us to describe a minimum requirement for a type param. And that is important in order to be able to use, for example, the things within this list beyond what we have seen so far. So we just dealt with this list to dict function while we were passed a callback that's used to generate IDs."
          },
          {
            "time": "[00:01:23]",
            "text": "But let's say we were building something out for a data layer, where every object that we're working with has a property on it called ID. Maybe it's coming from sequel database or something where there's just always this primary key. It's always going to be there, and we always want to use that as the mechanism for storing it in dictionary."
          },
          {
            "time": "[00:01:49]",
            "text": "Well, we don't need this callback anymore, but we do have to define this assumption about what the bare minimum requirement for the kinds of things we expect to be in this list. We need to define that somewhere. So let's dig into this. So the function signature we'd like to arrive at, we'd like to change from something like this to something that kind of looks like this, right?"
          },
          {
            "time": "[00:02:25]",
            "text": "So, previously, we kind of had a list of any's here or some other very specific type, but we need everything to at least be an object that has an ID on it. It's a minimum constraint that we need, why? Because as we store items in the dictionary, we're gonna reach into this item, and we're gonna retrieve a property off of it called ID."
          },
          {
            "time": "[00:02:51]",
            "text": "We didn't have this requirement with the first version of this algorithm. Right up here, we were given a function that we could use to get these IDs. Whoever was calling this function, it was their job to tell us what to do. We simply just said, you gave me a callback, I'm going to use this item with the callback."
          },
          {
            "time": "[00:03:10]",
            "text": "I have my ID, I don't need to know how this callback works, you handle that you provide it to me. Well, now we need to be able to reach into this, and grab an ID. So we need everything we receive to have an ID. Here's how this would work."
          },
          {
            "time": "[00:03:32]",
            "text": "This would be the naive approach that would fail, right? If we just tried to say, I have a type paramater T, I get a list of T's, effectively this thing becomes pretty pointless within the function. So if we look at this, so I've got my item here, I've got a T in this callback."
          },
          {
            "time": "[00:03:53]",
            "text": "If I try to get an autocomplete on this thing, there's nothing there for me to use. I cannot safely do anything here, why? Because T could be anything, it could be a list of nulls. I can't safely do anything because there's no minimum requirement for what kinds of Ts I'm willing to accept."
          },
          {
            "time": "[00:04:18]",
            "text": "So we need something better, we need something that allows us to always have that ID there. So what we need to do is describe this constraint. And I'm showing you kind of a one line diff version of the change that we need to make. Because it's useful to understand where the information moves as we start with the non-generic version of our function, and move to the generic version."
          },
          {
            "time": "[00:04:45]",
            "text": "This here, right, this is the minimum base class of minimum constraint we need this stuff to align with. It kind of moves into two places here, one like the array nature of this. We put that over here, but we've got this constraint on that type parameter now. And you might be wondering, are we using extends again, yet again, right, extends."
          },
          {
            "time": "[00:05:15]",
            "text": "What does this have to do with the extends that I already know about? Well, it's kind of related, at least conceptually, in that when you have a subclass that extends from a base class, you're kinda guaranteed to have all of that base class functionality. All of the class fields that were there, all of the methods, and you might have more."
          },
          {
            "time": "[00:05:36]",
            "text": "But at minimum, you are gonna have everything that can be expected of the base class. While here we're saying I can be given any T, but it has to at least meet this base requirement. That's the best I can do at helping you at unifying this concept of extends across everywhere it's used."
          },
          {
            "time": "[00:06:10]",
            "text": "So let's talk about scopes as they have to do with type parameters. In the world of variables, we know that inner scopes can see things that are available in outer scopes. For example in here, I am able to see bowl, and I'm able to see apple, I can see both, right?"
          },
          {
            "time": "[00:06:33]",
            "text": "You can you can see from the inside out, but not the outside in type parameters work a very similar way. So here we have a higher order function that's used to create a tuple. So you give it the first thing that goes into the tuple, and then you give it the last thing that you want to see in the tuple, just a tuple of size two, right?"
          },
          {
            "time": "[00:07:00]",
            "text": "So ultimately, what's gonna happen, if we look at the usage here, we've got a tupleCreator. And that returns a function, and then we finish the tuple by giving that an argument. So everything's gonna start with three, but then it'll finish with null or finish with this array of numbers."
          },
          {
            "time": "[00:07:22]",
            "text": "And I just wanna make it clear that here you can see we're allowed, just as in this case above where down here we can access both fruit and, sorry, both apple and bowl. Here, we can access both T and S because inner scopes can see outer scopes. Just be careful you don't make things too complicated with this."
          },
          {
            "time": "[00:07:46]",
            "text": "But a more pragmatic example might be you have a type parameter that's on a class. And then you have a method that has another type parameter of some sort. So finally, the last thing I want to leave you with here are some best practices around using generics. So first, make sure you remember that the point of these type parameters and of generic types is to relate multiple things, right?"
          },
          {
            "time": "[00:08:24]",
            "text": "In the case of our list to dictionary example, we're saying the list I'm given is related to the callback. They're of the same type, they both involve a T, right? And then I returned something that has a T in it, so they're all linked. If you're not using a type parameter more than once, you can end up casting inadvertently, basically, forcing TypeScript to regard something you have as a different type."
          },
          {
            "time": "[00:08:58]",
            "text": "So let's look at this, let's look at what's going on here. We've got a function here that says, return as string. Shouldn't be called returning a string, but return as something. So we give it an argument which isn't any and it returns a T. But look, we can give it a window, and we're gonna be forced to specify a type parameter explicitly here because nothing can be inferred here."
          },
          {
            "time": "[00:09:27]",
            "text": "We're not like accepting a T, we're just returning a T. But effectively, what ends up happening here is Windows passing straight through. But we've changed its type to a number, and this is should be obvious why this is dangerous, right? It's typecasting using a different mechanism. And typecasting is typically done with this as keyword where we're saying, look, just I know this is a window, but I want you to regard it as something else."
          },
          {
            "time": "[00:09:57]",
            "text": "So when doing a code review, you might be scanning through to see if someone's written as, but this is typecasting too. A single use of a type param, right, it's only used here. This will have the same effect, it's just a harder problem to catch in a code review."
          },
          {
            "time": "[00:10:17]",
            "text": "See two or more times, that's where you want to use type params. This here, we call this convenience casting, and if you're gonna cast, cast in a way, that is obvious for code reviewers. It may be what you want to do, but you want to have that discussion, and you want it to be clear that you're going to change the type of this thing."
          },
          {
            "time": "[00:10:47]",
            "text": "So you want to define your type parameters as simply as possible, and in a way that allows you to take advantage of all of the static analysis and the inference that TypeScript has to offer. So in this case, notice that, sorry, we have two options. We can either say T is a type, and that type extends from an array of HasIds, versus down here we could say T extends HasId."
          },
          {
            "time": "[00:11:29]",
            "text": "And the benefit here is basically your types are gonna get a lot dirtier, and depending see the tool tip here, it's sort of being inferred differently. I mean, it's kind of strange, right? The list is a T, T extends an array of HasIds, let's see what the return type is here."
          },
          {
            "time": "[00:11:54]",
            "text": "Look at that, look at what the return type is, it's a has ID or an undefined, whereas the return type here, it's a T or undefined. We've actually lost a type parameter here, isn't that interesting? And that's because when the return type is analyzed, we don't know what T is, right?"
          },
          {
            "time": "[00:12:14]",
            "text": "This is a list, all we know is it's at least a HasId, but the build time analysis can't figure out what the return type should be until it's actually called. And that is a problem that is why we have lost the T in the return type here. So you don't need to understand too much about why this is bad, but the best practice is to sort of push your type parameters down to the lowest level, the simplest way of describing them as you can."
          },
          {
            "time": "[00:12:50]",
            "text": "And then in your argument list, of course, you don't have to just take T straight up as an argument. You could take an array of Ts, a promise that resolves to a T, whatever you like. And there you can see the type checking will do its job more easily and more successfully."
          },
          {
            "time": "[00:13:07]",
            "text": "And then finally, the last thing I want to leave you with is don't make things generic unless there's real value in doing so premature abstraction is bad. It makes it hard for you to understand your own code, and for others to understand your code. So just make sure that you start out with simple things, and don't get into generic hell, where everything has 15 type params, and just becomes hard to even think about what's going on."
          },
          {
            "time": "[00:13:38]",
            "text": "These type parameters should have a purpose, you should have a small number of them, and just don't let the complexity get out of control."
          }
        ]
      },
      {
        "name": "24-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Just to recap all the ground that we've covered today. We started with a little introduction to TypeScript, and compiled our first TypeScript programmer, saw the compiled result. We changed our module types. We changed our language level, we saw the difference in output. We talked about variables, values, objects, and arrays."
          },
          {
            "time": "[00:00:21]",
            "text": "A little bit about tuples, and we learned about type annotations, and index signatures, ways to define the types of collections of data. Then we moved on to talk a little bit about theory for type systems. Different ways of categorizing type systems, and a little bit of set theory to describe union and intersection types."
          },
          {
            "time": "[00:00:44]",
            "text": "We gave our types names, using interfaces and type aliases, and defined some recursive types that we can use for any JSON value. Then, after talking about functions and classes, my favorite part about functions is those multiple function heads. We talked about top and bottom types. These are those extreme types that can be anything at all or nothing."
          },
          {
            "time": "[00:01:12]",
            "text": "And within extreme types, we talked about that cool example for exhaustive conditionals, where you can make sure that you handle every possible scenario. And you kind of end up with no pieces of the pie leftover, absolutely every scenario handled. And you have compiled time enforcement of that, which makes it really easy as you introduce new possibilities into your code base, they're caught for you."
          },
          {
            "time": "[00:01:38]",
            "text": "We built some user defined type guards and learned assertion type guards, and conditional type guards. Talked a little bit about nullish values, talked about generics, built up a little standard library for working with dictionaries. And then finally, scopes and constraints for type parameters. That is a lot of ground to cover."
          },
          {
            "time": "[00:02:00]",
            "text": "And that will put you in a great position for taking intermediate TypeScript, where we're going to dig even deeper into these topics. And now that we've conquered generics, we're ready to go with some even cooler concepts. Thanks so much for coming today and hope you had a good time."
          },
          {
            "time": "[00:02:19]",
            "text": "I hope you enjoyed the course."
          },
          {
            "time": "[00:02:19]",
            "text": ">> So back to the user defined type course, do you remember that CarLike example?"
          },
          {
            "time": "[00:02:19]",
            "text": ">> The car, sorry, let me go back to that. Type guards, and you wanted CarLike, the assertion ones or the is one?"
          },
          {
            "time": "[00:02:19]",
            "text": ">> It doesn't matter, I was wondering is there some sort of a more deliberate wave."
          },
          {
            "time": "[00:02:48]",
            "text": "It's shaking for your object type, especially that something I believe you'll find that most. It's a chaser, right, you came across it more than you should."
          },
          {
            "time": "[00:02:48]",
            "text": ">> Yeah, so you're wondering are there, I think you're saying this seems like a very low-level API. Are there higher level more declarative ways to inspect an object to figure out what types are on it?"
          },
          {
            "time": "[00:03:17]",
            "text": ">> Yes, maybe some sort of a utility that's been around."
          },
          {
            "time": "[00:03:17]",
            "text": ">> There are those utilities, and they do exist. Here's the trick though. Type checking at runtime is not free. And especially, if you're running this code on a very hot path, like a performance sensitive path. You may not want to be doing too much with a mystery library that may be doing some heavy things."
          },
          {
            "time": "[00:03:45]",
            "text": "It's kind of tricky to solve in the general case, but they do exist. I'm just not prepared to endorse any particular one. Cuz I'm really looking for simple and performance for things like this."
          },
          {
            "time": "[00:03:45]",
            "text": ">> So what are your advice exactly when it comes to this? Cuz I see a lot of repetitions in place."
          },
          {
            "time": "[00:04:06]",
            "text": ">> Yes. So my advice-"
          },
          {
            "time": "[00:04:06]",
            "text": ">> [INAUDIBLE] Is start to define a couple of fives and add some assertions, and type guard too is gonna be like a massive chunk."
          },
          {
            "time": "[00:04:06]",
            "text": ">> It does get a bit messy. My advice if you're at all able to do this is to push this problem into your API layer, where effectively every one of your, We're talking about values discovered at runtime really, that's often where you're gonna be using type guards."
          },
          {
            "time": "[00:04:44]",
            "text": "That discriminated union thing where, I see that there's a property called kind, and I see that there's this label on it. Once you can do that and you can say, well, if I see this thing here, this c tag on it, I know that the whole thing, I know what it's gonna be."
          },
          {
            "time": "[00:05:02]",
            "text": "That's a powerful idea. GraphQL has some support around this as well, where based on the query you make and some things that you can do at build time. You can have some pretty strong guarantees given that it sort of one central definition of a type that ends up both in your client and server code."
          },
          {
            "time": "[00:05:21]",
            "text": "That's also common approach. So anything where you have a well structured convention, this kind of code ends up being a lot cleaner, in that you have a few type guards that are heavily reused. And they sort of end up being nested, right? You could have a type guard that's, is this a single record or a collection?"
          },
          {
            "time": "[00:05:41]",
            "text": "Once you figure that out, okay, well, what's the type of this item in the collection? And they sort of stack up in that way. Does that make sense?"
          },
          {
            "time": "[00:05:41]",
            "text": ">> Yeah, thank you."
          },
          {
            "time": "[00:05:41]",
            "text": ">> There is one more I wanna leave you with, it's my favorite type guard of all time."
          },
          {
            "time": "[00:06:02]",
            "text": "It's this one. This will be an intermediate course for sure. We don't have to make it the assert. So, now we're mixing two things, right? It's a type guard that is generic. So, in this case, what this lets us do let, Something like that. So you could say if (isdefined(x))."
          },
          {
            "time": "[00:07:01]",
            "text": "And you can see here, it's a number. So you can start to make these type guards, involve type params with these type guards. And effectively what we're doing is we're saying, we're peeling away the undefined. This is why I don't wanna use the definite assertion operator. It's because I can write this, and it's something that will actually do the checking for me."
          },
          {
            "time": "[00:07:23]",
            "text": "And then it'll let me throw a meaningful error instead of cannot find too fixed on undefined, some weird, just letting it explode wherever it's gonna explode. But kind of getting clever with these things is is often time well spent."
          }
        ]
      }
    ]
  }
]