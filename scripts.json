[
  {
    "name": "intermediate-typescript",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to intermediate TypeScript, I'm Mike North, I'm a Senior Staff Engineer at LinkedIn, and I work in the developer productivity and happiness org. My job is predominantly helping make our COI and our UI ergonomics around developer infrastructure great. And TypeScript is a huge part of that, and that's why I'm a great person to speak to you about TypeScript today."
          },
          {
            "time": "[00:00:26]",
            "text": "Among the top goals that I have for this course is, number one, I wanna make sure that I package and pass onto you all of the key learnings that I have gained through many hours of helping guide and tutor others around TypeScript. So you're going to see a lot of little pieces of code throughout this course, that you can copy and paste right into your own app, and they can solve some of the common problems that I get a lot of questions about."
          },
          {
            "time": "[00:00:58]",
            "text": "By the end of this course, I also want you to be able to understand complicated type information. And I'm gonna show you a sample of where we're going to be, by the time this course wraps up. This may look scary right now, but take my word for it, we'll know how to break this down and how to troubleshoot it, and how to understand it, by the time we get through intermediate TypeScript."
          },
          {
            "time": "[00:01:23]",
            "text": "What should you already know by the time you start to take this course? Well, first, you should have a lot of experience working with regular JavaScript. We're going to be making extensive use of classes, functions, a sync await, promises, so you should be very comfortable working with those concepts."
          },
          {
            "time": "[00:01:42]",
            "text": "You also should have equivalent knowledge to what we cover in the TypeScript fundamentals of V3 course. In particular, you should be comfortable working with basic types for functions, objects, arrays, and tuples. And you should have crossed the threshold where you understand how generics work, at least with one or two type parameters."
          },
          {
            "time": "[00:02:07]",
            "text": "And this is something we cover in TypeScript fundamentals V3. Finally, make sure you brush up on index signatures, that's going to be a very important part of some of the more advanced topics that we're going to cover today. It's also worth stating that practical experience will aid you in terms of connecting the concepts were talking about today, to real-world situations."
          },
          {
            "time": "[00:02:30]",
            "text": "So it's helpful if you've worked in a code base that consumes type information for common libraries like react. We've spent a lot of time making this workshop as easy to use as possible. So, all you're going to need, is this website that we're working on today and the official TypeScript website."
          },
          {
            "time": "[00:02:54]",
            "text": "We've brought a lot of the features of VS Code right into your browser, so we'll be able to clearly see examples that highlight what's going on. And we'll be able to write our own code, and even write some code to pass some tests. As of the time we're recording this course, I have made four types of courses for Frontend Masters, and the way I think about them is as follows."
          },
          {
            "time": "[00:03:20]",
            "text": "TypeScript fundamentals and intermediate TypeScript are core courses, and most of our time together is gonna be spent in a lab environment. The idea here is that it's easy to teach these concepts in small controlled examples. And once we turn the light bulbs on, once we understand how things work, that makes it easier to take that knowledge and apply it in a more practical situation, and that's where these electives come into play."
          },
          {
            "time": "[00:03:47]",
            "text": "Production grade TypeScript and JS TS Monorepos, in those courses, we build an app together step by step. And that's where you can look for the applied techniques and the real world design patterns. We assume, in those courses, that you have already substantial experience working with TypeScript. And this is where you can learn to build things for production and at scale."
          }
        ]
      },
      {
        "name": "1-declaration-merging",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first topic we're going to discuss today is declaration merging. And this is the phenomenon by which types, and values can piggyback on top of each other. And they can be treated as a single named entity in your source code. By the end of this chapter, you'll be able to look at tooltips in Visual Studio code, which is the same tooltips that we see on this website."
          },
          {
            "time": "[00:00:24]",
            "text": "And you'll be able to make sense of exactly what's going on. Am I working with the type? Am I working with the value? How can I tell the difference? In this example, we have two what I'm going to call identifiers. And what I mean by an identifier is just a named thing that's defined in a single place."
          },
          {
            "time": "[00:00:45]",
            "text": "So we have one identifier called Fruit, which is a type. We know that, because it's an interface. And here is an identifier called banana, which is a value. TypeScript allows us to stack multiple things onto a single identifier. In this situation, we can see that we've named our interface, and our const variable the same thing, right?"
          },
          {
            "time": "[00:01:08]",
            "text": "They both fruit both with the capital letter. And we can see when we look at the tooltip for the interface, it's clearly just an interface. When we look at our variable, clearly it's just a concept declaration. But look at what happens when we attempt to export this as if we were exposing it outside of this TypeScript module."
          },
          {
            "time": "[00:01:28]",
            "text": "We can see this tooltip contains both, there's our const declaration, and there's our interface. These are actually two things stacking on top of the same word, Fruit. There's actually a third thing that we can stack onto this tooltip, so to speak unto this word, and that is a namespace."
          },
          {
            "time": "[00:01:51]",
            "text": "So in this example, we can create a class called Fruit with a static function on it. Now, we can create a namespace. And you can think of this as serving a very similar purpose as static class functions. And then finally we have a type called Fruit. So, if we hover over this export, and look at the tooltip, now we have three things class, interface, and namespace."
          },
          {
            "time": "[00:02:18]",
            "text": "So this is three things in one. Now you may be wondering when I'm importing stuff from other dependencies, how do I know what I'm working with? Well, I'm going to give you some investigative tools that you can use. To probe around, and to figure out what exactly is on one of these identifiers, right?"
          },
          {
            "time": "[00:02:42]",
            "text": "If I'm given Fruit, how can I test whether it's a class, sorry, how can I test whether it's a value, or a type, or both, or maybe neither? So, here are our tools. First, let's begin by creating a value, a type, and a namespace. And we've given them obvious names, so that when I put them up the screen here, you can remember what's going on, right?"
          },
          {
            "time": "[00:03:10]",
            "text": "So we've clearly got a value here. We've clearly got a type, which is just an empty interface. And then here we have a namespace. So you know something is a value if in a let or const declaration like this, you can put it on the right-hand side of the equal sign, and you get no error."
          },
          {
            "time": "[00:03:33]",
            "text": "If we try to do the same thing with the type, like we're doing down here, you can see that the compiler is not happy with us. And it's telling us is a type only refers to a type, but we're trying to use it as a value. So this alerts us to the fact that this is purely a type, there is no value part to this identifier."
          },
          {
            "time": "[00:03:58]",
            "text": "Let's look at a similar test but four types. So if we try to put this on the left-hand side of this assignment operator, and we get no error. That's an indication that this identifier can be treated as a type. And look what happens down here, if we try to do the same thing with a value, we get an error message."
          },
          {
            "time": "[00:04:20]",
            "text": "The thing we're using, it refers to a value, but we're trying to use it as a type here. So that failure tells us there's no type piece to whatever is on this thing, which is purely a value. Now, there's no equivalent test for namespaces, although the tooltips make it fairly obvious what's going on."
          },
          {
            "time": "[00:04:45]",
            "text": "So you see the word namespace on the left of the tooltip, that is a clear indicator. So you'd have to hover over it in order to figure out what exactly is happening there. While we're talking about namespace, some of you may be wondering, what's the point of these things?"
          },
          {
            "time": "[00:05:01]",
            "text": "And maybe you haven't seen them before, and you're wondering why they're even part of TypeScript? Well, an important aspect of TypeScript is it needs to be able to describe existing JavaScript libraries. Just think about when TypeScript was first made, and when they were trying to gain adoption. They needed to be able to say, here's type information that matches this existing library, which is written in regular JavaScript."
          },
          {
            "time": "[00:05:31]",
            "text": "So they needed to be able to type things like jQuery. And if we go to the jQuery homepage here, we can see some example usage right on the front page. So if we look down we can see, all right? Sometimes we're invoking this dollar sign thing as a function."
          },
          {
            "time": "[00:05:48]",
            "text": "And then down here, it appears that we're grabbing things off of the dollar sign, and they themselves are functions. So let's copy that code over, right? So this is basically the same code, it represents the same code. And we need to be able to describe types that can allow us to do these kinds of things."
          },
          {
            "time": "[00:06:13]",
            "text": "Here's how we might accomplish that. You can see here we're defining a function whose name is dollar sign. And we pass a selector in this could be up here, like h1 tags with a class title. And we're going to get all matching elements in a node list, as return value."
          },
          {
            "time": "[00:06:33]",
            "text": "In addition to that, to support this use case here, with .ajax, we need dollar sign to be a namespace that kind of stacks on top of that function of the same name. And that's what's allowing us up here to invoke this directly. And to use some of these functions that are sort of dangling off of the main function here."
          },
          {
            "time": "[00:06:58]",
            "text": "That's where namespaces are useful. Now, writing a library in this way. It's sort of leftover from the old way of consuming JavaScript dependencies, where you'd add a script tag to your app. And you would find that when all of your scripts have loaded, there's this global variable that has been tacked on to window or something, dollar sign, right?"
          },
          {
            "time": "[00:07:26]",
            "text": "And you could grab that, and basically access all of the capabilities of a library through that global variable. We don't really write things that way in modern JavaScript code bases. Now that we have modules, and better ability to consume third party code in that way. But we still need to be able to describe types for some of that old stuff that's lying around."
          },
          {
            "time": "[00:07:49]",
            "text": "So my advice is don't use namespaces too much. Don't focus on them too much. Cuz they're really about backwards compatibility, and not something that you often find is added to modern code bases. So now that we have a basic understanding of declaration merging, and how we can sort of sandwich or stack multiple things on a single named identifier."
          },
          {
            "time": "[00:08:19]",
            "text": "I want us to take a look back at the way classes work. So let's say that we have a class, like what you see on the screen now. It has three fields, each of which is optional, name, mass, and color. And then, it has a static functions. So, you could think of this, as a kind of a backup constructor of some sort."
          },
          {
            "time": "[00:08:42]",
            "text": "Sometimes you find that that's a good way to use static functions, a good use case for them rather. So if this is our class, let's apply the tests that we just discussed, and identify whether this is a value, or whether this is a type. So first we can test for value."
          },
          {
            "time": "[00:09:02]",
            "text": "And our test is to put it on the right-hand side of the assignment operator, and see if we get an error, and we don't. That means Fruit is a value. And when we take a look at this value. We can see that there's this createbanana thing, but note that we do not see color in this list."
          },
          {
            "time": "[00:09:21]",
            "text": "The reason is the value here is the class itself, not an instance of Fruit, it's the the factory or the constructor, right? We're seeing createbanana. We're seeing call, which indicates that this is kind of a function like classes or functions. So we would call this the static side of the class."
          },
          {
            "time": "[00:09:46]",
            "text": "Now, if we take that exact same identifier, and we test whether it's a type, the test is positive. The Fruit identifier is also a type. And when we look at the available completions here for the letter c, we can see that color is the only thing that's showing up."
          },
          {
            "time": "[00:10:07]",
            "text": "That's because when used as a type, this class is an interface that describes an instance of the class. So if you've been using classes, all along, now you know that they are a value, and a type of the same name stacked on top of each other. And depending on the context in which you use it, whether it's in the value position over here, or the type position over here."
          },
          {
            "time": "[00:10:35]",
            "text": "You're using one piece of it, or the other. So you've been making use of declaration merging, all along."
          }
        ]
      },
      {
        "name": "2-modules-cjs-setup",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Next let's talk about modules and interrupt between a modern TypeScript code base and common JS libraries. Node still uses common JS as its defaults module format although modernization efforts are underway, it'll be a long time before we can forget about this older way of writing JavaScript code."
          },
          {
            "time": "[00:00:24]",
            "text": "This is one of the trickiest aspects of getting dependencies to work nicely with your own code. And I have helped seasoned experts overcome the stumbling blocks I'm about to show you. So this is a lot of tips and tricks. They're valuable even for you experienced TypeScript practitioners. The reason we even need to talk about this is because until 2015, there was no standardized module format for JavaScript projects."
          },
          {
            "time": "[00:00:54]",
            "text": "As a result, several community based solutions emerged. We have CommonJS which was popular in the node community, AMD and UMD and these were more popular for browser based apps. Because of all the bundling technology we use for browser based apps, these two types of modules AMD and UMD have sort of gone away, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "Very few people write code like that, although sometimes we have these as a compiled target we don't really see that code. Common JS has stuck around and it's largely as I said, because of node, right. Node still consumes common JS libraries. And the core libraries of node are written in this format, so we need to know how to consume them."
          },
          {
            "time": "[00:01:47]",
            "text": "It's important to understand that I'm assuming and I encourage you to only write ES modules these days. You should be writing your own new code, using the new standard. Because that's a good way for you to be forward compatible, right? That your code will have a longer shelf life."
          },
          {
            "time": "[00:02:09]",
            "text": "First, everything you're used to seeing around model imports and exports in the Java script world, also works for TypeScript. So here are a bunch of examples. We can go through them very quickly. But they all work in TypeScript and JavaScript alike. So we've got multiple named imports. We have a default import, a named export a default export, these are re-exports, right?"
          },
          {
            "time": "[00:02:37]",
            "text": "We're sort of passing lemon and lime which originate in citrus, into our module and then export them out as if they're our named exports. All of this works in TypeScript. Although it is not super common in JavaScript projects, you're going to see things like this a lot in the TypeScript world, because often this is the solution to common JS entrop."
          },
          {
            "time": "[00:03:06]",
            "text": "So we see up here you have this module called berries. We're getting strawberry and raspberry from it. This would let you get a name space with all of the different berries hanging off of it. There's even a capability to alias a name space re-export, which is something TypeScript does today, and something JavaScript has just added to their draft specification for the language for the year 2021."
          },
          {
            "time": "[00:03:33]",
            "text": "So soon you will start to see this as a feature that you can use broadly across JavaScript. Great so that's stuff that works in JavaScript, also works in TypeScript let's talk about the more interesting thing. What are the special import concerns, you need to know about, as you take on authoring a library or an app in TypeScript?"
          },
          {
            "time": "[00:03:57]",
            "text": "Well first, if you're writing code that looks like this, or if If you're looking to write typed code that does the same thing as this, often you can just use this namespace import, right. So when we say I'm gonna grab this namespace fs from this module, if you've ever used this fs module which is one of nodes core modules, it's just a collection of functions hanging off of this fs thing."
          },
          {
            "time": "[00:04:23]",
            "text": "There's like read file sync, right file sync, read JSON, write JSON and the fs is just sort of a way to hold them all together. And we can import it just like this. Or you could import using a named imports like specific things from fs. Almost all common JS interrupt can be handled in this way."
          },
          {
            "time": "[00:04:48]",
            "text": "But there's one case that will really throw you for a loop if you encounter it and that's the case where whatever the module is exporting as its single export, it is not something that looks like a namespace. So let's look at this case here, where we have a function and effectively in our common JS code, we would see something like this, right?"
          },
          {
            "time": "[00:05:15]",
            "text": "module.exports equal In this whole function. Now we can't represent a function as a namespace, and by the way this is the equivalent code in TypeScript to accomplish this here. So if we try to consume it in this way, we're going to get an error message. And this says that if we wish to use ACMA script, imports and exports with this module, we have to turn a compiler flag on called esModuleInterop."
          },
          {
            "time": "[00:05:45]",
            "text": "And this error message is telling the truth. But what it's not telling us, is that there's an alternate solution to this problem and that is, for us to use an import that is not aligned with the ACMA script standard. And this will save us from having to turn this flag on."
          },
          {
            "time": "[00:06:04]",
            "text": "Why would I want to leave this flag off? Well, this is what I call a viral option. So viral options like es module and allowsSyntheticDefaultImports, if those are necessary, if you have to turn those on in order to make your types work, everyone who consumes your types will also have to turn them on."
          },
          {
            "time": "[00:06:28]",
            "text": "So particularly when I'm writing library code, I jumped through some serious hoops to make sure that I leave these off. And that means that if you're using one of my libraries, it's your decision whether you want to enable these or not. I don't want to force that decision on everyone who uses my code."
          },
          {
            "time": "[00:06:48]",
            "text": "So I call these viral options because when one library enables them, anyone who consumes it also has to turn it on. Thankfully, we have another solution to this problem, right. And that's the non ECMO script import. Here is how it works. So we still have this code here remains the same as when we last saw it."
          },
          {
            "time": "[00:07:10]",
            "text": "But here is the key thing, the key idea. This looks kind of like a common JS Import. But one words different, right? We're used to saying seeing const createbanana = require(\" /fruits'), but we see import instead of const. This is what makes it kind of a unique thing, right?"
          },
          {
            "time": "[00:07:32]",
            "text": "It's the imports used to be this way in very old versions of TypeScript, and you can still use them. And you can see the type information still comes along for the ride here. So given that in this situation we have to choose between a bunch of non ideal possibilities either forcing consumers of our code to turn some compiler option on, or doing this, I would sooner do this because I like the idea as a library author, I think it's part of my job to like absorb some of that pain for downstream consumers of my code."
          },
          {
            "time": "[00:08:09]",
            "text": "So I will almost always do something like this compared to forcing people to change their compiler settings. If we look at what this code compiles out to, thankfully, it's exactly what we would want. We can see module.exports = createbanana. And if we look up, that's what we were trying to accomplish here."
          },
          {
            "time": "[00:08:36]",
            "text": "And here, we can see that this is required, just the way we would hope to see common Jas code, if we have written it in regular JavaScript, right. It's just consuming the entire module as a single thing, invoking it directly because it's a function, we're good to go."
          },
          {
            "time": "[00:08:58]",
            "text": "Just on the topic of making sure your types don't require special compiler options, a quick reminder that VS code will download type information in the background as it sees users consuming a library. And there's a possibility that even if they're not depending on your library's types like directly, they'll start to see some autocomplete information in their authoring environment."
          },
          {
            "time": "[00:09:26]",
            "text": "So it's important especially if you're doing open source work, it's important to be good citizen. Make sure that if you publish types, those types of work. And make sure that you don't spread those viral options, and put that burden on your consumers cuz it may be a very tricky thing for them to straighten out, if they start to see red squiggles under their code cuz TypeScript is unhappy."
          },
          {
            "time": "[00:09:52]",
            "text": "Finally, I wanna talk about importing things that are not JavaScript modules. So if anyone in the class uses web pack or parcel or snow pack, anything like that, the way these bundlers work, is your JavaScript modules occasionally will point to non JavaScript things, that need to sort of be packaged in the same layer of assets as their respective JavaScript modules."
          },
          {
            "time": "[00:10:22]",
            "text": "So here let's imagine we have a react component that needs an image file, well, you could import an image like this. Here's a link to the Webpack documentation where I copied this line from. Now TypeScript is not happy with this by default. It's saying, I can't find a module named file.png, and that's because there is no TypeScript module called file.png, not in this environment."
          },
          {
            "time": "[00:10:50]",
            "text": "So we need some way to tell TypeScript that whenever we import a png file, it should be regarded as a JavaScript module with a default export, that is of type string. This can be accomplished if you create a file called global.d.ts, and you're gonna wanna create something called a module declaration."
          },
          {
            "time": "[00:11:13]",
            "text": "So in plain language, this could be taken to mean, I hereby state that a module exists and the name of that module is some arbitrary text followed by .png. And the default export of this module is going to be a value whose type is string. As a result of having this little piece of type information, elsewhere in your project, you're gonna see that this exact same line that was failing before, it's now not only error free, but we can see that the value of this IMG thing, it is of type string, which is great, that's ripe that's ready to put into an image tag source equals this, right?"
          }
        ]
      },
      {
        "name": "3-type-queries",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Type queries allow us to obtain a type from a value. And there are two new keywords I want to introduce, which fit into the category of type queries. Those are keyof and typeof. So first, we're going to look at keyof. keyof allows us to obtain all of the keys of an interface or object type of some sort."
          },
          {
            "time": "[00:00:30]",
            "text": "So here, note that we're looking at a type alias, right? And if we hover over Date here, you see obviously the word interface Date. That's an indication that we're working with this as a type. And we're using this keyof operator, and then we're getting something here, it says DatePropertyNames."
          },
          {
            "time": "[00:00:50]",
            "text": "We can't really see much more about this. Now, in JavaScript, we can have property keys that are strings or numbers or rarely symbols is a separate type symbol. So not all keys are strings. But if we wanted to take this thing that we have here and say, I wanna see the keys that are only strings, only those keys that are also a string, we could use the intersection type operator."
          },
          {
            "time": "[00:01:22]",
            "text": "Remember, if we think about the Venn diagram, the intersection type operator will help us to select only those things that are in the overlap portion of the Venn diagram, right? We're saying you must be a key of date and you also must be a string. And if you meet condition one and condition two, then you're part of this new type."
          },
          {
            "time": "[00:01:46]",
            "text": "If you think about geometry, and I'm sort of revealing my educational background here. I'm a mechanical engineer by education. I think of this kind of like a dot product in that, if you remember that you can kind of define vectors as some portion in the x direction and some portion in the y direction."
          },
          {
            "time": "[00:02:05]",
            "text": "You're kind of getting the part of a type that aligns with some other type, kind of like a dot product. That's useful enough to me that I want all of the other sort of visual learners to think of it that way. So it's the sub-part of keyof Date that is also included with string."
          },
          {
            "time": "[00:02:30]",
            "text": "So here we've got the same line that we had above. In our second line, we're saying intersect this with string, and look what we get. We get all of the property names of date that are also string. We've got toDateString, toLocaleTimeString, getFullYear, 33 more, right? It's even truncating this tooltip."
          },
          {
            "time": "[00:02:56]",
            "text": "There's a lot going on here. So remember, we're still working with types, but what we've created here is a union type, right? This is the or concept of all of the different property names, which could include methods or fields that we could find on date. We've obtained type information here."
          },
          {
            "time": "[00:03:17]",
            "text": "So if we wanted to get the other things that are left over, apparently there's this Symbol.toPrimitive thing. And you can read more about that here, but that's why this didn't show us a list of strings. There's actually one symbol in there and it's for converting a date to either a number or a string."
          },
          {
            "time": "[00:03:38]",
            "text": "And there's a footnote if you wanna play with that, if you're curious and wanna pull that thread. So that's keyof. It's gonna be really important later in the course, keyof. typeof, so this is a much more direct type query in that we're literally saying, I have a value and I wish to get the type that describes this value."
          },
          {
            "time": "[00:04:03]",
            "text": "So here's a little bit of sample code. I've made sort of a non-trivial value here just to sort of make things interesting. We have a fetch which returns a promise that resolves to a response, right? Look at that return type, they're promise, and then generic over response. And then here, we've created a second promise that resolves to a string."
          },
          {
            "time": "[00:04:28]",
            "text": "Promise.all, it takes an array of things. Any of those that are promise-ish, it'll wait for those. So if we await this, look at that tooltip, it's a tuple containing a response and a string. But let's pretend that this was much more complicated. We don't have a nice type that describes this."
          },
          {
            "time": "[00:04:49]",
            "text": "So if we wanted to obtain that type, all we'd need to do is grab this, right? This is our value. See the word const in the tooltip? We're using this typeof operator, or this keyword rather. And then we can create a type alias that describes what this thing is."
          },
          {
            "time": "[00:05:10]",
            "text": "You may be wondering like, where might I use this? Well, what if you're consuming a library that exposes some things to you, some values? But they don't give you the type information for these things directly as an interface or as a type alias that you could independently import and export."
          },
          {
            "time": "[00:05:31]",
            "text": "But if you wanted to make a function that takes the return value of something else or a function. What if this were a webpack config, a really complicated, big, big object with lots of stuff on it? If you wanted to make a function that takes a webpack config as an argument, this would be a way where you could say, hey, look, I have this thing."
          },
          {
            "time": "[00:05:50]",
            "text": "Maybe it came out of a function as a return value. And now I can have a type for it, and I can use that type for something else. It's great for sort of threading concepts through and making sure you're still referring to the original source of truth. I don't have a tuple written in this piece of code at all."
          },
          {
            "time": "[00:06:07]",
            "text": "I mean, unless you would argue that this is a tuple, but certainly not a tuple type. This is a value, right? It's the thing passed into Promise.all. But I am very much referring to the type information for resolve, for fetch, for Promise.all. That's all baked in to this Response, string."
          },
          {
            "time": "[00:06:29]",
            "text": "So if these were to ever change, if I upgrade my typescript version, for example, everything will flow through very nicely. I'm still just pointing to one single source of truth. I'm just sort of giving it a name so I can hold on to it with this type query."
          },
          {
            "time": "[00:06:44]",
            "text": "So typeof is also useful for obtaining the static side of a class. By static side, we mean like the factory, right? It's the ability to create new fruit in this case and any static methods that are on this class. So if we look at the tooltips below here, we haven't written the word typeof, but we can see it appearing to us."
          },
          {
            "time": "[00:07:11]",
            "text": "If we store as a variable a copy of this Fruit class, not an instance, we can see the type of this variable is typeof Fruit. And then if we create an instance, we can see that the type is just Fruit. So if you wanted to see the static stuff available on a class and you wanted a type for that, remember, if we just use Fruit in the value position as we are here, we're referring to the constructor, right, the class, not an instance."
          },
          {
            "time": "[00:07:48]",
            "text": "And then if we look at what its type is, now we have a way of getting access to it using this type query."
          }
        ]
      },
      {
        "name": "4-conditional-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types are kind of a ternary operator, but for type information. In fact, they use exactly the same syntax. And in this chapter, we're gonna look into these things. And we're gonna work up our way to what's coming next in the chapter after this, where we will see that there are some utility types that become possible once we introduce this concept of conditional types."
          },
          {
            "time": "[00:00:33]",
            "text": "Utility types are just, they're things that come with TypeScript for free, that are so broadly useful, that they're just included with TypeScript itself. It's kind of a little standard library. So first, let's talk about ternary operators as they pertain to values. You're used to seeing this in JavaScript already in all likelihood."
          },
          {
            "time": "[00:00:57]",
            "text": "So, it's just if, then, else logic and ternary, of course, just means having three parts. And we have our three parts here, right? So, if we have a value, we could say x is negative only if it is less than 0, right? So if it's greater than or equal to 0, it is non-negative, otherwise, it's negative."
          },
          {
            "time": "[00:01:25]",
            "text": "And there are three parts here. There's a condition to evaluate an expression to use if that condition evaluates to true. And then the expression to evaluate if that condition evaluates to false. All of this is gonna serve you well as we start talking about the equivalent in the types world."
          },
          {
            "time": "[00:01:46]",
            "text": "Let's look at the equivalent in the world of types. We have two appliances here that are used for cooking. We've got a grill and an oven. And they have no common shared method names. So we would say there's not very much overlap between these two things, between grill and oven."
          },
          {
            "time": "[00:02:04]",
            "text": "But that's what we're defining here. And then we can define a type that conditionally turns into either a grill or an oven. And we're gonna unpack this syntax piece by piece in just a moment. But for now, I just want you to observe the result. And the result is, remember, this is just a literal type."
          },
          {
            "time": "[00:02:28]",
            "text": "It's not a value. It's a specific string type, a string that only matches one particular thing. So if we say this is a cooking device of type grill, we get a grill out. If we say it's a cooking device of type oven, we get an oven out. And we also see the very familiar ternary operator at work here."
          },
          {
            "time": "[00:02:56]",
            "text": "And this is a condition. This is what to use if the condition evaluates to true and this if false. So if we strip everything back, we can see the pieces of interest, right? Those three parts. And it works exactly the same way. So we can kind of map it out in this way."
          },
          {
            "time": "[00:03:18]",
            "text": "If we've had a condition, expression if true, expression is false, they're just type expressions, they're not value expressions. And frankly, these two pieces here are not interesting, you could put whatever type you want there. This condition is kind of interesting. So, you can see that we're using the extends keyword here."
          },
          {
            "time": "[00:03:37]",
            "text": "And we've used it in a couple places. So if you took the fundamental course, we used extends to describe constraints for type parameters. A way of saying I take type T, and T must be at least this type. It at least must be an object that has an ID property on it, or it must be at least a string."
          },
          {
            "time": "[00:04:00]",
            "text": "Could be more than a string, but I want, I need to be able to assume that I can treat it as string and as a minimum requirement. Well, in this context, the word means the same thing. We're saying that, T must be at least this type. It's not an equality check."
          },
          {
            "time": "[00:04:23]",
            "text": "I think of it more like a greater than equals comparison. You are at least of this type. And this is the only tool we have as of today's version of TypeScript for expressing conditions. We can only use this extends word."
          }
        ]
      },
      {
        "name": "5-conditional-types-practice",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, quick little exercise here, with our understanding of how extends works. I want us to look at this list of eight examples, and tell me whether you think this will evaluate to true or false. So, just take a moment and look at these eight things, and we'll reveal the answers in a moment."
          },
          {
            "time": "[00:00:26]",
            "text": ">> Don't peak down here, this is where the answers are. Don't cheat yourself out of the learning experience here. But just think through these eight situations and see if you can figure out what's true and what's not. We're gonna go over the answers to this eight question quiz."
          },
          {
            "time": "[00:00:46]",
            "text": "And in doing so, we're gonna learn a little bit more about how this extends keyword works. So, we're gonna open up our spoiler warning. And so, as everywhere else in this course, these little code snippets, they're coming like directly from TypeScript compiler output. So you know I'm not lying to you."
          },
          {
            "time": "[00:01:09]",
            "text": "This is compiler results we're seeing as answers. So first, 64 extends number, that is true. And the way I encourage you to think about this, if you watch the TS fundamentals course, we likened types to kinda set theory, where we could say this type here, it's like any number you want, as long as it's 64."
          },
          {
            "time": "[00:01:37]",
            "text": "And over here, it's any number you want. So, the extends keyword, it's kinds like asking a question, does everything on the left fit within the set on the right? So, is the set 64 allowed within the set of all numbers, it is true. And here, we can see that the reverse is not true, why?"
          },
          {
            "time": "[00:02:03]",
            "text": "This number set here, that's gonna include the number 63, which is not in the set that only includes 64. So, this is just way too general. It includes things that won't make this type happy. So, number does not extend 64. Applying that same technique, we're seeing if the set of all possible string arrays fits within the set of all possible values that could ever exist in JavaScript, seems true."
          },
          {
            "time": "[00:02:39]",
            "text": "Within everything we could create in JavaScript, of course, we can include all string arrays. In chat says, I thought the inverse. I know man, that's why we're going over this. Like, this is a common misconception and I had to wrestle with this exact same thing. So, the slow and steady approach here is, well, it took for me to learn this."
          },
          {
            "time": "[00:03:03]",
            "text": "So, that's why I'm passing it on to the class. So, yeah, the set of strings is included in the set of any possible allowed values. And the set of all string arrays is also included in the set of all possible arrays. This type on the right includes arrays of numbers, arrays of Boolean, arrays of promises, right, and arrays of strings."
          },
          {
            "time": "[00:03:27]",
            "text": "So, there we go. This one's interesting. I bet a lot of people got this wrong. I bet a lot of people got this wrong. Because when you take things out to the infinities, right, to the infinitesimally strict and the infinitesimally not strict, it's very confusing to think about this, and it's tempting to stop applying the mental model."
          },
          {
            "time": "[00:03:53]",
            "text": "I bet a lot of people got this one right up here, and if you got them reversed, that's fine, right? That just means you didn't understand which direction extends was operating in. But I suspect if you mirror your answers, you might have had inconsistent results between this and this."
          },
          {
            "time": "[00:04:14]",
            "text": "Well, let's apply our same logic here. Never, the set of all values that can make never happy, empty set. Does everything that is included in an empty set fit in the set of all possible JavaScript values? Yes, of course. If we had to write a for loop to verify this condition for answer number five, we would never even loop over anything, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "There's nothing to check. And we kind of default to true. It's like, do you have room in your house for everything that's inside this empty box? Sure, [LAUGH] then yeah, there's nothing in there. We have room, that's the way to think about this. Here, this is another kind of interesting edge case, does the set of everything include the set of everything?"
          },
          {
            "time": "[00:05:09]",
            "text": "Sure, kind of with the reflexive property, this would better be true. Getting a little bit more complicated here and thinking now in terms of the type for a class constructor like a factory versus an instance. So, we've got first, the instance case, right? That's the interface called date."
          },
          {
            "time": "[00:05:31]",
            "text": "Does this include the set of all things that can be used with the new keyword? That's what this type means. Are you a newable, sometimes people use this newable word, right? So, an instance of date is not newable but if we put this type of keyword in front of it, and we get the type of the factory for dates, it turns out that that is newable."
          },
          {
            "time": "[00:06:06]",
            "text": "Does anyone have any questions about these? So, raise your hand or type y in the chat if you've got at least one of these wrong, and now you kind of understand a little bit more about how extends works, after thinking through it again. So, Dimitri asked the question, the modern set theory has some limitations for case six."
          },
          {
            "time": "[00:06:28]",
            "text": "We don't understand why exactly, maybe I could learn a little bit more about that. What I do think is if we just say, does everything in box A fit inside something designed for B? And in this case, we're sort of moving everything over like by definition, like the set of all strings is included in the set of all strings, right?"
          },
          {
            "time": "[00:06:53]",
            "text": "So, Christoph, you make a good point. And if you're watching this course now, you were thinking that extends sort of operated in the reverse direction. You might have thought about it as like, does the thing on the left, is that the larger of the two sets, and then this is the smaller of the two sets?"
          },
          {
            "time": "[00:07:15]",
            "text": "It's actually the opposite. Remember, extends is about getting more and more specific. If you have a base class and you make a sub class, and then another sub class, you're adding more properties, right? If we started out with any, we have the set of all possible things that you could create in the JavaScript universe."
          },
          {
            "time": "[00:07:39]",
            "text": "And then, we'll start saying well, all right, let's make it more specific. Let's just talk about arrays. All right, let's talk about just arrays that only contain strings. Well, every time you make one of those statements and you're saying, let's make this more specific, let's define more type information, let's add more constraints, you're narrowing, and narrowing, and narrowing and you're making drilling down."
          },
          {
            "time": "[00:08:06]",
            "text": "And there are fewer and fewer things in your set. So when we say it's 64, it's almost like a weird way to say it, but the 64 have a base class of number. Kind of a base type of number like, if we widen it out, would we end up with a number?"
          },
          {
            "time": "[00:08:29]",
            "text": "Like if we made string array more general, would we arrive at all possible arrays, right? Well, making it more general, let's allow non-strings to be included. And then we could say, maybe it doesn't have to be a array, more general still. So, let's start zooming out. These are great questions, and this is one of the best things I can do with this the short time we have together, to help you get over these hurdles."
          },
          {
            "time": "[00:08:57]",
            "text": "Let's put this conditional type concept to work. And we're going to look at an example and build our way up to some of the standard utility types, that are included with the TypeScript programming language."
          }
        ]
      },
      {
        "name": "6-extract-exclude",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Extract and exclude, these utility types which are included as part of TypeScript, they're used to obtain some sub part of a type, either through specifying what you're looking for, or what you're not looking for. Extract is about defining what you're looking for and you get that piece."
          },
          {
            "time": "[00:00:24]",
            "text": "Exclude is about describing what you want to leave behind, and you kind of get everything else. So these, behind the scenes, just use a conditional type. So we'll be able to put this concept we just learned into action now. So let's say we have a type that looks like this."
          },
          {
            "time": "[00:00:44]",
            "text": "So we have favorite colors, and we have a bunch of colors that are listed, right? So think of this, if we were in CSS and we were using the color or background color property, you can write out the word red. Or you can define colors like hash, F00."
          },
          {
            "time": "[00:01:05]",
            "text": "Or you could say RGB parentheses 255. You could specify your decimal values for each of those eight bit color slots. So we're allowing all of that here. So we kind of have a mix, right? We have strings, we have a three part tuple. And then we have an object with properties red, green and blue."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we wanted to obtain only the subset of what's described by this type, that is also a string, we could use extract in this way. If we scroll to the right, you can see that we get just the strings. The tuple is not there, the object is not there."
          },
          {
            "time": "[00:01:52]",
            "text": "We could do the same thing by changing this second thing, the second type that we pass to extract. And now what we're saying is within favorite colors, give me whatever sub part of this type has a property called red, whose type is a number. We don't need to specify this whole thing here."
          },
          {
            "time": "[00:02:21]",
            "text": "Remember, it's not an exact match. This is a minimum requirement. So let's pop this example out into the playground, and let's say, what if we did this? Let's add an alpha channel, right? We could, well, this is not gonna be because it overlaps so much with the other type."
          },
          {
            "time": "[00:02:44]",
            "text": "Let's say I'm just gonna do this. I just don't want one to be strictly a superset of the other. I want them to have some overlap where we can see an interesting thing. So if we look at object colors, now look, we selected both of those, if you see in the tooltip."
          },
          {
            "time": "[00:03:02]",
            "text": "The object that has green and blue written as words versus their first letter. So it's almost like a query searching for things that might contain a substring of, here's a fragment, you'll find me the whole thing. You can think of it kind of that way, at least when we're using it in this context."
          },
          {
            "time": "[00:03:21]",
            "text": "This is where we're doing the searching. Make that a little bigger. This is where we're doing the searching. And then this is the clue, right? This is the fragment to use as the basis for the search. That would be a perfectly valid way to think about this. And of course, with tuple colors, I'm just gonna pop back here."
          },
          {
            "time": "[00:03:44]",
            "text": "We could search so the result we get, of course is number, number, number. Let's try some other things here. What if we just search for things like a tuple of length 1, we get a never, not found, right? That's what it is in this case. It's like I examined everything, and here's the set I found, developer, it's an empty set, sorry."
          },
          {
            "time": "[00:04:09]",
            "text": "But if we did this, what if it's a wider type, a more general type that still kind of matches what we're looking for. Hey, there we go. Yeah, an array of numbers that is exactly three slots. Sure, I mean, it is an array of numbers. It's a very special array of numbers, it's specific, but we can search for something that is more general."
          },
          {
            "time": "[00:04:38]",
            "text": "In the same way that up here, right, we're searching for any object that has a property red whose value is a number. And we were picking up more than one thing. So you search with something that's more general and the matches will be at that level of specificity, or even more specific, right?"
          },
          {
            "time": "[00:04:59]",
            "text": "We're searching for any number arrays. And if we had, let's say we allowed an alpha channel here, maybe this one might work in a more interesting way. So now we'll get both. We'll get the three place tuple and the four place tuple. Why? They're both different kinds of number arrays."
          },
          {
            "time": "[00:05:17]",
            "text": "So one of the key insights I wanna make sure you walk away with, how to think of this specific versus general. What's this extends keyword all about? And this is really important in terms of making sense of what we're looking at here. Yeah, so in plain language, what this type is all about, we're extracting the subset of favorite colors that is assignable to string."
          },
          {
            "time": "[00:05:43]",
            "text": "That's specifically this thing up here, right, where we're grabbing the subset that is assignable to a type Exclude is the opposite of extract. And it's useful if you can very easily define what you wish to leave behind. So it's the same exact example, I've just changed the word extract to exclude, and here we're saying, show me all."
          },
          {
            "time": "[00:06:16]",
            "text": "Show me everything that doesn't match string. Show me everything that doesn't match string. So we get our array of numbers and we get our object. Those are the non string parts of favorite colors. So, how does it work? Here are the definitions of these two types. This is pulled straight out of the TypeScript source code, and it's very, very similar to what we were working with before."
          },
          {
            "time": "[00:06:47]",
            "text": "So in plain language, here's what's happening. We have a type T, this is a type parameter, and it's what we're operating on. In this case up here, we used favorite colors, right? It's this mixed bag. It's the haystack in which we're searching for a needle. And then we have typed U, U describes what we're searching for."
          },
          {
            "time": "[00:07:12]",
            "text": "So you can think of this almost like we look at all the different parts of type T, especially if it is a union type with this whole operator here. We're gonna look at each piece of it and we're going to see which of those pieces extend from you."
          },
          {
            "time": "[00:07:34]",
            "text": "Which of them match U or are even more specific than U but still match the minimum requirement of U? If this turns out to be true in the exclude case, we leave it out. We leave out whatever matches, otherwise we let it pass through. And this is the only difference between the two."
          },
          {
            "time": "[00:07:58]",
            "text": "It's never colon T versus T colon never. It's just the inverse condition, right? So this is a good example of how you might use conditional types."
          }
        ]
      },
      {
        "name": "7-type-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> First, I'd like to address some questions that I see in chat. So Dimitri asks, would it be correct to say that if I say that generics used are used more often when we write libraries. So Dimitri asks, are generics more appropriate to use in libraries versus app code?"
          },
          {
            "time": "[00:00:25]",
            "text": "I don't really think that it hinges on whether your code is library or app related. For example, I know of many apps that have use of generics in their data layer where they might have some concept of record type. Maybe if they're hitting like a SQL database, they have a primary key that's always ID, and they want some predictable pathway for going to fetch some information using generics and app code."
          },
          {
            "time": "[00:00:58]",
            "text": "In that area it's quite common. I would say the more reusable, the more reusability is a concern, the more you're gonna want to Leverages generics for that purpose. Yeah, libraries tend to get reused quite often. But it's not limited to libraries for sure. Leslie asks, I feel like generics can easily see him so complex because everyone's using random non-expressive letters."
          },
          {
            "time": "[00:01:31]",
            "text": "To represent types, is that considered the standard? There is no standard, I would say it's the norm to use these capital letters starting with T, but that is a leftover remnant from the C++ days. Sort of started in C++ with template classes, and then made its way into generics and Java and C-sharp."
          },
          {
            "time": "[00:01:54]",
            "text": "And now it's sort of this pattern that everyone who's used this concept before in other languages, they're used to doing it that way. I do 100% agree with you though. That, we don't like single letter variable names for values. Why are we cool with single letter names for types?"
          },
          {
            "time": "[00:02:13]",
            "text": "That's a very fair point. The good news is there's nothing that stops you from giving these more meaningful names, although you're going to come across a lot of code that just sort of has these very abstract letters. That make it difficult to sort of read the code, and understand what the intent of the developer was."
          },
          {
            "time": "[00:02:32]",
            "text": "That's a totally fair point."
          },
          {
            "time": "[00:02:32]",
            "text": ">> We see here like we use this extractor type, special type from the library, is this equivalent to the end operator? We use the model at the beginning with the key off date we combined and to extract on it the case on it, is extract basically doing the same thing or is there a difference?"
          },
          {
            "time": "[00:02:55]",
            "text": ">> That is a very, good point. So, there, I'm not sure if there are a 100% the same, but it's true that. The, it's true that the intersection type operator, that end type does accomplish things that are also possible using this syntax, with this arrangement of things. Now, I think you might get some side effects."
          },
          {
            "time": "[00:03:31]",
            "text": "But like in some cases, I'm reluctant to say that it will always work. But that's a very, very good point you bring up. I think, logically it makes a lot of sense. You're trying to get, the portion of one type that also is assignable to another type it would seem that's what we're dealing with."
          },
          {
            "time": "[00:03:54]",
            "text": "I just don't want to unfirmed say, yes they're absolutely the same thing. But they seem like there could be. This obviously you can't do with the end and the or would not give it to you either. Does that make sense?"
          },
          {
            "time": "[00:03:54]",
            "text": ">> Yes."
          },
          {
            "time": "[00:03:54]",
            "text": ">> So this exclude is sort of like the end to end it's useful to have a generic that will do that for you."
          },
          {
            "time": "[00:04:20]",
            "text": "And by the way, you're also going to see that there are things in fact, we're about to talk about the infer keyword. There are things that make it beneficial to use type params and to use a generic for extraction of some subpart of a type from another type."
          },
          {
            "time": "[00:04:45]",
            "text": "So I think you'll see a rationale for why it makes sense to do this shortly."
          }
        ]
      },
      {
        "name": "8-inference-with-conditional-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types have a special tool called the infer keyword, which can be used to extract some sub part of one type from another type. And it's not a coincidence that in the same release of TypeScript where we got conditional types. We also got this infer keyword you might feel, especially once you get used to using infer, you might feel that conditional types are sort of a very weak feature of the language."
          },
          {
            "time": "[00:00:36]",
            "text": "Without this infer keyword, it's almost like this. This is a necessary part of the story and they go hand in hand with conditional types. This infer keyword can only be used within the condition expression of a conditional type it can be used anywhere else in any kind of type expression."
          },
          {
            "time": "[00:00:58]",
            "text": "So, what we're gonna do since it's kind of an abstract concept, we're going to walk through a situation where we find that. The thing infer does for us is conspicuously missing from the language won't go up to a problem that only this new language feature could solve. And that'll help us understand how it ties into the practicalities of what we're trying to build in our In our real world apps."
          },
          {
            "time": "[00:01:28]",
            "text": "So, let's say that we have a class that takes a really complicated options object. And we'll say that it's called WebpackCompiler. And this is actually a subset of the Webpack configuration object. You don't need to remember all this, the whole point of having types is you want autocompletes here, right?"
          },
          {
            "time": "[00:01:48]",
            "text": "Cuz it's very, very flexible, like you can do a lot of different things here. But let's imagine that in the source code that we're consuming, it looks just like this, where we do not have an interface or a type alias that defines this. We only have it explicitly specified as the type of the one argument passed to the constructor, and then let's say in our own code, we want something like this where we define a configuration."
          },
          {
            "time": "[00:02:22]",
            "text": "We attempt to compile and then if something goes wrong, we log an error message out. And the configuration is part of that error message. Maybe this code is run on a machine that we don't have direct access to. And it's important that we be able in logs to see that."
          },
          {
            "time": "[00:02:42]",
            "text": "Like if it's a GitHub action, for example, we want to be able to see in the logs like this was a failure here was the config. I can copy this and I could run it. So I simply mean to convince you that This is something you might actually do, right?"
          },
          {
            "time": "[00:02:57]",
            "text": "And unfortunately, we have a spelling error here. We've said watch instead of wutch, and we get no type checking help with this spelling error. Why? Well, let's look at the type of this configure object. It's not anything that looks connected to the Webpack config. It's just an object that has two properties on it."
          },
          {
            "time": "[00:03:21]",
            "text": "We're just getting straight up inference here, based on the value or we're setting CFG to and we're passing it In the WebpackCompiler and nothing's objecting there why almost everything on this options object is optional, and we have an entry. That'll work. And the other property will just be disregarded."
          },
          {
            "time": "[00:03:46]",
            "text": "So, we want TypeScript to be able to help us out here. But we can't do this right now. Like if there was something else to import, maybe we could import it, we could use a type annotation here, and then it would start to catch our error. But as I said before, in this case, like all we have is, there's this class that I'm using and has a constructor."
          },
          {
            "time": "[00:04:10]",
            "text": "And the first argument of the constructor wants this thing. So we want to basically pull this type out somehow get a handle on it locally in our app code or our library code, we want to be able to give it a name and refer to it and use it as the type for variables."
          },
          {
            "time": "[00:04:29]",
            "text": "As if we just obtained it as an interface. So this is our goal. We want something like that. Something named that we can refer to, we just gotta get a handle on it first. And the infer keyword is what's going to let us do this. So it lets us abstract some piece of a type from a larger type."
          },
          {
            "time": "[00:04:55]",
            "text": "And before we go back to our Webpack example, which is very complicated, just the nature of that type is complicated. I want to work on an example that has the same approximate structure meaning it still is a one argument constructor. And we still want to obtain this thing, but all of the other noises is out and I think that if we solve this problem, we will also solve the same problem in the WebpackCompiler example."
          },
          {
            "time": "[00:05:26]",
            "text": "So we want to design some sort of type that takes fruit stand or some variant of it as a type parameter. And it emits array of strings. Right like, here's a class. Give me the first argument that the compiler or that the constructor receives. So this is actually the answer here and it looks quite complicated."
          },
          {
            "time": "[00:05:53]",
            "text": "We're going to pick it apart. You will understand every little piece of this syntax, but first I want you to accept that it works. So we've got this, this is sort of the answer here. We've got this fruit stand thing. And we've got like constructor Arg we pass in type of FruitStand."
          },
          {
            "time": "[00:06:14]",
            "text": "And what do we get out? The first argument that the constructor takes. Here's our WebpackCompiler example. We pass in type of that, and we get out. That's the type that we wanted this whole time. We wanted to sort of, grab that first argument, give it a name and we could Give this a name like this with the type alias, we could call it WebpackCompiler options if we want to."
          },
          {
            "time": "[00:06:39]",
            "text": "So this appears to work, it does work. Let's pick apart what all this stuff means here. So first we're just gonna build it up piece by piece. First we have a type alias and we're calling it constructor Arg. It takes a single type parameter, which we're calling C."
          },
          {
            "time": "[00:07:02]",
            "text": "It's gonna be C for class. Next, we want to create a conditional type and, we're gonna be analyzing the static side of a class, which is that's why up here, we're using type of right. That's to get the type of the class, not a type of the instance."
          },
          {
            "time": "[00:07:27]",
            "text": "And we want, To match that against something like this, right, this again is our any constructor type, right? This is this represents anything in JavaScript that is newable regardless of how many arguments it may take, regardless of what it instantiates. If you want to know more specific newable."
          },
          {
            "time": "[00:07:50]",
            "text": "You might put something over here, like any constructor that makes dates. Well, that's gonna be the date constructor. So, we started with this. So all we've added is the condition portion of what will become a conditional type. So this is we've already learned about this right we have our type puram."
          },
          {
            "time": "[00:08:11]",
            "text": "We're testing whether the type that C represents is included in the set that this represents. So is C in the set of all things that are newable. Now, we're about to make a little change that will make this a more specific type. But we want to collect that first constructor argument that this is where the infer keyword enters into the story."
          },
          {
            "time": "[00:08:36]",
            "text": "So we're going to change from accepting any arbitrary list of arguments to accepting a first argument which must be there and we're adding something here it looks like it's a new type parameter kind of, it doesn't it's not going to end up having to be part of our type parameter list."
          },
          {
            "time": "[00:08:57]",
            "text": "But typically we still use title case for this, right? And infer is to the left of it. So you can think of this almost like it's like a vacuum the end of a vacuum, right? We're gonna suck up whatever's here and call it A and after a we're prepared to have zero or more other arguments."
          },
          {
            "time": "[00:09:22]",
            "text": "We don't really care about those. But to maintain the flexibility of this thing that we're building will tolerate other arguments. You don't have to give us exactly a one argument instructor. Are our constructor we just want the first argument of any constructor. Now, the more keen eyed of you may notice, this is actually we've made this type more specific."
          },
          {
            "time": "[00:09:47]",
            "text": "So if we let me get both of these on the screen here, this type matches any newable, including zero argument constructors. This, you're gonna have to have one argument, right? This has to be present. I'm okay with that in this situation because the whole point is we're trying to obtain that."
          },
          {
            "time": "[00:10:09]",
            "text": "So if it sort of Nevers out, right, it sort of grounds out in the case where we use it with zero argument constructors like. I would say that it's a sign of misuse anyway, and that would be a reasonable result. There was nothing to obtain, so never. Right."
          },
          {
            "time": "[00:10:27]",
            "text": "So this is our condition here and now all that's left is for us to fill in what are we emit? What type do we evaluate out to if the condition It's true. And what do we evaluate out to if it's false. So in the case where our condition evaluates to true, we're able to use this type A, just as if it were a type parameter."
          },
          {
            "time": "[00:10:55]",
            "text": "So you can think of this kind of like it's in scope, right? You could use a here or you could use it here. But it's not just a placeholder like a label just so we can give this thing a name. So when people read our code, they can understand what's going on."
          },
          {
            "time": "[00:11:11]",
            "text": "We suck this up with our vacuum, and we can put it out here. Right? So we're saying if C, is a newable. Suck up that first argument that's passed to the constructor and give me its type. Now we need to put something here. And a good way to think about how we handle the other case, right the case where we turn up with nothing."
          },
          {
            "time": "[00:11:41]",
            "text": "We want to make sure that if we use this with a union type, with the or type It kind of disappears. And what I mean by that is whatever type we end up with here, right? Like if we evaluate out to this case, let's say that's x. I want wanna make sure that when we we evaluate an expression like this, we end up with just a string or number it kinda just, it's like multiplying by one, like just an identity thing where it's sort of like vanishes."
          },
          {
            "time": "[00:12:13]",
            "text": "That'll ensure that we're not adding noise whenever this type sort of plays with other types. So we can try that with any and look what happens when we do union any it swallows everything. Union any always swallows everything. The way I think about this, it's like if you send your friend to go to the grocery store."
          },
          {
            "time": "[00:12:43]",
            "text": "You're saying pick up three organic eggs, and 25 grams of some spice. And also get me everything in the store please. Well, you could have just led with that right? You could have just said, give me everything in the store. That's why this swallows everything. It's kind of like multiplying by zero in some way, in that if this is found in a union type, if you ever see this, it just makes the whole rest of the union type pointless because it's just going to evaluate out to any."
          },
          {
            "time": "[00:13:21]",
            "text": "So not only is this the wrong answer, this is not what we desire. It's like the exact opposite of what we desire. We want something that disappears, not something that dominates over and kind of takes over. The whole type. So if this gives us the exact opposite of what we're looking for, it makes sense to me to try the opposite of any, right?"
          },
          {
            "time": "[00:13:43]",
            "text": "So we're going to try this with never, and we in fact do get what we want. So when you're making these conditional types, in the case where something didn't match and you kind of just want to like escape out let's just like forget about it. Often you're just gonna want to admit and never type."
          },
          {
            "time": "[00:14:01]",
            "text": "Because that well, when used in a union type like this it will just disappear. No noise, so let's apply that to our constructor, our extractor, and we can see this is the answer. This is what we ended up with. So just again, to recap, it's a generic type that takes a type parameter C, we look at sea and we see If it's a newable, and if that newable takes at least one argument, we have a match."
          },
          {
            "time": "[00:14:42]",
            "text": "And in the event that we have a match, we're going to use our infer keyword which is like a vacuum. We're gonna suck up whatever's in that first argument, and we're going to put it in a box called A. And then, in the event that we had a match, we will always enter this branch."
          },
          {
            "time": "[00:15:03]",
            "text": "So you're always going to enter this branch, which is why you're gonna wanna use eight here. Often down here, you could put another ternary operator, you could chain these together. And you could say, well if it's a one argument constructor, we do this. Maybe if it's a two argument constructor, we build a tuple with the two things."
          },
          {
            "time": "[00:15:23]",
            "text": "You can sort of chain these together. It's normal by the way to see this chaining because, unlike in the value based JavaScript world, there is no more verbose and explicit equivalent to the ternary operator. We can't like expand this out into if then else. I know that some people don't like nested ternary is for that reason."
          },
          {
            "time": "[00:15:44]",
            "text": "So finally let's look at at the result here. So no matter what we use this type with, we can see that we get the result we're looking for. We get the first argument the constructor takes. So you can create a new date like literally new date. You can pass it a string, a date as a string, a number, which is like milliseconds since the epoch."
          },
          {
            "time": "[00:16:12]",
            "text": "And then you could create a date from another date here is the resolve and reject. you're used to seeing in a promise constructor. Here's our Webpack config. So now we have this ability to using infer, to suck up a part of a type and to obtain it and to create maybe a local reference to it in some way, taking this all the way to the finish line."
          },
          {
            "time": "[00:16:39]",
            "text": "If we go back to our first example, our motivating use case where we had the spelling error, and instead of just creating this object with inference taking care of the typing, we add this here we give it an explicit type annotation. As we've done right up here, we can see that not only do we get an error where we hoped we would get an error."
          },
          {
            "time": "[00:17:06]",
            "text": "TypeScript is found that there is a watch property and the word we used is pretty close to watch. So maybe it's a spelling error. Even guessing that it might be just a spelling mistake. So there you go. This is a great use of the infer keyword. And I use it all the time for this exact use case."
          },
          {
            "time": "[00:17:33]",
            "text": "Where I'm consuming some code and I wish I could obtain this type maybe because just for logging reasons or something, I want to like create the things that I'm passing into the function. First, log that out and then pass it in. And this is a great way even if those entities those types are not available for direct import by whoever made the library."
          },
          {
            "time": "[00:17:58]",
            "text": "That doesn't hold you back, you can still do this. So, be caution that I want to give you is in a very large app, be careful that you don't do this too too much, because it's not simple for the type checker to evaluate. And if you end up with with too much of this kind of behavior here too many conditional types, too much infer you can end up slowing down your the speed of your type of heads."
          },
          {
            "time": "[00:18:34]",
            "text": "Now that's not I would say only worried about this if you start experiencing that problem. It's not the kind of thing where, you want to make sure you avoid the problem so that you don't get out of control in the first place. Really, if you're looking to improve your performance, just make sure If you're not making like overusing this this feature of the language."
          },
          {
            "time": "[00:18:57]",
            "text": "But totally fair to use totally, the only tool for the job in many cases."
          }
        ]
      },
      {
        "name": "9-inference-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So Frank asks, this was a few minutes ago. So we made this type ConstructorArg, right, that was kind of what we ended up with, this was the last thing that we worked on in the previous chapter. Does the TypeScript team plan to make this a standard type, it seems pretty useful, same with JSON value in the last workshop."
          },
          {
            "time": "[00:00:26]",
            "text": "Yeah, this is a good point, and what I will say is that the bar is pretty high for including something in TypeScript itself. So we have, for example, Extract and Exclude, these are core types that are already in TypeScript. What I will say is there's nothing stopping you from writing your own types as a little library and importing that in the projects that you care about."
          },
          {
            "time": "[00:00:57]",
            "text": "For example, if I go to github.com/mike-north, how do I spell my name again? [LAUGH] Mike-north/types, you can see I have a little git repo here that is types, interfaces, and classes that I often use. And look, there's ConstructorArgs, so I bring this package into a variety of things that I work on."
          },
          {
            "time": "[00:01:26]",
            "text": "And some of these have made it into the language already, like at the time I wrote this library there was no required and there was no make everything optional, but I made my own. And as a result they're still here and that's fine, I'm not under pressure to get rid of these because these don't add to asset size, right, they just compile straight out, it's an identical type to what they have built."
          },
          {
            "time": "[00:01:57]",
            "text": "If we click that you can see that, well, we'll look more into this but It's just type information in a little JavaScript library. And if you would look at what happens with this kind of library when it's all bundled up, with one tiny exception here, so I create something called a deferred which is actually a class, right, so this isn't purely type information, a lot of this library is, right."
          },
          {
            "time": "[00:02:22]",
            "text": "But here, this is kinda like an inverted promise where whoever is holding the promise, they get to call resolve or reject from the outside, so it's gonna add a tiny little bit of asset size but nothing to be concerned about. So that's how I would answer this question, as you find things that are useful package them up and make them into little libraries that you can consume."
          },
          {
            "time": "[00:02:52]",
            "text": "I have one called JSON-typescript, and if we look at what this library contains it's very, very similar to what we built in the fundamentals class, right, this is an old school way that involves types and interfaces so this is compatible with TypeScript 2.8 even. I'm doing the same thing that we did in the fundamentals class, so all I have to do is install this package in a project and I can import stuff from it just as if it were a little library."
          },
          {
            "time": "[00:03:22]",
            "text": "If you wanna know how to set these kinds of libraries up robustly, and by that I mean if we look at this mike-north/types thing and the CI pipeline I have going here, I believe I'm testing against multiple nodes, like multiple versions of Node JS and multiple versions of the TypeScript compiler."
          },
          {
            "time": "[00:03:44]",
            "text": "And this means that as new dependencies are added, if you have dependencies here you're making sure that everything still continues to work in a very complete way. So this would be like I would be flattered and proud if you were to copy the infrastructure here and to use this for your own types, right, you just take everything in this source folder and modify it or add to it as you see fit."
          },
          {
            "time": "[00:04:12]",
            "text": "And feel free to open pull requests into mine if you think mine's useful and you wanna build on that instead, but this is sort of my own little mini standard library if you will. So we have three things ahead of us. Two more chapters in the website, and then I'm going to try to put everything kind of together in accomplishing a non-trivial task in the TypeScript playground, and that's gonna be building a little mini data layer."
          },
          {
            "time": "[00:04:40]",
            "text": "Because when we have different types of records, we have a lot of well structured type information and it's a place where we can take advantage of some of the things we've learned for high code reuse. So that's what we have ahead of us."
          }
        ]
      },
      {
        "name": "10-indexed-access-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about Indexed Access Types. The concept here is we're going to grab a piece of type information from another type using something that feels like a property key. So let's imagine we have an interface called Car, we can grab just the type of the color property here."
          },
          {
            "time": "[00:00:28]",
            "text": "Using, it kind of looks like the square bracket access notation for taking something off of a dictionary or accessing an element of an array. Note that although when working with values using the square brackets, we know that we can use .notation, right? So if we have a dictionary, and we saw this we probably say, well why don't you just doing like car.color?"
          },
          {
            "time": "[00:00:56]",
            "text": "That will not work here, this must be using square brackets. And you have to pass a string literal type into it. So there is some enforcement of a constraint here, so color is present on key of car. But look what happens if we use something that's not on car."
          },
          {
            "time": "[00:01:20]",
            "text": "So you'll get an error message. There is some validations helps catch spelling errors or if you were to remove something from car you think it's unused, then have confidence that all of these index access types will light up. And of course you can repeat this pattern, right? So if we only wanted to have the red part of car color, we could say give me color, and then within that just grab read."
          },
          {
            "time": "[00:01:52]",
            "text": "And so you could see these boxes, these square brackets applied over and over. Interestingly, if we pass a union type through this indexed access type, we get a union type out. So year is a number, color is red, green, and blue on an object. So you can see here it's, I call this projecting, right, you can almost sort of send your union type of keys into this index access type."
          },
          {
            "time": "[00:02:27]",
            "text": "And you get arguing union type of types of the values instead of types of the keys. Pretty straightforward concept, it's just sort of accessing a piece by name. And I know I use similar language to describe, extract, and exclude. Hopefully you can see the difference between what we're looking at here which is grabbing a chunk of an object type as is."
          },
          {
            "time": "[00:02:54]",
            "text": "As opposed to the conditional type with the infer keyword, where we were grabbing the constructor or looking at the construct signature, plugging up the argument out of that. That's a much more heavy handed way to do things behind the scenes it's also much more expensive to do things that way."
          },
          {
            "time": "[00:03:12]",
            "text": "This is cheap, this will not really affect your performance. Okay, last big concept and it's a big one, this is like a triple size section here, it's mapped types. So let's take a look at that."
          }
        ]
      },
      {
        "name": "11-mapped-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're about to see all of the concepts we've talked about today come together through something called mapped types. This is the most powerful tool, in my opinion, for transforming types, right, taking some type, making it another type in a very organized and deliberate way. Where does mapped types get its name from?"
          },
          {
            "time": "[00:00:26]",
            "text": "A great way to remember it is it's kind of like array.map, if you're familiar with that, in that what we're about to see it feels sort of like looping behavior. Where we're iterating over all the keys of something and we're producing a type for a value. Again, we're purely talking about type information here, but the mental model of array.map and looping through and providing that transformative logic that you'd define with the callback for array.map."
          },
          {
            "time": "[00:01:00]",
            "text": "That's conceptually gonna fit pretty nicely with what we're about to see here. Let's take a look at the basics. So if you recall from TypeScript fundamentals V3, or equivalent experience in the wild, index signatures. You've seen index signatures before, hopefully, and this is what they look like. Note that we have kind of an arbitrary word here describing a property key."
          },
          {
            "time": "[00:01:30]",
            "text": "It's an arbitrary property key with an arbitrary name, meaning for a dictionary, if I access any key at all, I'll get this value type out. And then here is the value type. So this is like a generic type for a dictionary. I mentioned this in the fundamentals class."
          },
          {
            "time": "[00:01:46]",
            "text": "I'll often say I want t or undefined here, because there's always a possibility that when you access something on a dictionary, it might not be there. And I want to keep myself honest and to make sure I check for the presence of a thing when I grab it out of a dictionary."
          },
          {
            "time": "[00:02:03]",
            "text": "So we could see here, we can create a what I'm calling a fruit catalog. It's a dictionary of fruits, it'll start out empty. Here I'm kinda illustrating the problem I just talked about. But when we access any key we wish despite the fact that this is empty, we see we get a fruit back."
          },
          {
            "time": "[00:02:21]",
            "text": "So this what we're passing in for the t and we're kinda threading it through. This is an index signature, we've already covered this before. I'm gonna introduce a new concept here. And why did need a new concept? Because the only thing an index signature allows us to do is say for an arbitrary key, here is the type you can expect to receive."
          },
          {
            "time": "[00:02:47]",
            "text": "What if we have something more specific than just a narrow string? Or sorry, something more specific than any string rather. What if we have a list of properties and we wish to use that and not just the Wild West like you could put fruitCatalog.turnip or whatever you want, right?"
          },
          {
            "time": "[00:03:11]",
            "text": "We don't want that, we want something a little more deliberate. Well, this mapped type is gonna allow us to do something like this. Now, because in my mind at least, when I say the word dictionary, that means this very flexible key value store where I can hang whatever I want on an arbitrary key."
          },
          {
            "time": "[00:03:30]",
            "text": "So I'm gonna actually call this something different, given that we're no longer gonna be in the world of arbitrary keys. We have a set description of the keys we wish to use and then we have some value types. So we're gonna call that a record, and to avoid collision with something that exists in TypeScript already, I'm gonna call this MyRecord, right?"
          },
          {
            "time": "[00:03:53]",
            "text": "Just to avoid colliding with an existing type. So here's what's going to change. This is our interface as before, and here is the new signature. And we can look at these side by side in a moment. But for now, I want you to look at the fact that when I access cherry and apple, I get a type of fruit that's coming out."
          },
          {
            "time": "[00:04:19]",
            "text": "But when I try to access pineapple, we get nothing. Pineapple does not exist on MyRecord, and cherry and apple are here. So it seems that we're able to say, here are the specific property keys that I wish to use. Whereas with the index type, it was kinda like put it anywhere in this object and I will hold it for you."
          },
          {
            "time": "[00:04:43]",
            "text": "So let's compare these two signatures side by side. On the top, we have this mapped type and on the bottom, we have the index signature. And I've hidden out the type for the value here, because really, that's not what these signatures are all about. We can put whatever we want there in that dot, dot, dot."
          },
          {
            "time": "[00:05:03]",
            "text": "We'll talk about that later. Right now let's just look at the stuff that's on the left side of the colon. So index signature, the name doesn't really matter. I mean, you can put something there if it will help the reader understand what you're trying to do, maybe it's customer ID or something like that."
          },
          {
            "time": "[00:05:23]",
            "text": "Something that has some meaning to the reader, but it's not as if you're referring to this value anywhere. You're not saying name doesn't matter dot whatever, you can't use that. We're gonna see later that in this mapped type, we're able to use this. So giving it a name and making that name descriptive is a little bit more important."
          },
          {
            "time": "[00:05:44]",
            "text": "So here we have a colon in a regular index signature, and here we have this word in. And you can think of, when I talk about looping behavior, think of this union type as what we're looping over. And think of this as your i, right? For i equals 0 and loop over this."
          },
          {
            "time": "[00:06:08]",
            "text": "Or if you're doing a for in, right, where you're like, const key in dictionary. Fruit key is first gonna be apple and then it's gonna be cherry, and we're kind of processing, at least mentally we can think of it as a loop. Now remember, this is just type information."
          },
          {
            "time": "[00:06:29]",
            "text": "So there's no code that's being run and looping. There's nowhere you could put a break point to see what's going on. But the mental model of looping will hold up here. So mapped type lets you be more constrained and specific. Index signature, by its very nature, is about defining arbitrary key value relationships, different tools for different jobs."
          },
          {
            "time": "[00:06:54]",
            "text": "One's not necessarily better than the other. But if you were to say FruitKey in string, you would now be using a mapped type that is equivalent to the index signature below. Cuz it would just iterate, it would say like for every string, every possible string, here is the way I defined my value type."
          },
          {
            "time": "[00:07:17]",
            "text": "If that statement is not proof, that statement should be proof that there is no real looping that's happening behind the scenes. Because there's no way to iterate over every possible string in JavaScript, not in a way that will perform. There's just no way, let's just say there's no way."
          },
          {
            "time": "[00:07:36]",
            "text": "It's sort of a projection but it feels like looping to us. We can think of it as looping. So the in keyword, it's a telltale sign you're dealing with a mapped type. And index signatures, you can only define them on arbitrary strings or arbitrary numbers. That's it. And look what happens if we try to be more constrained in a regular index signature."
          },
          {
            "time": "[00:08:01]",
            "text": "We're literally told that these error messages are getting better with every release, consider using a mapped object type instead. If we attempt to do the thing that mapped types are designed to do, or we're doing it the wrong way, we're told, just go make a mapped type, please."
          },
          {
            "time": "[00:08:21]",
            "text": "Cool, so that's the difference. Seems like an index signature builds on top of that concept, but it's different. So, let's make our MyRecord type just to show what that is, right? This is not generic yet. It very specifically operates on apple and cherry, and it very specifically operates on fruit."
          },
          {
            "time": "[00:08:44]",
            "text": "Let's make that a bit more generalized. So what we're gonna do is replace this fruit key thing, right? Where it says FruitKey in apple or cherry. So let's rename that to key, down here. And then we're gonna pass in this apple or cherry thing. We'll make that a type parameter here."
          },
          {
            "time": "[00:09:04]",
            "text": "We'll call it the KeyType. And that'll be the first thing. And then this thing to the right of the colon, you've got this fruit. So we wanna make that generic. We'll pull that into a type parameter as well. So that's all we're doing. And by the way, this is from an experienced practitioner of TypeScript."
          },
          {
            "time": "[00:09:25]",
            "text": "This is a good pattern to follow, implement the non-abstract thing, and then start pulling things out to make it parameterized. It's a good way to make sure that you at least can affirm that continues to work with the use case you care about. So now we'll end up with something like this."
          },
          {
            "time": "[00:09:47]",
            "text": "It's much more generalized where we can specify here that we can pass in something like apple or cherry, right? Pass that in as strings. Kind of like those will be the names of the properties. This will be the values, the value of the property. And then it's almost like we're looping over everything in the key type we passed in."
          },
          {
            "time": "[00:10:13]",
            "text": "First apple, then cherry, and then we're giving this type. We're giving it a value type on the other side. Now, this is already built into TypeScript, but now you understand how it works hopefully. So it's called Record. And I want you to look at these side by side and see that aside from this, the names of these properties, which I've tried to be just a bit more descriptive than single letters."
          },
          {
            "time": "[00:10:44]",
            "text": "We had the same form here, with one exception, and that's like this keyof any. But down here, you can see that like, these are the types of keys that JavaScript allows. You can have numbers, symbols or strings, and that's it. So I've just said, okay, well, strings, this is most of the stuff I care to work with here has property keys that are strings."
          },
          {
            "time": "[00:11:08]",
            "text": "So that's a difference in the constraint, but doesn't make things fundamentally different. And then we have key in, some type that we passed in. So this is property key in K, well, there it is. And then there's the second type of param, and there it is. And here's our second type of param, and there it is."
          },
          {
            "time": "[00:11:29]",
            "text": "So really, what we're able to do with this mapped type is build up an object with a set of known keys that have a consistent value type. That's the first use case for this. Now, why might you care about this? Well, sometimes you want to maybe have a bunch of form fields and they each have sort of a value and whether they're validated or not."
          },
          {
            "time": "[00:12:05]",
            "text": "It's great to have a nice dictionary like this, especially if you're pre-creating one and you know exactly what you expect to be there. I'm blurring the line here between a record and a dictionary. But this is a quick and easy way to go ahead and create one. I would say this is a subtype of a dictionary."
          },
          {
            "time": "[00:12:28]",
            "text": "A dictionary is flexible in that you can have arbitrary keys and this has specific keys. So this is just a more specific thing than a dictionary."
          }
        ]
      },
      {
        "name": "12-advanced-mapped-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Now let's combine this knowledge with what we just covered in the previous chapter, and that is an indexed access type. So what I've done here, and I apologize that the tooltip is kind of adding a big gap in the code, but this is just one type here, right?"
          },
          {
            "time": "[00:00:23]",
            "text": "What we're doing here is we wanna grab a portion of the window API as in the global that's available in a browser. And when do I do this? Well, especially if I'm writing code and I expect to make my tests nice and easy through dependency injection, I kinda want to limit myself to accessing only certain things on Window."
          },
          {
            "time": "[00:00:54]",
            "text": "So that I make sure that if I have to stub them in tests, or maybe if this is a single page app that I have to server render, well, there in the node world I might have to stub like polyfill some Windowish things so that the thing renders properly."
          },
          {
            "time": "[00:01:12]",
            "text": "But I wanna give myself sort of a explicit boundary so I know whenever I cross it. I can show you after we go through this a more real world example involving Chrome extensions and their Chrome extension API's. So great. So we have, we gonna call this part of Window and what we want is to grab only, we want something that looks like Window but it only has a couple things that can be found."
          },
          {
            "time": "[00:01:46]",
            "text": "So we're saying we're looping over these three things. So it's sort of almost like four each of these three, key is gonna be these sort of one at a time. And now we're using an indexed access type, right? So key is first gonna be document. So we're using Window[document], and we're gonna get this document type."
          },
          {
            "time": "[00:02:11]",
            "text": "And then the same thing for navigator, and then the same thing for set timeout, right? Here's the callback, and then here's the timeout number, and then here are the the arguments that are passed to the function. People, this is a rarely used aspect of set timeout. But ultimately, we get a subset of Windows, we get a portion of it, only these keys that we're interested in."
          },
          {
            "time": "[00:02:42]",
            "text": "So again we're gonna make this a little bit more generalized by pulling hard coded things out into typeparams. So the first thing we'll pull out is, we wanna pull out the keys, right? So that's this list of things here. So now we've got like Key in Keys, and that's a typeparam up here."
          },
          {
            "time": "[00:03:05]",
            "text": "And note that we're saying, Keys extends Key of window. Why do I want this, well pop out to the playground just so we can see it for ourselves. What if I did this? I would wanna be told, sorry, it's a pipe. I would wanna be told that zzz it's not a thing that could be found on Window, it's not found on Key of Window, Right?"
          },
          {
            "time": "[00:03:36]",
            "text": "A deliberate spelling error. If I took this away. Well the error would pop up in a different place. But now I'm being told hey, hey, hey, you can't just use Key as an index access type here, how do I know that that stuff's gonna be found on Window?"
          },
          {
            "time": "[00:03:56]",
            "text": "You could say hey it's a string, but so the first error is Keys, it could be a promise it could be a function, there's no constraint on Keys. I can't use that in a match type cuz can only use things that are like property keys, right? This is a core constraint of map types."
          },
          {
            "time": "[00:04:15]",
            "text": "It's about a property Key and looping over them. So even if I solve that by saying, It's a string, now this piece is gonna say, well, how do I know that these are things that I can get off of Window. It could be an arbitrary string. So that's why we have this in place just kinda makes everything work."
          },
          {
            "time": "[00:04:38]",
            "text": "It's not only a valid property key but it's the subset of all allowable property keys in JavaScript that will work with Window. And now, theme coming back, right? The error is popping up at the location where I apply my fix because I have misspelled this, and now things start to pass."
          },
          {
            "time": "[00:05:00]",
            "text": "So that's why you can see kinda how if we relax this, things will start to get angry in various places. This has to be a valid property key and hen this has to be a valid property key for Window. But we can get the same result out now, right?"
          },
          {
            "time": "[00:05:26]",
            "text": "So we had part of Window, this was hard coded for these three properties. So we made something here called PickWindowProperties, that's the more generalized thing, and then we can leverage that. So this is the general solution up here. We can get our specific solution back by saying, I wanna pick things off of Window, and here are the names of the properties that I wish to pick."
          },
          {
            "time": "[00:05:53]",
            "text": "Let's generalize it one step further by abstracting Window away. So we're gonna get rid of this and pull it out to a typeparam. So what we've done here, instead of calling it pickWindowProperties, we're just calling it PickProperties. And just as before we have these Keys that come in, I've actually moved it to the second type parameter, up here was the first, right?"
          },
          {
            "time": "[00:06:18]",
            "text": "I mean, it was the only one but it's in the second position now. So we have a valueType and then we have Keys, where these are Keys that are found on this valueType. And I'm using this map type here. So previously we were seeing what Window[Key], and now we're seeing ValueType[Key]."
          },
          {
            "time": "[00:06:42]",
            "text": "And we're still able to get our specific result here. Because we're parsing in Window, this is the thing we're plucking properties off of, and these are the names of the things that we're kinda peeling off. Let's open this in the playground. So I don't wanna talk about why I ordered these typeparams in this way."
          },
          {
            "time": "[00:07:11]",
            "text": "If I tried to reverse them, I might run into a problem, actually does this work now? That would be pretty cool. Wow they fixed this. All right, well, you'll still see stuff written the other way and I can kinda explain the rationale behind it. Just poking at it making sure, something's not right here."
          },
          {
            "time": "[00:07:39]",
            "text": "Let's see, I need the comma and then I think it'll work. Yep, okay, so it seems like this has been relaxed. But previously, you kinda had to state upfront. If I wanted to use ValueType in an argument, we first had to state the typeparam has to exist first, and then we can refer to it as a constraint for another typeparam."
          },
          {
            "time": "[00:08:07]",
            "text": "But it appears that recently they've relaxed this, which is kind of cool. That would let us build this API signature the way that we want, and in this case, just in terms of how you could read this out loud, I kinda like like this better. So I want to pick the properties document, navigators, setTimeout, setInterval from Window."
          },
          {
            "time": "[00:08:30]",
            "text": "And I like that rather than saying I want to pick the following things from Window, here are the properties that I want. You have both options available to you now. All right, Tristin asks a good question, in fact you've asked it twice and you've been very patient. So mapped types do they extend from dictionary, and since mapped types are a subset of a dictionary that extends word is still strange to me."
          },
          {
            "time": "[00:09:03]",
            "text": "So I would encourage you to think about this in terms of set theory. So if you imagine all of the dictionaries that could be in the universe. So things like this, right? All of these with all the possible property keys and all the possible ValueTypes. Some of them, [LAUGH] Some of them will be full of stuff, some of them will only have a couple property Keys."
          },
          {
            "time": "[00:09:41]",
            "text": "When we talk about something that is more constrained than this, more specific than this, we would say that it extends from this. So when we talk about mapped types kind of extend from their dictionary equivalents, you can think of it as, Dictionaries are more flexible than mapped types."
          },
          {
            "time": "[00:10:09]",
            "text": "So if I had, Or well, say this is a dictionary, Of dates, So it starts at empty. And then this will be, A index signature. And this is gonna require that I do a new date. Start of week is a new date. And I'll get rid of this little side panel here."
          },
          {
            "time": "[00:11:04]",
            "text": "Okay, so just looking at this code here, I would say that this dictionary is more flexible and more general than this type here, why? This has no opinion about which Keys dates are stored under. This one does have an opinion. So if I change these to let declarations, This is gonna be a problem."
          },
          {
            "time": "[00:11:36]",
            "text": "Because we can't, when we say I have a slot that's designed for a record, what guarantee do we have that end of week and start of week are here? We don't have that guarantee. Whereas in the other direction, Totally fine, why? The dictionary is ready to handle start of week, end of week, start of year, end of year, whatever you want."
          },
          {
            "time": "[00:12:03]",
            "text": "So that's, we see a Key insight here that records, these records are more specific than dictionaries. And when we talk about this extends word that's used in type parameter constraints, and in these conditional type conditions, the meaning of extends is, Something like this. We're saying is T, are all values that we could possibly have for T, to all of those satisfy what is described by date."
          },
          {
            "time": "[00:12:48]",
            "text": "And date could have many others that don't satisfy T, but does everything in the set that could be a possible T? Does all of that fit into date? So really we're saying, is T a specialized flavor of date? Is it a more specific version of date? It's a really tricky conceptual thing to get over, so I would encourage you if you're still having trouble with this, please ask more questions."
          },
          {
            "time": "[00:13:16]",
            "text": "Please keep kind of poking at this because it's one of these big lightbulbs that when it turns on, things become much more clear pretty broadly across the language. So now that we've generalized this let's look at what we have. We have a mapped type where we take two typeparams here, right?"
          },
          {
            "time": "[00:13:35]",
            "text": "So we take a value that we're plucking things off of this previously was Window. And then we have some union type potentially, that is one or more Keys that are found on this ValueType. And we're iterating over those Keys, and we're plucking the values off and this is what we get."
          }
        ]
      },
      {
        "name": "13-pick-mapping-modifiers",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Well, we have arrived at another built- in type that TypeScript includes, and that is Pick. So if we look at the built in pick up here, and the pick properties that we made, they're basically the same type parameter names aside. ValueType is going to be the T, as you can see it here and you can see here,ValueType is here, and here or also, there's a Keyof T and a Keyof ValueType, and then here we're creating over the keys."
          },
          {
            "time": "[00:00:36]",
            "text": "So that's how pick works. It like where for record, we just needed the map type. Here we're using this indexed access type to grab something off of something else, if that makes sense. We're using that square bracket notation. We're saying, here's document, give me document, right? Record if we look at it one more time, it was just a consistent thing we were always placing there, like, it's always going to be the same."
          },
          {
            "time": "[00:01:15]",
            "text": "Whereas here we're kind of like Were using a different key. And so as a result, what comes out like these are obviously different types. Document, navigator, set timeout. That's what this index access type gives us when used with a map type. Let's talk about mapping modifiers. These are just kind of something potentially to memorize or just remember that it exists, but not not an incredibly abstract concept."
          },
          {
            "time": "[00:01:46]",
            "text": "So, the way to think about this is, as we loop over in our map type, as we loop over all the keys, we have the option to determine whether the ValueType should be read only or optional. There are two independent things. You can be read only and optional or you can be non optional and writable like they're totally independent."
          },
          {
            "time": "[00:02:15]",
            "text": "So, you're gonna see that we will find a question mark in some of these code example and the word read only. So here, this is a built in type. We're going straight to the built in types here because these are kind of less interesting to build up. But this is the key."
          },
          {
            "time": "[00:02:33]",
            "text": "This is the thing that makes partial different from pick. While there are a couple things, first off. Pick, lets see you specify which keys you would like. Here, we're iterating over all the keys in type T. And over here, we're saying the value may or may not be there."
          },
          {
            "time": "[00:03:02]",
            "text": "So that's partial, and this is the opposite of partial. The only thing that changes is we have a minus sign. It's almost like we're removing the optionalness as we loop over. This is a very weird thing like, a rare thing to for you to put into your own types."
          },
          {
            "time": "[00:03:19]",
            "text": "But that's how this works, right? It's just that and then read only here. So this would, it doesn't really freeze the object. Just remember that TypeScript disappears as part of your build process. And so at runtime like this might actually be a writable thing. But this would type check it."
          },
          {
            "time": "[00:03:42]",
            "text": "So create a version of something that is read only. Maybe it's an options, object that you're passing to function or some object you're passing in a function. You want to make sure that you don't modify it, like mutate the thing that you were passed, you might make it read only so that when you receive it, you'll be called out."
          },
          {
            "time": "[00:04:02]",
            "text": "If you ever try to mess with something that really should live in your stack, right? Now there's no built in type for removal of read only you could implement it like this, but is not necessarily a good idea. It's probably if someone made something read only, might want to figure out what that reason is they probably don't want it messed with."
          },
          {
            "time": "[00:04:27]",
            "text": "But just showing you that there is continuity here in terms of question mark and read only they both work with this minus sign. Just know that the positioning of these. So this is fairly easy to remember because it's the same location of that question marked as optional class fields or optional object literal properties."
          },
          {
            "time": "[00:04:51]",
            "text": "And read only that's always to the left cuz it's kind of like where you would put an access modifier keyword in a class field or a method it's like public read only function,."
          }
        ]
      },
      {
        "name": "14-template-literal-types-key-mapping",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Template literal types. Not deserving enough of its own section I don't think, but a kind of a cool thing. It's a recent addition to TypeScript. So as of the time of filming this course 4.3 is the most recent TypeScript release. So template literal types have not been around for all that long."
          },
          {
            "time": "[00:00:26]",
            "text": "But I would like to show them to you because especially around data layer stuff they are really, really promising. They look like a great way to make highly reusable things. So we're going to experiment with them here. I have first, a type that I'm calling ArtFeatures, things that could appear in a painting, and then I have colors."
          },
          {
            "time": "[00:00:56]",
            "text": "So using the same syntax that you're used to using for ES template literals, by that I mean the backtick strings where you can interpolate non-string values into a template string. We can create what's called a template literal type. And what we're seeing here, so first, let's look at the syntax."
          },
          {
            "time": "[00:01:20]",
            "text": "We've got the backticks here. We have the dollar sign single brace, we're used to seeing that, right? And what we get, it's sort of every combination of color and paintable art feature. So we've got a darkSienna_cabin, darkSienna_tree, darkSienna_sunset, and now we're going to sapGreen_cabin. And it keeps going and going and going."
          },
          {
            "time": "[00:01:45]",
            "text": "When I showed this to my wife, she said that looks like a factorial. That will tell you how many of these you're going to get, right? It's every possible combination, how many unique combinations you'll get. But these are not good, in terms of, sorry, these are not idiomatic JavaScript method names, right?"
          },
          {
            "time": "[00:02:11]",
            "text": "I'm calling this art method names and look at those types, we don't use snake case, right? Not in JavaScript, I mean you totally could. The language supports it, but it's much more conventional to use camelCase. So how would we accomplish this? Well, you have a couple little special things, special transformers of these elements within your template literal type that would let you do something like this."
          },
          {
            "time": "[00:02:42]",
            "text": "Capitalize colors and we've removed the underscore but look at the d in darkSienna. Despite up here it being lowercase, right, the first letter's been capitalized and so we can get some nice method names here. Not a coincidence by the way, the feature set was built such that you could have lowercased property names and then maybe have getters and setters."
          },
          {
            "time": "[00:03:08]",
            "text": "And you want when people are using your code to be able to use these as things that feel like they were painstakingly implemented one at a time when really, it's just sort of an a times b. And here is the format of the string that I want. So why am I talking about this in a chapter of this course called mapped types?"
          },
          {
            "time": "[00:03:33]",
            "text": "Well, let's bring it back to mapped types. So what we can do here, some people call this key mapping. And effectively if we go back to our analogy of array.map, when you use array,map, you are converting the values of array A to array B, right? You're just converting the values."
          },
          {
            "time": "[00:03:56]",
            "text": "This lets us manipulate the keys as we're making that transformation. Let's see what happens, right? So here's the mapped type, right? I'm saying I'm iterating over each key and by the way, let me introduce this before [LAUGH] we go too deep in here. Let's say that this is just some piece of data, a record that I persist to an API somewhere."
          },
          {
            "time": "[00:04:23]",
            "text": "I've got an array of numbers, I've got an array of strings, and then this flags thing is a record of Booleans. So I'm gonna pop out into the TypeScript playground, we can play with this. Data state.so we've got digits, which is a number array, here's flags. So I've got dark mode and mobile, those are each a Boolean, maybe little user preferences that someone could turn those on and off, right?"
          },
          {
            "time": "[00:05:01]",
            "text": "Here I'm just being yelled at because I'm using this before it's been assigned. But it's equivalent to, Equivalent to something like that. We already talked about record but just bringing us home there. So what this lets us do is we're iterating over all of the keys in this data state interface, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "So that's gonna be first digits, then names then flags, and then we're using this as keyword, as is how this remapping can happen. And we're adding the word set in front of it and capitalizing, so we get a little method here that's called setDigits, setFlags and we can pass these things in."
          },
          {
            "time": "[00:05:52]",
            "text": "So if you've written data layer code where you have a bunch of Boolean properties where it's is, is dark mode, is user opt into beta. Well, you could see how you can now in a very generalized way derive some controlled accessors for those kinds of things. Maybe you would use object.defined property to dynamically build something and then be able to represent the types accurately."
          },
          {
            "time": "[00:06:29]",
            "text": "Let me show you a library where I would hope one day they'd use something like this to define types. This is my favorite library for colorizing CLI stuff in JavaScript. And basically, to make this string blue with a red background, you do .blue, and then look at this, bgRed."
          },
          {
            "time": "[00:06:55]",
            "text": "So every colors available as a foreground or background. And now instead of explicitly saying we've got the red and then we've got here's the red and then here's the bgRed. But now you could define this template type that would just add bg capitalized, the R in red boom, and now you can make a really nice API."
          },
          {
            "time": "[00:07:17]",
            "text": "And this library is a pleasure to use, it's very easily proves that you can build beautiful and highly ergonomic APIs. Not rest APIs but functional APIs using this kind of technique. And look, we're now back to catching spelling errors again, we get true type checking here, because I left the E off of mobile and TypeScripts figured that out."
          }
        ]
      },
      {
        "name": "15-filtering-out-properties",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Finally, the last sub part of mapped types that I'd like to talk about is, how do we filter properties out? So, we've already seen how we have some control over what is included via filtering the property key, right? So we used extract before, and we can actually, this is pretty cool."
          },
          {
            "time": "[00:00:26]",
            "text": "We can use a template literal type, almost like a query tool here to say, show me those keys of document that begin with the word query. That's pretty cool, right? It's almost like a find the substring like a regular expression, right? Which of these keys begins with query because it's any string that begins with query."
          },
          {
            "time": "[00:00:56]",
            "text": "That's what we're matching against. So we get all these QueryCommandEnabled, querySelector, querySelectorAll, etc. So those are the keys of interest and we can produce a filtered version of this document type. Meaning we only get those properties that are specified by the keys of our choosing, because that's what we're iterating over, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "We're saying K is each of these 1, 2, 3, 4, 5, 6, 7 things, right, to each of these seven things. For each of them, we'll go look at the document, get the value type, and that's what we're gonna have there. So this is one mechanism of filtering, if the key is the determining factor, but what if we want to filter based on the value?"
          },
          {
            "time": "[00:01:46]",
            "text": "For example, what if we wanted the things on the document object that are functions who return either an element or an element list, right? And I'm kinda thinking about querySelector and querySelectorAll, just things that we use for retrieving or creating DOM nodes. Now, in advance, I couldn't tell you which keys, I mean, I can tell you querySelector, querySelectorAll, are gonna be included."
          },
          {
            "time": "[00:02:14]",
            "text": "But I can't tell you which things those would be, right? So we're gonna need to think about how to approach this. And first, we're gonna go down the wrong road. So I wanna be very clear. I'm showing you something that doesn't work, but I think it's a useful midpoint as we approach a better solution."
          },
          {
            "time": "[00:02:37]",
            "text": "So first we're going to use never, we're gonna use a flawed approach. Here's a disclaimer, don't copy and paste this code into your app, please. We're gonna use a flawed approach and use a conditional type with a mapped type, In order to do this filtering, so I'm gonna read this to you in pieces."
          },
          {
            "time": "[00:03:00]",
            "text": "So we're iterating over all of the keys of document and we're performing a test. What's the test? What's our condition, is the value type for a given property key. It doesn't extend. Right, is it at least a function with an arbitrary number of arguments that returns either an element or an array of elements."
          },
          {
            "time": "[00:03:29]",
            "text": "This condition is the right one for sure. This will be represented in our good solution in a moment. So we're comparing this to see if it matches what we're looking for. And if it does, we let it pass through Document [K], right? And if it doesn't, we say, never, hoping it will disappear."
          },
          {
            "time": "[00:03:53]",
            "text": "But it doesn't, as you can see up here, we end up with every single property that is on document including 235 that have been suppressed. And although the things that match, I mean they're still usable, right? We don't say never hear. It's totally usable. Although that still works, it's not really gonna help us when it comes to autocompletes."
          },
          {
            "time": "[00:04:22]",
            "text": "We're gonna go here and we'll say, okay, let's see what subset of things I have available. That's a never these are all nevers, it's just a bunch of noise, a bunch of garbage in here. AppendChild, is that one of them. So that one didn't get zeroed out. But these gotten zeroed out, it's just a bunch of junk in here."
          },
          {
            "time": "[00:04:42]",
            "text": "It's not giving me good feedback as to what I can successfully use. So, hopefully we all agree, undesirable result. How can we make this better? A better approach is gonna involve filtering those keys first. And then once we have the set of keys that match our condition which is gonna be a value based condition."
          },
          {
            "time": "[00:05:12]",
            "text": "Then we'll be in a position where we can get something that looks more cleaned up. And I first want you to witness that this works and we're gonna peel it all back, and build up to it slowly. So when I say that this works, first, there aren't over 200 things here and the things that are here, I can't spot any nevers on my screen."
          },
          {
            "time": "[00:05:40]",
            "text": "So let's compare, there's seven more and up here there were 235 more. So it seems it's much more filtered down. And I'm gonna also sanity test and say, well, adopt node, create element, querySelector, do these things, do they feel like they're for DOM query, or DOM element creation?"
          },
          {
            "time": "[00:06:02]",
            "text": "Yes, just on a conceptual level these seem like what I was looking for. And then finally down here, this was one of the things I selected. So, I'm gonna kick out to the TypeScript Playground. And this is the kinda thing I would encourage you to pop this open on your own machines and follow along with me."
          },
          {
            "time": "[00:06:25]",
            "text": "Because what you're about to see is somebody who's familiar with working with these kinda types, me. You're gonna see how I deal with this thing up here, which is nutty and complicated, and hard to debug. And you're going to see how I make progress towards getting it to work."
          },
          {
            "time": "[00:06:53]",
            "text": "Because as, if you've been playing with this throughout the course, there's no debugger for types. This is not really code that runs, you're just defining constraints. So when things get complicated, and this is the equivalent of having many things on the same line of code, right? Where it's just doing a lot, one higher order function that does everything."
          },
          {
            "time": "[00:07:15]",
            "text": "It's really challenging to troubleshoot. So you're gonna see how I peel this back and how I can start with breaking this up into simple small things. And layer my way up into the thing that eventually is going to work. Okay, so I'm gonna actually come and add our solution and create a copy of it."
          },
          {
            "time": "[00:07:40]",
            "text": "So the approach that we wanna take here is, we want to select those keys, whose value type is what I'm looking for, right? So, we wanna go and find query selector and identify that is what we want. Because document.query selector is matching the condition that we're filtering for."
          },
          {
            "time": "[00:08:09]",
            "text": "We're not just picking it because of its name we're picking it because it has a value. That is what we're looking for. And that value is this. And I'm actually gonna deviate from our written solution there for a second just to add some more verbose, a greater explicit set of information here."
          },
          {
            "time": "[00:08:33]",
            "text": "So we'll just call this, ElementFunction, Element, and it's this, right? Just so we can refer to it by name and we get some of that punctuation out of our way. So we can take ElementFunction, we'll put it here, cuz that was working, cool. So FilteredKeys, I'm actually gonna get rid of this for now."
          },
          {
            "time": "[00:09:09]",
            "text": "All right, so let's look at this here. So we're taking in a type, right? The fact that we see keyof T, here and T[P], this is gonna be the thing we're iterating over. So let's call it, We'll call it ToFilter, right? We're filtering this thing. And then you will call this, Condition, something like condition, right?"
          },
          {
            "time": "[00:09:50]",
            "text": "It's the type that represents what we're trying to match. So we're going to loop over all of the keys. And then this is our little i in our for loop, right? For each key, this is our parameter, see that parameter in the tooltip? P for parameter. We're gonna go and grab the value type out of whatever we're filtering from."
          },
          {
            "time": "[00:10:20]",
            "text": "We're going to check it against the condition, right? Is the value type assignable to whatever we passed in? It's gonna be this, right? Is it a function that returns an element or an array of elements? And if so, this is weird, we've never seen this before. We saw a whole bunch of code that would do this, Right, we're like, did it match the condition?"
          },
          {
            "time": "[00:10:47]",
            "text": "Let it pass through. No, that's not what we're doing. If it works, if it passes the condition, we're sending the parameter through. This is the key, not the value, otherwise, never. So look at what we get out here. And let me make a smaller type so we can see this more easily."
          },
          {
            "time": "[00:11:10]",
            "text": "So we've got this, and we'll call this RelevantColorKeys. And we're going to filter for, Actually those should be numbers, right? Just let's keep it consistent with way I've treated colors throughout the day. Look, green number, save, so FilteredKeys. So we've got this color, that's what we're filtering over."
          },
          {
            "time": "[00:11:43]",
            "text": "And let's just make sure that everything passes straight through the way it should. I mean, I expect this to of course work, great. So everything passes through when I remove that condition. And then if this extends this condition, I should see P, what if we did this? You know what, I'm also gonna comment out."
          },
          {
            "time": "[00:12:15]",
            "text": "No, I have no idea why this would interfere with anything. So, okay, so we're back on track here. Now I can explain what's going on here pretty easily now. So, we're iterating over all properties of Color, right? We're looking at red, we're looking at green, we're looking at blue, and we're comparing them against number."
          },
          {
            "time": "[00:12:41]",
            "text": "We're comparing the value types against number, right? So this is number, this is gonna be here. This will be red, and then this here, it'll end up being a number. So if we were to do this, string, string for red, And then string for blue, now we can see that our RelevantColorKeys."
          },
          {
            "time": "[00:13:06]",
            "text": "So green is gonna kind of pass through. And then look everything else turns to a never because they don't match. Now, what we want are the property keys. Right, so we're still getting this object type out, we want the property keys. Well, we can take advantage of the fact that an indexed access type, we can send, we can sort of project something through an index access type."
          },
          {
            "time": "[00:13:33]",
            "text": "So I get this object type out. What if I did this? I just get green. So, it's almost like I'm starting with this and then I'm saying, okay, if I pass in the key of, right, it's just gonna be never, or green, or never. And remember, whenever we or with never, the never disappears."
          },
          {
            "time": "[00:14:14]",
            "text": "Nevers disappear when you or with them. So if we just simply say keyof Color, we're basically saying, I'm gonna transform all of the keys of color, a union type of all of the keys of color. And I'm gonna project them through this. And I'll get a union type of all of the values, but not all the values of color, cuz we've sort of modified it a bit here."
          },
          {
            "time": "[00:14:40]",
            "text": "We'll get all of the values of this, in a union type, never, or green, or never. And that's why we get just green. Now, we can actually move this up here and say keyof ToFilter, And it'll still be green. So now if we uncomment this and these, I think there may be one last thing we have to do, and there is."
          },
          {
            "time": "[00:15:15]",
            "text": "So our last problem to solve here, we've hit this before when using index access types. And basically it's saying that, look, I see you have this thing here. It's all of these keys, but they've passed through a couple things by this point. How do I know they're still key of document?"
          },
          {
            "time": "[00:15:36]",
            "text": "If you're gonna reach into document and access, if you're gonna use this thing here, how do I know that that's gonna work out? Well, the way we handled that before, was we said, hey, look, if you don't trust me, I mean, I know if we look at the keys of document and we look at what I have, they overlap completely."
          },
          {
            "time": "[00:16:00]",
            "text": "Meaning, Everything I have is included in the set of possible keys. So I'm happy to do this. I know it's a no up, but if it makes you comfortable, all the better. And now we are, I believe, should be where we need to be. Key of document, yep, and there it works."
          },
          {
            "time": "[00:16:23]",
            "text": "There's our query selector, returns an HTML input element. And look at that, this is just what we wanted. It's like a subset of document that only relates to DOM manipulation. So imagine now if you have a React app and you've ever done server side rendering, you know that sometimes you have to do some node stuff maybe you register a service worker, or some code runs and it's like, you tried to reach into window and it's not there."
          },
          {
            "time": "[00:16:51]",
            "text": "Well, this would let you kind of put some confines around that API that you're not supposed to be accessing if you're trying to serve or render your React app. Another example, here it is, so I built a Chrome extension recently. And when I'm defining the parts of the extension API that I wish to talk to, I make sure that, I don't want to reach in and touch too much."
          },
          {
            "time": "[00:17:22]",
            "text": "Because although I can use a lot of things on the Chrome extension API, depending on what permissions my extension is asked for, things will error or they won't, right? Unless I have the user's permission to access their location data, I can't do that. This lets me put boundaries around what's gonna be presented to me in autocompletes, right?"
          },
          {
            "time": "[00:17:48]",
            "text": "Where I only want to see this stuff showing up to me. And if I need some other part of the API, well, I'd have to come back here and I'd have to add it. And that'll be the trigger for me to say, when I ask for permission from users, and in a Chrome extension that's gonna be here."
          },
          {
            "time": "[00:18:09]",
            "text": "When I say, I need to be able to access the active tab and the tabs thing, right, all these permissions, that'll be my signal. I'm changing the boundaries, because I set up this nice sort of confinement around what I was building. And furthermore, I think here, so when I have to stub out parts of the Chrome API, I only have to deal with those pieces that I've said I'm going to access."
          },
          {
            "time": "[00:18:44]",
            "text": "So when I'm stubbing things out, I know, look, I only need this ad listener thing. Here on this type I've said, look, I only have these properties on there. I plucked these things off and I only wanna see that subset of things showing up. Well, now I have this type safety that tells me whenever I go out of bounds, right?"
          },
          {
            "time": "[00:19:05]",
            "text": "I have this partial Chrome API instead of the full blown thing that will show me everything and who knows what you have to stub there? It kind of depends on where you're writing your code. So that's a practical use case. I'm going to write up the types for a little mini data layer using a variety of the concepts that we've seen so far."
          },
          {
            "time": "[00:19:35]",
            "text": "But I do want you to celebrate one thing at this moment. And that is, that this type here, this FilteredKeys thing and the stuff you saw here, if we go back to the very beginning of the course, we had a slide on the beginning of the course where we set this out as our goal."
          },
          {
            "time": "[00:20:05]",
            "text": "And we've now accomplished it. And the way we do it is just sort of piecing it together, chunk by chunk by chunk, and sort of expanding it out so that we're not maybe not trying to do so much on one line. But then when we get it right, we can put it all back together."
          },
          {
            "time": "[00:20:21]",
            "text": "So hopefully we're feeling a little bit more comfortable at taking complicated things like this and sort of slicing them up a little bit."
          }
        ]
      },
      {
        "name": "16-typing-a-data-layer",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> As a final kinda capstone to intermediate TypeScript, we're going to do a little bit of a practical exercise and that is to make a well typed data layer or a data store using the concepts that we've learned in the class today. So, and I'm just in the playground here, and you could copy this code if you like."
          },
          {
            "time": "[00:00:26]",
            "text": "But all I've got is three classes, one is called book, one is called movie, one's called song. And I've just chosen a different meaningful property, which we'll turn into a class field for each of these different classes. So if we did b is new book, we'd have to give it an author, maybe I'm the author."
          },
          {
            "time": "[00:00:50]",
            "text": "And we can see that b.authored it gives us this type back, and that's because we're using these nice little shorthand param properties, maybe you heard us talk about this in TypeScript fundamentals. So, ultimately, what I want is an API that looks kind of like this. I wanna be able to create a new store, this is like a data store, that's what I mean by store."
          },
          {
            "time": "[00:01:17]",
            "text": "And then I wanna be able to do something like store.get('book'), and this should return a book. And I wanna be able to do getAll, and this should return an array of books. And maybe create and this should take an arb if it's a book. Hopefully we get the idea here."
          },
          {
            "time": "[00:01:43]",
            "text": "We want a kind of a nice little crud, some portion of a crud like data store that gives me some good types when I retrieve things, and it gives me some type safety when I'm trying to work with things, trying to modify them. So let's actually, I created a book here, Let's pass that in, let's use this as kind of a little test case, right?"
          },
          {
            "time": "[00:02:15]",
            "text": "And let's see if we can do this one, we'll say update, and this is gonna be kind of a patch, where I'm gonna pass some incomplete subset of fields here, maybe I'm just editing the title or something, call it a partial. So this would be a book ID."
          },
          {
            "time": "[00:02:42]",
            "text": "And then, Something like that. So we want create and update and then get a collection, and we want good type safety around this. And none of this works yet, so we're gonna have to make it work. So, clearly, we're gonna need these methods here, right? The getAll, create, and update."
          },
          {
            "time": "[00:03:19]",
            "text": "So now the methods exist but they don't take anything, they don't take the right types of things. And they all return void right now, so we need to do some work. Now I do notice that we've got book, book, book, book, we're referring to kind of a record type by name."
          },
          {
            "time": "[00:03:36]",
            "text": "So what I'm gonna do here is create a map of my records, and by map I just made a type that gives me keys and values. We'll call this EntityMap, since we've talked about the word record before in a different context, and I don't want to overload it."
          },
          {
            "time": "[00:04:06]",
            "text": "Great, so we've got movie, book, and song. The keys are the names I'm gonna use to refer to this kind of entity, and then these are the follow on classes and, sorry, they will be interfaces, because they're in the type position. I mean, we're defining them as classes but they will be the interface part of it, meaning the type of an instance of these classes."
          },
          {
            "time": "[00:04:33]",
            "text": "So in all of these methods here, I could say, kind, by the way, if you ever see kind in TypeScript code, it's because we don't wanna write the word type. That's a special thing, that's like a type alias. Kind is a good alternative to use. So, and this will be, A key of EntityMap, great."
          },
          {
            "time": "[00:04:58]",
            "text": "So now this book thing is gonna be happy. Now I actually want this to be generic, right? So we'll say k for kind. And the reason is, I need to create a relationship between things. So if you remember back to the TypeScript fundamentals, when we talked about generics and type params."
          },
          {
            "time": "[00:05:28]",
            "text": "The whole point of this is we're defining some parameter that describes a linkage between things. So, in the case of get, the relationship is I'm asking for a book, and let's say we provide an ID. And I'm gonna return a book, or maybe like a promise that resolves to a book."
          },
          {
            "time": "[00:05:54]",
            "text": "Let's pretend this is all synchronous for now, you can make it async by just making all these promises instead. But we're gonna return EntityMap[k], this is an indexed access type here, right? We're saying, project the word book through this EntityMap. All right, here's book, grab the value, bring it back."
          },
          {
            "time": "[00:06:18]",
            "text": "And so over here, look at our return type, when we use this string book here, we get a book back. Watch this, when we use movie, check that out, we're getting a movie back. So depending on that word that we're using, we get the right type of entity returned to us."
          },
          {
            "time": "[00:06:42]",
            "text": "Now, we can do the same thing with the collection, it should be very similar. But let's say we don't need an ID here, since we're getting them all, and I'm just gonna put square brackets after this. And let's see what's happening here, getAll('book'), we get an array of books."
          },
          {
            "time": "[00:06:59]",
            "text": "So this is a great use of generics, a great use of an index access type. Create, so here, we want to take an object to create, right? And this is gonna be an EntityMap[k], and this will be a void. So here, if we were to say, I'm creating a book, and in here we get author, right, get some validation."
          },
          {
            "time": "[00:07:31]",
            "text": "If we gonna change this word to movie or to song, song wants artist, From Mark G's new album, right? So, we get that nice linkage between the first argument, which is a literal type, it's a statement of which record we're operating on, and that gives us some really great control over the second argument."
          },
          {
            "time": "[00:08:00]",
            "text": "What about update? So we can actually just borrow this from the create, and we will say to update, or actually we need an ID here, cuz we're referring to an individual record. So we need an ID because we're referring to an individual record, and the only thing we're gonna change is we'll say partial."
          },
          {
            "time": "[00:08:25]",
            "text": "So if you remember what partial is, if we look at the type, it's gonna loop over all of the properties in whatever it's given and make the value type optional. So this means that if we had, let's say, books have a title, In addition to an author, so this would let us say I'm gonna update this book, and I could just do the author, or actually, I could do nothing at all, this is sort of a no update."
          },
          {
            "time": "[00:09:00]",
            "text": "But we get some validation, but we may just have a piece, like I'm just editing one field, right? Whereas up here, if we said book, We need an author, And a title. Something like that. Now we could, implementing these, I would leave as an exercise to you. That's not about the types, that's about the JavaScript, the actual code that you would run."
          },
          {
            "time": "[00:09:38]",
            "text": "So, what we've used here are, within partial, right, we've used a map to type, we've used this little modifier here, we've used an indexed access type. This mapping here is really nice and important, and everything's sort of flowing through that. So this interface ends up being really important because everything sort of threads through it."
          },
          {
            "time": "[00:10:01]",
            "text": "Now, what if we had each of these types of records in its own file? I mean, this is common, right? Where if we have models for data, we have a JavaScript module that is dedicated for book and for movie. Well, watch this. And then delete this, everything's gonna start failing at the bottom, cuz it's an empty interface, right?"
          },
          {
            "time": "[00:10:32]",
            "text": "So key of that empty interface, there's like, nothing's gonna make it happy, and in fact, the key of an empty interface is never. So a no string will make it happy, but we'll get back there, no cause for alarm. So we would still need EntityMap to exist. I'm just gonna create a line here representing different modules, and you'll have to take my word for it that this will work across multiple files."
          },
          {
            "time": "[00:11:00]",
            "text": "So let's imagine that these are all different files, we could do this. We're gonna take advantage of the fact that interfaces are open. I see some head nods, people know where I'm going with this. So, if you maybe have some kind of library or framework that you're using that has like code generation, where it builds starting point files for you, all you need is to have this."
          },
          {
            "time": "[00:11:34]",
            "text": "This is part of your code gen, this little thing. So each record type we have here, a movie, a song, a book, they're all sorta adding themselves to this EntityMap. It's almost like they're registering themselves with this central thing. And it turns out everything ends up being added here and our code starts working again."
          },
          {
            "time": "[00:11:59]",
            "text": "I need a title here, A History of TypeScript, I can't help myself. So, basically, we get the same autocomplete that we had before. If it works. There we go, book, movie, and song, right? So, this has the same effect as if we defined that one interface upfront. So you can have your code split up across many, many different modules."
          },
          {
            "time": "[00:12:31]",
            "text": "You get to group each concern according to movie, and song, and book, right? According to what you're modeling, instead of saying, all right, here's where we maintain all the types, and here's where we maintain the actual code that runs. That to me is the wrong splitting point, I like being able to go to this one file and it's all here, everything having to do with this is here."
          },
          {
            "time": "[00:13:01]",
            "text": "And this shows us that this EntityMap thing and interfaces in general are kind of this cross cutting thing that, You can use to sort of make horizontal things across your app. Meaning, we can refer to this now and it relates to all of the different types of records we could work with, not just one thing in one module."
          },
          {
            "time": "[00:13:28]",
            "text": "Now typically, these will be in separate files, we can kinda simulate that. And we're gonna do this with what's called a module declaration. This is as if, so make TypeScript think that this lives in a library called fem-data. All right, this is actually gonna still work, because we've got these EntityMap things here."
          },
          {
            "time": "[00:13:59]",
            "text": "Sorry, we've got the individual interface declarations for each record, but let's copy this over. Let's see how this works. Cool, now EntityMap is not gonna be accessible here, maybe we can do this. [SOUND] Import, this may be beyond what the, May be beyond what the playground can handle."
          },
          {
            "time": "[00:14:43]",
            "text": "Actually, we may be getting the right auto complete behavior here, let's check one more time. Nope, it's all disappeared. So, beyond the bounds of what can be done in the playground, but this is exactly what you would want if you were breaking things up across many JavaScript modules."
          },
          {
            "time": "[00:15:06]",
            "text": "So you could say, you would define this here where this interface actually exists, some ts file. And then here you could say location/of/entity-map, right? Just like it's a local file of some sort. And that'll make sure that you're modifying the EntityMap that's in that other file. You're augmenting that interface rather than an EntityMap that's in this one module, if that makes sense."
          },
          {
            "time": "[00:15:39]",
            "text": "It's a really powerful pattern that scales nicely, because you can imagine as you add and remove different modules and things, this list of things you could retrieve from the database grows. You don't want one central collision point where they're just tons of git conflicts there all the time."
          },
          {
            "time": "[00:16:00]",
            "text": "This makes it so everything sort of has its own place with one central location of registry."
          }
        ]
      },
      {
        "name": "17-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Just to recap, we begin by setting some goals and talking about how this course is designed to help you understand tricky type information and to give you tips and tricks that you can put right into your app. Copy paste code out of this course, and it'll save you major headache."
          },
          {
            "time": "[00:00:18]",
            "text": "We talked a little bit about how different kinds of declarations stack on top of each other and came to the realization that classes are actually two things stacked on top of each other. It's the factory and it's the instance, right? We talked a bit about modules and CJS interop one of the trickier things where frankly, I have helped a TC 39 members, the people who are on the JavaScript standards body."
          },
          {
            "time": "[00:00:43]",
            "text": "They've had trouble with this and I've had to walk them through this the same way I walked you through it. So don't feel bad if if you get stuck there, and it's a little mysterious. We extracted type information from values using type queries, like type of, then we moved on to conditional types."
          },
          {
            "time": "[00:01:03]",
            "text": "And the built in type script utility types extract and exclude, which are just conditional types behind the scenes. And we saw how having one branch of your condition resolve out to never, that allows you to do some really interesting things. We introduced the infer keyword and we built a utility type to extract an argument out of a constructor."
          },
          {
            "time": "[00:01:31]",
            "text": "And we looked at the example of something like a Webpack config where it's a meaningful type that adds a lot of value to you. But if you didn't have access to it directly, you could kind of suck it up with a vacuum and put it where you wanna put it and refer to it just as if it were an export interface."
          },
          {
            "time": "[00:01:50]",
            "text": "Index access types, this was just a little square bracket notation for grabbing like a sub part of a type. And then finally, this was the big thing we were sort of working our way up to mapped types and that's the thing that looks like an index signature. But we can imagine like we have a lot more control, hopefully you see now where we can loop over all of the keys and a type or all of some other key, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "Any union type that is based off of allowable property keys. And we can combine this with index access types, with conditional types, with those template literal types. And in a very powerful way transform one piece of type information to another. So I hope by the end of this you feel more confident working with type information how to pick it apart."
          },
          {
            "time": "[00:02:42]",
            "text": "You know how to debug it a little bit. And hopefully this will set you on a great path for your continued learning around TypeScript."
          }
        ]
      }
    ]
  },
  {
    "name": "introduction-to-dev-tools-v3",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hey everybody, welcome to this course, I'm really excited about it. This is my third time doing a DevTools course. But this is a brand new format, which I'm really excited about. The DevTools have added a lot of new cool things over the last year, which I'm excited about."
          },
          {
            "time": "[00:00:14]",
            "text": "And this one's gonna be a little bit differently paced in that we're going for a nice introduction to DevTools. So we'll kind of cover it later, but I'm hoping this course will be a really good tool for people whether you're absolutely brand new, been using them a little bit for a little while or are pretty comfortable and just looking for cool kind of tips and tricks and ways to be more productive."
          },
          {
            "time": "[00:00:35]",
            "text": "This whole course is one single repo that repo it's a link here for github.com./jkup/mastering-devtools. Or if you're not able to click on that, you can just go to github.com/jkup. Let me close this. And you'll see it's right on my home page, this masteringdevtools link. And it should be, I've tried to make it as easy as possible."
          },
          {
            "time": "[00:00:59]",
            "text": "So it's got instructions on it. You just clone the repo, CD into it, npm install and npm start. And the only requirement is Node, which comes with npm. So kinda the way that the course works is these pages which you can have locally if you have the repo, I'm just running the repo here so you can kind of see, I have mastering Chrome DevTools."
          },
          {
            "time": "[00:01:19]",
            "text": "I did my npm install. And now I can just do my npm start, and it'll load up the server. Then I go to localhost :3000, and this should be the exact same course that you all have. Just some important links to kind of refer back to. This is the course repository where this course is hosted."
          },
          {
            "time": "[00:01:34]",
            "text": "The official docs to Chrome DevTools are always a really good place they've been especially over the last couple years. They've put a lot of good content on there. They've got cool demos themselves. When they do updates, they mark them in there which is really good. And if anybody needs to get ahold of me, this is my Twitter handle, Jkup and my email address."
          },
          {
            "time": "[00:01:53]",
            "text": "And I love talking about DevTools and the course so please feel free to message me. That'd be kind of an interesting to start because I feel like DevTools are an interesting topic where I'm really passionate about them. I feel like a lot of people find a lot of value in them but they're a little bit of an interesting topic because you won't necessarily find them on the job application, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "It wouldn't be like needs Chrome DevTools experience. So I thought it'd be kind of cool to talk about why I think it's important to learn DevTools. I do think it's just a level up in general, like it's a really cool way to better understand code, better understand performance, all those things."
          },
          {
            "time": "[00:02:33]",
            "text": "It's a great tool for finding bugs quickly. I think that if you're somebody who's really comfortable with the stuff that we'll go over today, so like using the console using a step through debugger, using the audit tools, performance, all that, you'll be able to find bugs at work and fix them a lot faster."
          },
          {
            "time": "[00:02:50]",
            "text": "It's a really cool way to start your journey down web performance. This is not a web performance class, but it really touches on a lot of web performance topics. So it helps you learn network requests, CPU, memory, all these things. And if you are a web performance expert, you will come back to DevTools a lot and use them when you're auditing sites when you're finding bugs or issue."
          },
          {
            "time": "[00:03:12]",
            "text": "And then one of my favorite things about them is it's like when I got started doing web development, my favorite thing was to browse the web, find a really cool website and then learn how it worked. That was what I did when I was beginning. And I feel like the DevTools are a really incredible way to still do that."
          },
          {
            "time": "[00:03:30]",
            "text": "I'll visit a website, and it'll have a really cool animation, and I'll really wanna know how it works. And of course back in the day, it was probably just like a single HTML, a single CSS, and a single JavaScript file. So I could download the whole site and play with it."
          },
          {
            "time": "[00:03:44]",
            "text": "But these days sites are a lot more complicated but DevTools make the complicated site very easy to understand. Like how an animation happens, what CSS they're using for a cool piece that you see, or how they're getting things to load so quickly, all sorts of stuff like that."
          },
          {
            "time": "[00:03:58]",
            "text": "So I think they can be really fun for just playing, exploring, learning too. I also kind of wanted to make a note if you look around, there's all these great courses that exist all over the web, especially on front end masters. And a lot of them come down to this idea of creating, right?"
          },
          {
            "time": "[00:04:16]",
            "text": "There are about how to create react applications or how to create angular applications. But there's not a lot of courses out there that teach you what to do, congrats, you have an app and it's launched and you have users. What do you do now? And I find that a lot of people for their day-to-day job are in that situation where they're debugging things that the users find, or they're dealing with user complaints about speed or they're trying to make the site load faster, something like that."
          },
          {
            "time": "[00:04:42]",
            "text": "And so I think this is cool because it works across all platforms, whether you have an angular site, react site, a node site, a Java site, whatever, you can really learn a lot and get a lot of value out of the DevTools. Cool. So kind of a general high level course outline."
          },
          {
            "time": "[00:04:59]",
            "text": "So we'll start with a little bit of history on how DevTools came to be and kind of leading from where we started up to now. Then we'll do a walk through the panels. I kind of like it so we'll open the DevTools together. We'll click on each panel and we'll do not necessarily a high level, a medium level view of each panel, what it's good for, what we can use it for all these kind of different things like that."
          },
          {
            "time": "[00:05:20]",
            "text": "So we'll walk through those. And then I break the course into different sections. So we'll do a section on editing websites, one on debugging websites, one on network performance, one on CPU performance, one on memory performance. And then we'll wrap up with doing full audits. If you were coming into a brand new site, or you're looking at an old site with fresh eyes, how would we do a top down audit."
          },
          {
            "time": "[00:05:43]",
            "text": "A little bit about me. I'm John Kuperman, an engineer at Adobe and I work on the Creative Cloud. Before that I worked on the brave browser and I worked on twitter.com. I blog over at JohnKuperman.com and I really like teaching workshops on DevTools and accessibility."
          }
        ]
      },
      {
        "name": "1-devtools-history",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this is the first section called the introduction. And what we're gonna learn in this is the history of the browser DevTools. We're gonna take a little bit of a walk down memory lane or maybe not for the younger folks watching, but what it was like interacting with the DOM in the early days."
          },
          {
            "time": "[00:00:16]",
            "text": "And then we're gonna kind of cover the groups that I think this course is really best to benefit. So again, this is an introduction course, so we assume very little knowledge of the DevTools. So if we start at the very beginning, the way to open the DevTools, you have kind of two options, keyboard shortcuts or using your mouse."
          },
          {
            "time": "[00:00:36]",
            "text": "And so you can right click on any website, and you can click Inspect, and it'll open this, typically, it starts as a bottom panel. You can also use keyboard shortcuts, I've got two of them here, so you can use Command+Option+C on your Mac, or Control+Option+C does the exact same thing, it opens the DevTools."
          },
          {
            "time": "[00:00:53]",
            "text": "So we get these open and we have this thing that we're looking at, typically, depending on the keyboard shortcut user on the elements tab. And one of the ways that I like to start this off is by having people just think for a second about, if you had to describe what are you seeing here, how would you describe that?"
          },
          {
            "time": "[00:01:10]",
            "text": "And it's interesting because I feel like a lot of people, and this is not a wrong answer, but a lot of people say, you're looking at HTML and CSS, right? I mean, that's kind of what you're looking at. But the reason that I think it's so interesting is cuz it's not necessarily true, right?"
          },
          {
            "time": "[00:01:24]",
            "text": "It is HTML and CSS for sure, I'm not gonna argue that, margin zero is CSS so that a body tag is HTML. But you're really looking at this fully parsed browser rendered DOM, right? If you think about looking at raw HTML, you would have a very hard time clicking on the body and learning that it had background color of this gray."
          },
          {
            "time": "[00:01:46]",
            "text": "Because you'd have to look at the body, then you'd have to search your code base for some CSS. And you'd have to look at see if there was any body tags and all that. So this is not source code, this is after the source code has been sent down, the browser has done all its work and we're gonna get into what that work is later, and this fully interactive DOM is what we get here."
          },
          {
            "time": "[00:02:05]",
            "text": "And that's an important distinction because, back in the day, we didn't have this cool fully interactive DOM, we literally did have just the HTML and CSS. And so, this screen still exists, if you right click on your browser, and instead of going to Inspect, you View Page Source."
          },
          {
            "time": "[00:02:22]",
            "text": "And so, if you view the page source, you actually get the text content that gets sent down with the page. So here's my CSS which is in line, and then here's my HTML down here. And so, this is interesting, you could still kind of poke around at it or you could copy it all and put it into an ID or something like that."
          },
          {
            "time": "[00:02:40]",
            "text": "But, one of the big things that used to be super painful back in the day, was like let's say that you wanna check something's value in JavaScript, right? That's something we all do, probably all the time, we're like, wait a minute, this link isn't working, what's the value of link right now or what is foo equal."
          },
          {
            "time": "[00:02:54]",
            "text": "So what we used to do back in the day was with a lot of stuff [LAUGH], and some people haven't even messed with alert before. So, if I right click and open up the DevTools, and I go to the Console tab, and I type alert, hi, this used to be the thing back in the day, and I hit Enter."
          },
          {
            "time": "[00:03:10]",
            "text": "You'll see you get this browser rendered thing at the top of your screen that says, hi. So this is pretty cool and at first it kinda looks like, okay, I get it, it's like Console log, but it comes on the top of the screen, that's fine. But alert has a lot of limitations, for an example, if you are to go back in the DevTools again, and go to console and you were try alert anything that's not a primitive, like let's say an object."
          },
          {
            "time": "[00:03:35]",
            "text": "So I do name, and we make this a little bigger, name, Jon, and I tried to alert that you'll see I don't get named Jon, I get this two string version of the object. So, it says alert Object Object. And so, the thing that we used to have to do back in the day if we wanted to read the values of an object, was we would put them in a loop, like a for loop."
          },
          {
            "time": "[00:03:56]",
            "text": "And then we would log out each key and value, and we'd alert each one of those. And so, then you'd reload the site and it would get like an alert, and you click OK, OK, OK, until the whole thing went through. And so, the DevTools offering this interactive DOM, this ability to console log complex statements and complex types, like objects and arrays, is a really gigantic improvement."
          },
          {
            "time": "[00:04:17]",
            "text": "So, yeah, back in the day we're working, we have view page source, we have alert, those are kind of our tools for debugging. And then this really cool tool comes out Hexie's Live Dom Viewer, so I'm gonna open this in another tab. So this was like, you can kind of see it's actually quite similar, in a sense to the DevTools."
          },
          {
            "time": "[00:04:35]",
            "text": "But this was this really great tool, we're able to do things, like make an h1 Hello world, and we're able to see not only the markup, but we're able to see what the DOM is, and we're able to see a preview of it, all in real time. It was like [LAUGH] this is really mind blowing tooI, I know it's something that we take for granted nowadays, but it was this great thing."
          },
          {
            "time": "[00:04:58]",
            "text": "So you could grab that view source, and you could put it in here, and then you could actually start looking at the DOM structure, what it looks like. All these different things you can mess with it and see updates in real time. So that was great, and then and this is like a very old school, this tool came out, Firefox Firebug."
          },
          {
            "time": "[00:05:14]",
            "text": "And it was the very first built in browser extension that was a DevTool. And one of the things I always like to point out is that, if you use your imagination a little bit, this thing that came out, whatever, 20 plus years ago or something like that. It doesn't look too different than what we have today, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "I mean, if you look at this, you've got your HTML structure over here and you've got the corresponding CSS over here. We've kind of moved things around and all that but, essentially, Firebug comes out and sets this gold standard for development experience. There's a ton of stuff I can't do, of course, cuz it's a long time ago, but this was a giant change in how people built and edited and debugged websites."
          },
          {
            "time": "[00:05:55]",
            "text": "And so, Firebug was this incredible tool, kind of first of its kind, and a few years ago back in 2016, they officially sunsetted it. A lot of the core got moved into Firefox itself, Firefox comes with its own DevTools now, but it was sort of this big moment for us."
          },
          {
            "time": "[00:06:11]",
            "text": "Where we had all of a sudden our efficiency sped up, like a hundredfold and we could debug complex things. And we could just do, all this stuff that we couldn't do before, that's a really cool tool. And I was very sad when it got sunset just cuz it's kind of the end of an era."
          }
        ]
      },
      {
        "name": "2-elements-network-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hello, I mean this course is made for anybody but who I think I have content in this course for types of people that I think will get the most out of it. So I think anybody with little to no experience using Chrome DevTools, I hope to be able to walk you through each panel, what they do what they're good for, all that stuff."
          },
          {
            "time": "[00:00:18]",
            "text": "Probably when I pull people the most common group that I get are people who have used the Network and the Console panel before. They console log stuff, they've checked it or they've looked at the network overview and they have seen what comes in. But they've really never clicked on any of the other panels before."
          },
          {
            "time": "[00:00:34]",
            "text": "Maybe they clicked on it and it seemed overwhelming so they clicked away from it. So I'm hoping this will be a really nice introduction to the rest of those panels as well as learning a lot more about network and console. And the third group is people that are comfortable with the panels, but working to learn some tips and tricks."
          },
          {
            "time": "[00:00:50]",
            "text": "One thing I always love, I love keyboard shortcuts, I love experiments, I love little known things, little things that I pick up along the way. So all my workshops that I do, I try to fill with as many little tips and tricks sections as possible. Cuz I find them just really fun and they kinda help me speed up."
          },
          {
            "time": "[00:01:08]",
            "text": "All right, so now we'll move into the next lesson, which is what can the DevTools do? And so this lesson really we're just gonna go through each one. And we're gonna start playing around with them on a very high level, but just seeing some actual stuff that we can do with the DevTools."
          },
          {
            "time": "[00:01:24]",
            "text": "And then we'll get down into the course format for the rest of the course afterwards. So I kinda have two things I wanna point out before we go into it. One is a little bit about not feeling overwhelmed with stuff. I find a lot of times when I sit through workshops, there's so much incredible information."
          },
          {
            "time": "[00:01:42]",
            "text": "And sometimes I start getting a little bit stressed that I'm not gonna be able to retain all of it, right? I'm like, I gotta remember that, and that, and that, and that. So if I were to give you advice, I would say that I think it's more important to know what they can do, then how they can do it."
          },
          {
            "time": "[00:01:57]",
            "text": "Cuz if you know what they can do, you can come back to this final masters course, or you can look at the Docs or you can even just look at the DevTools and try to figure it out for yourself. So if I were to ask for one big takeaway, it would be only just try to remember I've seen DevTools can do this really cool CPU thing now I know exactly how to read a flame graph, right?"
          },
          {
            "time": "[00:02:14]",
            "text": "Those are kind of differences. And the other one, which is something we were talking about a little bit earlier, is that the Chrome extensions like plugins that you add to your browser can and often do mess with DevTools data because they can and often do mess with how you actually render websites."
          },
          {
            "time": "[00:02:31]",
            "text": "And this can lead to really inaccurate reporting. And this has bitten me a lot of times at work before. So my suggestion is, if you're doing something important, like you're auditing a customer's website, or you're trying to find if there's a memory leak on your page, I would either go ahead and disable all of your extensions, which you can do up at this window extensions tab."
          },
          {
            "time": "[00:02:52]",
            "text": "Or just open a new incognito window for the site that you're viewing, incognito windows by default have the extensions turned off. So I think that's always a good tip because there's a lot of stuff going on with these Chrome plugins that you might see new scripts being added to the DOM."
          },
          {
            "time": "[00:03:08]",
            "text": "You might see network requests being rejected or new network requests, all sorts of stuff that can be really tricky to figure out why it's happening. And it's often just a Chrome extension that you have. Awesome. All right, so let's begin with walking through the panels. So I'm gonna go ahead and I'm gonna open the DevTools."
          },
          {
            "time": "[00:03:26]",
            "text": "And we're gonna kinda go down this little list of high level things, and we'll just play with a little example of them so we can kind of see them visually happen. So the first panel is the elements panel. And I guess actually, before I go into each panel, it should be worth noting that these tabs can be dragged and dropped, and they persist in whatever order they're in."
          },
          {
            "time": "[00:03:45]",
            "text": "So if you see yours in a different order than mine, it's probably just because I've dragged mine around, nothing to worry about. You can drag these around until whatever order you want. But on the website is the order that I'm gonna be going through them in. Cool, so the Elements panel."
          },
          {
            "time": "[00:03:59]",
            "text": "So again, you're able to play with all the HTML and CSS. I find it's really interesting when in doubt, try double clicking something cuz it's really interesting what you can interact with here. So for example, some things might be more obvious like we can go ahead and take the body element here, and I'll click on it."
          },
          {
            "time": "[00:04:17]",
            "text": "And we can kind of scroll through all the CSS that applies to it. And so, we could do things like you can see the background color is gray. So I could change the background color to red and in real time the background of the website will update or purple, something like that."
          },
          {
            "time": "[00:04:32]",
            "text": "You can also change the actual property though. So, instead of background color, you could change it to color entirely. And now you'll see this is getting crossed out because there's two colors. But I would say always try double clicking on stuff. You can even double click on the selector itself."
          },
          {
            "time": "[00:04:50]",
            "text": "So if we set this back to background color, and I'll go through this auto select here, and that's purple, we could change this from body to div, something like that. And now you see the body has gone back to being its default color but every div on my site is now purple."
          },
          {
            "time": "[00:05:05]",
            "text": "And so there's a lot of different stuff that you can double click on. Another one that surprises me the first time was that if you take an element over here, like let's say this h1, let me scroll up a little bit so we can view it together. This is this title element that says lesson 2 here."
          },
          {
            "time": "[00:05:19]",
            "text": "You can even double click on the element itself. And so you can change it from an h1 into an h2. So there's two cool things here, one that you can edit the HTML. But two, if you notice over here, I know it's quite subtle, but If you change an opening tag, Chrome DevTools will automatically change the closing tag for you."
          },
          {
            "time": "[00:05:36]",
            "text": "So you can just change the opening to an h2 and hit Enter and there we go, it gets smaller. So I'll change this back to an h1, and we'll scroll back down to the lesson. You can also change classes and IDs. Again, the thing that might be more obvious you can see here we have an article with ID of main."
          },
          {
            "time": "[00:05:53]",
            "text": "The thing that might be more obvious is that we can change the ID from main to app or something like that. And you can see that explodes a lot of the CSS cuz I was using main as a selector. So I'm gonna go ahead and set it back to main."
          },
          {
            "time": "[00:06:04]",
            "text": "But the thing that might be less obvious is that you can actually double click on the ID portion itself and change it to maybe a class name of main instead, which still breaks because my CSS is looking for an ID. So pretty much everything in here is double clickable, which is really cool."
          },
          {
            "time": "[00:06:20]",
            "text": "You can also do things like, we saw that you can update these styles. But you can also do a lot of cool things for example, you can add a brand new style so we can click on this plus sign over here. This is on the right sidebar. And we can create a new style rule."
          },
          {
            "time": "[00:06:38]",
            "text": "And so, if we had one, we wanted to be more specific than, ID of main, we could do the default one is article of main. And so you can see whichever thing you've clicked on when you click new style, it kinda tries to pull a very specific selector for you."
          },
          {
            "time": "[00:06:52]",
            "text": "But you can put anything you want in here, like class of foo or something like that. These are also drag and droppable. So if you grab on to one of these like the h3, you can move it above the h1. And that will see back up here my course is now out of order."
          },
          {
            "time": "[00:07:07]",
            "text": "The h1 down here and the h3 over here. Yeah, so I finally have done like a really good job of making this page, sort of like Apple does with their products where it's pretty intuitive or like the thing you'd wanna do. I would just give it a try."
          },
          {
            "time": "[00:07:20]",
            "text": "[LAUGH] Always give it a try if you wanna make a new selector, drag stuff around, move it anything like that. Cool, and we'll get into a bunch more stuff cuz the elements tab can do amazing things later, but that's kind of the high level view. The Network tab."
          },
          {
            "time": "[00:07:34]",
            "text": "So this one, the basic idea is if you go to the network tab and then you refresh your page when you're on it, the probably most common thing that we do and let me hide a bunch of this other stuff for now, is we look at the stack of all requests sent."
          },
          {
            "time": "[00:07:49]",
            "text": "And so this is pretty cool. It's basically if you think about how a webpage works, right? You hit the server and the server always gives you an index.html, right? Or whatever, a file name.html. It's always the beginning, right? Because HTML is what we need for the very first request."
          },
          {
            "time": "[00:08:04]",
            "text": "So always see the top one here being an HTML or they call it document type over here. And if you click on it, you can actually see what the response is. I do have inline styles which might be a little bit confusing, but this is an HTML file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then what it will do is it'll walk this file and it's looking for any references to external resources, right? So when we do HTML, we often put links to CSS or script tags to JavaScript. Those are two very common things we do. We also put image tags, right?"
          },
          {
            "time": "[00:08:35]",
            "text": "And so as it's walking this, it'll say every time it's like, you need a CSS file, it'll go out and it'll fetch that. And so you can kinda see the network sort of works that way where it fetches the document, it reads through it, eventually it sees that I'm linking to a script."
          },
          {
            "time": "[00:08:48]",
            "text": "So it goes out and fetches that script. This is called prismjs I use it for my code snippet styling. And then it'll keep reading and keep reading and then eventually it gets to a font tag. I use a custom font in here, so it goes out and fetches that."
          },
          {
            "time": "[00:09:03]",
            "text": "So yeah, this is basically in order every request that was sent, and a bunch of cool information about it, like the http status, who initiated it, what type it is, how big it is, how long it took all sorts of great stuff. And we'll get into some really cool ways that you can actually diagnose a lot of really cool things including server issues, all from the network panel the DevTools when we cover that in the network section."
          },
          {
            "time": "[00:09:29]",
            "text": "So yeah, you can measure all sorts of page load stuff, so you can look at how long each file took. But you can also look down here at these really important events. So when we use a tool like Google's Lighthouse, which we'll cover later or web page test, any sort of tool to measure the speed of our website."
          },
          {
            "time": "[00:09:45]",
            "text": "The two events that it's always looking for like when did DOMContent loaded file and when did unload file. And so those are both built right into the DevTools here where you can see when they filed. You can also watch your site load in real time. This is like a lesser known thing that they offer."
          },
          {
            "time": "[00:10:03]",
            "text": "So if you click this setting cog up here, not the top one for all Devtools, but this one over here for network settings you can do capture screenshots. And then if you refresh again with capture screenshots, you can actually see when we audit sites later we will actually be able to watch the HTML come in unstyled, and then an image load and then a font come in and restyle everything."
          },
          {
            "time": "[00:10:26]",
            "text": "So we'll actually be able to see kind of all that stuff happen in real time. So these are the screenshots of the site loading. And then we're able to inspect request and response data. So when you're working with JavaScript, and especially when you're working with API's, so if you're at work or if you're doing a side project and working with some API especially when it's not working, they'll often ask for data about the headers sent either by the API or to the API."
          },
          {
            "time": "[00:10:53]",
            "text": "And so if we take like this request for prismjs, and instead of looking at the response, I'm gonna make this a little taller. We go over here and we look at the headers, we can get a lot of information from it, so you can see what response headers were sent down from the server."
          },
          {
            "time": "[00:11:07]",
            "text": "And you can see what headers you sent in your fact requests. These are gonna be the default ones, cuz it's just a script source. But this comes in really handy where oftentimes at a job your service will have some kind of request ID, some way of identifying it."
          },
          {
            "time": "[00:11:22]",
            "text": "And the service team will often ask you for that ID, because they wanna be able to look it up in their logs and see what went wrong, something like that. So that's a really common example I face where I say, hey, this user status API is broken. And they're like, well, can you give me an example request and I give it to them."
          },
          {
            "time": "[00:11:38]",
            "text": "And they're like, okay, well, can you give me your request ID. So then I come into the DevTools, I refresh and I look for the request ID header. So that happens a lot."
          }
        ]
      },
      {
        "name": "3-performance-console-security-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, performance. So, I [LAUGH] had sent out a tweet a while ago about what people would love to learn more about web dev tools and like pretty much across the board I got that people are scared of the performance tab. That's like a very [LAUGH] common response that I found from people."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really not that scary, but it is very, very powerful. For a little bit of context, it used to be two different tabs. They've kind of combined into one, and it has a lot of data. And so, the kind of high level view of how to use this is you go to the Performance tab, you click on this record button."
          },
          {
            "time": "[00:00:33]",
            "text": "You interact with the site, doing anything you want, and then you click stop. Some top level advice is to keep your recordings as small as possible so they keep you from being overwhelmed with like ten seconds worth of data. So, I usually, if I'm nervous about like filling in a form, I'll click Record, fill in the form quickly and click stop."
          },
          {
            "time": "[00:00:53]",
            "text": "Try to keep it contained as much as possible. You can also deselect things depending on what you're looking at. So, right now I have memory showing down in this section. Let's say I'm not concerned with memory right now, I can just hide it. I also have the same screenshots from the Network tab, which can be really useful."
          },
          {
            "time": "[00:01:08]",
            "text": "You're seeing how your JavaScript causes stuff to render, but if you're not looking for it at the time, you can just deselect it. And so, what you'll kind of be left with here is a little bit of showing how the website painted itself over time. So, this is your frames per second across the very top."
          },
          {
            "time": "[00:01:24]",
            "text": "And this is the CPU usage across the bottom. And then, you'll see all these different frames down here. So, you can see almost everything is gonna happen in the main thread. But you can see stuff like when it's rasterizing, when it's using the GPU, all those different things."
          },
          {
            "time": "[00:01:38]",
            "text": "We'll have a full lesson on performance auditing and stuff like that. But the basic idea is you hit Record, you do something that you're worried about, and then you hit Stop. And you can come in here and you can look for like, is there page jank? Like is it lagging?"
          },
          {
            "time": "[00:01:52]",
            "text": "What's the main thread doing? How busy is it? What's the memory usage? Or what's my CPU usage? Is it getting too high? All sorts of things like that. I think it's best to come in here with a specific question in mind, that also helps reduce how overwhelming it can be."
          },
          {
            "time": "[00:02:06]",
            "text": "So, it'd be like, I really wanna know if I have a memory leak. That's what I care about. So, you can turn on the memory, you can do your thing and you can look for a memory leak and we'll do that in the appropriate section too. Console, probably the most popular one."
          },
          {
            "time": "[00:02:22]",
            "text": "It's really cool, it's a JavaScript repo. So, you can type stuff like console.log('hi'), and it'll type hi. You could do var foo = 'foo', and it'll save that. And then later, you can do foo. That's pretty straightforward. Anytime you put a console log in your code, it'll log out here."
          },
          {
            "time": "[00:02:42]",
            "text": "But there's also some really other cool things you can do. Like for an example, you can go into the elements tab, and you can find an element like let's say this article, you can click on it. Then you go back into the console tab and you can do dollar sign zero."
          },
          {
            "time": "[00:02:55]",
            "text": "And dollar sign zero is a shortcode for whatever I last clicked on in the elements tab. So, if you hit enter, you can see it brings this article into the console. So, now if I wanted to manipulate it, like I could do, addEventListener, click or something like that."
          },
          {
            "time": "[00:03:12]",
            "text": "You can take an element from the elements tab, you can bring it into the console, you can mess with it there, which is pretty cool. All right, next is the Security tab. Again, this one's pretty straightforward. It just gives you an overview on the security for your page."
          },
          {
            "time": "[00:03:25]",
            "text": "So, it is the de facto standard these days that all sites should load over HTTPS. There's all these really cool resources, like Let's Encrypt, which gives you Just free SSL certificates. And so if you go to any website and you click any open dev tools and click on the security, it'll give you an overview."
          },
          {
            "time": "[00:03:43]",
            "text": "And the reason that there's an overview is one, it'll tell you if the actual index dot HTML file, like the main request was served over HTTPS. But it'll also tell you if any subsequent requests were served over HTTP, which can be insecure. So, you could have a fully secure site, and then you add like an embed for a video or something like that."
          },
          {
            "time": "[00:04:01]",
            "text": "And that might be over HTTP, which still leaves you vulnerable. So this is cool. Basically, on the high level, you want to open it and you want to see green. That's what you want. If you open it and you see green, everything's good. If you see any orange or red, it'll give you appropriate instructions for why it's doing that."
          },
          {
            "time": "[00:04:17]",
            "text": "It also lets you view the SSL certificate itself if you have any reason to be viewing that."
          }
        ]
      },
      {
        "name": "4-sources-application-memory-panels",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The sources tab, this is one that I feel like it's kind of underrated. It's basically a full ID and so over this course we'll learn how to do. We'll learn how to use the courses tab for step through debugging, which is really cool. So instead of just console logging, we'll be able to put a break point, we'll be able to pause the whole execution stack at that break point and kind of move around."
          },
          {
            "time": "[00:00:23]",
            "text": "We can check the call stack, like how we got there, what functions got called. We can keep an eye on certain variables, like watch a variable and see how it changes over time. But we can also use this really cool thing called work spaces, where we can drag our project into the dev tools, and after we set it up correctly, everything that we edit will actually persist to disk."
          },
          {
            "time": "[00:00:43]",
            "text": "So normally if you're in the elements tab, and you're messing with the CSS, I don't know who's gotten into this before. This happens me all the time, so I'll be like working on design I'll go into my elements tab and I'll get it perfect right. It's like the CSS look at the site looks like exactly perfect, but I've been working for like an hour."
          },
          {
            "time": "[00:00:59]",
            "text": "When I'm ready to ship it, I'm like, I don't even remember what all I changed at this point. Like I added so many classes and I added so many selectors and styles like, it's really difficult to figure out what you change. And so workspaces can be really cool cuz you still get that instant feedback of working in the sources or elements tab."
          },
          {
            "time": "[00:01:15]",
            "text": "But you can actually hit like Ctrl S or command S and it'll save it to disk, so we have a whole exercise on that for later. You got the application tab, I usually refer to this one is just storage as like a way of thinking about it. So this is where you'll come probably primarily to look at all the different ways we have of like caching and serving things locally."
          },
          {
            "time": "[00:01:36]",
            "text": "So that's like local storage, session data, cookies, index db, all sorts of stuff like that. It's also the place that you come if you have a progressive web app with a ServiceWorker. So if you have a service worker, it also has a service worker tab, where you can see is there a worker is it being registered, what it's doing all sorts of stuff like that."
          },
          {
            "time": "[00:01:55]",
            "text": "It's also maybe most commonly used to come into the storage and click clear all site data. That's probably what I use it for the most right so when you're like, you know you're in a weird state and you cache something or you're messing with sessions or cookies and it's everything's bad."
          },
          {
            "time": "[00:02:11]",
            "text": "You just come in here click clear site data, refresh the page and get a nice clean start. We've got the memory tab, so this one is very specific to your memory consumption. But it's really cool, so you can take a heap snapshot, which is like show how memory is currently being used in my app."
          },
          {
            "time": "[00:02:30]",
            "text": "You can do a timeline so you can like the profile or the performance page, you can record over time, and you can do stuff and you can see what you're doing that's using memory or not. And then there's this new tool which is like probably one of the things I'm most excited about, which is you can allocation sample."
          },
          {
            "time": "[00:02:46]",
            "text": "And that'll help you now that you have a memory leak hypothetically, it'll help you figure out what job script code you're using that's actually causing that memory leak. Because in the past it's been really easy to find out that you have one and it's been much more difficult to figure out why you have one."
          }
        ]
      },
      {
        "name": "5-lighthouse-device-emulation-element-finder",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Then we'll cover the Lighthouse tab. This one's great. This has been kind of a cool story to watch. So years ago, Chrome came out with this idea of Lighthouse. It used to have an audit tab, which kind of did similar things that came out of this idea of Lighthouse."
          },
          {
            "time": "[00:00:13]",
            "text": "It's like fully open source. It's contributed to by all these great people and it's just cool rules for, your site should have a first paint in this much time. Or if you say it's a progressive web app, it should work offline. Or if it should be accessible for people with disabilities or you should be taking advantage of Google's SEO recommendations, all this stuff."
          },
          {
            "time": "[00:00:36]",
            "text": "So they came out with this idea of Lighthouse and it used to live on its own website. And so in my last time teaching this course, I was use the audit if it's a local site. And if it's not a local site, go to Lighthouse and use Lighthouse."
          },
          {
            "time": "[00:00:49]",
            "text": "Lighthouse is awesome. But now Lighthouse is fully integrated with the dev tools itself, which is great. So you can do it all on a local site. Just to explain what I mean by that. If you have a great site like web page test is one of the best ways of like analyzing your site, but you have to a URL and hid it, right?"
          },
          {
            "time": "[00:01:05]",
            "text": "So if you haven't published your app yet, you can't use that website to measure it. So the dev tools are great, cuz even like we are if you're just on a local host, you can still run it. So I haven't published yet, but I wanna know how it's doing."
          },
          {
            "time": "[00:01:17]",
            "text": "So Lighthouse is this full page audits, we'll talk about all these great stuff its get. It's the place I'll always recommend starting if you're trying to gauge performance of a new app. Come here, it'll give you so much feedback before you have to dive into the weeds of network memory CPU."
          },
          {
            "time": "[00:01:34]",
            "text": "And also it can do other cool things, it can emulate devices. So this little button over here to the left,, you can click it and it will give you all these different options for exact screen sizes. So for folks that do a lot of front-end work and design, you can see exactly what your site will look like on a pixel two or something like that."
          },
          {
            "time": "[00:01:52]",
            "text": "And more than just shrinking your screen, this will actually send the appropriate headers. So if you have a server that reads in the request header and says, it's a mobile device, go here. Otherwise, send this. This will convince you that it is a mobile device. You can zoom in and you can actually test out."
          },
          {
            "time": "[00:02:08]",
            "text": "I hope you can see, but my mouse cursor is turned into a little touch circle. And so you can test out touch events too, which is which is really nice. Click that to go back and the last thing is this nice little element Finder. I use this a lot and I see people not using this a lot."
          },
          {
            "time": "[00:02:24]",
            "text": "So if you're looking for a specific element like this emoji or something like that rather than going into elements and trying to like drill down into it this way, you can click on this and then you can start moving around and it'll hover on different things. And whatever your click on, whatever it's hovering, it'll focus that."
          },
          {
            "time": "[00:02:40]",
            "text": "So I click on elements and it clicks it in here, and I can find that emoji really quickly. At the end, we'll go into a bunch of different settings and some experiments and some really cool stuff that you can do over here. But that's kind of the cover for the most part."
          },
          {
            "time": "[00:02:53]",
            "text": "The other thing that's important is you can choose where it's docked. So you can go to the right, to the left or pop it out. And one thing that's kind of interesting when we did the network tab, right, we did screenshots, but the screenshots you can see are really minor."
          },
          {
            "time": "[00:03:07]",
            "text": "And the reason is since we have the dev tools open here, Chrome only has to render this exposed part of the screen. So you won't get a full screenshot of your app, unless you go here. Pop them out and then you refresh. And now that Chrome actually has to render the full site, you'll get full size screenshots."
          },
          {
            "time": "[00:03:25]",
            "text": "So that's kind of the high-level view of each panel. We're gonna be spending a lot of time in each one. But just so when you see them, you can be, I know what that one's for. That one does memory stuff for that one checks HTTPS or that was the step through debugger, those kinds of things."
          }
        ]
      },
      {
        "name": "6-quick-edits-css-html-scroll-into-view",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's worth noting that there's a really cool feature that the DevTools offer. Which is if you own an Android device like an Android tablet or an Android phone, you can actually plug it into your computer and you can test your local apps on that Android device. It's not covered in this course but I do have a link to a really good doc on how to get that set up and going."
          },
          {
            "time": "[00:00:18]",
            "text": "That can be really good because, I think we've all seen it before where we use an emulator or like we control the screen to the right size and it looks perfect. And then it actually gets out on a user's device and it's not quite the same, they render a little bit differently."
          },
          {
            "time": "[00:00:32]",
            "text": "So being able to render your web app on a real android phone or Android device can be really valuable. And a lot of big companies will have device labs of some sort. Well, they have a bunch of old phones and stuff like that. So that can be really good."
          },
          {
            "time": "[00:00:44]",
            "text": "So quick edits, I'm going to go ahead and open my DevTools again. And this time, I'm gonna pin them back down to the bottom of my screen. So we've kind of seen this one already. We can go ahead and we can edit any CSS we want. So if we wanna change like the font color to red, or if we want to change the font family."
          },
          {
            "time": "[00:01:06]",
            "text": "Let me change this back to black so you can read it, I'm gonna change the font family to Arial or something like that. Anything we do over here will get reflected here. We can add new CSS rules. So I did show this already a little bit, but you can click this plus and you can make any rule you want."
          },
          {
            "time": "[00:01:22]",
            "text": "So you could do body nav or something like that. Or you could do a new ID of foo or a class of foo. You can do anything like that. You can edit the HTML. So we saw in the beginning that you can edit the tags by double clicking, you can edit the ID by double clicking."
          },
          {
            "time": "[00:01:41]",
            "text": "You can even edit the content here though by double clicking. So if we scroll up to the top here, I can change, Hello world, and I can hit enter on that, and that'll change. You can even for sometimes because you'll have a lot of content, you can right click on it and you can click Edit as HTML."
          },
          {
            "time": "[00:01:57]",
            "text": "And that will take the current element and it will give you this like really nice text editor. So maybe that's more comfortable and you can move around, add new lines, things like that. Depending on what you wanna do. Scroll into view is one of my favorite ones. So I work on a lot of infinite scrolling applications, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "And they get really long. And sometimes we'll have a bug, I'll be able to use the DevTools to figure out which, let's say we're working on Twitter, or we've got 100 tweets on the screen. And I can figure out the ID of the tweet. That's a problem, but I don't know where it is yet."
          },
          {
            "time": "[00:02:33]",
            "text": "So for an example, I'll use this inspector and I'll click on the Scroll into view, list item. And so here I have it in DevTools. So if I was to scroll all way down and I really wanted to mess with it, I can hover on it and I know this is subtle unfortunately can't make it larger."
          },
          {
            "time": "[00:02:49]",
            "text": "But, let me move to a clear area, when you hover on it, it will either show. If you put your eye up here, where my mouse is, it will show either a little arrow saying the items above where we are. Or if I was to go too far and hover on it, you'll get another little arrow here saying the items below where we are."
          },
          {
            "time": "[00:03:09]",
            "text": "So this used to be the best way we had to deal with it as you would hover it in DevTools and you would listen to the instructions. You scroll a little bit. It's still low, you'd scroll a little bit like I went too far. It's high now, all that."
          },
          {
            "time": "[00:03:19]",
            "text": "But now what we can do, let's say we're all the way at the bottom of the page is we can right click on a DevTool. And then click Scroll into view. And it'll actually move the view part right around the element that we have, which can be really helpful."
          },
          {
            "time": "[00:03:31]",
            "text": "Again, if you work on either just long or infinite scrolling websites. Console shortcuts, so I did cover $0 already. So if you click on an item and you go into the Console New $0, it also keeps some history. So we clicked on article, then we'll click on nav."
          },
          {
            "time": "[00:03:48]",
            "text": "So if we go back to the console $0 has now become nav, that's the thing that we clicked on most recently. But $1 will stay article. So it goes back through three so you can kind of keep some history of the different elements that you're working on. You can hide and show elements, which is kind of cool."
          },
          {
            "time": "[00:04:03]",
            "text": "So if I scroll up to this, Hello World, and I hit h it will hide or show the element, this can be really nice when you're kind of doing some design. You wanna move some stuff around, but the text is in the way or something like that. You can hide it."
          },
          {
            "time": "[00:04:16]",
            "text": "You can also, there's just times where you can just right click and just delete the item, right? And that will actually take it out of the DOM. So you notice the difference. Let me refresh the page. When I go to this h1, and I hit h, it sets it to display or visibility hidden, which means it stays so the space around it stays."
          },
          {
            "time": "[00:04:34]",
            "text": "But when I either hit the delete key or right click delete, it actually plucks it from the DOM and the DOM adjusts. Refresh again. You can simulate state. This is another cool one. So if we take this and we go find one of my links like this Quick Edits, so we've got Quick Edits down here."
          },
          {
            "time": "[00:04:51]",
            "text": "You can click this colon hov and you can simulate a lot of different state like hover active focus, all these things. This is really funny because I pair program a lot and sometimes I'll be pairing with someone who's working on a hover state. And they'll be like doing like this, like they'll be hovering over it."
          },
          {
            "time": "[00:05:08]",
            "text": "And then they'll be looking down here in the style section trying to see what's changing. So you can really just put the hover state on it. And now I can fully see what hover CSS is applied and I can edit it."
          }
        ]
      },
      {
        "name": "7-quick-edits-computed-styles-specificity",
        "timeFrames": [
          {
            "time": "[00:00:02]",
            "text": ">> All right, we can also get computed styles. I'm gonna cover this a little bit later. But CSS is kind of an interesting language because it doesn't have a compile time or it doesn't have errors in the same way that maybe JavaScript does. So for example, if we wrote some CSS that was, class of foo background red, and then right afterwards we wrote, class of foo background blue."
          },
          {
            "time": "[00:00:27]",
            "text": "How is CSS supposed to deal with that, right? We've got this kind of conflict. In JavaScript we throw an error or it would just assign the latest one that's been given, right? If you did like var foo equals red foo equals blue. It would just set it and it's just a constant with error."
          },
          {
            "time": "[00:00:42]",
            "text": "But CSS is a little bit weird. And it's also weird because, the CSS when you write it isn't aware of the structure of the DOM, what it will be when it actually renders. So that sounds complicated, but I don't think it really is. So let's say we write CSS where we write, all divs are blue and anything with the class of foo is red."
          },
          {
            "time": "[00:01:04]",
            "text": "That seems like pretty straightforward, right? Divs are blue things with foo are rad. But then let's say we make a div with the class of foo. Now all of a sudden CSS has a problem, right? Because you've told it now two different things apply. And so what it does is it follows these rules called CSS specificity, and it's basically a big giant fight, [LAUGH] right?"
          },
          {
            "time": "[00:01:24]",
            "text": "Where they all the selectors that exist on a given element fight. And so Estelle has this really great website, which I've linked to here called CSS Specifishity. And it's a little comic which kind of helps you understand how these CSS rules play out. And so you can see each type of selector in the top left, a cute drawing in the middle, and then it's kinda score down here."
          },
          {
            "time": "[00:01:50]",
            "text": "So you can see the weakest selector of all is the star, the asterisk, and that will apply to everything universally. So sometimes you'll see like asterisk, margin 0, padding 0 on a website. So just kind of by default, stuff doesn't have padding. And then we get into an element selector, and then we get into a double element selector, then more and more selectors."
          },
          {
            "time": "[00:02:10]",
            "text": "So if you have a ul with an li with a span in there, if you do span, blue, li span, red ul li span yellow, it'll be yellow cuz that's the most specific. Because it's got three in there. Then it goes into classes, then it goes into an asterisk with a class anyway kind of follows the whole way up."
          },
          {
            "time": "[00:02:31]",
            "text": "But what's kind of important to know is that element selectors are the weakest type of selector besides the asterisks. And then it classes are also pretty weak. And then as you get up IDs are pretty strong. And then inline styles like in your HTML so if you do div style equals background blue is really strong and the only thing stronger than that is an important tag."
          },
          {
            "time": "[00:02:52]",
            "text": "Which we all try to keep probably out of our sights, but they find their way in anyway. But that's just like, this isn't a CSS class. But that's a high level view which is needed for this next section because CSS has a really hard job where you author it, and it runs having no idea what DOM what HTML is gonna run on."
          },
          {
            "time": "[00:03:11]",
            "text": "And so it needs these are rules for when there's conflicting information. So computed styles back to where I was before, is really cool. So you can click on an element like let's go find this h2 here. And then instead of being on the styles tab, which is probably the one we spend most of our time on, you can click computed."
          },
          {
            "time": "[00:03:29]",
            "text": "And what computed is going to give you is a list of like okay after the fight happens, [LAUGH] I don't know how else to phrase it besides the fight. But after a CSS specificity rules are all applied, these are the things that won, right? These are the things, so if you had for an example, we can take the h2, and we can say okay, h2s are all blue, right?"
          },
          {
            "time": "[00:03:52]",
            "text": "And so that h2 turns blue. And then, but it's got an idea of quick edits, right? So we go ahead and we make a new selector and we do quick edits and we do okay. Well, quick edits, those are all red, right? And so as we'd expect, it turns red because an ID is stronger than an element, right?"
          },
          {
            "time": "[00:04:09]",
            "text": "But when you work on big apps with a lot of teams all contributing stuff, it's never quite this simple. It's like two selectors, right? It's like everybody's bringing selectors to the table. So you're like every component has its own stuff and different teams write different stuff. And, oftentimes people come up with these solutions like scoped styles or BAM or all these different things to try to deal with this cuz it gets really difficult."
          },
          {
            "time": "[00:04:33]",
            "text": "When I work at Twitter which is a massive web app, I can't tell you how many times I would get a ticket like extra boarder appearing on tweets when you're logged out and you are viewing this and reply. And I'm looking at CSS to try and find specific role, it's like ul li so the idea of tweets and class of active tweet, all that stuff."
          },
          {
            "time": "[00:04:51]",
            "text": "Really confusing. So computed styles can be really great because you can go to computed styles, you can try to find the thing you are looking for like, why is it red, right? You can find that color is red, that's fine. Then you can click this little caret here, and it'll say, look, here's a list of all the things that change the color, and here's the one that won out, right?"
          },
          {
            "time": "[00:05:11]",
            "text": "And so if you click on this little arrow next to the one, it'll take you back into the styles tab, right? So we've gone from key to back in the styles, and it'll show you where that is. So computed is really cool. It also shows you the full box model."
          },
          {
            "time": "[00:05:26]",
            "text": "Again, this is not like an HTML or CSS class, but I assume a lot of people have heard the term box model before, the HTML box model. And so it's basically it's like you have a thing and it has a size, but then it has padding potentially, then it has border potentially, then it has margin potentially."
          },
          {
            "time": "[00:05:43]",
            "text": "This is a really great way of visualizing it for any element. So you can see the element has a size 1200 by 38. It has no padding, no border and a margin of 33 on the top and 8 on the bottom. This is gonna be really cool too when you're just trying to visualize how stuff's gonna render."
          },
          {
            "time": "[00:06:00]",
            "text": "Yeah, and so this is a great tool, especially for big apps where you're trying to figure out why something is the way it is. You can just go ahead and refresh, you can be like why is this black cover on it? See there's only one rule, click on the arrow and it will take me right to the actual line that sets the color to black."
          }
        ]
      },
      {
        "name": "8-quick-edits-html-breakpoints-themes-accessibility",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> HTML breakpoints, these are another really, cool thing. So this is like an anecdote, but I had this job once where I was working on a tool. And the tool was essentially this giant table that was populated with data in real time. So like little cells of the table table would always change and I was really new on this team."
          },
          {
            "time": "[00:00:20]",
            "text": "And we had a bug where when one would change, sometimes it would go blank, it would like update and it would go white and the bug was to figure out why that was happening. And so this is like back to the very first slide of like dev tools can kind of help you level up If I was not good with dev tools, I would have done what everyone else would have done."
          },
          {
            "time": "[00:00:40]",
            "text": "I would have either asked around, or open the code and start trying to find what code populates the table, stuff like that. But knowing Dev tools, you can do these really cool things. So, just like we'll learn how to set break points in our JavaScript code in the next section, you can set break points on your HTML code."
          },
          {
            "time": "[00:00:58]",
            "text": "So, if I go to like the HTML element way up here, and I right click it, I'll get this break on drop down. And so, what this is doing is it says when one of these three things next happens, I want you to pause JavaScript execution. And I want you to show me what JavaScript caused the HTML to change, which is really very powerful."
          },
          {
            "time": "[00:01:21]",
            "text": "So you have three options, which is whenever the subtree is modified, and if you think about the DOM being a tree, so elements have children, elements of children elements all the way down, right? And so if you go to the HTML, which is the top element, and you say when the subtree is modified, that will mean anything on the app."
          },
          {
            "time": "[00:01:38]",
            "text": "But if you had a table like in my anecdote, you'd go to the table and do it there. You could also do when attributes are modified. So that would be if we did it, let's say on this h1. It wouldn't change if the text changed, but it would change if the ID changed like an attribute."
          },
          {
            "time": "[00:01:52]",
            "text": "And then the third option is break when a node is removed. Again, this can be really helpful, so as a little contrived example, I'll do break on for the HTML subtree modification, so anything changes in the subtree break? I think I have an old one clicking around here, which I'll get rid of."
          },
          {
            "time": "[00:02:09]",
            "text": "Okay, so now you can see this little blue breakpoint on the HTML. So then I can go into console, and I can do like document, get element by ID. Let me find one that exists idea main, so go back here. Grab this main, and I'll do main dot inner text equals high, something like that."
          },
          {
            "time": "[00:02:31]",
            "text": "So I changed the articles inner text to be high and before it even processed, I get this. I get this breakpoint here and my DOM where everything is, is paused. And if I click on the call stack, again, we'll get into debugging later. I just want people to be aware that they can do this cool thing it'll actually, show me the line that changed that bit of HTML."
          },
          {
            "time": "[00:02:52]",
            "text": "So I think this is one of those things that is really powerful for ultra specific situations. Like you'll be in a situation where the website is behaving strangely. And you have no real idea what's doing it in the JavaScript. Being able to figure out exactly what line of JavaScript is altering the HTML can be really useful."
          },
          {
            "time": "[00:03:09]",
            "text": "So I'll go ahead and play through here and go back to elements. As you can see the whole site turned into the word Hi."
          },
          {
            "time": "[00:03:09]",
            "text": ">> I followed along with the debugger example and mine is just stuck on when I updated the inner text to Hi,"
          },
          {
            "time": "[00:03:09]",
            "text": ">> Do you see up at the top of the screen a little I think it's like a yellow bar with a play button on it."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yeah,"
          },
          {
            "time": "[00:03:30]",
            "text": ">> You can hit that to play through. And I think it'll, get you there one more time and you hit play again and then it should go through."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Okay."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yep, and then the other way to do it. Yeah, that button should always be there."
          },
          {
            "time": "[00:03:42]",
            "text": "I think there's me we do this again, so you should have this play button up here. I think there's also a way to just like deactivate back here on the sources tab, you can deactivate all break points, and then if you hit play, it just won't stop again, which can be nice."
          },
          {
            "time": "[00:03:58]",
            "text": "So you can kind of leave them on, you can also then at any time go back to elements and right click breakout and then remove the thing and then the blue circle should go away. So then we have a finding event listeners to this is like very much in common with the HTML break points where we can see something going on with our app, but we're not exactly sure where it's coming from."
          },
          {
            "time": "[00:04:21]",
            "text": "So, like for example, you click on a button and it does something and you want to know where that JavaScript comes from. So that's what this third tab over here event listeners is for. And so you can see this is a static HTML site. So there is not really any event listeners except for this one that my code highlighter uses."
          },
          {
            "time": "[00:04:40]",
            "text": "But if you were to do some code like make a button and then add event listener, click to it or something like that or if you're in react and you did an unclick event or anything like that, those will all show up here. When you click on the items you could like click on different items and see if they have any event listeners this way."
          },
          {
            "time": "[00:04:57]",
            "text": "Color formats is another cool one, this one was added a few years ago, but I really like it. So you can see over here we've got border top and then it's like this reddish color. So we can pretty easily edit the hex codes, right, but another thing you can do is you can click on the color itself and it opens this like really nice color palette."
          },
          {
            "time": "[00:05:16]",
            "text": "You can drag it all around, so let's do something like, let me close this and let's take like the body and we'll do background color and we'll click on that. So now you can kind of drag it all around and really find the exact color that you're looking for."
          },
          {
            "time": "[00:05:32]",
            "text": "You can change all the kind of hue and saturation and transparency and all that stuff, and it'll give you the hex code. Another really cool thing is this section down here as the lower half which populates like colors themes. So for example is material UI, you can again, you can click on an element click on the actual square of the color, click on these this little toggle here, and then click on material UI."
          },
          {
            "time": "[00:06:05]",
            "text": "And now it'll populate this nice little section here. So as we're doing stuff, like we can choose the body background from material UI colors, which is Google's color theme, but the thing I use it for more than that, and let me refresh real quick, so I get rid of that yellow is I'll go to here."
          },
          {
            "time": "[00:06:20]",
            "text": "Click on this and then I'll click on page colors. And what this does is it's dynamically reading the colors on the current page and then generating a color scheme out of those. So this is like the actual blue that I use up here. You can also see that when you scroll off of this modal, it turns into one of those really cool like zoom things."
          },
          {
            "time": "[00:06:39]",
            "text": "And so you can like hover over if you wanted to get the hex for this blue, or this white or this red or anything like that. So these are all really cool, so it's got like an eyedropper. It's got all the kinda Hue Saturation stuff, it has multiple different formats RGBA, HSLA, hex and then it's got this really cool theme picker here."
          },
          {
            "time": "[00:06:58]",
            "text": "So there's like a lot here for when you're designing stuff. There's also a cool little Dev tools trick, which is you can go back to body and hover, you can shift click on any color box, and it'll instantly convert it between the color format. So I know some people at their jobs like we all use HSLA or we all use RGB or something like that."
          },
          {
            "time": "[00:07:18]",
            "text": "So you could just like Set it to a thing that you know like a hex, and then you can shift click on it to turn it into RGB other stuff that does it has this accessibility panel. The accessibility panel is really nice for when you're doing stuff like, we do a lot of stuff at work with making our sites keyboard accessible."
          },
          {
            "time": "[00:07:34]",
            "text": "So everything that you can do with a mouse you should be able to do by tabbing around with the keyboard. And so this can be really nice where it shows this accessibility tree. And you can see like what items have tab indexes or which ones have any kind of ARIA."
          },
          {
            "time": "[00:07:47]",
            "text": "Attributes on anything like that will be in here. And it can be really helpful when you're just trying to look at like, is this getting tap index or does this have my Aria label that I put on or anything like that will be in this tree."
          }
        ]
      },
      {
        "name": "9-quick-edits-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the first exercise. And this is all about the quick edits that we just learned. So it's to take this actual page here. And can you change this from an ordered list to an unordered list? Clicking on this link ,makes a pop up here. But can you find the JavaScript that calls this event, and then the third, one's like a little bit of a quiz, but there's a way to cheat."
          },
          {
            "time": "[00:00:21]",
            "text": "And like I said, dev tools helps you level up. So I have a button and when you click the button, this block quote gets rendered, right? And it gets rendered with this class, this ID and this inline style and I also have CSS on the page, which has an element selector, a class selector and an ID selector with important."
          },
          {
            "time": "[00:00:40]",
            "text": "And so the question on CSS specificity is can you guess what color it will be? But the dev tools cheat is let's say you forgotten all the specificity stuff already. Can you use dev tools that actually view what color it'll be before it gets rendered to the DOM?"
          },
          {
            "time": "[00:00:54]",
            "text": "And then the last one is there's a whole big list full of cards here. And when we wanna do is we wanna find the border color of the one with an ID of 12345678. And so can you use the dev tools to put in that ID and actually get to that card and view the border color."
          }
        ]
      },
      {
        "name": "10-quick-edits-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go through this exercise together, so the first two things we can do just via the elements tab. So the very first one, I'm gonna open up the DevTools, and use this selector to find the list that we're in and see that it is an unordered list and so you can just double click to edit it UL and then hit enter."
          },
          {
            "time": "[00:00:21]",
            "text": "That'll change it so you'll notice it goes from numbered to dots. The second one is interesting, it's probably the easy, there's a couple different ways you could actually do it. The easiest way probably would be to look for an event listener so if we again use this, select the link here, then go over to event listeners and we can see that there's two this one is this color scheme for my code."
          },
          {
            "time": "[00:00:45]",
            "text": "So that's not it this one's a click listener and so if we click on it, it'll take us to the sources and it'll actually take us to the actual function that's calling it. So the button in the block quote is kind of interesting. So if we remember from the specificity class, we would see that the element selectors, the weakest class, the next than ID, and then inline styles are the strongest, but the very, very strongest thing is an important tag."
          },
          {
            "time": "[00:01:18]",
            "text": "So it should be this yellow color the other way that we could do it though, because DevTools helps you cheat, which is awesome is we could just find the block quote in the DOM here. And then we could just go to the computed tab and then we can just see that yellow is the color that wins out here so we can actually see it before it's even rendered."
          },
          {
            "time": "[00:01:39]",
            "text": "So that's yellow and then for the last one, can you find out the border color, the one with this ID again, a couple different ways we could do it. You can always just scroll through them [LAUGH] and you can look for it that's no problem at all. You could also cheat a little bit by doing something like document get element by ID and then passing that ID in and this way we'll bring the element in here."
          },
          {
            "time": "[00:02:02]",
            "text": "And sort of like we covered before you can see right where my mouse is now that if I hover on it, it says it's down but we can also right click and we can scroll it into view. And we can see this is the card with that ID and it has a border of green."
          },
          {
            "time": "[00:02:17]",
            "text": "So any questions on this exercise? And then I had a couple questions that came in in between that I wanted to go through, but if anybody has anything on the this exercise itself, I'd love to hear. So the question was, how did we find the JavaScript for when you clicked this link up here?"
          },
          {
            "time": "[00:02:33]",
            "text": "How did we get there? So I open up DevTools and I'll go to the elements panel and I wanna be over here on the event listeners panel. And so what the event listeners will do is it'll show you any and all event listeners on the currently selected item over here."
          },
          {
            "time": "[00:02:50]",
            "text": "And so the easiest way to do it is to use the selector to get the link and now that the link is hovered we'll see that over here up here at the click listener. And this click listeners on the link, and it actually has the JavaScript file and the line number so if you click that, it'll take you into the sources right on that line."
          },
          {
            "time": "[00:03:09]",
            "text": "Again, a lot of these are easy with like the cleaner exercises like often you'll as your the code gets bigger and more complicated. It might be a little bit obscured away with like a helper function, but this is at least get you on the right track for finding it."
          },
          {
            "time": "[00:03:24]",
            "text": "And we work with debuggers later we'll see that finding the line can actually be super helpful once you set a breakpoint on it, which we'll do in another section. I had one really good question earlier too, which I wanted to answer, it's actually very similar to this one that we just covered."
          },
          {
            "time": "[00:03:40]",
            "text": "It was like the element breakpoints where you're resetting a break on over here. And the question was, okay, well, what if you're using some kind of framework like let's say you're using React, so won't be as simple as like, div enter text equals hello, could you do it that way?"
          },
          {
            "time": "[00:03:55]",
            "text": "The short answer is actually the same, which is you can set a breakpoint do the thing, yes, it will open a react function, but you can walk the call stack back to the your specific application code. And we'll do some really cool stuff with debuggers later but that's the short answer."
          },
          {
            "time": "[00:04:10]",
            "text": "The longer answer, though, is if you're using a framework and that framework has its own DevTools, which we'll cover at the end, that would probably be your best bet. So if you get the React DevTools, and then you look at the React elements panel, which would be a new DevTools over here, that can show you specifically why a component rendered, right?"
          },
          {
            "time": "[00:04:29]",
            "text": "So that would be like hey, this render because you clicked this thing like that, it'd be a lot more helpful but you can do it without the React DevTools. You'll just have to look at a big long call stack and you'll have to look at the file names and you have to walk back until it's not core react Jes dot j s anymore until it's your actual application."
          }
        ]
      },
      {
        "name": "11-workspaces",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So now we're kinda moving into the sources tab. And the thing that I always like I have these two screenshots here, like when you really think about the sources tab, it's sort of like your customer, your ID built into the dev tools. So, here's like the exact same file open in my dev tools and then open in my ID, which I use VS code."
          },
          {
            "time": "[00:00:18]",
            "text": "So you have like the center panel, which has the code in it line numbers and everything. You got the left sidebar, which is like a tree that you can kinda walk just like this one here. And the difference is you got all these great debugging things on the right, which will play within the debugging section."
          },
          {
            "time": "[00:00:33]",
            "text": "But you can even hide those and then just deal with this so you can really just use it as your ID Which is what we're gonna do in the next exercise. It's got a lot of your favorite things in it like so for example, if I open up dev tools here, and I go to sources, and let me get rid of this little console Jordan, if anybody's wondering about this, you can go to the data dot here."
          },
          {
            "time": "[00:00:55]",
            "text": "And you can do show console door or you can use the Escape key. And that'll give you a console overlaid on any non console panel. So you can be on the elements with the console or the network with a console or sources with a console and then you can just XOR escape to hide it."
          },
          {
            "time": "[00:01:11]",
            "text": "That's really useful sometimes if you just wanna log something out and see it. So if I go here, you get a lot of the things that work in your current ID. So for example, if I do a command P which in VS code will open a fuzzy search on the files, I get the exact same fuzzy search here."
          },
          {
            "time": "[00:01:27]",
            "text": "I can bring up any file like that. A lot of the same shortcuts for commenting and all that stuff will work. So I'd really encourage you to when you're in sources just to try whatever feels natural and see if it just happens to work here. Cool. So yeah, it's like your full ID and we're gonna play with that a lot as we play with workspaces."
          },
          {
            "time": "[00:01:48]",
            "text": "So workspaces are super, super cool. They're what let you persist your changes to disk, but it wouldn't be super cool thing without some super serious limitations on it. So before we get too far excited with workspaces, let's talk about what it can and what it can't do. And so the limitation if you think about apps, and you think about kinda what we're doing here, if there is a one to one correspondence between what you kinda send down over the server and what you author on the server and what you author and what you view in the website."
          },
          {
            "time": "[00:02:24]",
            "text": "And what I mean by that is like If you make an index at HTML, then when I hit your website, the same index HTML that you hand wrote is gonna come to me, right like it's the same file just automatically transferred. If you write a node app, and you use a templating language like moustache and you hand write a moustache file, the templating language, we'll turn that into an index dot HTML and send it to me, right?"
          },
          {
            "time": "[00:02:48]",
            "text": "That's kinda how that's working. So in the first example, you write HTML, it sends HTML. There's a one to one example that'll work great with a workspace no problem. And the second example, we're using a templating language. That won't work with a workspace because if I update my index dot HTML on my laptop inside the workspace, your server doesn't really have a way of knowing which template file to update."
          },
          {
            "time": "[00:03:12]",
            "text": "It's it's that would be too complex. So in those situations, you can still persist your CSS and your JavaScript changes to disk. But you cannot persist your HTML changes to this because you're not actually writing HTML. And this is also sadly true. With tools like react where again, you're not writing the HTML, you're writing JSX and react is turning it into HTML."
          },
          {
            "time": "[00:03:37]",
            "text": "So, in the dev tools, you'll see index HTML. But there as you know, there really isn't an index dot HTML on the server. It's like an index.js or like 20 js file. So there is a limitation there. Sometimes it's confusing, but it's basically, like if the thing that's on my dev tool laptop is the exact same thing that is in my code, then it's easy to persist."
          },
          {
            "time": "[00:03:58]",
            "text": "If it's not, then it's not gonna persist. So oftentimes, the sad reality is with like the current tech stacks are very pill chain heavy. Like I'm sure a lot of you at work or like, you use react and you use bubble and use a templating engine and all these different things or use a CSS preprocessor."
          },
          {
            "time": "[00:04:17]",
            "text": "That will mean that the workspace idea won't work for you. But if you are working with vanilla CSS, or vanilla JavaScript, or vanilla HTML, then workspaces will be awesome. So does that make sense? I'm gonna pause if anybody has questions, and I know that's like a very good, kinda a confusing concept."
          },
          {
            "time": "[00:04:34]",
            "text": "So let me just pause for a sec if anybody has any questions on that."
          },
          {
            "time": "[00:04:34]",
            "text": ">> Yes, I have. Can we just save the changes and for example from the website google.com and save the changes and reload the page so we can just load the external JavaScript but with our changes?"
          },
          {
            "time": "[00:04:57]",
            "text": ">> Yeah, you can. That's a great question. So it's like, can we, instead of like saving to disk, let's say and updating actual source code, can we set it up so that we can persist changes through a refresh basically. And we will cover that in another section. The short answer is yes, there are still some limitations."
          },
          {
            "time": "[00:05:14]",
            "text": "Some things we can't save. But for the most part, yeah, you can set it up so that like you can change the JavaScript and it'll survive a refresh, but it won't actually write to your local, the code bases file system. But yeah, we will be able to do that."
          },
          {
            "time": "[00:05:28]",
            "text": "And that's not using workspaces that's just built in with the dev tools networking tool, but we can do it there, which is cool."
          }
        ]
      },
      {
        "name": "12-workspaces-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're gonna move right into another exercise. This one's on workspaces. Again, we'll take like 15 minutes to work on it or, but I'll be here for any questions that people have. So, the idea here, there's full instructions. So you'll want and let me go through the instructions live and then you all can try it."
          },
          {
            "time": "[00:00:20]",
            "text": "So the idea here is I'm gonna go to my node app, which is running this local thing. I'm going to kill it for now. And then what we have let me open my finder to my Dev Tools repo. So we have this workspace folder here, and this just very simply has an HTML, JavaScript and CSS file."
          },
          {
            "time": "[00:00:39]",
            "text": "And so we want to do two things. One, I wanna open the index.html file with Google Chrome. So I right clicked on it and clicked open. And that you can see it's opening like a file, not a HTTP. So it's opening this file and it should look like this, this little to do list."
          },
          {
            "time": "[00:00:55]",
            "text": "And then the second thing we'll wanna do is we'll want to open up the Dev tools, inspect here, go to sources. And again, these are all written down step by step here. So we want to go to source and then I'll go back to my finder my file system."
          },
          {
            "time": "[00:01:09]",
            "text": "I'll grab this whole workspace folder here. And I'm just gonna drag it on to the sources, and it should change into this thing. And so the two things we're doing are one, we're opening the index file in Chrome, and then we're dragging our source code for it onto the sources tab."
          },
          {
            "time": "[00:01:25]",
            "text": "And that should prompt this little warning up at the top saying hey, Dev Tools wants to access your local file system. Is that what you really want? And we'll say yes allow. And when those steps are done, you should see that the workspace is synced by over here in the left, you should see these little green icons next to each one."
          },
          {
            "time": "[00:01:43]",
            "text": "So again, so kill the current node app. Go to your sources panel, go to your Windows Explorer or your finder if you're on Mac and get the project and open its index.html and then go back a level and grab the whole workspace folder and drag it into the sources panel here should prompt you with this."
          },
          {
            "time": "[00:02:02]",
            "text": "Do you want to allow you say yes and then you should see these things all green. And if you have any questions, let me know when it is set up. I have a couple of little things these little To Do List tasks that you can do and what you should be able to see."
          },
          {
            "time": "[00:02:16]",
            "text": "For example, if I go into my style.CSS, and at the same time I go into my Real ID, and I open my workspace style.CSS. So these are the same file wrapper you can see, I should be able to make a change here, like height 100 pixels and then hit Command S to save or Ctrl S and then go back here and actually see the real file has changed on my file system."
          },
          {
            "time": "[00:02:40]",
            "text": "That's what we're going for there. So again, the setup is kind of the part that I really want you to get the experience with. So, yeah, opening that new file, then taking the folder and dragging it into the Sources tab, and if you want to play around with the exercises, awesome, but the setup and getting it to actually persist is the big thing."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Can we save the changes in Sources panel html.css.javascript? Sometimes it doesn't work."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Yeah, so if it's sinking, like if it's green, and it says that it's linked, then it should absolutely work. But yes, sometimes they can get into, I've seen him get into a weird state before I used to be a lot more problematic."
          },
          {
            "time": "[00:03:23]",
            "text": "So, if you run into any problems, what I would do is I would on the left here, go to the File System tab. Then I would right click on the folder and remove it from the workspace entirely. Say Yes, I'd like to get rid of it and then I would just start over again just take the thing and drag it back in here, click Allow over here and it should go all all green like that."
          },
          {
            "time": "[00:03:44]",
            "text": "So you can see here I got into a weird state because I had an existing at it. Saved when I deleted it and grabbed it all over again. And so again, like I would just go in here, remove it. Okay close this out so it's not still with active changes, drag it back in here."
          },
          {
            "time": "[00:04:04]",
            "text": "Allow, and now they're all green again so if they're green they're persisting."
          }
        ]
      },
      {
        "name": "13-workspaces-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We had a couple of really good questions and comments. Important one was that, folks are finding, they open the dev tools. So I'm on my Mac and the the workspace is actually on my Mac. And so, when I do things if I do body back ground blue, or something like that, it live reloads in real time."
          },
          {
            "time": "[00:00:20]",
            "text": "But a couple of folks were doing things either via remote workspace or via windows subsystem Linux, and they're finding that the changes, they do persist. So if you go and you type stuff and you hit save, and then you look in your editor, it'll be there. But the live reloading won't happen over and WSL."
          },
          {
            "time": "[00:00:36]",
            "text": "Let me go through the kind of solving these and then we'll do pause for any questions that anybody had going through it. So yeah, so I kind of got everything all set up and got my green dots here. And then so the first thing was centering the page title."
          },
          {
            "time": "[00:00:51]",
            "text": "So I'll go and grab that and the elements over here. I can either do it there, or I can go into sources, the CSS, and I can do something like I'll add a new selector for h1s. And I'll do text align center. So I'll do that. Change the background color so I can kind of go into elements and grab the body."
          },
          {
            "time": "[00:01:14]",
            "text": "Maybe add a new selector or something like that, background color 333. That looks real bad, eee looks better. And then the last thing was some JavaScript. So what I was hoping was you would type in a new item, and you'd hit Enter, and it should add it to the list."
          },
          {
            "time": "[00:01:34]",
            "text": "So if we type in a new item, we hit Enter, nothing happens. We go to the console, and it's logging it, but nothing's happening. So we can go into the sources tab and we can look at the JavaScript and we can see, it's grabbing the form field, it's grabbing the list of items."
          },
          {
            "time": "[00:01:50]",
            "text": "It's pre-populating with these three items, and it calls this render function which will set the, HTML the list to empty. Then we'll go through each one of these items and it will create a new item and set the inner text to or create a new list item and set the inner text to the item."
          },
          {
            "time": "[00:02:11]",
            "text": "And so what we really want to do is when on the form when you add an event listener and you type something in, we check the key to see if the key is entered, which I already have in here. And we are logging the form value but we really wanna do is we wanna just push that form value on to the list of items here."
          },
          {
            "time": "[00:02:29]",
            "text": "And so we should be able to do something just like items, push and save that. And now when we come here and we hit Enter, I'm gonna close these, you can see you know, hello, something like that. It will add the item. So yeah, again not super important getting these things right but more important getting the workspace set up and actually playing around with the elements panel seeing what works, what doesn't."
          },
          {
            "time": "[00:02:50]",
            "text": "Playing around with the sources and then seeing that it actually updates your if I do workspace index or main.js. We can see my new items push code has made it to my file system. So that is workspaces. Again, the kind of TLDR there is it won't work for a lot of situations."
          },
          {
            "time": "[00:03:08]",
            "text": "But if you are in a situation where it'll work, it can be a really nice way of editing things really quickly and seeing the changes right there."
          }
        ]
      },
      {
        "name": "14-step-through-debugging",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we've kind of made it through the editing section, so we've learned how to do quick edits, we've learned how to do sources, and we've learned how to do workspaces. And now we're gonna move into the debugging section in the workshop. And so, this one will be different where we won't be altering any HTML or CSS."
          },
          {
            "time": "[00:00:17]",
            "text": "We will be altering some JavaScript but more importantly, we're gonna be looking at broken things and trying to get a better idea of why they're broken or how they're broken. So, one concept that's great is step through debugging, and I find the room is usually kind of split on this."
          },
          {
            "time": "[00:00:33]",
            "text": "Where some people are super familiar with it, and maybe they've even done it before or at least they understand the idea. And other people, especially people who haven't programmed in other languages aren't really sure what it is. And so the idea is that a step through debugger, so when you put a console log in your code, which is how a lot of people debug JavaScript."
          },
          {
            "time": "[00:00:53]",
            "text": "The code will run and then it'll hit the console log, log it out, and then it'll keep running the application state. So a contrived example of where that has shortcomings would be, you console log the link that you're about to do an API call to and it's wrong."
          },
          {
            "time": "[00:01:09]",
            "text": "And then you're like well wait, what set it to the wrong thing, but it's too late, the application states already finished. Then you'd have to refresh the whole thing or work through the whole workflow again, in order to get back into that application state. And the contrived example of a link being set wrong might not be great, but if you can imagine an app with a really big workflow."
          },
          {
            "time": "[00:01:26]",
            "text": "Like you have to go to the site, you log in, you add something to your shopping cart, you go to the coupon page, you enter the coupon, that's where the bug is. So if you console log something, and then you get the wrong value or not value we're expecting, now you have to go manually through that whole step again to get it."
          },
          {
            "time": "[00:01:43]",
            "text": "That differs a lot from step through debugger, so a debugger statement unlike a console log, will actually completely pause the application execution, it will not go forward until you tell it to. And so, that can be a lot more powerful because instead of just getting your console log right, you can pause and you can spend as long as you need."
          },
          {
            "time": "[00:02:03]",
            "text": "Looking around, changing things, walking back, walking forward, again, you can really just pause the whole app and look around. So, I guess the way I usually think about it is like, console log is great for a lot of tasks, like straightforward tasks, like if you're just like, what's the value of my post ID or something like that."
          },
          {
            "time": "[00:02:20]",
            "text": "There's no need to use a debugger for that, you can easily just console log it, but when something's really wrong and you wanna take your time and really explore it. Or when you've console logged three times and you keep getting the wrong thing, there might be a really good time to use a debugger instead and actually poke around, cool."
          },
          {
            "time": "[00:02:39]",
            "text": "So, this lesson is pretty short, but it's a little bit heavy, so I'll kinda go through it and then we'll take as long as we need for any questions before we go into the exercise. And feel free to have me go back through things, anything that's helpful. So, I'll go ahead and I'll right click, and I'll click Inspect, and we're gonna be in the Sources tab this time."
          },
          {
            "time": "[00:02:58]",
            "text": "So let me close all of these, so if I first go to Console before we get to Sources, we can see I have this function just for demonstration purposes that's just logging in the background, it's just an interval, and it's just logging things out. And so, if we click over here, we can go to this Debugging js file, and we can see I tried to make the whole workshop not very js heavy."
          },
          {
            "time": "[00:03:18]",
            "text": "So the basic idea is a set interval which we'll get called regularly, getting called every ten seconds. And it does this code where it's just got a couple things, so it calls function1. Function1 is here, function1 sets a constant then calls function2, there's an if else, then it calls either function3 or function4, that's like the whole thing, again, the JavaScript is not very important."
          },
          {
            "time": "[00:03:38]",
            "text": "So if I wanna figure out what's going on, let's say, I wanted to see if function3 gets called or function4 gets called, I'm not sure. I can start at the very beginning and you can really go anywhere you want. And if you hover over these numbers here, you'll see a little gray bar up here, and if you click on one, it'll turn blue, and that means a breakpoint is set."
          },
          {
            "time": "[00:03:55]",
            "text": "At the same time, you can see over here on the right sidebar, it keeps a list of all the breakpoints that you have currently, and you can see when is set. So the ten seconds have gone by, so the function gets called, and here we pause. So you can prove it's paused in a lot of different ways but, for an example, you won't see any more console logs here, because it's not getting called over, and over again, anymore, it's been fully paused."
          },
          {
            "time": "[00:04:16]",
            "text": "And if you had a more robust website with application state doing things, you would notice it was paused as well. So when something is paused, we use the left sidebar we're using for Workspaces, now we can kind of move that away cuz it's not super important. And then the center panel with our source code, we usually use that to set one or multiple breakpoints."
          },
          {
            "time": "[00:04:36]",
            "text": "But when those are set, then it becomes less important and the right sidebar becomes the important thing that we're looking at. So let me minimize all these and we can kind of go through because they're all very different, and we'll actually go bottom up. So, all the ones here are just different break points, right?"
          },
          {
            "time": "[00:04:53]",
            "text": "So we learn how to do a DOM Breakpoint, in one of the earlier lessons, that was when you right click on an element in the elements path panel. So if we were to go here, right click on body, Break on, subtree modification. Now we're to come back to Sources, we would see that there's now a DOM Breakpoint in here."
          },
          {
            "time": "[00:05:10]",
            "text": "So this is just keeping a list, cuz if you're debugging something really hairy, eventually you'll probably have breakpoints all over the place, and it's kinda nice to be able to have a central place for it. So I'm gonna go back to elements, and I'm just gonna remove this breakpoint, cuz we're not using it."
          },
          {
            "time": "[00:05:23]",
            "text": "Back to sources, XHR Breakpoints are really interesting, we can cover those in a bit. But the basic idea with XHR Breakpoints is that if you have an app, this used to happen to me all the time at Twitter, so we have twitter.com, and it's doing constant API calls, right?"
          },
          {
            "time": "[00:05:41]",
            "text": "It's getting your timeline, and it's getting your friends, and it's getting your following list, and who to follow, it's all these different things. And all have that would be wrapped in a single function, right? Like a helper function like fetch or Twitter API or something like that. And so, there'd be a problem with one of them that I really wanted to debug."
          },
          {
            "time": "[00:05:58]",
            "text": "But when I put a breakpoint in the helper function, as you can imagine, it would pause every single time, and so I'd be clicking play, waiting for my one to come. So what you can do is these XHR Breakpoints, you can click plus here, and it's really nice."
          },
          {
            "time": "[00:06:11]",
            "text": "It says break only when the URL contains, and so you could do tweets or something like that or at Adobe, you could call it, do something that's only the Photoshop service or something like that. And then the helper function you don't need a manual breakpoint in, it'll actually tell you when an XHR or a fetch request happens with that in the URL."
          },
          {
            "time": "[00:06:30]",
            "text": "That can be really helpful, again, it's very powerful but only in niche situations, right? If you have too many function or too many network calls, and you really wanna breakpoint on only one of them, you can use those. But for mostly today, let me pause this, for most today we're just gonna be in the regular breakpoints, and this will be a list of things where you have actually clicked."
          },
          {
            "time": "[00:06:51]",
            "text": "So if I go through and I click a bunch of stuff, you can see this list is populating. Go back down to just zero here, cool, then we'll see Scope here, so this is really nice. So, if you've done any of the great front end masters courses on advanced JavaScript or anything like that, you know there's a lot of talk about scope and how JavaScript variables are scoped."
          },
          {
            "time": "[00:07:16]",
            "text": "Var versus con scoping and this scoping, and all this different stuff like that. This can be a really nice way to see what this is set to, currently undefined, and what scope you're in for the different functions, like what's in scope. So you have the local scope, which is the set interval, and in it, you have access to four top level things, function1, function2, functions3, function4, and this is undefined."
          },
          {
            "time": "[00:07:38]",
            "text": "Then you have the Global scope, right? And that's gonna be the window in this sense, again, not a JavaScript class, but it could be really cool to go back and rewatch one of Kyle Simpson's JavaScript classes. And while he's doing the examples, open up this sources panel with your own example and actually be able to just see everything that you have access to in your Local and your Global scope."
          },
          {
            "time": "[00:07:57]",
            "text": "So this will just be all the stuff that's on the window object, right? So we'll go ahead and close that, close that, and close that. Now the Call Stack, right now you can see the Call Stack is one line item long. Because this is in the global scope, there's a single anonymous function, which is this anonymous function right here, which is this one, and that's the whole call stack."
          },
          {
            "time": "[00:08:18]",
            "text": "But as we go further stepping in, it can be really good as the Call Stack expands to see, watch it expand basically. And this kind of ties in earlier a lot of people were talking about how real world apps often use frameworks, they often use helper functions. And so, putting a simple debugger or an HTML DOM Breakpoint, might not get you exactly where you need to be."
          },
          {
            "time": "[00:08:40]",
            "text": "Because that event listener that DOM breakpoint it's being done by a helper function or it's being done by reactor angular. And so, this Call Stack is really great because while it will start with angular react, something like that. It will end up being really long and you can back trace all the way through until you see a file name that you recognize, right?"
          },
          {
            "time": "[00:08:57]",
            "text": "So, often it'll look like react.js, and then eventually it'll be my helper component.js, and then eventually it'll be current debugging view.js. I'm like, that's the one, so you can click on that. You can also do a really cool thing with these, when you're using frameworks and things like that."
          },
          {
            "time": "[00:09:15]",
            "text": "Which is you can find any script that's like a third party library, and you can right click on it, and you can click Blackbox script. And what that'll mean is your basically, I don't wanna see that in my call stacks anymore, and I don't wanna see it on my breakpoints anymore."
          },
          {
            "time": "[00:09:30]",
            "text": "So, I really recommend that if you're, again, if you're using one of these UI libraries, react or view or something like that, and you know the bug is not in the react library itself. So you don't wanna see 30 call stacks of react for your two call stacks of your application."
          },
          {
            "time": "[00:09:43]",
            "text": "You can right click on react.js and blackbox it, and then it won't show up here anymore. And then Watch is really cool, basically, you can add watch expressions at any time and we'll do this in a minute to keep an eye on any variable as things move through."
          },
          {
            "time": "[00:09:58]",
            "text": "So the equivalent of like, let's do this as an example, so the equivalent of going into our code here. So if we go into debugging.js, and what we wanna do is we wanna, what we used to do would be we would console.log(foo), right? That is a common thing we would do, obviously, it is just set to a string here."
          },
          {
            "time": "[00:10:19]",
            "text": "And then you would, let us say, you would hit play on it or remove this breakpoint, you would see when it gets called for the first time, it will set foo and then it will console log it, right? That is like a stuff that we do pretty often."
          },
          {
            "time": "[00:10:30]",
            "text": "So here it goes, it logs foo and then a log some other thing. So the equivalent in a breakpoint would be to go ahead and delete this console log and save it again. And then put a breakpoint in here, the same line where we added the console log, and then add a watch expression for foo."
          },
          {
            "time": "[00:10:45]",
            "text": "And so now it'll wait until it hits the breakpoint at which point, so we hit the breakpoint at which point, the watch expression fool is here, those are equivalent things basically. So you can see, this is like a lot more setup work than console logging. So, only use it when you have a need to use it, but it's also a lot more robust."
          },
          {
            "time": "[00:11:02]",
            "text": "So if I go ahead and remove this breakpoint set one back at the beginning, and hit play again, it'll go through and it'll stop here. And so, all of that has just been like what the UI is, so now let's get into what step through debugging means. And step through debugging has to do with these buttons over here."
          },
          {
            "time": "[00:11:21]",
            "text": "And so, basically, when you get caught in a breakpoint, and you can always tell up here there's this little thing that says we're paused in the debugger, you have a few options, right? One button is to be like, I don't care about that resumed script execution. So, if I hit this, it would go away it would finish cuz I have no other break points."
          },
          {
            "time": "[00:11:36]",
            "text": "And then nine seconds later when it triggered again, it would just break here, again, and I could keep hitting play every ten seconds. Some other options that you can step over to the next function call, so if you're on one, you can step over two or you can step into the current one."
          },
          {
            "time": "[00:11:51]",
            "text": "So, say I had function1 and function2 and I stopped at function1, step over would send me to function2 and highlight it. Step into actually take me as we can see here, into the guts of function1, so now we've stepped into this function. And so, you can basically walk down or walk back out, any application."
          },
          {
            "time": "[00:12:12]",
            "text": "Again, there's something to keep in mind because of how this works. So if you think about the JavaScript execution stack, and it's going line by line, it's executing things. You can always step over something, you can always step into something. But when you step back out, it can't time travel, it doesn't go back in time, it steps out and goes to the next line."
          },
          {
            "time": "[00:12:31]",
            "text": "So, if you're here on function1 and I step out, it will not take me back to function1, again, cuz it can't go backwards in time, it'll take me to the end of the function. And then if I hit play, I have to wait for another function when we get called."
          },
          {
            "time": "[00:12:43]",
            "text": "Just gonna pause for a second, if I can make that more clear, if anybody has any questions, I'd love to answer those now. Just on execution being paused and the choices that you have to step over into out of or play on. Yeah, the question was I still don't understand what's going on with watch."
          },
          {
            "time": "[00:13:01]",
            "text": "And so, watch lets you put any expression in here, so you can put a variable name or a function name or anything like that, and as it gets paused, you can see what it's set to. So let me make an example, let me deselect this and play on just, we get back to the screen and we go into the code here."
          },
          {
            "time": "[00:13:18]",
            "text": "So inside function1, we set foo to foo, right? And then we call function2 and we pass foo into it, and then we check if foo is foo, which it will be and we call function3. So let's take function3, we'll pass foo into it, and then we'll receive foo here, and then we'll do foo equals bar, and we'll set that here."
          },
          {
            "time": "[00:13:39]",
            "text": "Does that make sense to kind of the JavaScript level? So, we set a variable to something and pass it in, pass it in again, and now we change what the variable is set to. Does that make sense? Okay, so we'll save that and we'll restart, and we'll put our breakpoint back here."
          },
          {
            "time": "[00:13:56]",
            "text": "And we'll give it a couple seconds till it gets caught in the breakpoint. Okay, great. So as of this point, we have foo in our watch expression and it has not been defined, so it's unavailable, it would be undefined if you were to console log it. But we'll step into function1, and you see that on this line it hasn't executed yet."
          },
          {
            "time": "[00:14:18]",
            "text": "So as we know from JavaScript hoisting, the declaration has been hoisted but the evaluation hasn't happened, so it says foo is undefined. Into the next line function2, at this point foo has been defined, so now it's set to foo. So it's basically, it's like anytime the variable changes, the watcher updates here."
          },
          {
            "time": "[00:14:36]",
            "text": "So if we step into function2, we can see that foo is still foo, and then we step in, we can see that we get into this call a function3. Where we pass it in, step in again, and we can see again this line 18 hasn't executed yet. So as of this time, foo is still foo, but when we step into the very next line, now foo has been changed to bar."
          },
          {
            "time": "[00:14:55]",
            "text": "So the watcher is like anytime this variable updates, let me know, and that's really important because if we didn't pass it in, then foo would go back to undefined, because it wouldn't be in that scope. But it's basically, the watchers are the same, the watcher is basically the equivalent of wherever we currently are in, we have the blue line is of doing a console log of whatever you put in the watcher at that line."
          },
          {
            "time": "[00:15:20]",
            "text": "That's like the same thing, it's just the way of logging out values. Cool, and so, again, so the kind of thing to do when you're debugging code would be to figure out where the problem is. That's always the first thing that you wanna do, like what function has the problem or whatever."
          },
          {
            "time": "[00:15:37]",
            "text": "So if you're getting something like foo.bar is undefined, you're like, okay, and maybe you would see that in your console, you'd see foo.bar is undefined. And you'd click on the file name over here, and it would take you into the Sources tab where you're calling foo.bar. And then you can put a breakpoint on it, or you can put a breakpoint right after it."
          },
          {
            "time": "[00:15:53]",
            "text": "And you could watch all the foo and see what properties foo does have, does it have a bar? No, does it have a bar, maybe does have that those kinda things. So you can really take as long as you need paused in this execution state, and kinda when you're done, you can hit play and it'll play it through."
          }
        ]
      },
      {
        "name": "15-step-through-debugging-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let me walk through the exercise itself. So there's an unordered list here on this exercise debugging called ui id catfacts. So if we inspect the DOM and we go to elements and we go inside the article inside div. We can see here this URL of ID of catfacts."
          },
          {
            "time": "[00:00:21]",
            "text": "And what's supposed to be happening, we have this file public exercises debugging.js in our repo exercises debugging. So here it is. So it's supposed to be happening is it's fetching this API of catfacts. It's calling to JSON on, then it's taking the results. It's going through each of them."
          },
          {
            "time": "[00:00:43]",
            "text": "And it's making a new list item and appending it, but something's wrong. So what we're supposed to be seeing here under here is a list of facts about cats is a list of facts about cats. But something's going wrong with it. And so the idea is to start with the console, see if there's any errors and then from there, put a step through debugger and and figure out what's going wrong and and how to fix it."
          },
          {
            "time": "[00:01:05]",
            "text": "And so that's the exercise. Before we get started do we have any other questions on it? And again, we'll meet back afterwards and we'll go through the whole thing together. So the question is, you use the debugger and you end up with a lot of breakpoints, how can you get rid of a bunch of them, I don't know off the top of my head."
          },
          {
            "time": "[00:01:22]",
            "text": "So let me let me get in this console log here and see if I can find it. So let us see we have a bunch of them. So it is so you have them all in multiple files, everything like that. So you can't do it from here. You can come over to the sidebar with the break points over here."
          },
          {
            "time": "[00:01:36]",
            "text": "Then you can right click on one and remove all breakpoints, and that'll get rid of all of them from all the files and then you just hit play one more time and it'll play through with no more breakpoints."
          }
        ]
      },
      {
        "name": "16-step-through-debugging-solution-and-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we got some really good questions during the exercise. So I think I'm going to solve the exercise with everybody together and then I've got I think three that I saw and then if anybody else has any will go through those two. So yeah, so for the step 3 debugging Like usually when you have error, the console is always like a good place to start, like usually anything that throws will end up in the console."
          },
          {
            "time": "[00:00:28]",
            "text": "So the first thing I see is like this type error. So the console is a nice way to get to the sources tab as opposed to looking through the file yourself. So I'll go ahead and click on it and it'll take me over here and this specific error was documented, that new element is not a function."
          },
          {
            "time": "[00:00:44]",
            "text": "So if I go to my sources over here. Then maybe do like a Google search or something like document new element. I can see that the actual API is create element, not new element. So we can go ahead in our ID. We can go ahead and change that to create element."
          },
          {
            "time": "[00:01:04]",
            "text": "Then I'll hit save, and then I'll refresh. So now there's no more console error and I saw some folks kind of getting to here. It's like, okay, it's not a JavaScript error, but why is it rendering like this giant list of undefined. So we go back into our sources and we can just do something set a breakpoint."
          },
          {
            "time": "[00:01:23]",
            "text": "And so I'll set a breakpoint and then I'll refresh the page. So we hit this break point, it stopped here, I can use the watch over here. So for example, I can watch on li, and I can see that it is in fact, a list item. So that I mean that looks good."
          },
          {
            "time": "[00:01:38]",
            "text": "And then I can add another watch item and I can make it item. And so I can see as an object with a bunch of stuff. So what it looks like we're doing is we're setting li.innertext to item.fact. And we can see if we hover over the fact is set to undefined whereas item is set to an object."
          },
          {
            "time": "[00:01:57]",
            "text": "So I can go ahead and I can browse in here, trying to see what's going on here. I can see that there isn't a fact property, but there is a text property. So I can go back to my code here and change it from item fact to item text and hit save again."
          },
          {
            "time": "[00:02:14]",
            "text": "I'll remove this break point for now and refresh. And now we've got all these facts about cats, which I'll try very hard not to read and in fact move on with the rest of the content but a couple of things here. There's a couple different ways you could solve it."
          },
          {
            "time": "[00:02:30]",
            "text": "Again, I'm kind of just trying to highlight like, I think normally what I would have done was console logged item here, but it is kind of nice to combine like the debugger was like actually like take that second to breathe and look around at the function. Look around with the object, see what you have access to, what you don't."
          },
          {
            "time": "[00:02:46]",
            "text": "It's kind of a nice way to do it. We got a couple questions that were really good. So one question was about what you put in watchers. And it was like, do you have to specify what you put in the watch? Or can you just watch everything? So the answer is that you do have to specify what you put in the watch."
          },
          {
            "time": "[00:03:03]",
            "text": "You can't put like a wild card in. But if I go ahead and I refresh here, or maybe make a breakpoint here and play to it, I can close what's in my watchers and I can look at my scope. And so if you come down here into scope and you'll get local scope, you can see everything that you do have access to in this function."
          },
          {
            "time": "[00:03:21]",
            "text": "You can also see everything you have access to in the global function. So if you wanna browse what you have access to scope is the place to do that. If you want to keep an eye on a very specific one watch is the place to do that. We had another question was my extensions are getting in the way, and so you kind of have two options."
          },
          {
            "time": "[00:03:40]",
            "text": "If you notice a Chrome extension is getting in the way one is to open an incognito window and do the same thing there. The other one is you can go to Window and extensions. And then you can just deactivate all of them here so that that won't uninstall them, right like here, you can just deactivate LastPass and close it and then refresh the site again so you can kind of go either way."
          },
          {
            "time": "[00:04:00]",
            "text": "It is a tricky thing. It's bitten me a lot before in real life production cases where I'm experiencing something and it turns out to be a Chrome extension. So I think it's a good idea to either turn them off. One other cool thing you could do is I oftentimes, like I'll have Chrome as my daily driver for my browser."
          },
          {
            "time": "[00:04:17]",
            "text": "And then, I'll download Chrome Canary, which is their like, pre release, build. I'll use Chrome Canary with zero extensions. That'll be like my, what I use for dev tools, whereas like Chrome will be like what I use for browsing. So you have a couple of different options there."
          },
          {
            "time": "[00:04:29]",
            "text": "But it is good to keep in mind that that the extensions can break it."
          },
          {
            "time": "[00:04:29]",
            "text": ">> I have a quick question for the watch."
          },
          {
            "time": "[00:04:29]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:04:29]",
            "text": ">> If you're setting the watch do you also have to set a breakpoint on this specific element that you're watching where those specific variables that you're watching?"
          },
          {
            "time": "[00:04:43]",
            "text": "Or good at if you set it, let's say after the elements when you call it, would that still work?"
          },
          {
            "time": "[00:04:43]",
            "text": ">> Yeah. So basically what this is gonna do is every time a breakpoint gets hit, it will update the values in here. So like if you had like a function that set foo and then way later you put a break point it would still have access to foo because that's totally fine but as for like keeping track of, it'll update every time you either hit a break point or like you step in or out of a function that will update then."
          },
          {
            "time": "[00:05:19]",
            "text": "So it doesn't really matter where you place it but this will only post data when you've like hit a breakpoint basically. Somebody had asked, okay, without doing workspaces, is there a way to get your changes so that they will persist through a refresh, right? So not necessarily writing to disk and that whole thing, but I just want to be able to like change some JavaScript, refresh the page and see it execute."
          },
          {
            "time": "[00:05:43]",
            "text": "There is a way to do that. And so to do that, you come over here to the left panel, where we were on page before, and you click over here to overrides. And what you have to do is you have to create or give Chroma folder to store all these little diffs and it can be literally anything."
          },
          {
            "time": "[00:06:01]",
            "text": "So you can click Select Folder for overrides, you can make your own folder that's no problem. Like I can make a folder and call it like FUBAR or something like that. You could put it in your documents so you can make it, Chrome, local overrides folder, anything like that, it's fine."
          },
          {
            "time": "[00:06:16]",
            "text": "When you select it, you'll have to go through the permissions process or like allow and your OS might ask to. But once that is that, then we can do things like we could go to the body. We could do you know, like background color red or something like that."
          },
          {
            "time": "[00:06:31]",
            "text": "And now when we refresh, it'll stay red. And we can do that with our sources panel and our JavaScript, everything like that. So if you're that's, that's always good for like, if you're, especially with JavaScript that runs once, I think somebody had asked about this earlier to where it's like, you load the page and you make an edit and you want to see it and then you refresh which gets the page from the server again, so you've lost your edit, like that kind of thing."
          },
          {
            "time": "[00:06:52]",
            "text": "So if you go to sources overrides and set up an override, you'll be able to get that"
          }
        ]
      },
      {
        "name": "17-network-performance-network-waterfall",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this I have broken out into three sub chapters, because they're kind of three different ways of looking at performance. The first one that we'll cover is network performance. That's going to be like things coming over the network to from your servers to your users. The second section is going to be CPU performance."
          },
          {
            "time": "[00:00:15]",
            "text": "So that's going to be like the page has loaded. And now the users doing stuff and how slow is that? And the third one is gonna be memory. And that one is also gonna be kinda on page load. But it's gonna be how much memory your app is allocating, do you have a memory leak, things like that."
          },
          {
            "time": "[00:00:31]",
            "text": "So those would be the kinda three sections. So we start with network performance. One thing I always find really interesting Is every time some company does a study the metrics they come back on for how important page load is always kind of blows my mind. So I have like a couple of things that I was just able to find where it's like Walmart Amazon, finding that 1% increase in earnings for every 100 milliseconds that could shave off their webpage speed."
          },
          {
            "time": "[00:00:58]",
            "text": "Is like, hugely substantial amount of money, just things going faster. And I think we all know it at a certain end when it gets really bad. You go to a website and it's like spinning and spinning and spinning, like I'll just go find a different website. But I'm always amazed that when you look at the aggregate, like how many users that you just lose, with even small like barely perceptible slowdowns Yahoo saw a 9% increase in traffic for every 400 milliseconds they improved."
          },
          {
            "time": "[00:01:25]",
            "text": "That's like less than half a second. Huge increase. And Google's as it loses 20% of their traffic for every 100 milliseconds they take to load. That one makes a little bit more sense because you, you really expect Google to be instant like google.com, bing.com you expect those to be Really, really fast because you're not there to stay here or there to go to another place.And then these just interesting numbers like in the one to three second range as your page is loading people up."
          },
          {
            "time": "[00:01:54]",
            "text": "Probability of leaving goes up to like 32% as it extends to like one to five seconds. It's like 90% And then bounces just increased like over 100% more bounces as you go past that 5% five second range so you can really losing a lot. You can get a lot of this info if you use like Google Analytics or something you can see how many people bounce but, but it's a little bit harder to measure because Google Analytics like depending on where you put it in your script, People might even leave before it loads, right."
          },
          {
            "time": "[00:02:24]",
            "text": "And so it's it's probably even worse than that. So that's kind of the importance of this network stuff. And I think it's always important to, to have a little bit of like empathy for your users. This is really common where like, you'll be at some big company, maybe and you're like in."
          },
          {
            "time": "[00:02:41]",
            "text": "San Francisco in the United States on a brand new MacBook Pro. And you're like my site is really fast, right? Like it loads like right away and it's really good. And then, there's like so many places with worse internet connection and there's so many people on worse devices."
          },
          {
            "time": "[00:02:59]",
            "text": "And then you start thinking about well what about people using it on mobile devices on worse internet connection? I mean, it really, it really can be a very different experience based on where you are. And I think even people living in like very modern high internet speed cities like if you take the train somewhere and you go in a tunnel and you lose your connection, like we all know That frustration right or you're like at an airport, and all of a sudden everything is crawling like."
          },
          {
            "time": "[00:03:22]",
            "text": "So I think it's really important to not just test on, the maximum the best possible conditions, but to think about your user base. Again, with a good analytics tool, you can get a lot of this like, You actually have a lot of users in this region or that region."
          },
          {
            "time": "[00:03:37]",
            "text": "And there's tons of stuff you can do, which is kind of what we're going to be covering So yeah, we're gonna kinda learn network terminology, and then what the Network tab can do. So if I go ahead and I open the Network tab here, we've sorta seen it once already."
          },
          {
            "time": "[00:03:53]",
            "text": "And let me go ahead and click this cog and disable screenshots just for now because they take up a lot of room, and then I'll refresh the page. So Like we covered at the very beginning, you see like this list in order of every network request your app made."
          },
          {
            "time": "[00:04:06]",
            "text": "And the bigger the app, the more network requests you'll see, especially as there's like analytics and tracking code and ads and all these images and, everything's a network request. So you'll see the name of the request here. You will see the status, again this isn't like a web fundamentals class, but it dev tools kind of taps into everything, so, for those that know like network status is like 200 is okay, a 400 is usually like a client side error, 500 range is like a server side error, all these different things."
          },
          {
            "time": "[00:04:39]",
            "text": "It's nice to see these, they'll actually go red when the error and error as well. The type that it is documents, stylesheets images all that the initiators kind of interesting because you can kind of get this waterfall view of like, okay your document came in that called a JavaScript file and that called a JavaScript file and you can kind of like watch it."
          },
          {
            "time": "[00:04:57]",
            "text": "There's also a kind of a cool tip and trick which is you can hold Shift as you move around. And when you hold shift over an item, it'll turn everything that item called Red. And if that item was called by something, it'll turn that green. So you can see like this font here, the font was called by network dot html, that screen and it called two other files."
          },
          {
            "time": "[00:05:23]",
            "text": "Those are rad. It's just kind of a neat way of like visualizing what happened. You can also see the size. And when this is cached, like if you use compression and caching, you'll see that on this as well, and you can see how long it took to load."
          },
          {
            "time": "[00:05:36]",
            "text": "And then you get this really cool waterfall. So this is what happens when you hover over these here. You get this waterfall, And the waterfall like if you have a request that's taking a really long time, the waterfall can help you figure out where in the process that request is getting stuck."
          },
          {
            "time": "[00:05:51]",
            "text": "And we'll cover that in a second because that's kind of a pretty in depth one. But it's also worth noting that if you right click on any of these, there's actually a lot more columns that you can add So you can add like the path, the URL, what domain they came from, you can add cookies that were set the priority of it all those kinds of things."
          },
          {
            "time": "[00:06:10]",
            "text": "And again, just to give a bit of context here before we go into the waterfall terminology we've kind of seen like a script and or an HTML file, we'll call scripts we'll call CSS call images, all these things, but it's really important to know that on the browser level, you get like a certain number of requests, which is, I believe, either five or six depending on the browser that you can do at one time."
          },
          {
            "time": "[00:06:34]",
            "text": "So if you tried to call like 20 images, it would send out six requests, you know, for the six first images. And then as they come down, then it would start filling like a queue basically where I would call the next images. So it's worth knowing right away that you can't just do unlimited requests."
          },
          {
            "time": "[00:06:50]",
            "text": "And if you think about it, that's where we get this culture of like concatenating our JavaScript files or using CSS sprites instead of images. Because there's a performance gain to be had by having less total requests. So for those familiar with that, who have like bundled their JavaScript together or who have stuck images into a sprite or bundle their CSS, that's why it's because we're limited to the number of resources."
          },
          {
            "time": "[00:07:12]",
            "text": "But the other thing that's really interesting is that Rather than just going down your HTML, and just like in queueing everything it sees like script, CSS, CSS, CSS, you know, going through, the browser's really smart, and it tries to figure out things that it thinks will be higher and lower priority."
          },
          {
            "time": "[00:07:31]",
            "text": "And then it goes down a priority list which is like really great because otherwise. If you think about it, you could put like an image tag and then a CSS tag right after it and the CSS you need that styles your page and the images like I mean, it's you do need the image eventually, but it's usually more additive."
          },
          {
            "time": "[00:07:48]",
            "text": "So what chrome will do is it has this whole system in place where it'll be like, I think these are the top priority. I think these are medium. I think these are lower priority. And that way you don't have to restructure your HTML in a weird way just to get things to load."
          },
          {
            "time": "[00:08:00]",
            "text": "So you can actually right click here and you can do priority and it will add this new column. And it's kind of cool to play around with where you're like, like it views, my HTML obviously, and my CSS is the highest priority. Then it gets to this PNG here I've used that as low priority."
          },
          {
            "time": "[00:08:17]",
            "text": "And then back down here, these font files that are needed to render high priority these two PMGs low JavaScript, medium. It's kind of interesting to see how the browser thinks about it. And it sort of makes sense where usually the HTML and the CSS are like the vital things, like get the site to display and then JavaScript is like."
          },
          {
            "time": "[00:08:35]",
            "text": "Probably somewhat important, but usually it happens after the page load the JavaScript kicks in. And the images are like the lowest importance thing. It's just kind of an interesting thing to see. Does that make sense to everybody that kind of sucks. Six total requests at simultaneous requests and they're more advanced than you would think."
          },
          {
            "time": "[00:08:53]",
            "text": "Cuz Chrome and Firefox and Edge all have a system to figure out what the priority order is. Let me know if you have any questions on that."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Is there a way to change their priority order? Because I remember you can defer scripts."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:08:53]",
            "text": ">> And the head does that."
          },
          {
            "time": "[00:09:11]",
            "text": "What does that do to the priority order?"
          },
          {
            "time": "[00:09:11]",
            "text": ">> Yeah, so you can override it. You can You can make things like higher priority. Well, so there's a couple ways you can override it. Yeah, you can move things up to the head. So like Google Analytics will be like, for example, I want my JavaScript to be in the head please, which will make it a higher priority by itself."
          },
          {
            "time": "[00:09:31]",
            "text": "You can also do things like you can like preload images, you can be like, this one's really important. And then you can Yeah, exactly on the on the other side, you can defer and that says this is less important, right? So yeah, so you can go in and you can either preload or defer."
          },
          {
            "time": "[00:09:46]",
            "text": "And you can also move things around in the structure so that they're, you know, higher up or whatever. And that and that will override these. Yep. So the waterfall is interesting, because I feel like it's largely ignored. And then one day you'll have a thing like this happens to me all the time at work will be like, Hey, Why is this taking so long?"
          },
          {
            "time": "[00:10:03]",
            "text": "And I'll be like, it's this call this API call. And then my boss will be like, well okay, but [LAUGH] Whose fault is that? Right? Not that my bosses mean, but they'll be like, well, what's the problem? Is the problem like the response is too big, is the problem that the service is too slow or that we're too slow or, So this can be really interesting."
          },
          {
            "time": "[00:10:21]",
            "text": "So it provides this really nice colour coded timeline for things that can really help you dive in. And when you're making a ticket, especially if you're like a front end engineer making a ticket for a service engineer, it can help a lot and be really impressive. Again, like one of the themes of this is like Dev Tools helps you cheat a little bit."
          },
          {
            "time": "[00:10:37]",
            "text": "They can be really impressive where you're like, Hey, this is a DNS issue or like, Hey, this is an SSL issue. They're like, Whoa, How did you know that? It's like I'm really cool, so what I've done here because of [INAUDIBLE] I've sort of broken down the waterfall in order and the colours used here are the same colors that combatbtwo of these."
          },
          {
            "time": "[00:10:56]",
            "text": "So, the first colors you'll see which is at the top are white and grey and those are queueing installed. Queuing is exactly what we just talked about. Either there's higher priority stuff, or it's the same priority, but we've already hit our 6 total connections. So I gotta wait."
          },
          {
            "time": "[00:11:11]",
            "text": "Or and this is very rare. The browser is doing some work and just needs a second, that's fine too. And so then they'll show is stalled the entire time that they're stuck queuing so you can see how long they waited. Then the next three are kinda green and orange."
          },
          {
            "time": "[00:11:25]",
            "text": "Those are like setup things happening. One is DNS lookup. So we all know that we were crest like google.com. But that's not a computer's address, right. That's a domain name. So it has to go to the DNS service and find what server to actually reroute to. So if that's slow, that's something going on with DNS routing, not not our company."
          },
          {
            "time": "[00:11:43]",
            "text": "Then it sets up the initial connection, right? So the TCP connection SSL connection, there could be a problem in there. If you're using a ServiceWorker. Like if you have a progressive web app, you can see another orange bar for ServiceWorker setup like it's being bootstrapped. And then purple ServiceWorker has been set up, it's starting to respond."
          },
          {
            "time": "[00:12:00]",
            "text": "Now green is an interesting one green and blue are like the data has gotten on the server and it's coming to you finally, green is waiting time to first byte which is a metric that a lot of sites use to mark performance of their services, which is you know, I say give me food at PNG, and then I will my computer chrome will mark when I get the very first byte of data, the very first packet of data comes over."
          },
          {
            "time": "[00:12:24]",
            "text": "I can use that to kind of gauge how quick my connection between the server and the client are. And then content download is how long it takes for all the rest of the bytes to get over. This one's interesting because this can be largely a client issue, right?"
          },
          {
            "time": "[00:12:38]",
            "text": "If I have a JavaScript file that's like 100 kilobytes, it's going to take a very different time to download In that San Francisco, you know, high speed internet connection than it is if you're on the train, and you're going through a tunnel or something like that. But it can be really nice to kind of categorize things like the white and gray means that too many requests, right?"
          },
          {
            "time": "[00:12:57]",
            "text": "And we're just the browser's just stuck. Not even working on those requests, yet. So you can kinda concatenate your scripts, image sprites, all that cool stuff. The green and orange is like stuffs being set up on the service side. So maybe there's like a hiccup with the DNS registry or the SSL some Something like that."
          },
          {
            "time": "[00:13:16]",
            "text": "The waiting time to first byte is slow. It's a service issue. So you can go to your service, you can be like, hey, time to first byte is really slow. Maybe it's a database problem. Maybe the servers are overwhelmed or they're just slow, something like that. And when content download becomes an issue, you can't just blame the user."
          },
          {
            "time": "[00:13:31]",
            "text": "So you'd have to figure out what you can do to make the content smaller, right? If people are just you know, waiting and this is something that we see Lot of especially in this like modern world where it's so easy to go shopping for new JavaScript libraries, you just keep adding them to your code base."
          },
          {
            "time": "[00:13:44]",
            "text": "You know, you're like, I need a calculator app and I need this. I need that or whatever the things get really big and you'll see large content download times."
          }
        ]
      },
      {
        "name": "18-network-performance-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What is the correlation between priority and waterfall?"
          },
          {
            "time": "[00:00:00]",
            "text": ">> The waterfall will show the actual statistics for that particular request, right like that request. But the priority is how the browser chooses which order to fire things in. So if you have a lower priority item, you will see that it spends time either queueing or stalled."
          },
          {
            "time": "[00:00:23]",
            "text": "If you have more than six, both conditions have to be met. If you only have six total items, the lowest priority gets fetched at the exact same time as the highest priority. But if you have more than six requests, that's images, scripts, CSS, all that stuff, then you'll see lower priority items will spend time queuing whereas higher priority items will not spend time queuing cuz they'll go right away."
          },
          {
            "time": "[00:00:44]",
            "text": ">> So for the waiting, that's specifically an issue with the server side code, or it could be like you said something with the database, that's it, and usually you have to look there to find a way to speed it up?"
          },
          {
            "time": "[00:00:44]",
            "text": ">> Yeah, that's a great question, so time to first byte and waiting, are those always server side issues or could they be front end issues?"
          },
          {
            "time": "[00:01:02]",
            "text": "I mean, technically it could be front end if your connection is so bad that a byte takes a while, there could be some issue there, right? If you're on a really, really weak connection, your time to first byte will be slow as well."
          },
          {
            "time": "[00:01:02]",
            "text": ">> But typically, since it's such a small amount of data, if you see a slow time to first byte, it usually means that between the server getting the request and giving the very first piece of data back is taking a long time, something in there, whether it's server processing the requests or something in the database or something like that."
          },
          {
            "time": "[00:01:33]",
            "text": "It could potentially be something's slow for you, but for example, if other websites are loading great for you and then your website has got a slow time to first byte, that's almost guaranteed to be a server issue."
          },
          {
            "time": "[00:01:33]",
            "text": ">> And did any of these also take into consideration the user's machine?"
          },
          {
            "time": "[00:01:52]",
            "text": ">> So they don't normalize data, they won't say for you this is doing what, Lighthouse for the audits will do something kind of like that. They'll say, this is pretty good for a slow device, something like that. But these are just going to show simply the time taken."
          },
          {
            "time": "[00:02:09]",
            "text": "So if we do a refresh here, it's just gonna say, how many milliseconds it's spent at each phase. So it's spent six queueing, DNS lookup was four milliseconds, and then you can see that the time to first byte took 60, which is very fast, but you can see just pure milliseconds."
          },
          {
            "time": "[00:02:26]",
            "text": "So no, it doesn't normalize the data at all."
          },
          {
            "time": "[00:02:26]",
            "text": ">> I have an equation. What is the initiator columns about? Yep, so the initiator is who requested that. So if you think about you have an HTML file that has a script source main.js in it. So main.js' initiator would be index.html cuz index.html is what called that."
          },
          {
            "time": "[00:02:52]",
            "text": "And then if in that script source you did a fetch for food.jpg, then food.jpg's initiator would be main.js cuz that was who initiated it. So it's like, why did you call this thing? It's like, so it's like this one, we have this, give a refresh here, we have this network.html."
          },
          {
            "time": "[00:03:14]",
            "text": "So we have network.html, that was initiated just by the server, right? That's always the the main thing you get is an HTML file. But then if you look at all these, you can see the initiator network called the JS, network called the PNG, network called this CSS file."
          },
          {
            "time": "[00:03:30]",
            "text": "But the CSS file called these other two CSS files, so you can see the initiator is different for that."
          },
          {
            "time": "[00:03:30]",
            "text": ">> I just had a question. So if we do a cmd F on the network panel, there is a joy version opens up to the right. I was wondering how can we use that, this one, yeah."
          },
          {
            "time": "[00:03:49]",
            "text": ">> So this one's kind of interesting. So you have kind of two options here, you have one is the option just to filter, to kind of filter this list down, right? And so you can do things like if you search for net, you can do something like that."
          },
          {
            "time": "[00:04:03]",
            "text": "You can also do, I think it'll support some amount of regular expressions or whatever. Yeah, the other option that you can do is you can do this kind of more advanced search by cmd+F or ctrl+F. And now when you search for things in here, it'll actually parse all the response data as well."
          },
          {
            "time": "[00:04:21]",
            "text": "So you can like a lot of these will have headers. So basically the filter here is gonna search your names, right? That's what it's gonna search. The search bar here is gonna search the names, all the response headers, all the request headers and the resulting response body itself."
          },
          {
            "time": "[00:04:37]",
            "text": "So you can really kind of filter through. We're almost done with the network, but I do have one call that I like to do which is rightfully, we obsess about network performance. It's a good thing to obsess about. And the faster you get your site, the happier users will be."
          },
          {
            "time": "[00:04:51]",
            "text": "But I do feel like sometimes we get really carried away with this idea of, and actually the jesup question is a great segue of, well, if we can just really compress everything and send it over, then we've solved our problem, right? So we'd take this gigantic thing of JavaScript and we compress it and send it over the wire and that's great because it's fast over the wire."
          },
          {
            "time": "[00:05:11]",
            "text": "But I do want to always caution people that as we compress more and more and as we send more and more JavaScript specifically instead of images over the wire, parse time becomes a really big bottleneck as well and it's something to keep in mind. So the idea with compression being you take a JavaScript file, it's 10,000 lines long, you run it through Gzip, and you get a much smaller file, which is great, cuz smaller files travel faster over the wire, but they have to be uncompressed on the client's machine, right?"
          },
          {
            "time": "[00:05:43]",
            "text": "Their browser will uncompress it. And they still have to parse that giant amount of JavaScript. So I do think that compression is great, we should compress everything. There's a lot of websites that are gzip everything or whatever and they'll check a website to make sure that everything is being compressed and broadly is even faster."
          },
          {
            "time": "[00:06:00]",
            "text": "But we need to keep in mind that at the end of the day, we really should be trying to limit the amount of JavaScript that we send over the wire too. Those are always huge wins because even if we can get the network request quick, the parse time is really substantial."
          },
          {
            "time": "[00:06:15]",
            "text": "There's this post by Addy Osmani here that I linked to, which is well worth the read on itself, but it's called JavaScript Startup Performance. And it's just all about kinda like the cost of JavaScript. So I took this picture from it, which I really liked for people that want a better idea of how kinda these things work like after the JavaScript makes it over the wire and is uncompressed."
          },
          {
            "time": "[00:06:37]",
            "text": "It still has to get parsed and turned into the DOM tree and it gets compiled and optimized. All this stuff has to happen on this large amount of code. So while we shrink our images and bundle and shrink our JavaScript, all that, trying to send less JavaScript over the wire is vitally important to speed."
          },
          {
            "time": "[00:06:54]",
            "text": "And you can do really cool things. You can asynchronously load bundles if there's a web pack front end masters course where Shawn shows how to split your bundles up and only load what you need at page load and bring stuff in. So there's a lot of different ways we can think about it."
          },
          {
            "time": "[00:07:08]",
            "text": "Network's really important but parse time is really important too. And there's a little graph, the same JavaScript file. So you're on your nice desktop computer and it takes 200 milliseconds, which is well within a fine range for everything to parse, but you move over to a mobile device that has a worst CPU and it can take over a second to parse the exact same file."
          },
          {
            "time": "[00:07:26]",
            "text": "So just to call out on that stuff. Cool, any questions about that?"
          },
          {
            "time": "[00:07:26]",
            "text": ">> When you go to the size, right, when you're in your Network tab, you're looking at the size column. If I were to refresh this page right now, and not a hard refresh, but just a refresh, I don't see it on your screen, but I see some assets showing up as dis cache [CROSSTALK] memory cache?"
          },
          {
            "time": "[00:07:54]",
            "text": ">> Yeah, I have this cache disabled. So if I unclick that, yeah, so these are just things that the browser has been able to optimize for you. So these items that are just CSS file items that are just being cached on your disk, so they won't have to load."
          },
          {
            "time": "[00:08:11]",
            "text": "So you can see the page load time goes down to zero milliseconds. This is similarly true, you'll see it if you cache responses to yourself, right? So if you set cache headers on your network requests, then you'll see those reflected there as well."
          }
        ]
      },
      {
        "name": "19-measuring-real-user-performance",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the very last thing I wanted to cover as network stuff is the idea of measuring real user performance. So this is a really cool idea. It was actually something I didn't get into until later in my career. So what we would always do is we would like, again, we are like authoring a web app, and we look at it on our machine and we are like, it is pretty fast or whatever."
          },
          {
            "time": "[00:00:22]",
            "text": "We know the amount of milliseconds that it takes. And then somebody even asked a question earlier about like, but does it normalize that data based on your network conditions? And it does not. But I think that's hinting at a really a larger question, which is like, okay, but how fast is it for your average user or like how fast is it for the bottom 10% slowest user computers?"
          },
          {
            "time": "[00:00:43]",
            "text": "Or something like that. And so this idea came around a long time ago of shipping some code that would like sort of get the time that it actually takes on their actual computer and send it back to you. So at its like absolute simplest, you could stand up a service that takes like maybe a username and event like the page to load and a time, right and you could have a database that stores all that."
          },
          {
            "time": "[00:01:07]",
            "text": "Then you could ship some JavaScript in your actual app that looks like this. And let's say this for loop that's doing nothing is your page to load or whatever. So you could do like a start time using date time. And then you could do some expensive thing and then you could do an end time."
          },
          {
            "time": "[00:01:21]",
            "text": "And then you can figure out the difference yourself by doing n minus star and then you could send that to this cool service. You can be like, whoa, like most people, it takes one second. But look at this, a few 100 people, it's taking 30 seconds what's going on there."
          },
          {
            "time": "[00:01:35]",
            "text": "And you can learn all sorta cool stuff like, we have our data centers in the US. But we're getting a really big, African bumping users. We should get a data center out there. We should do something like that. So this happens to us a lot like at Twitter at startups."
          },
          {
            "time": "[00:01:49]",
            "text": "You'll see your app will go big in a new place that it hasn't been big before. And all of a sudden everybody's kind of crossing over the the data takes a long time. So this can be really cool to A, see what how it performs on slower computers but B, to recognize when something has changed, like you have a new country city zone that's getting really popular and you wanna go add some resources to it."
          },
          {
            "time": "[00:02:12]",
            "text": "So this is what we used to do. But then we got this really cool thing called console time, which is way better. So instead of doing the math ourselves, we could just console time we could pass in a string. Now we do the thing when it console time and the same string and then it keeps track of it."
          },
          {
            "time": "[00:02:28]",
            "text": "It prints it out for us, which is like super cool. And it's also more accurate it prints it out down to a more finite number. So then that was the cool thing to do for a really long time. And now we have an even cooler thing, [LAUGH] which I get really excited about, which is the performance API."
          },
          {
            "time": "[00:02:46]",
            "text": "And so, again, these are all doing the exact same thing, right? But it's like, instead of console time and console time, and you do performance which is a global.mark, and then performance.markend, and then you can print out, mark and measure is the technology, so then I print out a random string, and then which two things to compare."
          },
          {
            "time": "[00:03:05]",
            "text": "So this is very much the same as, up here where I would do like console and start. But the cool thing about doing it this way is not only do you get that time, but it actually is like a standardized thing that other browsers recognize. So if you run some code like this, and let me see if I have some going, Yeah, so if you run some code like this and you do a performance measurement, which is what the tab we're gonna cover next."
          },
          {
            "time": "[00:03:34]",
            "text": "But if you do a record, and then you refresh the page, and then you stop the recording, we can ignore a lot of stuff. But we can see that my mark and measure actually made it into a brand new section called Timings in the Performance tab where I can actually see how long it took."
          },
          {
            "time": "[00:03:48]",
            "text": "I can interact with that. So it's like way cooler than console logging out, and minus start or whatever you do a performance mark and a performance measure, and it'll actually show you in the Performance tab, exactly how long it took and what it was doing and cool stuff like that."
          },
          {
            "time": "[00:04:02]",
            "text": "So these are really cool to add something like this, whichever approach you take is fine. And to stand up some kind of service that receives all of it. And you can really see how long it's taking your actual users to load your actual code. The performance API also has a bunch of really cool stuff."
          },
          {
            "time": "[00:04:18]",
            "text": "I'm not gonna cover it in depth, but I did just wanna show you so just on any random site, you can do something like Performance get entries by type, and then you pass in a type. So I'll print this get entries by type of resource. And it'll actually show me all eight of the resources at grab, which is the exact same stuff that you see over here."
          },
          {
            "time": "[00:04:37]",
            "text": "But you can start like brainstorming like as you get more into this stuff that you could totally build your own Tooling, around, for example, you could just take this, and you could send it to your service. So your user sending it in, and now you can see the network waterfall, for your users in real time, as opposed to just you using your app."
          },
          {
            "time": "[00:04:55]",
            "text": "Things like that. You could do paints. So every time the browser has to do a repaint, and you can see what was it called? What did it? What triggered it? How long did it take? All these really cool things. So it's basically the same API that Dev Tools is using to do its like network stuff and things like that."
          },
          {
            "time": "[00:05:11]",
            "text": "But now you can not only harness it by making custom scripts where you can actually grab that user data and send it to a service, you can re better understand how long all these things are taking. This was really cool. I would just if I were you, I just do like a performance."
          },
          {
            "time": "[00:05:26]",
            "text": "And then do a dot and just check out all these like very, very cool things that it can do. And MDN has really great docs on the performance API, which I've linked to up here. It really opens up like a whole world of stuff you can do."
          }
        ]
      },
      {
        "name": "20-on-page-performance",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the on-page performance or the CPU lesson, and so we're gonna be messing with the performance panel. We're gonna learn about how to read the flame graph, how to find page jank, we're gonna learn about a bunch of really cool little tools that it has to kind of help out along the way."
          },
          {
            "time": "[00:00:19]",
            "text": "And before we get into that, I kinda wanted to talk about the way that we're viewing performance these days, so Google has this rail philosophy which I really like. It's the rail performance philosophy, and it's kind of four different things to think about, four different considerations. One is general app response time, so that would be, we've all been there, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "Where we met on a website and we click a button and it doesn't interact in any way, I have no idea, what did it get my clicked and not get my click, these kind of things. So some type of response really quick for the user, so they know that you've received what they've done, the second category is animations."
          },
          {
            "time": "[00:00:57]",
            "text": "So whether it's a cool scroll animation, or something moving, or something really vital you're making a game or whatever, animation speed is really important especially cuz it gets really choppy. Idle time too, I'm sure you've all heard or people say this a lot, but JavaScript is single threaded, we're not going into too much JavaScript detail, basically it can't do multiple things at once."
          },
          {
            "time": "[00:01:24]",
            "text": "And so what we often do in our application code is we just, send it I need to do this and this and this. I have all these ideas of stuff I wanna do and we just in a big file, just do all this stuff, but if you keep the thread really busy, it's hard for your app to be interactive, right?"
          },
          {
            "time": "[00:01:41]",
            "text": "Your app is not interactive when the thread is busy and so, making sure that you batch up your work, which we'll cover a little bit. You can go a long way with making it so, I don't know if you've been there before, been on a mobile site and it's loading you try to scroll it."
          },
          {
            "time": "[00:01:53]",
            "text": "And you can't even scroll it, cuz everything is so clogged up it's so busy you can't even move it? That's what idle time is, and last one is load, so both the on page load, we covered with the network stuff, but also as you're changing things up, make sure the loading time is smooth."
          },
          {
            "time": "[00:02:08]",
            "text": "And Google's kind of broken it down in this cool way, so the zero to 16 millisecond, which is really, really small, everything feels really good to a user. Once you get 60 to 100 milliseconds, I think under 100 milliseconds they still can't tell the difference between immediate and 100 milliseconds or under."
          },
          {
            "time": "[00:02:33]",
            "text": "As far as the way our eyes and brains perceive things, but once we get up above 100, you can immediately feel it, right.? And so, I think one thing that's fine if you stick under 1,000, then it still feels like 1,000 milliseconds so one second, you still feel engaged in that task maybe."
          },
          {
            "time": "[00:02:53]",
            "text": "But you're definitely feeling that there's been a change, some requests and some perceptible amount of work happening. And then kind of over 1,000, it's a problem, things are taking too long, people lose focus and then once you get over 10,000, which is 10 seconds, you can see a lot of abandonment."
          },
          {
            "time": "[00:03:09]",
            "text": "So I think that the 0 to 16 is amazing, that's for our animations that should be our goal. 0 to 100 is totally fine for actions, if I click, add to cart and it takes 100 milliseconds to update the cart, totally fine it still feels good. 100 to 1,000 starts feeling, okay, maybe I asked a lot I can see that it's taking a while but it's still enough for people to keep focused, and I want you to go over that, people start losing focus a lot."
          },
          {
            "time": "[00:03:34]",
            "text": "So it's basically kind of the same thing that we did with network, except this is different because they are on the page at this point. But, with a lot of these very modern single page apps, the slowest loads sometimes aren't the initial load sometimes it initially loads fast and then you click something and it takes a long time."
          },
          {
            "time": "[00:03:51]",
            "text": "There's a terminology one, but I find this a really good educational terminology so, people mentioned page jank a lot on web performance talks. And it's interesting cuz it basically just means lag, or stuttering, or jittering, what the official definition is any stuttering, juddering or halting that user see as a site is not keeping up with refresh rate."
          },
          {
            "time": "[00:04:15]",
            "text": "But I remember a long time ago, I would always hear about refresh rates, hertz or frames per second or whatever, and I sort of get that you want more frames per second? You don't want less frames per [LAUGH] second, but I didn't fully understand, what's going on here?"
          },
          {
            "time": "[00:04:34]",
            "text": "And so I got this definition that I found on the Google Docs that I really like, so it's, okay, it starts with your display refresh rate. And so, most of the devices today refresh their screens 60 times every second. And in order to always look very smooth, the screen is hi, I'm about to refresh browser do you have anything, and the browser needs to be able to serve up a frame."
          },
          {
            "time": "[00:04:59]",
            "text": "So that's you can kinda think about constantly happening, your monitor is like, hey, I need to go. What do you have in the browser cool, here's a frame and that's happening 60 times a second. And so if you do the math on that every 16.66 milliseconds, you have to have a new frame ready to go, that is how often one new frame will go out the door, and so it would be tempting to say."
          },
          {
            "time": "[00:05:20]",
            "text": "So you need to never do so much work with an animation, that you don't have a new frame ready every 16 milliseconds. But the reality is there's actually, you don't get the full 16 because the browser has housekeeping work and stuff to do. So really, each animation needs a new frame to serve up in ten milliseconds, and if things get too blocked, where every 10 milliseconds, it doesn't have a frame to show."
          },
          {
            "time": "[00:05:43]",
            "text": "So for example, you're just asking for a full repaint constantly in the browsers trying to get it done. It won't have one for the monitor so, it won't give one and that results in dropped frames basically, so you'll be losing frames there. And so this seems like a lot if you're not doing heavy video game animations, but it's worth thinking about even if you're just doing a cool wave of animation, or a background, or a parallax scroll or something like that."
          },
          {
            "time": "[00:06:08]",
            "text": "There's all these ways that we can be pragmatic and we can try to be better about making sure that there's a frame to go every 16 or every 10 milliseconds, cool. So, think at that point, we can kinda open up and kind of peek in, just before we get into talking about jank and things like that."
          },
          {
            "time": "[00:06:26]",
            "text": "I just kinda wanted to explain, how we should think about it with the rail model, and what these kind of times mean as far as losing frames. So the Performance tab, so go over and we'll click on it, and there's kind of two options here, option one is to this one where you do a refresh and that'll show you the actual creation of the page performance."
          },
          {
            "time": "[00:06:48]",
            "text": "And option two, is just to start a Recording where you can do whatever you want, interact with something and then hit Stop, and those are four different use cases, right? One you wanna know, especially if you have a react or angular app, how does it assemble the app."
          },
          {
            "time": "[00:07:01]",
            "text": "What's the page performance like when it's bootstrapping, the other one is man this add to cart button takes a long time what's going on here? And so, if we do one here a Refresh and Profile and then hit Stop, we can kind of see all these different things happening."
          },
          {
            "time": "[00:07:15]",
            "text": "So, the screen is always for sure the scariest cuz there's just so much happening, but I wanna try really hard today to make it a little bit less scary, a little bit more understandable. So, I think if we view it in sections, that's one of the best ways we can do it, so I'm gonna try to kinda minimize, toggle up a couple of things here, okay?"
          },
          {
            "time": "[00:07:34]",
            "text": "So we sorta have three sections, we have this summary view down here, which I'm gonna minimize I'm gonna get to that one last. Then we have up here, this is a section I know it's a little bit hard to see my mouse, but above my mouse. And up here is a separate section, and that's showing three things layered on top of each other, one of them is the frames per second."
          },
          {
            "time": "[00:07:57]",
            "text": "So we'll be looking for big jumps in that if we lose frames, the other one is what the CPU spends its time doing. We'll see a bunch of different colors in there, which will relate to the summary section, and then the third one is just network traffic, and so that's one thing."
          },
          {
            "time": "[00:08:13]",
            "text": "So if you ignore all of these, and we just focus on this top thing, we can kind of, I'm gonna click here and I'm gonna drag an area to kind of Zoom in and focus on it. So I click and drag there, so we can kind of see that there's three different things going on, you can see across the bottom that the network is busy the whole time is our site's loading."
          },
          {
            "time": "[00:08:31]",
            "text": "It's doing stuff with this blue bar, you can even see right here, it stops being busy, as soon as everything is loaded there's no more blue bar. You can also see that there's two little seconds where we actually go up in high frames per second, there's two little jumps here, right one here and one here."
          },
          {
            "time": "[00:08:47]",
            "text": "And for the most part it's completely clear, and those frames per second jumps, tie in very nicely to the CPU doing work, and that's almost always going to be the case, right? The CPU is telling the browser to re-render stuff and you'll see stuff at the same time, and then the last part for this section is the colors."
          },
          {
            "time": "[00:09:06]",
            "text": "So if we zoom in even closer here, we can see there it might even be a little hard to see. Unfortunately I can't make this bigger but there's yellow, purple and green, then mostly yellow, little purple and a tiny bit of green. And if we go back to the Summary tab, we can kind of see what the colors mean, so the color yellow is script running."
          },
          {
            "time": "[00:09:24]",
            "text": "So if you had a for loop or Fibonacci generator, some JavaScript that's running, blue is network, so we don't see any blue that would be waiting on something to load. And then we get into rendering and then repainting, and so the rendering is heavy math that the browser is doing calculating."
          },
          {
            "time": "[00:09:40]",
            "text": "If you say this needs to be 200 pics by 200 pics and float left, then the browser has to figure out how to size it and where to put it. And then once it's figured that out, then the browser actually repaints that area of the screen so, I'm gonna take a little pause there."
          },
          {
            "time": "[00:09:54]",
            "text": "So we haven't gotten into the the big middle area, but we've looked a little bit at, okay. So we can reload or we can Record while we're doing stuff, and we get these kind of three sections up here, showing the frames per second. What work the CPU is doing and the network traffic, how are people feeling about that so far?"
          },
          {
            "time": "[00:10:13]",
            "text": "I know this is for years I just ignored this tab because it was too overwhelming for me so, if you're feeling pretty good about that, then you can see we did a refresh. And the page starts loading all this network stuff, you can even see back here it was just doing system work."
          },
          {
            "time": "[00:10:29]",
            "text": "Something the browser's doing as refresh happens, then we get into here and you can see, okay, now some work happens. There's some scripts running, frames per second shoot up a little bit, there's some rendering and painting that happens, and it kinda goes back down to just hanging out."
          }
        ]
      },
      {
        "name": "21-performance-panel-page-jank-tips",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so I think that sort of sums up this top area, which is like a pretty nice kind of high level view, what's going on? Are we having any issues? And we'll see in the exercise that the dev tools are really good when there are issues like when you're having page jank they just start highlighting stuff with red both up here and in the main section, which is really nice because you can just kind of open it up and see if there's problems."
          },
          {
            "time": "[00:00:25]",
            "text": "So now moving into this section, this one used to be less complicated, but I think it's way better now. It used to just be a single column for all the different stuff going on, but now you can see that all of these little columns are titled by different things that are happening."
          },
          {
            "time": "[00:00:43]",
            "text": "And so you can see like the network requests as like I request my fonts and things like that. And it has a lot of the data that we saw on the previous one like you can see the time it took and the priority it had which is really nice."
          },
          {
            "time": "[00:00:55]",
            "text": "That was the exact same stuff we saw on the Network tab earlier. You can also see all the frames and we'll take a look specifically that when we start doing some real GPU heavy stuff. The timings one we had already seen, right? That if you do any performance marking measure, the stuff will show up here which can be really nice."
          },
          {
            "time": "[00:01:16]",
            "text": "Actually don't know what the experience one does [LAUGH]. I've never used that one before. I think it's part of this. Yeah, I'm not sure. And then we can see the main thread here, right? So again, JavaScript being single threaded, this is where all the work will kick off."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we had like a big for loop or if we have, calculating something or you have react, parsing the JSX tree and generating stuff, see all that going on in here. We can check out all the rasterizing that happens on the site as it loads. We can see if any work that the GPU is doing, what work it's doing."
          },
          {
            "time": "[00:01:47]",
            "text": "And then we've got a couple of other things here that I honestly I'm not sure exactly what they do, but this like child IO thread and the compositor. So for the most part we're just going to be we use timings when we do our own performance market measure."
          },
          {
            "time": "[00:02:00]",
            "text": "The network, one is really helpful to associate. A big request came in and then I started getting page jank, but it's not as helpful when you wanna see what's what's really going on. But for the most part, we're going to just stick in this main thread. This is where we're going to be able to see a lot of stuff as it's happening."
          },
          {
            "time": "[00:02:20]",
            "text": "So let me close this for a second. So as we kind of get into things, I think it's, it's important to look at specific examples, which we'll do and we'll kind of figure some stuff out but it's also important to know understand some high level concepts. And the high level concepts are both things that you can do to avoid page jank and performance problems."
          },
          {
            "time": "[00:02:41]",
            "text": "But they're also they explain a lot about what frameworks do and like why these frameworks exist and how they work under the hood and things like that. And so the first thing that you can do is there's an API on the window object called requestAnimationFrame. This is really great."
          },
          {
            "time": "[00:02:56]",
            "text": "And the basic idea is that instead of doing a thing, like changing the size of something right? By doing like dev.style.width equals 500 pixels, you can take that and you can pass it in as a callback to request animation frame, that same thing. And what that says is I do want you to do this, but you don't need to interrupt everything and do it."
          },
          {
            "time": "[00:03:18]",
            "text": "Before you do the next window, repaint, please do a request animation, please do this piece of task. So like an idea of how things can go really awry is this code up here. So this looks like pretty normal where you're like, you grab a thing from the DOM, you grab its height, and then you change its height and then you grab another things height and you change its height, and you just kind of like doing your work, right."
          },
          {
            "time": "[00:03:39]",
            "text": "You're just like grabbing three things and changing their heights or whatever, but the order that they happen in really matters because when you do read that it can cache that. So now anytime you refer to h1, it's got that value cached, right? So it doesn't need to hit the window again."
          },
          {
            "time": "[00:03:55]",
            "text": "But then you do a right it invalidates the layout right now we have no idea how tall this thing actually is rendered to be. And so when we if we write vanilla code that interacts with the DOM, we can get into this bad habit of like doing reads and writes back and forth."
          },
          {
            "time": "[00:04:09]",
            "text": "And we're never able to cache those values like we're always just wiping out the or invalidating the cache. And then rereading and rereading and rereading. So one approach that you could do is you could like pump all of these reads and writes into a request animation frame. So the kind of way I like to look through it is like let's say you have a site by yourself and you're aware of this."
          },
          {
            "time": "[00:04:31]",
            "text": "So you write this code, you're like, This, this won't do. I kind of wanna do all my reads together and then all my rights that's like a that'll make things a little better. So you do that. But then you add a bunch of other people onto your team."
          },
          {
            "time": "[00:04:44]",
            "text": "Now it's gonna get really annoying. It's like no, you can't just read the DOM, you got to go over here. And this is where we do our DOM reading. This is where we do our DOM writing, it gets really obnoxious. So what you could do is you could put all of those reads and writes into a request animation frame so that way, you're only invalidating the layout right before it gets repainted anyway for another frame."
          },
          {
            "time": "[00:05:04]",
            "text": "But the important takeaway here is maybe not to use requestAnimationFrame all the time. But the important thing is, this is one of the really cool benefits that using a front end framework will do is all of these frameworks will do this stuff for you. So if you're like in react and you say, Set the height on something or rerender, a new component, it won't interrupt to do it."
          },
          {
            "time": "[00:05:22]",
            "text": "It'll wait until the next animation frame fire, so I think the bigger takeaway here than using this API all the time is that this is one of the really cool benefits from using some open source front end framework is they'll do stuff like this for you. Another thing you can do web workers, so if we load a page and we see in kind of, this like center area here, if we see a bunch of big yellow JavaScript stuff like I had an example here of like, calculating Fibonacci or something like that, where it's like, it's really busy, the process is really busy."
          },
          {
            "time": "[00:05:56]",
            "text": "You can offload that stuff to a web worker, which essentially gives JavaScript the main thread back to handle the actual website. There's a lot of cool talks on web workers and stuff like that I have a very basic example. So you can like grab two things like you can grab an input form and a feet on a div to display some stuff in If you can check if the window dot worker API exists, like if this browser supports it, and if it does, you can instantiate a new one."
          },
          {
            "time": "[00:06:23]",
            "text": "And then you can basically send messages with a post message command and you can receive messages with an on message command. So for example, like a contrived example, if you have a bunch of cool animations on your screen, but you have to calculate a really big number If you don't use a web worker when the calculation's happening, those animations are going to just stop, right?"
          },
          {
            "time": "[00:06:41]",
            "text": "They're gonna freeze there because the main thread's being used to calculate the number. And as we mentioned a little bit ago, you could also get around this by moving all those animations into CSS, which would free you up there. But in lieu of that, you could take the big calculation, you could toss it to a web worker that'll split off another thread, do your calculation and then answer back."
          },
          {
            "time": "[00:06:59]",
            "text": "Meanwhile, the animations go smoothly. Web Workers are a whole separate topic. They have restrictions like they can't mess with the DOM. But they're really great for kicking off any kind of big tasks like If you do any kind of Frontend processing for your ads or something like that, which ones got clicked on, which ones got seen and you have all this math to do."
          },
          {
            "time": "[00:07:17]",
            "text": "That's a great example of when to use a web worker to free up the main thread. The next one use a framework. I meant to put an asterisk here, this is a warning. I'm not a gigantic framework proponent. I'm not like you should always use some framework for your apps."
          },
          {
            "time": "[00:07:32]",
            "text": "Not at all. But I do think if you're getting into a problem where you're trying to do something like anything with animation heavy working on a game working on a really flashy website, and you start seeing these page jank problems, then using some kind of framework and doesn't have to be a react style."
          },
          {
            "time": "[00:07:49]",
            "text": "It could be like a D3 style or something like that. One of the big benefits is they will batch up this work for you and do those things. And then the last thing is just like again, kind of back to the Network tab, the idea of reducing complexity."
          },
          {
            "time": "[00:08:03]",
            "text": "So this is like, you can be amazed at all the things like even like a long, CSS selectors like, DIV UL Li span ,or something like that take more processing power than shorter UI like, selectors like a class name or something like that. Just like kinda a million things that ,you could do."
          },
          {
            "time": "[00:08:19]",
            "text": "But I think the big ways to do it are,using web workers for expensive stuff and using requestAnimationFrame for batching up all of your writes and, reads and things like that. I know those are a little weird because they're covered but not covered in depth like this isn't going to be on web workers or RIF."
          }
        ]
      },
      {
        "name": "22-layout-thrashing-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We have an exercise here. This one starts to get a little bit harder. So if folks are struggling with it, there's like absolutely no problem with just waiting until we go over the whole thing together. But this is like a really cool opportunity. I would just suggest to at least play around with the Performance tab and start looking at it."
          },
          {
            "time": "[00:00:21]",
            "text": "So the [LAUGH] idea is it's about layout thrashing. Well, we've been talking about it's about page jank, and things like that. So you can see right now, we've got these ten little Frontend Masters logos, and they're just animating around, on the screen here. And they're really smooth, at least for my screen."
          },
          {
            "time": "[00:00:35]",
            "text": "They're very smooth. And as you start adding more, and more, and more, I have a very new laptop, but, it gets to the point where they're very not smooth. I'm not sure how it's coming in, but like on my screen, they're like very jittery. And so, this is a kind of a multi part task."
          },
          {
            "time": "[00:00:52]",
            "text": "I'm going to remove some sort of back down. So the first one is to make it jittery, keep adding 10 or 100 until it gets jittery. And when it's jittery, like we'll add a couple like this, we'll open up the dev tools. We'll go to performance and we'll record like just one second, let's say."
          },
          {
            "time": "[00:01:08]",
            "text": "So another like tip for when you're doing the recordings is there's a lot of information to process. So the shorter that you can keep your recordings to the better. If you try to record like 10 or 15 seconds of stuff, you'll just have way too much data it'll take too long to parse, and it'll be too much to look at."
          },
          {
            "time": "[00:01:26]",
            "text": "So the exercise here is to get it to the point where it's janking to do a performance recording on it. And then we'll want to one, look at all the ways that Dev Tools tells you. There's page junk, which I'm sort of kind of giving away here with like these big red bars and things like that."
          },
          {
            "time": "[00:01:45]",
            "text": "So that's one, see if we can figure that out. And then the other thing is, can you figure out from just the main thread view, what function is causing the page junk? Just to look at, read through it, scroll up and down. One thing I should mention is navigating is a little bit tricky here."
          },
          {
            "time": "[00:02:01]",
            "text": "So let me go back and record again. So I'll just record for one second and stop it. So we're just gonna be looking in the main thread. But navigating is really hard to do. So if you scroll like up and down, you'll see that it doesn't actually move you up and down."
          },
          {
            "time": "[00:02:17]",
            "text": "It moves you like you're zooming in. I don't know if you can see these bars up here. So as what I would think would scroll me down actually zooms in and zooms out over a specific section of time. And so what you'll wanna do if you wanna actually scroll up and down, like here or something like that, you'll wanna hold Shift while you scroll, and that'll allow you to actually move up and down the call stack."
          },
          {
            "time": "[00:02:39]",
            "text": "So you can see this whole thing, this is the whole second of me running. You can zoom in on a little bit. We should be able to see what type of stuff was happening here. This is on the optimized example still, but there's only ten of them. But you can see that the frames per second are high, they're looking pretty good."
          },
          {
            "time": "[00:02:57]",
            "text": "You can see that there's a lot of free time, that's those slashes through, and the time that is spent it looks like it's spent between, if we go back to this summary, and drag it up. Between scripting and rendering looks like it's pretty evenly spent. So the idea here will be to do the exact same thing, but after you've hit add 100 enough times so that there's actual junk happening and take a look at how different it looks."
          },
          {
            "time": "[00:03:18]",
            "text": "How you can identify that there's definitely a problem here and see if you can kind of figure out just by peeking around in this main thread, what tasks are happening when the page jank is starting to happen?"
          }
        ]
      },
      {
        "name": "23-layout-thrashing-solution",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we already kind of looked at what it looks like on normal. So let's add, I think for me, it's adding 400 or maybe 500, I start seeing some really significant junk. So I'll do the recording for one second, again, always recommend keep the recordings as small as possible cuz there's just so much data."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really cool, so, hopefully this should look very different this time, with all of that stuff, than it did the last time. And there's a couple of things I wanna draw your attention to one, is the red lines across the top, in the frames per second. So, those red lines are where it lost a frame, right?"
          },
          {
            "time": "[00:00:32]",
            "text": "Or it dropped a frame, so, it should be really obvious when you load up a worksite or something like that, get it in that state where you're worried about it, do a recording. And you should see, Chrome is like telling you hey, there was some serious issues here."
          },
          {
            "time": "[00:00:46]",
            "text": "In a very similar vein, under the experience panel here, you see this layout shift in red, which I'm not 100% sure on what it means, but it definitely relates to the frame dropping in some ways. Something's going on there, another thing that you can see is that whereas before, the chart here for the CPU was mostly small mountains with a lot of free time, though white and gray slashes."
          },
          {
            "time": "[00:01:12]",
            "text": "And now it's basically 100% CPU for the entire time it's running the app. You can still see it kind of comes in these waves, there's little bounces, but it's just a massive amount. So if we go ahead and we expand the main tab, we can kind of see every app has its own very unique personality, right with how things are working."
          },
          {
            "time": "[00:01:35]",
            "text": "And so you can kind of see here that what keeps happening is every 100 milliseconds some tasks is getting fired, and something is going on that's causing again, you can see more red saying that the task took too long. There's probably junk or whatever. When you're looking at the thread, what you don't care about is how tall things are."
          },
          {
            "time": "[00:01:57]",
            "text": "That's fine because that's complexity of your code is all it is. So if you have, my example with debugging where you have function one calls, function two calls, function three, let's say you just had 100 of those, you would have a really long execution stack, but it would happen really quickly cuz all it's doing is calling another function."
          },
          {
            "time": "[00:02:15]",
            "text": "So when you're looking at this thing, if it goes up and down 100 or something like that, that's nothing to worry about. What you do wanna worry about is the ones that are too wide, because as we said before, every 16 milliseconds it needs to have a new frame to send basically."
          },
          {
            "time": "[00:02:31]",
            "text": "And so you're looking for long wide ones or the problematic ones and the really long call stacks are not a problem. And so you can see here, we only had 16 milliseconds to produce this frame. And this animation itself took 129 milliseconds so that is a lot of drop frames happening there."
          },
          {
            "time": "[00:02:50]",
            "text": "In a similar way, the way that you can find the problematic function or the problematic code is to go down the call stack and find the last long one before they get really small. So if you think about it, it's if you have a if you have a function called Fibonacci, and it takes forever to generate a Fibonacci number."
          },
          {
            "time": "[00:03:10]",
            "text": "And you wrap it in a function called foo, and all foo does is call Fibonacci, foo will look long too even though it's not really doing anything cuz it's the parent of a long function, right? And so you'd see foo Fibonacci but what so you wanna do is you wanna keep looking at the long ones until you get to the last long one who itself only called a bunch of short ones, because the short ones, aren't gonna be a problem."
          },
          {
            "time": "[00:03:34]",
            "text": "And then you know the last long one is going to be the closest that you can get to the problematic function. Does that make sense, I know that it's kind of a confused, so in this example, we see that the task took too long. And we wanna know what caused and so we can see this is long, long, long then we get to App update long."
          },
          {
            "time": "[00:03:51]",
            "text": "And then after app update, if we were to zoom in here, we would just see that it's calling a million tiny any little short ones. So, if we wanted to know what function was the problem here, app update is the last long one before a bunch of the short ones."
          },
          {
            "time": "[00:04:06]",
            "text": "And then you can do cool things, so you can click on app update if we wanted to kinda see what's going on. And we can bring back up this summary view here, once we click on any cell you can see this is changing. So we can click on the last long one and then we can go and open the actual file where the function got called boom here."
          },
          {
            "time": "[00:04:25]",
            "text": "So again, from the performance, you find whichever cell that you wanna investigate, and then you look at the summary, which you might have to drag up a little bit and then you click on the file name. So one thing that you'll notice that's really cool is after you've done a performance audit, when you look into sources, Chrome will save how long the function took to run in the sidebar here, of all the stuff that it was able to see."
          },
          {
            "time": "[00:04:48]",
            "text": "Which is really cool, so you can see this app update took a super long time, took like well over a second, almost 1.5 seconds. And then as you start looking into it, so that basically gets us to the JavaScript code that's causing our problem. In this case, we can see that it's doing a lot of reads and writes right, where it's going through each one of these little Chrome Dev Tools things and it's looking to see so it's reading them to see if it has a class name."
          },
          {
            "time": "[00:05:16]",
            "text": "And then if it does have that class name, it's reading them again to get the offset from it. And then it's reading the current position against the max height of the screen that it's in. So it's doing really, really heavy calculation right and it's doing them in an inefficient order where it's like read, write, read, write, read, write, just like we saw before."
          },
          {
            "time": "[00:05:35]",
            "text": "And what's really cool is that there's this optimize button on here and literally all this is doing is it's batching those things so that they're done without invalidating layout just like we were talking about in the example before. And so even with this many hundreds and hundreds of them, if you click optimize, you can see that they instantly smooth right up."
          },
          {
            "time": "[00:05:54]",
            "text": "So it's not just don't do heavy lifting, the web is very capable of doing heavy lifting. But it's important to know how these layouts happen because if you optimize around them, like do all your reads and then do all your rights, and you put both of those in request animation frame you can get a really smooth animation even though it's still doing a lot of really heavy work."
          },
          {
            "time": "[00:06:13]",
            "text": "How are folks feeling about that? Any questions?"
          },
          {
            "time": "[00:06:13]",
            "text": ">> You said something about getting the opportunity to dig into the call stack. So, cuz when we clicked on thrashing.js that did take us to sources."
          },
          {
            "time": "[00:06:13]",
            "text": ">> Right."
          },
          {
            "time": "[00:06:13]",
            "text": ">> But there was nothing in the call stack on the right. So, I think I'm missing a piece of the puzzle."
          },
          {
            "time": "[00:06:32]",
            "text": ">> Yeah, no, absolutely, no, that's great. So yeah, the question was about that I mentioned earlier that when we're looking at performance, we'll be able to look into the call stack of how it got there. But when you clicked on one like we did, and you clicked on the link, which is what we had done earlier, it didn't actually take you to sources with a call stack, right?"
          },
          {
            "time": "[00:06:52]",
            "text": "We got to App update and we clicked on this and it was not paused at a debugger. So we've got two options here, option one is we can now that we've gone to sources, we can set a debugger, right? We can set a breakpoint there and then let it hit again and when it hits again, we'll get the full call stack over here."
          },
          {
            "time": "[00:07:08]",
            "text": "So that's option one, option two is back over here on this performance panel, where we can actually see where these things came from, this one's not a good example because it's literally just animation frames are firing. Every time, but If this was wrapped in a function or something that you would still see the call stack here as well."
          },
          {
            "time": "[00:07:30]",
            "text": "So it's kinda up to you if you just want to peek at it, the call tree can be really good for that if you just wanna see where it came from. If you really wanna understand it better then I would recommend clicking on the file name and then adding app update is here, so then adding one here and then you're able to see."
          },
          {
            "time": "[00:07:46]",
            "text": "But again, this example is not great for that because it's just request Animation Frame firing. But if you did have something calling other stuff like react generating, you will see that all here in the call stack."
          }
        ]
      },
      {
        "name": "24-running-node-js",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Last thing I wanted to show before we move on, which is really cool and people have asked about this is that and this used to be much harder but since node.js is just a wrapper around the js. Which is the same JavaScript engine that chrome uses, you can actually very very easily run your Node.js apps through the devtools as well So I'll demo that."
          },
          {
            "time": "[00:00:20]",
            "text": "So basically, I'm just going to go to my terminal and I'm going to kill the app that I currently have and clear the page. And then instead of running, so I was running NPM start, which is set to run node server.js. This is how I've been running the app."
          },
          {
            "time": "[00:00:36]",
            "text": "You can now go and you can change it to do node dash dash inspect. And do the same thing. So it'll still load the site just like normal, but now when we open up the devtools, we'll see this little node.js icon up here. And if we click on that, we can actually see it pops out its own."
          },
          {
            "time": "[00:00:52]",
            "text": "Kind of got two devtools, right? You've got devtools inception going on. But you can click on like profile, for example. And you can do a full profile and then we'll like refresh the app and then we'll stop the profile or something like that. And so you can do all of these."
          },
          {
            "time": "[00:01:08]",
            "text": "Let me move it over to the flame chart that we're used to. You can do these things. You can actually watch my little Node sample app started up right where it's like it's a fast defy app. And it's like walking ASDs as it walks the mark down all this like really cool stuff."
          },
          {
            "time": "[00:01:21]",
            "text": "So doing it with like a web server is like pretty cool, but like one thing you could do that would be really interesting is if like you're using Web pack, and your build times are slow. You could actually do run node inspect and then call web pack and then you could open it up in here with a profile and like do the same exact thing, right?"
          },
          {
            "time": "[00:01:38]",
            "text": "You can walk any kind of node command line application and see it. So I have like a little example that I'll just do with you all, but you can feel free to follow along with but in the server.js file, I have this like silly little function commented out, which is FUBAR so you can uncomment it."
          },
          {
            "time": "[00:01:55]",
            "text": "And then you can go up and in the get lesson page, you can uncomment it being called. Now save that, now go back to my terminal, and I'll start node with the inspect flag. And then I'll go back to my devtools. And I'll click the node icon again here and I'll start recording then I'll go back here and I'll refresh the page and then I will stop recording."
          },
          {
            "time": "[00:02:18]",
            "text": "And we can actually see like inside this fast defy which is the framework I'm using get this like FUBAR function, so we're actually seeing like the node server trying to process stuff. And you can see it's it's reading and markdown, and then it hits this thing. So you can do a really nice, just like we did with the front end code."
          },
          {
            "time": "[00:02:33]",
            "text": "You can do it with all your back end code. Here's my server.js file. Here's how long it took to do this silly thing, all that stuff. So this is really cool, because when you start looking into it, there's like a lot of stuff that we use day to day that's just a node app."
          },
          {
            "time": "[00:02:45]",
            "text": "And so just the idea of being able to run, the Chrome devtools that you're used to on the node app can be really cool."
          }
        ]
      },
      {
        "name": "25-memory-leaks-memory-heap-snapshots",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the last lesson around performance is going to be on memory. Another call out that I just wanted to make before we go too much further is that I can't remember exactly when I think very soon there's going to be another course coming in front end masters."
          },
          {
            "time": "[00:00:15]",
            "text": "It's on the work schedule for advanced dev tools stuff that Omar is going to be running, he does all sorts of good stuff. So if you are like these are meant to serve as kind of like your introduction into like, okay, I get what the performance tab does and I know what I'm looking at and I see paging and stuff like that but if you're interested in finding out a lot more on like, he's going to do I think real life case studies and like a bunch of really cool intricate stuff into like memory, CPU, network, all that stuff."
          },
          {
            "time": "[00:00:40]",
            "text": "Stay tuned for his class because it's coming pretty soon. So yeah, the basic idea with memory. So JavaScript as a lot of people know has garbage collection to it, right? So you don't need to actually declare and purge your memory. But with garbage collected languages, you can end up with what we call memory leaks, but they're basically like stuff that you've forgotten about."
          },
          {
            "time": "[00:01:04]",
            "text": "So like, one example would be if you make too many DOM nodes, and you don't clean up after them, so if you're like making a table, a lot of people use like virtual scrollers. And what those will do is they'll render like 20 frames of the table and then as you scroll, it'll reuse the top ones and replace them in the bottom, things like that so you don't end up with a huge DOM."
          },
          {
            "time": "[00:01:25]",
            "text": "But if you didn't use a virtual scrolling, you just tried to render like a million table rows or something like that. It would take a lot of memory and you'd start noticing a real performance hit after a while. Another thing that can get you is, this one's a little bit tricky."
          },
          {
            "time": "[00:01:38]",
            "text": "But when you think about code, like you're often interacting between the DOM and JavaScript, like we've been doing it a lot today. So for example, we'll like in JavaScript will do document.create element LI right? And so we have a list item but it's in memory only it hasn't been attached to the DOM yet."
          },
          {
            "time": "[00:01:58]",
            "text": "And then we'll do that LI that we did, we'll do like body.add child and we'll pass that and now LI it's in the DOM. And so one thing that can happen is that those references to the in memory ones that you never did put in the DOM or you put in you took out if you don't know those out or delete them somehow those can just grow and grow in memory as well."
          },
          {
            "time": "[00:02:18]",
            "text": "And so the kind of most important thing that you want to do is like, establish like, if you have a memory like that's like the first step right? Before we go diving too deep into it, so we really have like three tools for it. And one of them is a caveat of the course because it is in Chrome, but it is not part of the Chrome Dev Tools, but it is a very cool tool that Chrome offers."
          },
          {
            "time": "[00:02:40]",
            "text": "And so that one is the Chrome Task Manager. So if you go up to the top right, then you click on the three dots, and then you go to more tools Task Manager. You get this really cool thing that I didn't know existed for a super long time."
          },
          {
            "time": "[00:02:53]",
            "text": "And so this is basically like your activity manager, but just for what Chrome's doing. So it'll show all the tabs that you have open. It'll show all the services that it's running everything like that. Now, it doesn't work right off the bat because it just shows its memory footprint and its CPU."
          },
          {
            "time": "[00:03:08]",
            "text": "But what we really wanna know is do I have a JavaScript memory leak, so we can right click on the headers here, and we can go over to JavaScript memory and we can add that new column here. And so now we've got JavaScript memory so we can see that the right now my front end masters tab with the chat is taking up a lot of memory."
          },
          {
            "time": "[00:03:26]",
            "text": "And then my Google search is taking up some memory. My tab is taking up less memory, those kind of things. So one thing that's cool, let me kind of reorganize stuff a little bit here. So I'll close these just to kind of simplify stuff. And then I'll drag, let me grab hold of my browser here."
          },
          {
            "time": "[00:03:45]",
            "text": "I'll drag this over, and then I'll kind of set this up. So what I want to be able to do is kind of do both at the same time, right, I want to see my tabs. And I also want to see the memory usage. So if we take like this tab here, it's using two megabytes of JavaScript memory basically."
          },
          {
            "time": "[00:04:01]",
            "text": "And then I made all these buttons that make a bunch of DOM nodes or make a bunch of detach nodes or something like that. So we see that it's at 2700. And as I start kind of clicking on it takes like a second or two, we can see it spike up really high right to 6000."
          },
          {
            "time": "[00:04:16]",
            "text": "I know that's really small. I can't find a way to make the text bigger. But this is like one cool thing you can do. So to be a memory leak, you would open up the task manager, enable JavaScript memory, highlight the tab that you're worried about. And then do whatever you're worried about."
          },
          {
            "time": "[00:04:30]",
            "text": "Are you worried that it has a memory leak is it just sits there, are you worried about that has a memory leak as users interact, do whatever it is, and kind of keep track of this because ideally, all the memory that we allocate, we should also be purging, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "So if we're creating DOM, we should destroy DOM. If we're creating a big array, we should get rid of that big array, those kinds of things. So you should always be able to find it that way. Another way that you should be able to find it ,let me fullscreen this again and refresh, is actually back on the Performance tab from the CPU one."
          },
          {
            "time": "[00:04:57]",
            "text": "One of the reasons I think that it seems so confusing is because it's just doing so much, but when we're on the Performance tab, we can click on memory here. So if we do a recording, and let's say we go back to our page and we do some stuff and clicking on these buttons that I know use a memory then I stop it."
          },
          {
            "time": "[00:05:15]",
            "text": "We can see down here these kind of gains in memory and so memory usage like if it goes up and over and back down is never a bad thing because it's there for us to use, that's totally fine. What you always want to look for is this kind of jagged, like sawtooth."
          },
          {
            "time": "[00:05:29]",
            "text": "If it's like climbing, that means it's seeing kind of using something, it's not purging, and then it's using more and more. So you can see this kind of pattern every time I click the button, it consumes more memory. It also gives us kind of a nice breakdown. So it'll show us what memory is used by the JavaScript heap, what of it is documents, what of it is like DOM nodes being created, event listeners or GPU memory being used."
          },
          {
            "time": "[00:05:51]",
            "text": "So that can kind of start getting us in the right direction. We use the task manager to see if we have a leak, just watching the JavaScript memory. And then we can use the performance profile to see what type of thing is causing this issue. And then the third thing we can use is, of course, the memory panel itself."
          },
          {
            "time": "[00:06:09]",
            "text": "So let me dock these back to the bottom. So we've got three options here for viewing memory. One of them is just to grab a heap snapshot. So it just grabs everything that's in memory at the time and shows it to you. So for example, I could do a snapshot like this, it takes a second and it shows this big list of items."
          },
          {
            "time": "[00:06:30]",
            "text": "So this list we're going to be looking at in a couple of different ways, but the basic idea is that we'll see the type of item like what it was constructed by like a UL list item or just an internal system stuff or an array, things that should be familiar and then it'll show these couple of things that show shallow size, distance, and retain size."
          },
          {
            "time": "[00:06:50]",
            "text": "Distance for the most part we can ignore. It means distance from the window object, from the global, basically like how far deep it is. But shallow and retain size are really important. So the shallow size is like, how big is that thing? So if you have an array of a million, how big is an array of a million?"
          },
          {
            "time": "[00:07:09]",
            "text": "Retain size is important because of how garbage collection works. So garbage collection works via this mark and sweep process. I don't know if anybody's ever heard of mark and sweep before. Basically it grabs everything that there is and it gives it like a flag like false. And then it starts from the window and it walks every single thing that the window is pointing towards and everything it's pointing towards and everything all the way down the tree."
          },
          {
            "time": "[00:07:32]",
            "text": "And everything it touches, it flips the false to a true. So it's like I've seen you, I've seen you. And then at the end of the pass, anything that still has a false flag can be deleted, right? Because nothing's pointing to it. And so the idea again being if you have an array of a million and you have a function called foo, and all food does is it points at that array of a million."
          },
          {
            "time": "[00:07:53]",
            "text": "So it's like array equals another big array of a million, then array of a million is the big thing, but since foo is pointing to the array of a million, the array of a million will stay as long as foo has something pointing to it. So it kind of like it's basically you can have like an object, and the object can be pointing to a key that has an array that's really big."
          },
          {
            "time": "[00:08:17]",
            "text": "As long as that object stays in memory, it has to keep everything the object points to in memory too, because it doesn't know when those could be accessed. And so what can happen, with these DOM nodes that I talked about earlier, as you can accidentally still have a reference to something that you don't care about anymore."
          },
          {
            "time": "[00:08:33]",
            "text": "So like a good thing would be like you create the LI, you stick it in the DOM, but you still have that LI. If you never know it out, it'll just stay in memory like forever basically. And so, that's all a long winded way of saying that you'll get two different things, one of the shallow size is the actual size of the thing, the retained size is how much memory could be free if that thing were deleted."
          },
          {
            "time": "[00:08:55]",
            "text": "And the difference being like you could have an object with just two keys on it so very small shallow size, but one of those keys points to a gigantic array of like a million so the retain size is very big, because the only reason that array is sticking around is because of your object."
          },
          {
            "time": "[00:09:10]",
            "text": "Does that make sense, I'm gonna pause for a second on that. So that's like basically as long as something has a pointer, it stays in memory. So if you add anything to the window object, as long as the window object stays, which it always will, that thing stays."
          },
          {
            "time": "[00:09:22]",
            "text": "And so you can kind of get this difference in like how big is the thing? Okay, but how much memory kind of clear up if I deleted that thing, meaning that thing and anything that it's the only pointer to, so yeah, back onto the memory pad. So we've got the heap snapshot, which is great."
          },
          {
            "time": "[00:09:36]",
            "text": "Another tool that we have, which is really useful is allocation over time. So we can basically see when memory is being allocated over a period of time, sort of like the performance or we're measuring across time. So like you could demo this pretty easily by starting a time allocation, starting record and then hitting one of my buttons and will see that every time I hit a button a whole bunch of memory is allocated."
          },
          {
            "time": "[00:09:59]",
            "text": "And we can also see that it never goes back down. It's not like a shape like that. And so if I stop my recording here, I can see, let me make this a little bigger. That things are getting bigger. I can sort by shallow size I can see."
          },
          {
            "time": "[00:10:12]",
            "text": "So the system in parentheses that's like its own stuff. But I can see that these arrays are really big and they're full of these detached HTMLLIElements. So if I were to look into the code just so we can kind of get a picture of what we're doing that's causing this it shouldn't be too much of a surprise that we're making a whole bunch of UILIElements and we're never knowing them out."
          },
          {
            "time": "[00:10:32]",
            "text": "So like we're attaching them but we're not getting rid of them in memory, they just stay in memory. Is that kind of making sense? So I know it's contrived, like a for loop of 1000, where you're creating elements or whatever, but the idea being that you can kind of start in the memory panel, see if you have a leak or how much is being used."
          },
          {
            "time": "[00:10:50]",
            "text": "You can also see what's taking it up over time. Cool. So the last thing, which was probably like the most common question I got, last time I did the course. But Chrome has added a really cool feature for it is like, people would always ask, okay, like I see I have a leak."
          },
          {
            "time": "[00:11:06]",
            "text": "I know that there's a problem. How do I figure out what it is, like what's causing it? Where's it coming from, because you have these big complicated apps. And so chrome added this really cool thing, this allocation sampling. And so what this does is it lets you kind of record again over time down here, but what it's going to do is instead of, just let me go ahead and stop that, it's coming up."
          },
          {
            "time": "[00:11:32]",
            "text": "Let me delete this, let me start one and then do something that takes up memory. I think the problem I keep running into is, if no memory is being used, then the profiles will be empty. And this is just a flat page. So start one, click one of the buttons."
          },
          {
            "time": "[00:11:48]",
            "text": "Now this is actually going to tell you instead of just all there's a bunch of arrays, or there's a bunch of UlLIEelements, it's going to tell you what function is causing that problem. This is like great. It's like something I've been waiting for years and years because a lot of times complicated apps are like, yeah, I see that I have event listeners."
          },
          {
            "time": "[00:12:06]",
            "text": "And there's a bunch of detached event listeners, but I don't know what's creating them or something like that. So being able to go from memory allocation to actually pinpointing you in the sources panel which function is causing things is like a superpower. It's really convenient. So yeah, I think the kind of TLDR with memory is the first way to do it is get the task manager to even see if you have a problem."
          },
          {
            "time": "[00:12:31]",
            "text": "Like is it allocating a lot of memory, and if so, is it going up over time? If it does having a problem, then I would go into the Performance tab and do a performance recording and then I'll get you a little bit of like a visual on like what type of problem is it?"
          },
          {
            "time": "[00:12:43]",
            "text": "Is it like JS heap? Is it DOM nodes? Is an event listeners? That kind of thing. And then coming in here and actually taking a look at like, what's allocating? How much is it eventually going for the allocations snapshot so you can see what JavaScript is causing those things."
          },
          {
            "time": "[00:12:59]",
            "text": "It won't always be this clear obviously, usually you'll have a couple different things that are big and taking up room. But this can really help you like narrow down what's causing stuff and what's not going away. One thing I forgot to mention that you can do too, is there's a forced garbage collection button here."
          },
          {
            "time": "[00:13:14]",
            "text": "So another thing that would probably be useful because sometimes you allocate memory for a long time, but you do get rid of it eventually when garbage collection happens. So for example, if we go back to the heap snapshot, we can start a recording. And then we can like generate and then we can try to garbage collect and we should see it go back down to zero, but since it's not, that's like a way we can be sure that there is a leak, right that there's not stuff."
          },
          {
            "time": "[00:13:40]",
            "text": "We're not using it and garbage collection doesn't take it away. That's a problem. Yeah, so the question is when you're looking at memory in the Performance tabs, you're looking at kind of the chart at the bottom, are you looking to see if the JavaScript heap goes up and down or if any of them are not going down?"
          },
          {
            "time": "[00:13:57]",
            "text": "And it's really if any of them are Jiggs sign up, it doesn't matter which one, then that's some sort of problem because they should all go back down to a stable level after any big allocation should always go back down. Or at the very least, it should go up and go flat."
          },
          {
            "time": "[00:14:13]",
            "text": "Like, let's say you have an app where you just rendering like 10,000 things and that's just what you're doing. So it should go up and then it should stay, but it should not keep climbing like the only reason it would be climbing is if it was miss properly allocated or it's just not being garbage collected."
          }
        ]
      },
      {
        "name": "26-what-can-slow-down-a-website",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's always fun, like it's fun to go to a new site and just give it like some kind of audit, like a very high level view of like, what's going on with it, i remember this one time as an antidote, i was doing an interview. I was interviewing for a job and one of the questions was what can slow down a website [LAUGH] I've only guys ranted for like 45 minutes I was like kind of disappointed when the interview was over."
          },
          {
            "time": "[00:00:23]",
            "text": "I was like I still have more things, so it's kind of wanted to talk through some of the things that I've seen very commonly slow down websites, and I always kind of group it into like back end and front end stuff. Obviously, those groups they don't really hold true today as things have gotten very complicated [LAUGH] when you have server less sites or you have a front end service team and then a back end service team, but I really mean you have the user's computer and then you have where your code is stored at your data center and kinda one or the other side."
          },
          {
            "time": "[00:00:55]",
            "text": "So when you think about back end things that can slow down websites, Database calls can happen a lot like me the database is an index property. I properly I know Brian Hall just did like a huge course on front of masters on introduction to databases. Sure it covers a bunch of great stuff on like being efficient queries, but I've seen it often where you have a lightning fast server but a really slow my SQL database and that's just going to slow down the request."
          },
          {
            "time": "[00:01:19]",
            "text": "The server can be slow Or there can be not enough servers, it's just overwhelmed and it's having a hard time responding. The network can be bad, this can kinda both into front end or back end, so either some calls between services can be too slow network connection or from the client to the server can be slow."
          },
          {
            "time": "[00:01:40]",
            "text": "And those are really interesting to fix because there's lots of different things you can do, you can put your static assets out on a CDN can be great. There's also all sorts of cool serverless technologies that let you host your code in multiple places, basically like a CDN for dynamic stuff."
          },
          {
            "time": "[00:01:58]",
            "text": "A lot of bigger companies will have data centres located strategically all over the world, or they'll buy like a small presence like a pop or something like that in certain areas to make connections faster. There's a lot of interesting stuff you can do there, and then the last thing which you talked about a little bit is compression."
          },
          {
            "time": "[00:02:16]",
            "text": "I wanted to give like a quick shout out to jesup and brotli here because they also kind of belongs in the network section. But there's two compression formats that browsers actually understand which are g zip and brotli. Which means that if you use them to compress your code and send that compressed code over the wire."
          },
          {
            "time": "[00:02:36]",
            "text": "The browser doesn't need any extensions or anything special to be able to uncompressed your code and read it back out, which is great. So it's Think of it as like a zip format that all browsers understand, which means that you should be probably compressing everything that you use, so for example, if you have like a node app, let's say use Express node or whatever, then you would just wanna look for like unexpressed node, compress, plugin, right, some kind of middleware."
          },
          {
            "time": "[00:03:03]",
            "text": "They all have these, whether it's like a Java app or a Ruby app or whatever, you just want something that's gonna jesup all of your requests that gets sent over and all your static assets as well. So compression is great, on the front end, we see a lot of things these days, one of the things I see most often are really large JavaScript bundle sizes."
          },
          {
            "time": "[00:03:23]",
            "text": "That's probably 90% of the cases that I diagnose, come down to that where it's like people say like, can you try to stick under like 2,3, 4 100 kilobytes of JavaScript and then you go look at some of these sites, and you're looking at like 5 6 7 megabytes of JavaScript."
          },
          {
            "time": "[00:03:40]",
            "text": "And it's just, it's so easy, i mean, it's so easy to get set up, you need a cool thing and you go to NPM and you find the cool thing and you NPM install it and you just add it and like before long you've got, just so much code."
          },
          {
            "time": "[00:03:56]",
            "text": "This could be its whole own class, so I'm not gonna go too deep into it, but reducing the dependencies you have is great. Making sure that you're your bundler is optimized is great and another thing is taking advantage of all the modern things. I said Webpack is very flexible, you can say, hey, I need this, but I don't need it on page load, so just download it asynchronously."
          },
          {
            "time": "[00:04:18]",
            "text": "There's lots of really cool things you can do with bundlers to make the site faster, too many files we kinda covered this already. I always like doing audits at the end even though audit is the easiest on a technical level. It also kinda nicely wraps up all the stuff that we've been learning as you're like, yeah, we kind of covered that, so we covered in the networking section that you can only do 6 synchronous requests at a time."
          },
          {
            "time": "[00:04:41]",
            "text": "So if you have Like 700 images that need to come down, it's just gonna be queuing installed for a really long time. Again, with images, just like JavaScript, you can make a lot of them asynchronous if you don't need it for the actual page load, like if it's just presentational or if it's below the fold, like down, scroll lower, just make a may synchronous."
          },
          {
            "time": "[00:05:00]",
            "text": "It can be a huge savings, Images also are tricky like, they can be uncompressed they can be too big. So I we see this a lot where in your CSS you'll have like image style, width 500, height 500 great, and then you hover over the image, and it'll be like, well, the natural size of this image is like 2600 by 1400."
          },
          {
            "time": "[00:05:24]",
            "text": "And it's like, well, why are you sending this like giant image over the network if you're only going to render it in a very small way. The other thing is that images have all of this metadata, so if you open as someone who works for one of the largest Companies that puts that metadata [LAUGH] there."
          },
          {
            "time": "[00:05:39]",
            "text": "When you open something and like Photoshop or whatever, it's gonna save all this really, really handy stuff so that when you open it again, you know has all this history and what file or what program it was last edited with all this stuff. It's really good for keeping local files but it's really bad for the web, so if you use something like image optimizer, or any number of cloud services do the same thing they'll like trim all this metadata off."
          },
          {
            "time": "[00:06:04]",
            "text": "One, it can be a security issue, we often read about hacks where like Exif, data was left on images and people could find where they were posted from. Number two its file sizes, you don't need all that metadata just makes the image bigger, so would they call that as lossless image compression."
          },
          {
            "time": "[00:06:19]",
            "text": "That's the thing to look into, which is making the image smaller without losing any quality, that's basically what it means. So images to large images on compressed, unused JavaScript and CSS, this one could be another kind of workshop, so Chrome dev tools can tell you unused code. But the story is like never really that simple, right, because you'll often have CSS that's there to style a modal that the user just hasn't clicked on yet."
          },
          {
            "time": "[00:06:45]",
            "text": "So it's not really unused, it just hasn't been used yet, so I think the better thing to do is to use the bundle async stuff. So like use your Webpack, like dynamic imports or whatever bundler you're using to be like, hey, my that modal the JavaScript and the accompanying CSS does not need to come on page load."
          },
          {
            "time": "[00:07:04]",
            "text": "It can come later, is a good way to do it, CSS in the document body, that's another one is where you put stuff will trigger when, so if you put stuff in the head versus the body the CSS and the body will be like an asynchronous, like a lower priority loads, then it'll cause everything to kind of warp in afterwards."
          },
          {
            "time": "[00:07:27]",
            "text": "But then a lot of JavaScript libraries, like analytics ones always want you to put that in the head, which will then block a lot of the thing. So you are like waiting on Google analytics before your page loads, so really tricky and last one, browser caching. So setting cache headers on your server, and then respecting them in the browser is great, i actually over the break I had seen some questions over E tags which I think now is a good segue into."
          },
          {
            "time": "[00:07:55]",
            "text": "So I mentioned E tags earlier is like a standard, that people use for, caching something until it changes basically, and so they're not necessarily for free though. So the E tag is a header that your server will need to set, and you can look it up on MDN, but it's just E tag, and so your server will send an E tag header with a unique hash to like the file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then the client also needs to do some work, the client will need to with the fetch request send an F non match header itself and this is all you can find this on MDN. But basically the server will need to send the unique hash, and then the client will need to send only give me a new file if it's not this hash and and that's how they can kind of communicate very quickly together."
          },
          {
            "time": "[00:08:39]",
            "text": "So these things are a little confusing but there, hugely important when you're, working on a big site that has like user uploaded images that can change but they don't change very often. So ideally, you would cache them all but sometimes you need to purge that cache."
          }
        ]
      },
      {
        "name": "27-simulating-network-conditions",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Another thing, before we get into Lighthouse, is that dev tools can do some really cool stuff simulating conditions. So I'm gonna go ahead and open the Element Inspector. So on the Network tab, if we go to these settings down here, I'm sorry, where is this? There it is."
          },
          {
            "time": "[00:00:16]",
            "text": "Sorry, it moved it. So on the Network tab, this little drop down here, you can throttle network conditions. So you can look at, for example, all the way to offline, but you can look at a slow 3G connection or a fast 3G connections. So we can see my site loads pretty quickly almost instantly, but then on a slow 3G connection, you can see it kind of spinning and spinning here."
          },
          {
            "time": "[00:00:36]",
            "text": "So that can be a really cool thing. You can simulate these connections and see, well what is somebody going to experience if they're on a really bad network? The other thing they can do is in the Performance tab, under their settings, you can actually do CPU throttling, too, which is really cool."
          },
          {
            "time": "[00:00:51]",
            "text": "If you remember in the network lesson we talked about how bites over the wire isn't the only thing. Parse time can also be hugely important for page load. So what if you are worried about parse time? You can come into the Performance tab, you can set a CPU throttle, and then you can reload the page there, and you can see how long it actually takes to parks all your JavaScript on a slower connection."
          },
          {
            "time": "[00:01:12]",
            "text": "So that's really cool. So you can, yeah, you can throw out the network and you can throw out all the CPU. Very, very useful if you want to get a little bit of that empathy of what users will see on slower connections. Another aside I wanted to make is that let's say you have kinda trimmed your code down, so it is what you need it to be."
          },
          {
            "time": "[00:01:35]",
            "text": "Moving things around so that, while it will load slowly it loads well, can be very important. So, for example, sites that are entirely client side rendered, like a react site where you just render a div main from the server with nothing in it, then React boots up and then React populates it."
          },
          {
            "time": "[00:01:52]",
            "text": "What if you put a nice static HTML file and instead, so that was a really slow connection, while React is parsing, the user at least get some good HTML and some CSS, stuff like that, and this can be done in a number of ways, but the network throttling can be really cool to watch how your site loads, and it can give you some ideas into things that you can do to at least make the experience better, even if people do have to wait a few seconds for the whole thing to load."
          }
        ]
      },
      {
        "name": "28-lighthouse-audits",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is really, really cool. So, Lighthouse is the last tab we're gonna kinda cover here. When I did this talk last time, Lighthouse wasn't in the panel, and was it's own separate website. It's a open source initiative that came out of Google. It's really well maintained with all these rulesets and tests for web performance."
          },
          {
            "time": "[00:00:24]",
            "text": "And I used to have this advice where I was like, if you're doing a local app, you got to use Audit. But if you have an app on production, go check out lighthouse. It's like the best. And now Lighthouse is here in the tabs, which I'm like, just very giddy over because it's just so good."
          },
          {
            "time": "[00:00:38]",
            "text": "All the rules are open source and online and a ton of people contribute to it. And it has all these different categories, which are somewhat self explanatory. They're maybe a little complicated, but so performance is going to be initial page load performance, very similar to what we've been doing manually with the network stuff."
          },
          {
            "time": "[00:00:57]",
            "text": "Progressive Web App is going to check, does it service worker does it work offline. Does it have a manifest? All these great things for progressive web apps which we're not building right now, best practices is gonna be just a lot of normal stuff about the images and compression and all those different things."
          },
          {
            "time": "[00:01:15]",
            "text": "Accessibility is hugely valuable, I have an accessibility course on front of masters but making sure that interactive elements can be done via the keyboard, making sure that color contrast works well for people with different vision impairments. All sort of things like that making sure screen readers are going to have an easy time reading your content, to non sighted users."
          },
          {
            "time": "[00:01:35]",
            "text": "And then SEO, just making sure that you're doing kind of the basic things for Google to be able to track your website well and for other search engines to track as well. So I think for now, let's just go through, let's just generate a mega report. And this is keeping in mind that we know that we're not a progressive web app."
          },
          {
            "time": "[00:01:50]",
            "text": "We know we don't have any of those features. So, you click what you want, and then you click Generate Report and it's gonna do a bunch of stuff in the background. It's going to refresh the page and stuff like that. And so you get this very, very nice easy to parse, 0 through 100 score on all the different categories."
          },
          {
            "time": "[00:02:08]",
            "text": "So you can see it's pretty cool. I found that we're not a progressive web app and instead of giving you a bad read score, it's just kind of grayed it out. We get 100 number Performance, 90 on Accessibility, 93 on Best Practices, 78 on SEO. So let's just start looking through."
          },
          {
            "time": "[00:02:23]",
            "text": "These are like, sometimes I think about things that I'm like, you could probably just make money just by offering people who have business websites and aren't super tech savvy, probably just honestly like run Lighthouse, print it out and go talk to them about it. It's so valuable even though it's free, it's just so cool to be able to see."
          },
          {
            "time": "[00:02:43]",
            "text": "So on the Performance tab, that's the onload performance. We can see all these great things like how long it took for the first contentful paint, how long it took before the site was interactive. For those of us that work at big companies, we probably have a few of these metrics that are mandated, like time to first byte or first contentful paint."
          },
          {
            "time": "[00:03:02]",
            "text": "Those will be things that we need to keep the app on a certain time. So first contentful paint is like we talked about on there when the page renders the first time and time to interactive. I've seen this on some slower sites where it's loading that is blocking the main thread where you can't click on things, you can't scroll, you can't click on a button."
          },
          {
            "time": "[00:03:20]",
            "text": "So that's time to interactive before. The main thread is free enough that you can do stuff again. Largest contentful, paint, layout shift, all these different metrics. And what's really cool with these is if you get one red or yellow, it'll flag you with a page for each and every one of them where you can click on the page and go to this really nicely maintained dock for like, well, why am I getting that?"
          },
          {
            "time": "[00:03:43]",
            "text": "What can I do? What's the problem here? I know I'm gushing over it, but it's just so awesome. Lighthouse is such, such a great resource. Cool, so kinda scrolling down. You can also see, I know these are all mini. Remember I said that if you have the Dev tools not popped out, the screenshots will be really tiny."
          },
          {
            "time": "[00:04:01]",
            "text": "So here is just little tiny screenshots of what's going on up there. And then it has suggestions. So here it can says the only suggestion normally you get a lot is that you could save 100 milliseconds or something like that if you eliminated render blocking resources, and specifically if I extend that it's the custom font that I use."
          },
          {
            "time": "[00:04:22]",
            "text": "So I have a custom font. It's pretty small. But if I got rid of it, then I could speed things up a lot. The other thing you could do is, you can do that. Have you ever loaded a site and it loads with a system font and then it changes into being a custom font."
          },
          {
            "time": "[00:04:36]",
            "text": "You guys do that. I mean, it's gonna be a lot faster or not maybe a lot, but it'll be somewhat faster but at a worse user experience. So kinda your choice. And then here's all the things that, these are not marked red. So, if they were I could go and read into those more, if I was messed something up."
          },
          {
            "time": "[00:04:53]",
            "text": "And then here are the ones that are passed audit. So you can see these two. These are all the things that would flag, if you're on a production site, and it had any of these issues. Next one accessibility. Same thing, it just gives you immediately useful, very helpful stuff."
          },
          {
            "time": "[00:05:07]",
            "text": "So it's like, this HTML element doesn't have a Lang attribute. And it has this whole important thing about screen readers. If you don't set a language on the HTML element, they will use the user's default language. So if you are a Spanish speaking user on a Spanish screen reader, and I have an English website, but I don't set the Lang, it's going to try to read it in Spanish because I haven't set the Lang."
          },
          {
            "time": "[00:05:29]",
            "text": "So, immediately very, very useful stuff that you honestly could just go, just follow along and kind of fix all these things. Then again choose all the passed audits that we got. I will give a caveat here. Accessibility testing like automated testing has come such a long way. And I know that sounds a little cliche, but it's especially true with accessibility, like really nothing beats the real thing."
          },
          {
            "time": "[00:05:52]",
            "text": "Nothing beats actually getting a user on and trying to tab around and make sure, because things might have tab index, but they might be unintuitive or clunky. And Chrome Dev Tools won't be able to catch that. So this is a really good starting point. These are easy things to fix, but accessibility is very subjective."
          },
          {
            "time": "[00:06:10]",
            "text": "For making a good experience, it's a little bit harder to Lindt and better to have somebody on your team that knows how to use a screen reader and knows how to tab around and make sure that it feels good. That feels nice. Another thing, best practices, missing one where there's no doctype set."
          },
          {
            "time": "[00:06:28]",
            "text": "So again, on the HTML, you might how you usually do like doctype HTML, or whatever, sort of a relic back to the old days where we had, before HTML5, we had all these specific doctypes and these specific modes that browsers would. But again, you can go to the Learn More and it'll just tell you to put doctype HTML at the top of your page."
          },
          {
            "time": "[00:06:47]",
            "text": "And then here are the audits I passed. Coming to SEO, I don't have a meta viewport tag. And so this helps mobile devices know how to scale so they don't have to pinch to zoom. Have you ever loaded a site on your mobile device and it's like super mini, and you're trying to zoom into it?"
          },
          {
            "time": "[00:07:02]",
            "text": "So this meta viewport can help with that. And there's no meta description. Again, not an SEO class, but these are things that help the search engine know more about the page so that they can index it better. Cool, and then PWA. I failed a bunch of things, but it's not a PWA."
          },
          {
            "time": "[00:07:19]",
            "text": "That's okay. So it said, hey, we went offline and we expected to 200, we didn't get one. It doesn't have any service workers at all. There's no web app manifest. I mean, these are things we know because it's not a progressive web app. But if you do have one working on mobile@twitter.com, and you want it in the App Store and you want to, make sure that you pass all these PWA tests as well."
          },
          {
            "time": "[00:07:40]",
            "text": "Cool, and then it's got a bunch of meta information, just about what slowed down at use, what site it was, all these kinda great stuff."
          }
        ]
      },
      {
        "name": "29-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Two things that are sort of outside scope for this course I didn't want to go too long, but I think are very cool. Puppeteer for all those that don't know Google's chrome can be called from node in a headless way. So folks that do like, what's it called end to end tests on your websites."
          },
          {
            "time": "[00:00:18]",
            "text": "So, maybe you'll have one actually opens a tab logs in does stuff like that? Puppeteer is a great tool for that. There's also some other tools like WebDriver, and things like that. But when you think about the performance API that we covered earlier, you can do some really cool things with puppeteer WebDriver, where you could have it log in and record some metrics and save those metrics or I like to do like CI workflows."
          },
          {
            "time": "[00:00:41]",
            "text": "I always have this like philosophy that If you can't lint it, test and make a CI rule for it, you shouldn't bother somebody on their code review about it. You know, it's like let the computer do that. Don't you change? So, one thing that I like to do is I have a few I called my performance budget."
          },
          {
            "time": "[00:00:58]",
            "text": "I think Alex Russell from Chrome, maybe coined that term. So, I have my performance budget. And we use puppeteer, puppeteer logs of performance API. If they're greater than certain numbers, it flags the PR. So when you go to put a PR up, things are a little bit too slow."
          },
          {
            "time": "[00:01:13]",
            "text": "And then it's not a person yelling at you. It's just a simple rule there. So, there's a lot that you can do there, combining the performance API with Puppeteer. Similarly with Lighthouse, they have a CI that you can call from node as well. So, you can do a very similar thing where you could say, on every PR spin up the website, hit it with Lighthouse, and if it gets less than 100 flag PR, you could do something like that, which is very cool."
          },
          {
            "time": "[00:01:36]",
            "text": "I think that would be a little bit more going into like Jenkins or CI jobs and that's a little outside of scope, but it's just something cool to think about.cool. So, basically the last thing that I just wanted to talk about kind of in Lieu of Puppeteer and lighthouse."
          },
          {
            "time": "[00:01:51]",
            "text": "CI are just some other cool like parting notes because we've kind of gotten through all the heavy stuff. One thing that's really cool our Chrome Dev Tools experiments, so if we right click and we go into inspect and then we go to the settings cog up here. You'll see a lot of different stuff which is cool that you can kind of control the display."
          },
          {
            "time": "[00:02:09]",
            "text": "You can do light mode, dark mode, you can control how the panels are defaulted laid out. Remember in the sources debugging, I said you could right click and you could black box a script if you didn't want it seen. If you want to remove one that you've black box, you can come here and do so, the devices over here is where you can emulate different devices."
          },
          {
            "time": "[00:02:30]",
            "text": "So you got all sorts of cool defaults that you can set, but one that I wanted to bring attention to is experiments. So, before things launch, they always come out here in this experiments tab. And so you can take a look through there's always really neat stuff in here, It's like use as is enable at your own risk [LAUGH] all this stuff so they're not documented."
          },
          {
            "time": "[00:02:52]",
            "text": "A lot of times you have to poke around to see where they even are, you'll enable somebody to get on the memory tab. No is on the performance. I see it now. But there's always a really cool stuff. Some of this stuff doesn't make it in to Dev tools."
          },
          {
            "time": "[00:03:06]",
            "text": "But this is really neat stuff that you can kinda play around with and see. There's another little one that I wanted to show which is, if we go to the dot.da and show the console drawer, and then we go to its dot, dot, dot, there's a bunch of little stuff that you can see here."
          },
          {
            "time": "[00:03:25]",
            "text": "And so one thing that I always like to do is, you can like click on like rendering for an example. And there's all this endless cool things that you can do, but you can do something like paint flashing. That's one of my favorite things to do. Then anytime Chrome is repainting like as i over things, it'll show you in this cool green outline."
          },
          {
            "time": "[00:03:49]",
            "text": "And so this could be really cool. You have a big react app and it's going kinda slow. Sometimes it might be repainting the whole site just when you're trying to change a really small thing. And this would be a really great way to figure that out. So you just go into it."
          },
          {
            "time": "[00:04:03]",
            "text": "Dev Tools, open the console drawer and then data dot here and you can see all sorts of just really neat stuff. Yeah, there's all sorts of amazing things that you can add. But each one of them each one of these just has a list of checkbox. Here's another one that I really like."
          },
          {
            "time": "[00:04:18]",
            "text": "This frame rendering stats. It just shows the frames per second as I scroll around and the performance of it, things like that you can see how much GPU memory it's using. So, I can just like very high level, get an idea of cool stuff like that. So, those are probably the two I use most often paint flashing and the frame rendering stats, but just be aware that there's a whole bunch of cool little extra things that you can add."
          },
          {
            "time": "[00:04:40]",
            "text": "You know, to the bottom drawer as well. The other thing we got a lot of good questions earlier in the workshop about, does this work react with Angular? So the answer is always going to be yes. Like for example, if you do an HTML break point, it will show you what JavaScript caused, but we talked about, it's going to be very deep inside the react reconcile."
          },
          {
            "time": "[00:05:03]",
            "text": "Whatever. So, I really recommend checking out these, the separate Dev Tools. So react has one view has one, angular has one. So, these are Chrome extensions that you can use and there. They're so good like I use this just every day at work so for react I this is not a react focused class by any means, but you can instead of you have your regular elements tab."
          },
          {
            "time": "[00:05:26]",
            "text": "But then you get a components tab and in that it shows the actual whatever you named your react components over here, and shows what props they get what hooks they have, like all this like amazing stuff. So, while the answer is always yes, you can use the elements and the elements, break point, even if it's a react app."
          },
          {
            "time": "[00:05:44]",
            "text": "The longer answer is, but look how cool it is. If you use the specific framework Dev Tools you can get so much information. And then we looked at the Performance Tab, it has its own what they call profile. It's a specific react Performance Tab. It works the same way a recording and you stop it, but it'll specifically show you this is a heavy render and it's caused by this hook, it speaks the language a lot better."
          },
          {
            "time": "[00:06:10]",
            "text": "So, if you're working on a big angular app or react app whatever it is check out their Dev Tools, because they're I'm this just seems to me so much time every day. I worked on a project ones back in the day that was too big. For the react Dev Tools they'd crash and it was such a hit to my productivity where I was man."
          },
          {
            "time": "[00:06:28]",
            "text": "I would open it every day and they'd crash every day. So, they've fixed that since then. But these are a really great way to kinda work around that. Awesome, and my very last lesson is just kinda where to go from here. Another huge shout out, I think I'll be able to find it on when it's scheduled for."
          },
          {
            "time": "[00:06:47]",
            "text": "Because unfortunately, I forgot, but there's an advanced web tools course coming on May 17th. From humor, he's been like for years we've been I don't know him, but I've known him as the other Dev Tools content creator in this space. There's the two of us. So, I'm really pumped that he's gonna be coming on."
          },
          {
            "time": "[00:07:06]",
            "text": "He's really in depth performance audits and all these like real world cases. He's just such an expert. So that advanced class is going to be super cool. The official Dev Tools Doc's are always a good place to look for things. They're all linked here in the project. And then I've also linked my Twitter."
          },
          {
            "time": "[00:07:24]",
            "text": "I love talking about stuff. If any of you have reached out to me in the past on stuff, I'm always geek to DM about cool Dev Tools stuff or whatever. The Chrome Dev Tools have a Twitter link as well. And then my very last shout out is there's this new initiative web dot Dev."
          },
          {
            "time": "[00:07:37]",
            "text": "I'm not sure if people have heard of it. It's like this big web community. I think Google kind of owns it but a lot of open source contributions from a lot of people. It's so cool. They have all these topics, on such a playground like all this cool stuff."
          },
          {
            "time": "[00:07:55]",
            "text": "Web vitals progressive web app is all free, really high level content they worked with, the framework teams when react and angular and they work with a web host teams like netlify universe, and they. They just worked with like everybody to get these extremely high quality articles out there."
          },
          {
            "time": "[00:08:12]",
            "text": "So, if you're looking to learn something new, I just love this, I read new articles on it all the time. Otherwise, thank you so much. I love doing these workshops and I love meeting people and hanging out and talking about Dev Tools. So thank you very much for hanging out with me today."
          }
        ]
      }
    ]
  },
  {
    "name": "typescript-fundamentals-v3",
    "sessions": [
      {
        "name": "0-introduction",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to TypeScript Fundamentals V3. My name is Mike North, and I'm a senior staff engineer at LinkedIn. I work in a part of the company called the developer productivity and happiness team, where I'm an infrastructure user experience expert. As well as the company's lead for TypeScript infrastructure and how we roll TypeScript out across all of our JavaScript code bases."
          },
          {
            "time": "[00:00:27]",
            "text": "So we're gonna start with some real talk, I can't make you a TypeScript expert at the end of a one day workshop, it's just not possible. But what I can do is make sure that by the end of today, you have a well formed mental model that will hold up even when things get complicated."
          },
          {
            "time": "[00:00:46]",
            "text": "And then you can learn more and you can try these things out that we're going to introduce today. And I can guarantee you that by setting you on the right path, you will find it easier and easier to take in that new information on your own as you continue your TypeScript adventure."
          },
          {
            "time": "[00:01:05]",
            "text": "So first, let's talk about what TypeScript is. It's a syntactic superset of JavaScript, meaning it sort of starts with all of the JavaScript syntax you know as its starting point and then layers additional concepts on top. It's an open source project maintained by Microsoft, and the goal is to add types to JavaScript."
          },
          {
            "time": "[00:01:32]",
            "text": "So through the use of the compiler, TypeScript compiles out to readable JavaScript, and it comes in three parts. There's the programming language, the language server, and that's a piece of software that's sort of behind your editing environment. It feeds your editor like VSCode, all that great information that powers autocompletes."
          },
          {
            "time": "[00:01:56]",
            "text": "And then there's the compiler, and the compiler is what performs that analysis on your code base and makes sure everything lines up the way it should. TypeScript is incredibly popular. So this is the third version of the TypeScript Fundamentals course that I'm teaching for Frontend Masters. And 2019, this is where I taught the first version, and I brought out a chart like this."
          },
          {
            "time": "[00:02:22]",
            "text": "And I was really proud to be able to show, look, React's a very popular library and TypeScript is on par with React, look, it's so popular. That trend has obviously changed, React looks sort of like it's been left in the dust here. I mean, these are two completely different projects but just in terms of the things we think about with ubiquitous pieces of tooling, things that are sort of always in your Node modules for one reason or another."
          },
          {
            "time": "[00:02:52]",
            "text": "TypeScript is one of those things that is increasingly part of what you're already doing, even if you're not using it directly. And to me, it's starting to look like exponential growth, not even linear growth here. So, everybody is using this, people are really excited about it, why? I'm gonna give you a couple reasons why you might care about TypeScript, why it might be an appealing thing for you to look into."
          },
          {
            "time": "[00:03:23]",
            "text": "And we're obviously gonna learn more about this throughout the day, you'll have many reasons by the end of the day. First, it allows you as a code author to leave more of your intent on the page. So if we look at a function like this that you could find in a regular JavaScript application, this, it sort of is a function that just runs a + b, right?"
          },
          {
            "time": "[00:03:47]",
            "text": "This could be string concatenation, it could be numeric addition, I mean the function name in this case gives us sort of a clue here, but if you use this to combine strings, it would work. Imagine in the future if somebody came along and made what they thought was a non-breaking change and they add the ability for a third upper end to be part of what's happening here."
          },
          {
            "time": "[00:04:12]",
            "text": "If you were using this with string concatenation, you'd end up with zeros at the end of every string that you're combining through this function. So intent matters here, and whenever there are multiple interpretations of what are the constraints, and what's going on, and what was this designed to do, you're kinda asking for trouble."
          },
          {
            "time": "[00:04:31]",
            "text": "In the TypeScript world, we can have something like this where we say a is a number, b is a number, this function returns a number. And even though theoretically a + b could be used to combine strings, it's very clear what the author intended for this to do."
          },
          {
            "time": "[00:04:49]",
            "text": "And not only is the code more clear as we read it, but we are alerted to any use of add that deviates from what the author originally intended. And this little pop up here, this error message, is the kind of thing you would see right in your editing environment like VSCode."
          },
          {
            "time": "[00:05:09]",
            "text": "So baking in more of that intent is a huge win for TypeScript. Reason number two of many, TypeScript has the potential to allow you to move some kinds of errors from runtime where they affect users to compile time, which is maybe before you even open a pull request."
          },
          {
            "time": "[00:05:32]",
            "text": "Examples of these kinds of errors that you can catch include values that might or might not be there. Incomplete refactoring where maybe you should have changed something in seven places but you only caught six. And then internal contracts within your code base. Maybe it's the properties you thought you were passing to a component, right, and now it requires that you give it something new, TypeScript will help you catch that kind of thing."
          },
          {
            "time": "[00:05:58]",
            "text": "Finally, TypeScript serves as the foundation for a great code authoring experience. And I am of course referring to not just the validation of making sure we're passing functions the right things, but this great auto-complete where we sort of get code documentation brought right into our editing environment. Really, really cool stuff and in my opinion this is sort of catching up with the rest of the software engineering world where we finally get a rich editing environment instead of basically a lightweight text editor that does syntax highlighting."
          },
          {
            "time": "[00:06:33]",
            "text": "That's kind of where the JavaScript world has been for too long. So, the last time I taught this workshop, this is TypeScript Fundamentals V2, we spent a lot of time uncommenting code, looking at small examples. Inspecting tooltips to understand what's going on, how is TypeScript understanding our code, we have leveled things up for this course."
          },
          {
            "time": "[00:06:59]",
            "text": "So the only things you're going to need in order to follow along are this website that we're looking at right now and the official TypeScript website. You won't even need to crack open your code editor, why? We've brought VSCode into the browser, so we're gonna be able to see examples and get hands-on without having to set anything up, some really cool stuff."
          },
          {
            "time": "[00:07:25]",
            "text": "Let's look at how we're going to spend our time during this course. First, we will look at compiling our first TypeScript program and we will talk about variables, objects, and arrays. We'll take a quick break, and then we're going to get into some theory. And we'll talk about how TypeScript's type system is different from what you may have seen in Java, or C#, basically anywhere else in the programming world."
          },
          {
            "time": "[00:07:51]",
            "text": "TypeScript is sort of a unique beast in some ways. After lunch, we're going to collaboratively work together to define some of our own type information. And after tackling some of the last core concepts in the JavaScript world, functions and classes, we'll talk about these top and bottom types, right?"
          },
          {
            "time": "[00:08:12]",
            "text": "These are things that can hold anything or nothing. Sounds abstract but they're very, very useful. Finally, towards the end of the day, we're gonna slow things way down and tackle one of the most mysterious and abstract aspects of the TypeScript programming language. And that is generics, or defining types in terms of other types."
          },
          {
            "time": "[00:08:37]",
            "text": "This is one of the great conceptual walls I can help you get over, and generally one of the biggest sticking points that people hit as they're trying to start working with this programming language. Here's a question, in a design system how can I support consuming apps that don't use TypeScript as well as those that do, and do I need to provide type definitions as well as prototypes?"
          },
          {
            "time": "[00:09:05]",
            "text": "Well, this is one of the great aspects of TypeScript, one of the core principles is that it needs to be able to work with regular JavaScript code. So even if your consumers are using regular JavaScript, they'll still get a lot of the benefits of that type information that comes from a library written in TypeScript, right?"
          },
          {
            "time": "[00:09:30]",
            "text": "So if you write the TypeScript, all of your users will get that better developer experience to varying degrees but they're all going to benefit to some degree. A very, very good question. We'll learn more about that very quickly, actually, in the next chapter of the course. So Nita asks are there any open source projects for beginners where we can apply and practice TypeScript after this course?"
          },
          {
            "time": "[00:09:58]",
            "text": "I'm gonna have to look back on that one, I'm sure there are some, one I can tell you for sure is the TypeScript website. So there are a lot of issues on the TypeScript website that are marked as good for new contributors, and by its very nature, it has a lot of small examples."
          },
          {
            "time": "[00:10:17]",
            "text": "And as people who are just learning the language, that's kind of a superpower in that case where you can use your lack of experience in this specific area to speak to what's confusing and what's not. And you can really help make the documentation, the little small projects that are part of that TypeScript handbook and the website."
          },
          {
            "time": "[00:10:38]",
            "text": "You can make those a little bit better so that they work for you because you're the intended audience, right? So we have another question, are there any plans to introduce aspects of TypeScript into the JavaScript programming language? I would have to say, no, but don't worry. So JavaScript is kind of strange in that code that we wrote in 1995, 1992, it still has to run as JavaScript, right?"
          },
          {
            "time": "[00:11:06]",
            "text": "The Internet has to remain backwards compatible. And for that reason, it's unlikely that we'll shift from sort of a dynamically typed or duck typed model to a statically typed model. So don't expect anytime soon for types to become part of what most people can run in their browser."
          },
          {
            "time": "[00:11:31]",
            "text": "Now, however, [LAUGH] we do see examples where something is sort of piloted in TypeScript, right? TypeScript adds a feature by itself and then those become part of the JavaScript programming language but it doesn't include the types. Examples of this include decorators, which are likely to be part of JavaScript soon."
          },
          {
            "time": "[00:11:56]",
            "text": "Private fields, so TypeScript has this concept of class fields that only that class itself can see. Well, that's now part of JavaScript. So there are a few situations where, aside from the typing aspect of things, language features sort of prove themselves out in the TypeScript world. And then that allows TC39, the standards body that decides what is part of JavaScript, right, it allows them to see hey, there are a lot of apps that got a lot of value out of this."
          },
          {
            "time": "[00:12:29]",
            "text": "How can we bring this to everybody, people who write JavaScript and TypeScript? And then sort of we merge everything together, right, where we make sure that once it's standardized, everyone can make use of those kinds of features. Well, let's jump in and look at how we might compile our first TypeScript program."
          },
          {
            "time": "[00:12:53]",
            "text": "Now, if you wanted to, you could check out this repo, if you click Edit on GitHub, it'll take you to a page in this repo. I would encourage you not to for this video course because we're gonna move kinda quickly, and I'm gonna show you everything you would see if you were to compile it yourself."
          }
        ]
      },
      {
        "name": "1-compiling-a-typescript-program",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first thing we're gonna do is compile a basic TypeScript program. And this is gonna be about the simplest program that we can think of, consisting only of three files. Our goals in this chapter are to learn a little bit about how to use the TSC compiler command."
          },
          {
            "time": "[00:00:18]",
            "text": "We're going to learn and understand how JavaScript language level and module type affect the kinda thing that comes out of our compiler. And then, finally, we're gonna look at other things that come out of the compiler than JavaScript, right? We're gonna see some type information that we could potentially publish along with this code."
          },
          {
            "time": "[00:00:41]",
            "text": "If it were a library and this is called the declaration file. Which has the extension .d.ts. So let's consider a simple project, as I said, it'll consist of three files. So we've got package JSON, which is the normal package JSON you're used to seeing in JavaScript project. We have a tsconfig file, which contains all of the instructions, and options, or passing to the compiler."
          },
          {
            "time": "[00:01:07]",
            "text": "And then, finally, we have some source code. So let's look at these three files one by one. In package JSON, we can see a couple of things. We have only one dependency, and it's a dev dependency, and that is TypeScript. In addition to that, we have an NPM script."
          },
          {
            "time": "[00:01:25]",
            "text": "So that we could run something like yarn Dev, or NPM, run Dev, and we would see the TypeScript compiler start up and watch our source code. So that every time we save a file, it'll incrementally kind of update the build result. If you've used Webpack-dev-server or something like nodemon, this will give you similar behavior."
          },
          {
            "time": "[00:01:49]",
            "text": "And preserve watch output this just make sure that every save does not clear your console's output. You kind of wanna keep that council output, in my opinion, I don't like things erasing my terminal history. So let's look at our tsconfig, the second of the three files. We have only three properties in this file, and we're gonna start from the bottom."
          },
          {
            "time": "[00:02:18]",
            "text": "So include tells the compiler where to find our source code. In this case, we're going to end up compiling all ts files that we find in the source folder, that's just index ts. We have two compiler options that we're defining here. First is, where are we going to put our output, right?"
          },
          {
            "time": "[00:02:38]",
            "text": "Everything that the compiler generates. By default, TypeScript will create JavaScript files that are side by side with the TypeScript source that created them. I don't like this because it kind of mixes my build result with my source code. I like having everything in a folder like dist or out, something like that."
          },
          {
            "time": "[00:02:58]",
            "text": "So that if I ever wanna clear everything away and build again, I can just rm rf and be rid of the built stuff. Finally, we have a target property, and this helps us describe the language level of our build output. By default, it's ES3, which is kind of like Internet Explorer six level of JavaScript."
          },
          {
            "time": "[00:03:22]",
            "text": "And we're gonna start there and see the garbage that the compiler spits out. And we're gonna crank that language level up to more and more modern JavaScript. Let's say we were only supporting modern browsers, and we'll see that things get cleaned up quite nicely. So it's important to understand that everything we described in this compiler object can be passed to the TSC command, as a COI flag."
          },
          {
            "time": "[00:03:49]",
            "text": "So here's an example of outDir. Now, I don't typically like using VCLI flags except in very, very simple situations. I'm very quick to sort of set up a tsconfig and have this nice, you know, configuration that I can check in with my project. And I can be sure that I'm gonna be running exactly the same command over and over again."
          },
          {
            "time": "[00:04:15]",
            "text": "The last of the three files we're gonna at, is the source code, right, this index.ts file. And it's not a big program, but it contains a couple interesting things that will present us with some clear signals about how the compiler responds to that target property, this here. As well as the type of module we instruct the compiler to make for us."
          },
          {
            "time": "[00:04:40]",
            "text": "So you're going to see that it includes the use of a promise, which only came with JavaScript 2015 edition, right, ES2015. Then we'll see that a sync and await are used, which kind of had partial support through generator functions in ES2015. But it only got real clear support like using a sync and await as keywords that came in ES2017."
          },
          {
            "time": "[00:05:07]",
            "text": "So we should start to see things kind of disappear and become the more normal code that we're used to reading modern JavaScript as we crank that language level up. And here is the source code. So all this program does, here's the entry point. It console.log something, and what is it console.log?"
          },
          {
            "time": "[00:05:27]",
            "text": "Well, it's whatever addNumbers returns and that gets awaited. So addNumbers, just waits for half a second and then adds a and b together. So effectively we should see like a half second wait and then seven printed to our console, not too complicated. This is a good opportunity for me to show you one of the features of this website that we're gonna be looking at today."
          },
          {
            "time": "[00:05:58]",
            "text": "You can hover over various symbols in these code samples and see what you would be seeing in Visual Studio Code. So this is a little bit like a read only VS Code frame where you can really understand the types of everything that you're touching. This is really, really important because the tooltips don't lie, this will tell you why something is failing and it helps, you understand what's going on within the code."
          },
          {
            "time": "[00:06:28]",
            "text": "So the vast majority of the code samples, you'll see today allow you to do this. Additionally, if we want to see this code run in the TypeScript playground, you could hit this try button. And it would take you right here and you'd be able to actually click logs, and run this, and right now, we can't run it."
          },
          {
            "time": "[00:06:47]",
            "text": "But because we have an expert in this playground, which it's not designed to handle. But you're gonna be able to actually, play with each of these examples and I encourage you to poke at them and to understand them, and to maybe try to break them try to fix them."
          },
          {
            "time": "[00:07:05]",
            "text": "So let's go back to what we were just looking at. So this is our small program and here I'm cluing you into hovering over tooltips. So how might we run the compiler? Well, if you were to check this program out this this repo out what you could, you could run yarn dev, and you would see that TypeScript is starting to watch your code."
          },
          {
            "time": "[00:07:26]",
            "text": "And immediately you would see a dist folder created, which would contain an index.js file. And we can look at what that code would be and shield your eyes because it's a mess. This is like all the polyfills, right, this is a sync and await and promises and just a bunch of junk here, right?"
          },
          {
            "time": "[00:07:51]",
            "text": "Remember, this is really dumbed down JavaScript for IE6. So we're gonna close this, be done with it. And that'll be our starting point, just a bunch of junk. So let's change the target language level, we can simply go from ES3 to ES2015. Leaving everything else intact, and the compiler output would change."
          },
          {
            "time": "[00:08:17]",
            "text": "So now we start to see some more modern language features, but not everything we're used to seeing. So there is a promise constructor which is nice, we do see a yield keyword. Interesting that we got this in ES2015, but we didn't get a sync and await yet. So we have a generator function which makes the polyfill for a sync and await makes it much cleaner."
          },
          {
            "time": "[00:08:44]",
            "text": "Because that's a very important thing to be able to use to define a sync and await. But it doesn't yet look like our source code with the type stripped away. That's where we're sort of working our way towards. So this is ES2015 if we step up to ES2017, this is what it would look like."
          },
          {
            "time": "[00:09:07]",
            "text": "So we're going to see actual use of the a sync and await keywords. And this a waiter helper, which is this thing up here, that will have disappeared and here we go. Now, this looks like our TypeScript code with the types removed. So if you're interested in how to define your output, target is a really important thing to define."
          },
          {
            "time": "[00:09:32]",
            "text": "One of the questions we got during the break had to do with multi target output, right? What if you're building for modern browsers and you have a legacy browser you need to support. So typically what I would do is have TypeScript output something like this, which by the way, still is in ES modules."
          },
          {
            "time": "[00:09:53]",
            "text": "And then you could use something like Babel to make a legacy build for IE11 if you need to. So in your dist folder, if we had run the compiler, we would have found a file called index.d.ts, and this is a declaration file. Now, there's a new keyword here that I'm gonna ask you to ignore for the time being."
          },
          {
            "time": "[00:10:18]",
            "text": "Cuz it's not the most interesting thing going on here. The most interesting thing is this appears to be a function with no implementation. It's just sort of a semi colon at the end of the arguments list, right? So you can think of this almost like the types that were stripped away from our source code."
          },
          {
            "time": "[00:10:37]",
            "text": "So you start with TypeScript, which is code that runs and types, and then your compiler almost separates those out. So you get a js file that runs and you get these dts files, which contain only the type information. Why is this good? Well, it lets people who are just using JavaScript who aren't writing TypeScript."
          },
          {
            "time": "[00:11:02]",
            "text": "They can compile those js files and just call it a day. And people who are writing TypeScript, they can kind of reassemble that together and have the JavaScript that runs and the types that describe the constraints. So this is what will allow you to remain compatible with users who depend on your code regardless of whether they themselves are authoring TypeScript."
          },
          {
            "time": "[00:11:27]",
            "text": "So one more thing that's important to understand are the types of modules the compiler is emitting. If we tried to run this code that we generated up here, right this code here, specifically with this export keyword. If we tried to run this with node, we would get an error right at that line with the export keyword, why?"
          },
          {
            "time": "[00:11:47]",
            "text": "Node wants common j s modules right this is node js is module system predates a standardized JavaScript module. And even today, although they are moving towards these standardized modules, even today, node wants to run a common j s module. And you can read more about that if you click this link."
          },
          {
            "time": "[00:12:11]",
            "text": "But if we wanted to make something that runs with node, it's just as easy as adding a module property to our compiler options in the tsconfig file. And what this is gonna generate for us is it will change this export add numbers and we'll change that into exports.addNumbers equals addNumbers."
          },
          {
            "time": "[00:12:33]",
            "text": "So this is the kind of output that we expect in the node js world. This represents the easiest and simplest possible TypeScript program that you could compile. Now we're going to pivot and talk about the programming language. Now that we kind of know how to use the tool"
          }
        ]
      },
      {
        "name": "2-variables-values",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about variables and values. In this chapter, we're gonna talk about simple let and const declarations and the very basics of typing functions. And that will serve as a good foundation for us to start building other more complicated types on. So variable declarations in JavaScript, kind of look like this, right?"
          },
          {
            "time": "[00:00:21]",
            "text": "We have let and const hopefully nobody's using bar anymore, but we can just say something like, let age = 6. And you may note that TypeScript is kinda figured out this is a number. This does not seem like an impressive trick, because obviously 6 is a number, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "Well, what you're seeing is inference, where TypeScript can contextually understand the situation. It can see that yes, we have a variable declaration with an initializer, right? Where we're assigning it to 6 right away, clearly that should be a number, right? And not every programming language has this by the wa,y if you work in the Java or the C++ area, every variable declaration typically comes with the type up front."
          },
          {
            "time": "[00:01:11]",
            "text": "You have to say like int age =6, you'd have to say it's an IT. This up here seems like regular JavaScript. But down here, you could totally do this with JavaScript, but TypeScript is unhappy, why? Age was the variable that was born with a type and that type is number."
          },
          {
            "time": "[00:01:31]",
            "text": "And we can see that if we attempt to give it a value that's a string, it's going to yell at us. This is the kind of thing that TypeScript is designed to catch. I want you to remember that in TypeScript variables are born with their types. So there are things we can do, which we'll learn about later to make these types more specific."
          },
          {
            "time": "[00:01:54]",
            "text": "But it's hard to make them more general, once they're declared. So, it's important to make sure that when you define your variables, they have the types that you need them to have. And if you ever need to generalize them, usually you go right back to that variable declaration, and that's where you have to make a change."
          },
          {
            "time": "[00:02:13]",
            "text": "So let's look at a similar example, but with const. So if we just change our let to const, we can see that we get a different type here, and that type is 6. And you might think, well 6 is a value, right? Number is a type 6 is a value."
          },
          {
            "time": "[00:02:29]",
            "text": "What we have here is called a literal type and it's a more specific kind of type. It's not just any number, it's any number that is 6. You can think of it that way, right? So the reason that changing let to const has done this thing, that we see before our eyes has to do with two things going on."
          },
          {
            "time": "[00:02:56]",
            "text": "One, it's the nature of const's declarations, they can't be reassigned. So we know that once we point it at a thing, it will forever pointed that thing, age will always point to whatever it is assigned to. And then the second is that, numbers in JavaScript are immutable value types."
          },
          {
            "time": "[00:03:17]",
            "text": "Unlike arrays, where that's a value type where you can push things into it, right? 6 will always be 6, right? We can create a new number, but we can't change an existing number. So basically, this whole thing is poured and concrete, where it's a variable that can never point to something else."
          },
          {
            "time": "[00:03:39]",
            "text": "And the thing it currently points to cannot change. So we know very specifically that this is 6 and it will always be 6. So TypeScript can make a safe more specific assumption here. And that's a theme we're going to see over and over, by the way, where TypeScript tries to make the most specific assumption, that it can without risking getting in your way."
          },
          {
            "time": "[00:04:06]",
            "text": "So 6 is called a literal type, meaning it is literally the number 6 and if we think about why we were able to make this assumption more specifically, like we said in our two reasons there. But imagine if we made that same kind of very specific assumption with a let declaration."
          },
          {
            "time": "[00:04:29]",
            "text": "So if we go back up here, what if we assumed age was always going to be 6 that would get in our way, right? Like the nature of let declarations we're probably going to assign them to something else in the future. And that's why you get that the more relaxed constraint there, where normal code that treats this as a number is going to behave nicely, right?"
          },
          {
            "time": "[00:04:52]",
            "text": "Don't want TypeScript to get into your way. We're gonna see literal types over and over, but you can just think of them as a set of allowed values. So sometimes we end up in situations where we have to declare a variable, and then the variable gets its value sometime later."
          },
          {
            "time": "[00:05:17]",
            "text": "So let's look at this piece of code which begins with a timestamp, and it ends up measuring a startTime and then sometime later when it finishes a random wait, and it record an endTime. So maybe we wanna have access to this endTime in this outer scope. But clearly like within this set timeout function, that's when it's actually going to get its endTime."
          },
          {
            "time": "[00:05:48]",
            "text": "So you could end up with something like this. And if we look at the way this is defined, we can see that this is of type any that's what this notation means, by the way. EndTime is a variable, it's a let declaration and it has a type called any."
          },
          {
            "time": "[00:06:04]",
            "text": "Any is the most flexible type in TypeScript. And you can think of it kind of like JavaScript variable rules, where we could set it equal to a string and then a number and then a function and then null and then whatever, there's no constraint. It can be anything, any value that is allowed in the JavaScript world."
          },
          {
            "time": "[00:06:28]",
            "text": "So it's not necessarily bad, but it's often much more flexible than what you want. And in this case, we can see that there's just not enough information for TypeScript to make a guess as to what this should be. Because types are assigned to variables when those variables are born."
          },
          {
            "time": "[00:06:49]",
            "text": "And when this is born, we don't know when the set timeout is gonna be invoked, and we don't know what value it's going to get. So in this case, we need to add what's called a type annotation. And that is our colon type syntax, right? Where let here, what we're saying is, endTime is a Date, we're not giving it a value yet, but it's going to get a Date and you should treat it as if it's going to get a Date."
          },
          {
            "time": "[00:07:22]",
            "text": "And now when we for some reason we're setting this to = to 0 before we give it its real endTime. We're told that we can't give it a number. This is a slot that's designed for a Date. This is exactly what we should give it. So now we're seeing enforcement of types."
          },
          {
            "time": "[00:07:40]",
            "text": "I only add type annotations like this when I have to, because it's just extra stuff in your code, and it tends to make things a little bit more difficult to refactor. If you start adding types all over the place, but in this case it's absolutely appropriate and absolutely necessary."
          },
          {
            "time": "[00:08:00]",
            "text": "So let's look at functions. This same syntax that we saw with this variable up here, right? Colon Date this can be used with our add function here that we saw in the first slide of the course. It can be use to state that a and b are numbers."
          },
          {
            "time": "[00:08:20]",
            "text": "And this function add returns numbers. You can see that by default, everything ends up being any. This is because like imagine we were converting this from a JavaScript file to a TypeScript file. Maybe we start with everything loose and then we wanna crank things up and define the types as we go."
          },
          {
            "time": "[00:08:40]",
            "text": "That's probably not what we want in the end now, right? So why is any gonna be a problem in this case? Well, look here. This we know is gonna be 7 based on the implementation of the function a+b. So we know promise doesn't accept 7 as its constructor argument, but TypeScript seems to be happy about this."
          },
          {
            "time": "[00:09:05]",
            "text": "This is not the same point that I was making before, where the return value doesn't have a type and therefore we could use it. We can reach into it in unsafe ways. If you have an any that's floating around. If that value enters well typed code, it will break that well typed code, so the guarantees I have around promises don't matter right now."
          },
          {
            "time": "[00:09:27]",
            "text": "Because I have this any, so having something like this floating around can weaken your guarantees that you have around your code. It's kinda dangerous thin, now I say dangerous. It's only as dangerous as a regular JavaScript variable, which is dangerous. So let's add some type annotations here. We can say that a and b are arguments, each of them is a number."
          },
          {
            "time": "[00:09:52]",
            "text": "And here it's very clear that the result that's returned is a number. And if we attempt to use this, I mean, we already saw this example, we can't pass a string in that's not compatible with a number. You may notice that, the return type of the function is also inferred so that number on the right side of the tooltip, the compiler is smart enough to figure out that a + b, the result of adding those numbers together is a number and that's what's returned."
          }
        ]
      },
      {
        "name": "3-typing-functions",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So I prefer to explicitly state return types. And I'm going to show you why, it has to do with where problems are surfaced. Do you want those problems to be surfaced at the place where you declare the function? Or do you want them to be surfaced where you use the function?"
          },
          {
            "time": "[00:00:21]",
            "text": "So my preference is this, and we can see that once we define a return type we get an additional benefit there. And that is, every code path that goes through the implementation of this function must live up to what you state will happen. Meaning, even if you had like six or seven different branches that happened based on different conditions, lots of complicated logic for adding two numbers together."
          },
          {
            "time": "[00:00:46]",
            "text": "Every one of those has to return a number or throw but you can't return null and one of those cases, this will give you guarantees that everything is handled down every path that that could possibly be taken. I want this error here, surfaced at the function declaration. Not at where I'm using it, so I'm gonna pop up in the TypeScript playground and we can look at the alternative here."
          },
          {
            "time": "[00:01:20]",
            "text": "So I can add 3 and 4 here, let's get rid of this. Yeah, this is a great example. So what's happening here is add, it has a return type void, meaning it doesn't return and rather than talk about void now, let's return null, right? Add returns null, so right now let's say I use add a bunch of different places in my program."
          },
          {
            "time": "[00:01:53]",
            "text": "They're all gonna light up, and the errors happening at the point of invocation. If I state my intentions up front with a return type that's explicit, Now, all of my usage is fine, because I mean, it's not gonna run the way I would want it to run. But it returns a number that's what I've stated, should happen, will happen."
          },
          {
            "time": "[00:02:23]",
            "text": "And now this is one thing that I need to fix, so it just reduces the noise. You're not seeing like 15 different things light up, you're seeing 1 thing light up, and it's taking you to the location of where you need to make a fix. This is better, in my opinion, that's why I like explicit return types."
          },
          {
            "time": "[00:02:41]",
            "text": "Let's you state your intentions upfront, make sure you follow through with them. And it surfaces problems where you need to fix the problems."
          },
          {
            "time": "[00:02:41]",
            "text": ">> Mike, this seems, kinda like local preventative medicine, almost like when you were, that last thing you did, I'm sorry. When you are declaring, I guess what the output type should be?"
          },
          {
            "time": "[00:03:05]",
            "text": ">> Yep."
          },
          {
            "time": "[00:03:05]",
            "text": ">> So that you don't leave locally in your code and you can detect the error before it happens, I suppose, just trying to, in simple terms for me,"
          },
          {
            "time": "[00:03:05]",
            "text": ">> Sure, let me tell you the way I think about this. So test driven development isn't for everybody, but I like type driven development, meaning, sometimes I will state what I'm trying to do and put the usage of the function I have not implemented yet in place."
          },
          {
            "time": "[00:03:40]",
            "text": "And I can define what I think I need in terms of inputs and outputs, and then I can implement it later. So I like to use this as a tool and frequently I'll end up doing this. Write the code that I want to be able to run and then fill in all of my functions."
          },
          {
            "time": "[00:03:58]",
            "text": "Now, you talk about this as local preventative medicine. I think about this as local boundaries, where instead of validating that your whole program works by running an extensive test suite that tests everything all together. You can on a per function basis, ensure that within this function, I am returning the right thing, I am accepting the right thing, and then you can move on to another function."
          },
          {
            "time": "[00:04:29]",
            "text": "Now, TypeScript is not a replacement for tests, it's not a replacement for unit tests. But this does give you the ability to shift between micro and macro. Is this function doing the right thing, is it returning the right thing? Do I have the right guarantees around it and then shift out, and let's test the whole program, and let's make sure that things work the way they should."
          },
          {
            "time": "[00:04:56]",
            "text": "And I say TypeScript is not a replacement for tests because all it does is checks types, right? It doesn't actually ensure that a and b actually gets summed up together. So if you were writing tests that specifically validated only the type information, yes, you can eliminate those. But, I think it's kind of a dangerous statement to say, You no longer have to write a lot of unit tests."
          },
          {
            "time": "[00:05:24]",
            "text": "TypeScript has nothing to do with behavior that's still left to JavaScript. So, hopefully we're writing those kinds of unit tests to begin with, don't stop writing this."
          }
        ]
      },
      {
        "name": "4-typing-functions-q-a-and-objects",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Why does TypeScript not complain in that example, where I'm passing a number into the promise constructor whether the result is any? Yeah, it's kinda mysterious, right? So I'm gonna go back to that example because it is quite shocking, right? Let me let me take us back here."
          },
          {
            "time": "[00:00:20]",
            "text": "It's this one right here. Like the reason I show this to you is because n E's are dangerous. And the fact that in this case, just to recall, like what stage of the code we were at here, we had not given arguments a type and therefore, like what is a plus b even mean when a or b theoretically could be anything right?"
          },
          {
            "time": "[00:00:44]",
            "text": "We don't know. So result ends up being in any. Now, the point here is that an any does not just cause problems that have to do with itself. When an enemy is passed into well that flexibility will compromise that well typed code. So in this case, an any variable can hold anything, and they can also masquerade as anything."
          },
          {
            "time": "[00:01:18]",
            "text": "That's a useful way to think about this. It's a wild card It can accept anything, but it can also present itself as anything. And in this case, that's gonna cause problems, even if your types are really, really good about where that any goes where it enters into. So that's the liability of having something like this."
          },
          {
            "time": "[00:01:45]",
            "text": "Hopefully that makes sense. It can masquerade as anything. Louise making a comment about my unit test remarks. Yes I agree with you that, the guarantees and the checking that type script gives you in a, in a declarative way, right? These constraints, they help avoid defensive programming to some extent, but when we start building type cards, you may accuse me of defensive programming again."
          },
          {
            "time": "[00:02:11]",
            "text": "So I wish to withhold your judgment for the time being. All right and he says much of the job of TypeScript is about type annotation. The JS doc introduced way before TypeScript was inter invented. Let me rephrase this question. So, Annice you're basically asking, like, why do we say that there's so much value that comes along with TypeScript."
          },
          {
            "time": "[00:02:36]",
            "text": "When you could have done some of these things in the JS doc world. That's a very fair point. But let me show you this. Let me show you what you could have done in the JS doc world. So Annice is referring to the fact that I could have done."
          },
          {
            "time": "[00:02:57]",
            "text": "Sorry I always forget the ordering of this. Let's hover over these tool tips. Oops maybe I'm doing this wrong. I think it's like that. Let me try one of each, see if it works. I think the fact that it's running in the type playground is hurting us a little bit here, But take it from me, I really think it's this B and A number."
          },
          {
            "time": "[00:03:34]",
            "text": "So you could have done something like this. And if this were a more normal environment, we would have seen that like a and b are regarded as numbers. But here's something that JS doc would have also let you do something like that right where you forget to add a type for one of your variables and defining more complicated types in JS Doc is really complicated, things with type params and stuff like that."
          },
          {
            "time": "[00:04:00]",
            "text": "So really what JSDoc was missing was strong enforcement of alignment. Between the comments that you're writing and the code that they were documenting that that was hard, and for that matter within your function, JS doc was probably not helping you much unless you're being extremely vigilant about saying like result equal saying Something like this."
          },
          {
            "time": "[00:04:33]",
            "text": "This level of JS doc might have gotten you a long way, but I don't come across too many code bases to do this. It's a lot of vigilance required to keep all this up today. Okay, I am actually gonna proceed because a lot of these other questions I know we're going to get to later on."
          },
          {
            "time": "[00:05:06]",
            "text": "Nita asks what is a use case for any. We're gonna talk about that in the section called Top and Bottom tyes, dedicated discussion around any and it's kind of a part of network and unknown which is kind of like a special program. So with that let's pick back up."
          },
          {
            "time": "[00:05:25]",
            "text": "Now that we've covered variables and basic functions, it's time to talk about collections. These mutable value types. And in JavaScript, these are objects, arrays, and something called Tuples which are a special type of array. So we're gonna learn how to type all of these different things. And let's begin with objects."
          },
          {
            "time": "[00:05:50]",
            "text": "So when we talk about the types of objects, they are two things, what properties are on this object? And what are the types of these properties? And that applied recursively could describe deeply nested objects, or very small objects. I mean that that's the core principle. Some people refer to this as a shape, right?"
          },
          {
            "time": "[00:06:15]",
            "text": "What properties do you have and what kinds of things can I store under each of the properties? So let's just start with a conceptual model of a car, which we could describe as like a 2002 Toyota Corolla. It has a year a make and a model, the make and the model are going to end up being strings."
          },
          {
            "time": "[00:06:36]",
            "text": "And the year it's gonna end up being a number. So we can describe the type of this object as follows. And again, we're seeing the same syntax, value, or like property name or variable name, colon type, and we're creating something that looks a lot like JavaScript objects syntax."
          },
          {
            "time": "[00:07:01]",
            "text": "But instead of key value, we have key type. We can actually use this colon type syntax with this structure that we've created. If we hover over a car, we can see that it's stuck, right? So just as before where we were saying, age colon number, or end time colon date, we're seeing car colon and then this big thing that we've created and that's a type of object."
          },
          {
            "time": "[00:07:35]",
            "text": "If we wanted to use this to describe an argument, we can do this. And we can see that as we reach into this object and we do car.make, make as a string, model is a string, and year is a number. So this is where we're getting that nice validation and these would show up in autocomplete as well."
          },
          {
            "time": "[00:07:57]",
            "text": "If you did car.m, you would see that making model drop down."
          }
        ]
      },
      {
        "name": "5-optional-properties",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So what about optional properties? Let's extend our model of a car and we'll say, sometimes we have an electric car and they wanna charge at a particular voltage. So what is that chargeVoltage? Is it 240 volts, what is it? Now, chargeVoltage doesn't make any sense for a car that runs on gasoline."
          },
          {
            "time": "[00:00:23]",
            "text": "So, Let's say that for electric cars we will find this value, but for non-electric cars this value will be missing. So this is an optional property that may or may not be there. It's sometimes there, and it's a number. So we're going to use this question mark to state that chargeVoltage might be there, but if it is there it will be a number."
          },
          {
            "time": "[00:00:54]",
            "text": "And if we hover over this, the type of chargeVoltage, its number and then a pipe and undefined. Can someone make a guess as to what the pipe means? When do we see a pipe in JavaScript? Maybe two pipes next to each other."
          },
          {
            "time": "[00:00:54]",
            "text": ">> Means or?"
          },
          {
            "time": "[00:00:54]",
            "text": ">> It means or, very good."
          },
          {
            "time": "[00:01:16]",
            "text": "So you can think of this as or for types. I see a lot of people in the chat got it as well. So we'll talk more about and and or, it is possible with types. But here we're seeing something that conceptually aligns with what we set out to do."
          },
          {
            "time": "[00:01:30]",
            "text": "And that is, it may or may not be there. So here we can see we regenerate our string. Here's our chargeVoltage, and this is interesting. So, what we're doing here is we're gonna make a basic string, and then I've just put this line here to kind of reveal the type of chargeVoltage that has this undefined."
          },
          {
            "time": "[00:01:57]",
            "text": "And then we have this condition. And at run time, if we think about what this will do, we're checking to see if chargeVoltage is defined or it's not. So we're creating a branch of code that will only execute if something is there for chargeVoltage. And sure enough, we can see that we've eliminated the undefined possibility here, right?"
          },
          {
            "time": "[00:02:24]",
            "text": "If we go down this branch of code, TypeScript seems to be able to understand that we're gonna have a number there, and we can use it. We can print it as a number, right? This is what's called a type guard. It's where you typically will combine some sort of predicate, like a check true or false expression, right?"
          },
          {
            "time": "[00:02:50]",
            "text": "You'll combine that with some control flow tool like if or a case switch. And in doing that, you'll create branches of code where the compiler can understand that like we'll take a left turn if we're undefined, and we'll take a right turn if we are defined. And that allows you to kind of consume these things safely."
          },
          {
            "time": "[00:03:17]",
            "text": "By the way, this is one of those key points I talked about where people love TypeScript. Every time I convert a JavaScript code base to TypeScript I find a bunch of these, where somebody was sort of betting on this value will probably be there. And it turns out, there's no code that guarantees that, TypeScript is gonna demand that we put this line here in order to start using it."
          },
          {
            "time": "[00:03:39]",
            "text": "We can go out to the playground and give this a shot. So if we were to take this away, and let me make this a little bit more obvious, we'll say, toFixed, right? So I'm just trying to use this in a way that's gonna really break if it's something other than a number."
          },
          {
            "time": "[00:04:03]",
            "text": "If we got rid of this type guard, it's just gonna say, look, you can't do that. This could be undefined, you can't just reach into it and call toFixed. So the type guard serves that purpose. And I guarantee you write JavaScript code today that is missing these in important places."
          },
          {
            "time": "[00:04:24]",
            "text": "I know, I do it all the time. Like every time I convert, I find a bunch of these. So, because we have this optional property, we can either pass this value in as we are down here, or we can omit it. Now, some of you may wonder what if here, For this chargeVoltage, what if I did this?"
          },
          {
            "time": "[00:05:00]",
            "text": "And let's try to use it. So something's not happy here. And if we look at this error, it's a little hard to read. I read TypeScript errors from the bottom up cuz they're kind of like stack traces, especially in this case where we have a problem with the whole object."
          },
          {
            "time": "[00:05:34]",
            "text": "That lowest line and the error message will tell you the property that caused the problem. So we're seeing, okay, chargeVoltage is declared here, chargeVoltage is missing in type, and then it lists the type, but it's required in type, and then it lists another type here. So what we're saying here is if I didn't have a chargeVoltage, I actually have to do chargeVoltage is undefined."
          },
          {
            "time": "[00:05:58]",
            "text": "I have to pass in an undefined, that's kind of weird. There's a difference between an optional property and a property that has the potential to have an undefined value. Optional properties can be left out, but if you do this, someone's gonna have to pass an undefined, which is really weird."
          },
          {
            "time": "[00:06:19]",
            "text": "I don't like passing undefined in as a deliberate argument, right? That's kind of strange, or deliberate property value. So, that's the difference. And I see some face palms in chat. This is a justifiable facepalm. So, yeah, you wouldn't be able to do this. So optional is more than simply adding that or undefined."
          },
          {
            "time": "[00:06:45]",
            "text": "It means that it can be present, it can be absent. There is another type of error that TypeScript catches for us called excess property checking. And again, I'm gonna illustrate this with an example that builds potentially one more thing onto our car model. So we have our make, model, and year."
          },
          {
            "time": "[00:07:06]",
            "text": "And let's say that someone got really eager and they decided they want to describe the color of their car and pass that into this function. So we're getting what's called an excess property error, and the keywords to look for here is object literal may only specify known properties right here."
          },
          {
            "time": "[00:07:34]",
            "text": "And color is not one of those properties. So it's saying, you gave me this thing and I didn't ask for it. And if we eliminated it, everything would be fine, why? Why is TypeScript mad at us? This won't break your code. The fact that red's there won't break your code, so why are we being alerted?"
          },
          {
            "time": "[00:07:55]",
            "text": "Well, If we started to use car in here, there's no way to safely access that color property. So it's a case where when we're changing, when we have that color property there, we're setting ourselves up to never be able to safely access that extra thing. It's like an appendix, it's this vestigial thing that serves no purpose can safely be eliminated, we know conclusively."
          },
          {
            "time": "[00:08:26]",
            "text": "So there are a couple things we could do if we wanted to handle this case, and I'm going to show you a couple of them. First, we could certainly say oops, we can make it optional. This would make this thing go away cuz potentially in here, we could use the undefined check, we could access color, it's no longer a pointless thing to pass in."
          },
          {
            "time": "[00:08:52]",
            "text": "So that's one thing we could do. And here's another thing that sort of makes the point as to how the compiler is trying to help us. Let's, myCar, let's give it a value, or variable, rather. So here, we're also not getting an error, why? Well, conceivably, something else other than printCar, could reach into this my car thing, And get color."
          },
          {
            "time": "[00:09:23]",
            "text": "That's totally fair. It's no longer definitely pointless to have that color property on there. And when we talk about object literal, like access object literal property checking, it had to do with the fact that we were just passing this thing in directly to the function as an object literal."
          },
          {
            "time": "[00:09:46]",
            "text": "And that's why we were guaranteed that like nobody is ever gonna be able to make use of this color property. No one else has access to it. It just lives in the argument list of this one invocation of print car. It lives in a stack frame. And so definitely no one else is gonna be able to use it."
          },
          {
            "time": "[00:10:10]",
            "text": "So you will see errors like that when you convert something from JavaScript to TypeScript, and you'll solve it a number of ways. As you're doing your early conversions, it's gonna be because your types were missing something like, yeah, color, we need to handle color. And then you're gonna start to find things where there's like a misspelling or something weird."
          },
          {
            "time": "[00:10:31]",
            "text": "So we saw three different ways to solve this. Remove the property, add the property to the type, or create a variable. Because conceivably, something else could access color through that variable."
          }
        ]
      },
      {
        "name": "6-index-signatures-object-q-a",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So great, we learn how to type rigid objects. What about dictionaries? So let's imagine an address book situation. I know the address book and my phone lets me store multiple phone numbers where I could say, home, work, fax, pager, whatever apparently grew up during the 80s. So might look something like this, right, where we have a consistent type of value that is stored under an arbitrary key."
          },
          {
            "time": "[00:00:31]",
            "text": "So we have this nice way to easily look up values by key, just give me the work number. In order to type this properly, we need something called an index signature. And here's what that looks like. We have these square brackets and you should think of this almost like box notation for accessing a value off of a property, like dictionary square bracket and then a string for the property key."
          },
          {
            "time": "[00:00:57]",
            "text": "That's a good mnemonic device here, right? So you can pass in any string, you can call this k whatever you want. It's sort of arbitrary, cuz you're not really consuming k elsewhere. And then this is the type of value that you will find under each key. And here we're starting out with an empty dictionary but you can see we can reach in and we will get this object out."
          },
          {
            "time": "[00:01:20]",
            "text": "Now, I'm showing you this flavor of a dictionary for simplicity. What I like to do is add, and I'll go out to the playground here. I like to do this because it's bothersome that we know this is empty, and yet we're reaching in and assuming facts will be there."
          },
          {
            "time": "[00:01:42]",
            "text": "Do I really wanna be able to do this? Which this will happily let me do. I kinda want that extra rigor of being asked to check whether fax is actually present or not. But it's up to you different patterns work for different use cases. You pass a variable with extra property to a function that does not use that property and it'll be okay."
          },
          {
            "time": "[00:02:12]",
            "text": "It does sound like you're describing the excess property erroring case. TypeScript is basically trying to discourage you from adding extra stuff to object literals which it can guarantee you will not be able to safely access from within the body of the function. And Theresa asks, why does storing that object as a variable get rid of the error?"
          },
          {
            "time": "[00:02:45]",
            "text": "Let me take us back to that little screen. So why is it that if we take this here, cut my car. So, when we weren't using this through a variable we went in here and we said, well, let me just copy this. So we've got a variable right now we're not currently using and we're passing this in, we get this error message."
          },
          {
            "time": "[00:03:22]",
            "text": "So I suggest that there is no way to safely access color. No way, within the print car function. Like first nobody can see this object other than print car. It's an argument that you're passing to the function, out here there's just no way for me to access that object that I've created, to pass into the function."
          },
          {
            "time": "[00:03:49]",
            "text": "The only place we can access it, is from within print car. And within print car, we've stated that, this is the type of object we receive. So, if I do car.c colors not appearing on this list. We can't access that color property. So based on the fact that only print car can see it, can see the object, and print car won't be able to access that color property that's why you're getting that error."
          },
          {
            "time": "[00:04:18]",
            "text": "Let's see if those same conditions hold true in the case where we're using the variable. So I'm gonna replace this with my car. And print car still cannot access a color property because it doesn't state upfront that color might be there. However, down here, We can see color, right?"
          },
          {
            "time": "[00:04:48]",
            "text": "We have this variable and conceivably we could use this variable in other places, in other ways, maybe for a different function that wants to see a color there. So, in the case where we're storing this as a variable, you cannot prove that the color property is a waste."
          },
          {
            "time": "[00:05:10]",
            "text": "You cannot prove that it's pointless and that's why we no longer get the error. You only get the error when it can be proven that the property is pointless."
          }
        ]
      },
      {
        "name": "7-arrays-tuples",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about arrays. So we've talked a little bit about object types. Obviously, arrays are the other main type of collection that we work with in JavaScript. And sort of key value storage we have positional storage. So, typically, for at least simple types of arrays, all we have to do is add a pair of square brackets after the type of the member of the array."
          },
          {
            "time": "[00:00:27]",
            "text": "So this would be an array of strings. And you see the inference works here, just as we would hope where we don't have to explicitly write a type annotation. TypeScript understands what's going on. We could use our object type here as well to say we have an array of cars and we could start with one car in there."
          },
          {
            "time": "[00:00:47]",
            "text": "So this you can think of it as like this is just as much a type, as the word string is a type and it can be used in all the same places. So that's simple arrays. Let's talk about tuples. So tuples are, I mean, you could have used tuples in regular JavaScript if you wanted to."
          },
          {
            "time": "[00:01:09]",
            "text": "There's no special treatment. It's more like just a pattern. Where you have some meaning of positional ordering of different pieces of data. So if we wanted to store our 2002, Toyota Corolla, we could just have a convention that says, the first member the first element of the tuple is the year followed by the make, followed by the model."
          },
          {
            "time": "[00:01:37]",
            "text": "So we could store it like this. And then this makes destructured assignment really nice because we can then pull out the individual little parts of this compound value. And do something interesting with your making model. So, unfortunately, inference is not going to be our friend here. And again, we're back to the theme of TypeScript making."
          },
          {
            "time": "[00:02:04]",
            "text": "We're trying to make a reasonable and safe assumption, that will stay out of our way most of the time. And in this case, it's decided that what we're trying to do is create a mixed array of arbitrary length that contains some mix of strings and numbers. And that's gonna be a problem for us, why?"
          },
          {
            "time": "[00:02:30]",
            "text": "Well we could add an additional element, right? Like this is a sedan versus a coupe. The year is not in the right place, right? The year should be the first element and this is in the second position here. So it's just not describing things as tightly as we really want."
          },
          {
            "time": "[00:02:51]",
            "text": "I invite you to think about this question. What do you want most of the time? So sometimes we return an array that has two things in it and it's always two things and there's always a number and then a string. And other times we use arrays of arbitrary length."
          },
          {
            "time": "[00:03:07]",
            "text": "So show of hands, who uses arrays as like arbitrary length collections more often than like, just a pair of things? Like I know I do. And in the chat, you can just type y or n, yes or no. Yeah, I see some hands up. So TypeScript is designing around this."
          },
          {
            "time": "[00:03:28]",
            "text": "They don't want to mess with your regular array use case. And this is not a big problem, but all it means is that you're going to have to explicitly state when you intend for an array to be treated as a tuple. And you're gonna just need to define a type annotation in that case."
          },
          {
            "time": "[00:03:46]",
            "text": "Again, it's running with the theme of type strip trying to stay out of your way while providing you with safety. And here is what that tuple might look like. So within the square brackets, we're simply indicating with each position what type of value we expect to find there."
          },
          {
            "time": "[00:04:10]",
            "text": "In this case, we're being shown that or being alerted to the fact that two things seem to be out of place, TypeScripts, not happy with the first or the second element here. And that's because they need to be switched in terms of position and then here we're seeing that source has 4 elements, the target only allows 3."
          },
          {
            "time": "[00:04:30]",
            "text": "It's basically saying the right hand side has 4 things on the left hand side, you have my car and you told me I should have 3 things. Therefore I object, right? So this is how you define tuples. They're, really useful in cases where you want to return multiple things."
          },
          {
            "time": "[00:04:50]",
            "text": "But maybe it's not a type that's so formalized that you wanna store things under property keys, like often, maybe for form validation case, right? I don't want to throw errors. I kind of want to return errors. I'll return a tuple that has in the first position, a string that's like success or okay."
          },
          {
            "time": "[00:05:10]",
            "text": "And then data, or the first position it'll be like error and then followed by the error. But this is a pattern you see often in languages like Python or Elixir. Where you return these things? So, you do want to be careful here and TypeScript 4.3 it's the latest release."
          },
          {
            "time": "[00:05:38]",
            "text": "So I'm leaving this immortalizing this comment saying that, something might happen in the future, but today there are limitations. There is not a whole lot of support for stopping you from treating this like an array. So in this case, you can see that during assignment, we get the error messages we would hope to get."
          },
          {
            "time": "[00:06:04]",
            "text": "But in this case, you can see that we start with a two element tuple. We can push the third one in, we can pop them all out and TypeScript is not going to stop us from doing anything here. I can give you a hypothesis as to why TypeScript letting us do this."
          },
          {
            "time": "[00:06:22]",
            "text": "And it's because there is no type equivalence check on num pair that happens when we invoke methods on it. There's no concept in TypeScript yet of like, I'm calling this thing push. Therefore, the thing that I was invoking it on, like numb pair, it's type should change. There's no concept like that in the language yet."
          },
          {
            "time": "[00:06:49]",
            "text": "So you have to be aware that you only get that validation on assignment and you can still shoot yourself in the foot by messing with your tuple using push and pop. And Luis points out there's a proposal for real records and tuples and JS. That's, great. There are a lot of proposals for things in JS."
          },
          {
            "time": "[00:07:16]",
            "text": "So I wouldn't wanna represent that this is coming or even likely, until these proposals advance to like at least stage three. Seems like the kind of thing that might work though cuz it's to be reasonably performant. All right, and Niche has a question that I need to read for a moment."
          },
          {
            "time": "[00:07:38]",
            "text": "Okay, I'm just gonna sort of boil that question down and Niche asks a question about is the JavaScript community, and really it's like TC 39, the committee that decides what JavaScript is. Are they going to make JavaScript a statically typed language? I think it's extremely unlikely. I'm gonna say less than 1% chance, probably much less."
          },
          {
            "time": "[00:08:08]",
            "text": "And the reason is, this works pretty well, having sort of JavaScript be a compiled target. Now, what's more likely to happen is something around WebAssembly where you have other typed languages that compile out to WebAssembly bundle. And maybe that includes some runtime type checking. But remember this runtime type checking does not come for free."
          },
          {
            "time": "[00:08:37]",
            "text": "And we still have a lot of JavaScript to run in the world. So I do not expect types to be added to JavaScript directly. But that shouldn't get in your way because you can use this and treat JavaScript as a build target."
          }
        ]
      },
      {
        "name": "8-structural-vs-nominal-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we're gonna take a little bit of a step back here. So far we've talked about variables, simple function argument types, and return types. We've talked about objects, arrays, and tuples. And now I want us to step back and consider different kinds of type systems. And more specifically, how do we categorize different kinds of types systems?"
          },
          {
            "time": "[00:00:23]",
            "text": "Because we hear a lot of words to describe these things, right? Static, dynamic, duck typing, some people use this term strong types. What does it all mean? And what is the way to describe what we're seeing type scripts do? So first, we need to understand, what is type checking?"
          },
          {
            "time": "[00:00:43]",
            "text": "Type checking has to do with answering a question about type equivalence. As in, when we're using a foo, a function here, is the value we're passing in, equivalent to what the function is designed to accept? It's a comparison, right? Does this align with the constraints of where I'm trying to use this value?"
          },
          {
            "time": "[00:01:11]",
            "text": "That is type compatibility or type equivalence. That's the question that we're evaluating when we analyze this code, and think about whether we should have an error on this line here. This happens when you pass a value into a function. This happens when you assign things. So in this case, let's say x and y are both variables."
          },
          {
            "time": "[00:01:34]",
            "text": "And here we'd be wondering is the value that y holds type-equivalent to what x wants to hold? And if so, this assignment may proceed without objection. But if x wants a number and y hold the string, problem. Type equivalence checks happen on return types, especially when you have this explicit return type here."
          },
          {
            "time": "[00:02:00]",
            "text": "Is my strings an array of strings? That's what we said we would return. Are we returning it? Is the value I'm returning equivalent to the type this function says it's going to return? So this is the same question, it's just sort of asked in several places. You can check this footnote out if you wanna see another example that's weird."
          },
          {
            "time": "[00:02:27]",
            "text": "But this is most of what you wanna think about. So, with that question in mind, let's think about different kinds of type systems and how they answer this question. So the first way to categorize different types systems is static versus dynamic. Static type systems have you write types in your code."
          },
          {
            "time": "[00:02:54]",
            "text": "And that's TypeScript is one of these things, right? Java, c++, C sharp, any of these things are static type systems. It could be argued that Python with type hints also kind of fits into this category, but there's not much enforcement there. So it'd be a hard thing to defend."
          },
          {
            "time": "[00:03:16]",
            "text": "But TypeScript is definitely a static type system. Types are in your code and they're evaluated as part of the belt. Dynamic type systems perform their type equivalence check at runtime. So, this includes a bunch of languages here, where typically, you're just gonna see variable declarations that just say, I have a variable name and its value is Mike."
          },
          {
            "time": "[00:03:43]",
            "text": "And there are no types there, right? There's no support really for adding types in a formalized way. We can also think about type system as either nominal or structural. This is a weird one, because TypeScript is a structural type system. But just about every other thing you see in the programming language world, they are nominal type systems."
          },
          {
            "time": "[00:04:09]",
            "text": "So nominal type systems is all about a name. That's what nominal means. So here's a sample of Java code. And you can see here, similar to TypeScript, we have some properties, they are associated with some types. We have a class that contains these properties. And we have a function here, print car and it takes a car as an argument."
          },
          {
            "time": "[00:04:36]",
            "text": "The type equivalence check that is evaluated down here, it's really did myCar come out of a constructor called Car? Is your class named Car? That's a nominal type system. Everything is about what is the name of your class? And the reason that this wouldn't work so well in the JavaScript world is there's a whole lot of code out there that's not written with classes like this."
          },
          {
            "time": "[00:05:08]",
            "text": "We pass objects with properties around all the time. And if we had to convert everything to classes, that would be a very substantial change to our code bases that if required as part of migrating to TypeScript, it would just be a lot of extra work. So a nominal type system won't really fit existing JavaScript code, structural type systems just care about shape."
          },
          {
            "time": "[00:05:35]",
            "text": "So here we have similar other classes here, we can even have Car and Truck which kind of share some properties. We've got make model and year, they exist both on Car and Truck. And we've even got an object here, it's not an instance of a class, it has make, model, and year."
          },
          {
            "time": "[00:05:58]",
            "text": "Turns out, everything's gonna work with printCar. All printCar cares about here is do you have make, model, and year? It doesn't matter if you're an instance of a class, or you're just a regular object, or maybe you're some weird function with some properties hanging off of it. I mean, that's a class, right?"
          },
          {
            "time": "[00:06:19]",
            "text": "But [LAUGH] it'll work with any of them. All it cares about is look, I intend to reach into whatever you give me and I'm gonna use make, I'm gonna use a model, I'm gonna use year. I don't care about the other stuff going on around it, here's what I need."
          },
          {
            "time": "[00:06:38]",
            "text": "That's a structural type system. And these words here, Car and Truck, they're just around for our convenience. They're around so that we as code authors can make sense of what our code is doing. They play no role in any sort of type-equivalents checking. You could make something that might simulate what's happening in Java."
          },
          {
            "time": "[00:07:06]",
            "text": "You'd have to say give me a value that has a constructor property, which is a function that returns cars. Okay, you've defined the structure of something that is a factory of cars and that is the car class. Okay, you could do that but normal TypeScript code will not, right?"
          },
          {
            "time": "[00:07:31]",
            "text": "Normal TypeScript code, it's just do you have what I need? The properties and the types those properties can hold. If so, we're good to go. Duck typing. We hear about duck typing. I mean, people describe JavaScript as a duck typed programming language. And this gets its name from the duck test, which means if it looks like a duck, swims like a duck, quacks like a duck, it's probably a duck."
          },
          {
            "time": "[00:07:58]",
            "text": "And this is kind of another way of saying dynamic typing, where we kinda attempt to go ahead and use something, and if it works out, okay, and if it doesn't, we'll throw an error at runtime. That's how JavaScript works. You can think of it as having similarities to structural typing."
          },
          {
            "time": "[00:08:21]",
            "text": "In that, you just care about having what you need, right? You don't care about who created it. It's similar to structural typing in that way, but it's also dynamic typing, in that there is no type information at build time to evaluate. So all of these errors are popping up at runtime."
          },
          {
            "time": "[00:08:39]",
            "text": "Does that make sense? I mean, it might be a little bit of a stretch to say it's similar to structural typing. But what they do have in common is they have no concern for whether you came out of a class or whether you're an object literal. As long as you have what is needed in order to carry out the operation, we'll try to do that."
          },
          {
            "time": "[00:09:01]",
            "text": "But structural typing usually goes with static types as well, right, where you have that type information. Okay, finally, we have strong versus weak types. These terms don't really have good definitions. There's no such thing I'm aware of that's called strong typing. When people use the word strong typing, I think they usually mean, static types, types that are in your code."
          },
          {
            "time": "[00:09:27]",
            "text": "And when they say weak types, I think they mean dynamic types. But there is no consensus around a definition for any of these terms. So you won't hear me use strong types in this course, except right now? Static and dynamic, right, are the types in the code, or do we attempt to sort of YOLO it and figure out if things are gonna work at runtime?"
          }
        ]
      },
      {
        "name": "9-union-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're going to talk about today is union and intersection types. And these conceptually can be thought of as logical Boolean operators, and by that we mean, and, or. There are other operators that have no representation in typescript but we do have this concept of and, and or."
          },
          {
            "time": "[00:00:24]",
            "text": "So this is a hard concept for people to wrap their heads around sometimes. So we're just gonna use a very kind of explicit example here. Let's imagine that we have two sets of things. We have things that are fruits, and then we have things that are sour, and there is some overlap those fruits that are sour."
          },
          {
            "time": "[00:00:47]",
            "text": "So a union type, you can read up on the sort of set theory definition of what a union type is, if you wish, but you don't need to know that in order to be successful with that trip. You can think of a union type as OR, for types."
          },
          {
            "time": "[00:01:07]",
            "text": "And by union, we mean it could be something that is in either of the two circles, including the overlap between them. So if you think of a union like in terms of this logical Boolean operator, I'll show you go to the wiki page. Just to show you this one diagram here, right, it's everything."
          },
          {
            "time": "[00:01:30]",
            "text": "Everything that could be in either category. So that's the OR. Intersection types are only the intersection and that's the end, meaning, the only things that are allowed are things that are in the left side and the right side. That is an intersection type and, so in that case we would be only looking at, lemon, lime and grapefruit and that's because they are both fruits and sour."
          },
          {
            "time": "[00:02:05]",
            "text": "So let's look at how these two concepts are represented in the TypeScript programming language. Union types can be described using this pipe operator. For example, if we had a string, maybe it's like a property on some response object that a function returns and it could either be success literally that one string, or it could be the string error."
          },
          {
            "time": "[00:02:30]",
            "text": "So it's not just any string, it's one of these two specific strings. Here's another example. Let's flip a coin, do a math.random. If it's more than 0.5, let's call that heads otherwise we return tail, so it could be one of these two. And the outcome, you can see it's heads or tails, one or the other."
          },
          {
            "time": "[00:02:52]",
            "text": "And in this case, by the way, note that there's no possibility of it being both heads and tails at the same time. So a union type doesn't have to involve a potential overlapping area here. It could literally be a string or number and there is nothing that is both a string and a number at the same time."
          },
          {
            "time": "[00:03:15]",
            "text": "Sort of two separate circles, but a union type would represent anything that is in either circle, regardless of whether there's an overlap or not. So let's make this a bit more interesting using the tuples concept that we talked about earlier. And this is actually a common pattern that people like to use whenever there may be collecting errors and returning them instead of throwing an error and sort of interrupting the execution of the program."
          },
          {
            "time": "[00:03:44]",
            "text": "So let's say that we are trying to get some user information and that's what we're returning here, is a name and an email address. And we're wrapping that in a tuple, right? So the name and the email address, that's an object and we're storing that object in the second position of the tuple and the first position we're calling success, right?"
          },
          {
            "time": "[00:04:11]",
            "text": "See that string success to the extreme right of this tool tip. So that's like our success tuple, it starts with the word success, and then it gives us some data. And then in case of an error, we've got a string error and then an error object instead of throwing it, we're just gonna return it here."
          },
          {
            "time": "[00:04:27]",
            "text": "So what that lets us do, Is we have this thing, right? It could be either option, we can choose how to handle it and we will know what's in the second position of the tuple based on the string that we see in the first position. So we're gonna look at how we can deal with this value now, right?"
          },
          {
            "time": "[00:04:50]",
            "text": "It's either this, or it's that, or this piece here, one or the other. So here's how we might consume that value. First, I want you to see that if we look at either element of this tuple by itself, this union type concept has sort of propagated through each member of the tuple, right?"
          },
          {
            "time": "[00:05:21]",
            "text": "Our first element here, it's one of these two strings, and then our second element is either an error or this object. So each by themselves, they sort of have this duality until we straighten out what's going on. And I'm going to open this up in the TypeScript playground really quick, because part of the motivating use case here, we can get rid of this output here."
          },
          {
            "time": "[00:05:45]",
            "text": "But part of what's interesting is, why would we need to narrow things down? Why can't we handle this value directly? So if I look at this first thing, right, it's either error or success. And I have a lot of stuff on here that indicates that yeah, this is gonna be a string."
          },
          {
            "time": "[00:06:06]",
            "text": "It's one specific string or another specific string, but definitely a string. This second value down here is a bit more complicated, right? It's an error or this special object and it turns out that all we can access on this is name, why is that? Because error has a property called name, and this object has a property called name, and in both cases, they are strings."
          },
          {
            "time": "[00:06:31]",
            "text": "So all that we're able to access here is the guaranteed behavior, the guaranteed stuff that will be there, regardless of whether it's an error, or whether it's this object with a name and email property. We have a name in either case, but we're very limited in terms of what we can do as long as it's sort of in this state where we're not sure what it is."
          },
          {
            "time": "[00:06:54]",
            "text": "So to access email, for example, I'm not gonna be able to do that, why? Because email does not exist on type error, right? We have to arrive at a conclusion that this is not the error case in order to safely access email, and that motivates what we're about to talk about now."
          },
          {
            "time": "[00:07:14]",
            "text": "So here's the autocomplete we would get for the letter S, like clearly we access sub string behavior. Here we can only access name as we saw. And the bottom line is, when a value has a type that includes a union, we're only able to use this common behavior that's guaranteed to be there, no matter which circle we're in our Venn diagram or two separate circle in our case."
          },
          {
            "time": "[00:07:44]",
            "text": "So the way we address this is through a process called narrowing. And we've already seen this one, so we didn't give it a name but it's this process of using some condition with control flow. So we define a branch of code that will only be taken if we're in our success case and another that will only be taken if we're in our error case."
          },
          {
            "time": "[00:08:10]",
            "text": "And this will be done via this concept called type guards. So later in the course we're going to define our own type guards. These are called user defined type guards. And I like to think of these as where build time validation and runtime behavior meet. We saw one for example that was using type of."
          },
          {
            "time": "[00:08:36]",
            "text": "Here, remember when we were talking about our charging voltage. It was this optional property, it could be there it could not be there. So this is a type guard, it connects build time validation with runtime behavior in that, at runtime, we know that we will only enter this branch of code if charge voltage is defined."
          },
          {
            "time": "[00:08:58]",
            "text": "At build time, we can operate with the assumption that this is defined, right? So it it does serve as glue between these two worlds, runtime check that happens with a compile time narrowing down an increase in specificity of the type. So here in this case, is how we could make use of a type guard."
          },
          {
            "time": "[00:09:24]",
            "text": "So this same function, maybe get user info has two types of things that might return. And we can see that still each element of the tuple has this, maybe could be this, maybe could be that, which is kind of what a union type is all about. And we can narrow things down, we can use instance of, for example."
          },
          {
            "time": "[00:09:50]",
            "text": "So if second is an error, well, this branch of code will only enter it for the arrow case. And then in the else clause of this condition, we get everything that's leftover. After the if is handled, you can kinda think of it like slicing up a pie, where there are two things that this could be."
          },
          {
            "time": "[00:10:12]",
            "text": "And will handle the portion of possible futures where this is an error, and then all that's left is everything that's not error and that's what ends up happening in the else clause, right? So there's still a benefit to being in this else thing. So that's great, it's even better though."
          },
          {
            "time": "[00:10:31]",
            "text": "And this narrowing up here, this would work with just the return object. It's either an error or it's this object, but we can talk about how this tuple gives us some benefit via this concept called discriminated unions. And what this is telling us here, well, let's first look at what we're dealing with."
          },
          {
            "time": "[00:10:53]",
            "text": "We're looking at the first element of the tuple, we're seeing if it exactly matches our specific string. And then look, in this case, the entire tuple is in the error case, right? That's the string error and then the error object and then down here we have our success tuple."
          },
          {
            "time": "[00:11:13]",
            "text": "So TypeScript behind the scenes, clearly understands that if this string is found in the first position of the tuple, we know what's going to be in the second position. It understands that these are not two shifting values either of which could be one or the other, there's one scenario, and then there's another scenario."
          },
          {
            "time": "[00:11:35]",
            "text": "We could never end up with this object here accompanied by the error string. It's clear that TypeScript understands that because our check is on the first part of the tuple and what we're seeing as a benefit is the whole tuple is either in one category or the other."
          },
          {
            "time": "[00:11:51]",
            "text": "This is what's called a discriminated union. And what makes it a discriminated union is we have a convenient key of some sort to use in combination with the type guard that lets us in a broader sense switch between many different possibilities. And this could be a property on an object, or it could be a value in a tuple but usually it's gonna be something where you can have a type guard that looks like this where you can handle one of a number of cases."
          },
          {
            "time": "[00:12:22]",
            "text": "If there were 57 different possible tuples we could return as long as each had a specific key like this. A specific string as the zeroeth element. You could make a nice case switch that would handle each one of those cases, and TypeScript would cooperate with you. And you'd get that nice well formed whole tuple with both the sort of label for it and that second position which is where the deeper information is."
          },
          {
            "time": "[00:12:54]",
            "text": "Another word for this by the way, just in case you see it in the wild, it's a tagged union type, and the tag is error or success. It's whatever that word is, which is the indicator of what should be found in the other position."
          }
        ]
      },
      {
        "name": "10-intersection-types",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Great, so those are union types. Let's talk about intersection types, and as we get into intersection types, I should be clear that you're going to find union types far more often. And I want you to think about why that might be, well, we'll leave that as a mystery for now."
          },
          {
            "time": "[00:00:17]",
            "text": "Intersection types are substantially more rare. And conceptually, what an intersection type is, just to remind you, it is an END operator. And this is where in terms of the values allowed, if we go back up to the top here, we're talking about only the overlap between these two sets of things."
          },
          {
            "time": "[00:00:43]",
            "text": "Let's use an example here, and let's imagine a case where we wanted an instrumented promise. And by that I mean a promise that sort of measures the time at which an async operation began, and then a time at which things finished. Maybe you want to print this to the console or fire some sort of tracking event, so you can understand how your code's performing."
          },
          {
            "time": "[00:01:10]",
            "text": "In any case, it could look something like this. Well, sorry, I described a use case here and actually changed my mind and made it a similar use case. Let me describe what this use case does. Just cuz the promised one turned out to be tricky, this is something I've actually used it for to be clear, this is something I can make a concise example around."
          },
          {
            "time": "[00:01:34]",
            "text": "So, what we're doing here is we have a date, and we want basically date to have a new property on it that's called end. Now we're not changing all dates by reopening the prototype and tacking on a new function, we just want a date with extras, a date with some extra stuff on it."
          },
          {
            "time": "[00:01:55]",
            "text": "So this is what this could look like. So we've got makeWeek, and it'll use today as the start date, it'll add a week to today's date in order to establish the end. And I'm using this spread operator to basically get everything that's on date, or everything that's on start, rather, and then tack on the other day at the end of the week to the end."
          },
          {
            "time": "[00:02:23]",
            "text": "The type I get back is everything that you know and love about date, and in addition to that, an end property where you can find another date. I'm just gonna open this in the playground. So we've got all of this stuff, the regular date API, and there's the end, and there's the other date."
          },
          {
            "time": "[00:02:46]",
            "text": "So it's sort of like mashing these two things together, right? That's what this end operator does. It's almost like a merging together of two types. This being one and this being the other."
          },
          {
            "time": "[00:02:46]",
            "text": ">> Doesn't this look more like a union than an intersection? Because when you say, this way it doesn't have all the properties of the data option."
          },
          {
            "time": "[00:03:11]",
            "text": ">> So if you look at the behavior that's available to you, it like feels like the labels for these types are kind of reversed, right? But if you think about these in terms of the values that you're allowed to have, that's where this makes sense. So let's go back up to our diagram at the top, let's say that we have a set of a bunch of different values here."
          },
          {
            "time": "[00:03:41]",
            "text": "On the left, instead of fruit, we have all things that are dates. And on the right, we have all things that have an end property whose value is a date. The only thing that we're happy with here, the only thing that matches our type with that intersection type operator, the end, it would be things that meet both categories."
          },
          {
            "time": "[00:04:06]",
            "text": "So, depending on how you look at it, you could see at one of two ways. If you're thinking about this in terms of the the set theory, meaning, I have a variable of this type, what values is it allowed to hold? Then it's this slice in the middle, it's the intersection."
          },
          {
            "time": "[00:04:24]",
            "text": "But if you're thinking about it in terms of the resultant object, what can I do with it? Well, that's where you see everything. If we changed our mental model to like, on the left, we've got things that can be done on date, and on the right we've got things that can be done on this object with an end property, now we can do everything, right?"
          },
          {
            "time": "[00:04:46]",
            "text": "It's the whole thing. That is not what this kind of type derives its name from. It's not about what you can do with it, it's about what types of values may it hold. But I feel your pain in that, I get these things mixed up a lot, because it's tempting to think of it in terms of what may be done on this thing."
          },
          {
            "time": "[00:05:14]",
            "text": "But where they get their names has to do with which set of values are allowable to be type equivalent to this thing. Does that make sense? It's really tricky, I used to teach this and say, look, I want you to push intersection and union those words, push them out the door and just remember end and or."
          },
          {
            "time": "[00:05:35]",
            "text": "Cuz we know we've got the two symbols, they match up with the way we use them in JavaScript conditionals, that level of understanding will take you a long way. But in terms of the way we think about these sets, it's really mostly about what can this value hold, and it's only the things that are both."
          },
          {
            "time": "[00:05:54]",
            "text": "And as a result, you get everything that's available on either type, right? Hopefully, that makes sense, I'm always looking for better ways to explain this to folks. But it's a common dissonance that people experience when they learn TypeScript. All right, so I am stating, I'm postulating that there's a 50 to 1 ratio or more of when you'll see there we go, I'm searching them already."
          },
          {
            "time": "[00:06:34]",
            "text": "A 50 to 1 ratio, when you'll see the or types versus the end types. And as you think about why this might be, consider control flow. So, we can have functions that branch, right? You have a condition and in one case you do one thing and the other case you do another thing."
          },
          {
            "time": "[00:06:56]",
            "text": "The return type of the function ends up being path A or path B. So a lot of these or types originate from things that look kind of like this. Right? As a result, we get this or, this will happen a lot in your code. Branching is something that happens a lot."
          },
          {
            "time": "[00:07:27]",
            "text": "Control flow happens a lot, it's a very, very common phenomenon. This sort of merging of two things together, much less common, so that's why you're gonna see this or thing far more often. It's because control flow results in many possibilities, depending on what the inputs are, and thus you get the or, or union type out."
          },
          {
            "time": "[00:07:59]",
            "text": "And that's it, that's the end and the or. The devil's in the details here, and when used in conjunction with other things gets more complicated, but you can just think of it as end and or. With that, it's about time for us to talk about interfaces and type aliases."
          }
        ]
      },
      {
        "name": "11-type-aliases",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Interfaces and Type Aliases are a way you can give a friendly name to your types. Remember, we're still operating within a structural type system here. So the fact that you call your interface, car, or fruit or whatever it is, that's for you, and other people that contribute to your code base, it's just a friendly name."
          },
          {
            "time": "[00:00:25]",
            "text": "In many cases, you're going to be able to be free to choose whether you wish to use an interface, or a type alias. So we're first gonna talk about type aliases because they're the easier of the two concepts. Then we'll talk about interfaces. In particular, we're going to talk a little bit about how they work with classes and how they work with inheritance."
          },
          {
            "time": "[00:00:48]",
            "text": "We'll talk about what it means to say, interfaces are open in TypeScript. And then finally, I'm gonna give you a little guide about what are the cases where I do have an opinion about which one you use, and finally, defining recursive types. After this, we're gonna do our first collaborative exercise and build types that describe any valid JSON value."
          },
          {
            "time": "[00:01:17]",
            "text": "We're gonna write some code until the tests pass. So let's get to it. Type aliases. So, we've dealt with types that look like this, be they a piece of user information or a car. Colon and then a bunch of stuff. And you can imagine I'm sure you don't have to imagine too hard that as we add a third, fourth, fifth, sixth property to this, it starts to get very, very cumbersome."
          },
          {
            "time": "[00:01:45]",
            "text": "You're gonna end up making a spelling error or if you wanna add one more thing to this, maybe you have to update seven different places, it's just gonna become a lot, right? So, Type aliases help with this. Three things they do for us. They allow us to give our type a more meaningful name, something that is semantic, right, where the name of the thing describes its purpose."
          },
          {
            "time": "[00:02:14]",
            "text": "We're going to be able to declare a type alias in a single place and imported and exported it just as if it were a value the same way we would import an export functions or constants or anything like that from other JavaScript modules. So we can centrally define at once and refer to it in a bunch of different places, which is great."
          },
          {
            "time": "[00:02:35]",
            "text": "That's gonna make our lives much easier as things get more complicated. So, this is the first multifile example I'm showing you. Please just trust that imports and exports work reasonably well. So this is like a hypothetical filename. Here's an export from the file name. And then you can see it's imported down here."
          },
          {
            "time": "[00:02:57]",
            "text": "And the type information does sort of flow through. Here you can see that instead of just to saying I have this type and using this for every variable, every function parameter I care about, we're saying, I'm gonna create an alias for this type. So I'm gonna use this type keyword."
          },
          {
            "time": "[00:03:17]",
            "text": "I'm gonna give my alias a name. And then we're gonna set it equal to some type information. And it's important to understand a couple things here. One, this is a very rare situation where we can see type information appearing on the right hand side of an assignment operator."
          },
          {
            "time": "[00:03:39]",
            "text": "Usually it's all on the left. Almost always it's all on the left, right? The second thing this declaration we're making, this user contact info. This will disappear as part of your build process. It'll just compile straight out. So it doesn't add any asset size or anything like that."
          },
          {
            "time": "[00:04:05]",
            "text": "Alright, so this is how it's defined and we can export it just as if it were, function or something else. So let's look at how we can use it. So we import it. And then we can use it in place of explicitly stating the type itself. And we could use this in a bunch of different functions in this file."
          },
          {
            "time": "[00:04:25]",
            "text": "So we're really just giving a Type a name. That's all in it. That's why they call it a type alias. And you can use a type alias for any type you wish to define, there are really no limitations beyond what TypeScript itself can do. I'm just simply making the point here that we don't need things to be labelled with this specific type, we're just describing a structure here, right?"
          },
          {
            "time": "[00:04:50]",
            "text": "User contact info, anything that has the right properties will make this happy. So here's an example of something that it does have this access property. We're storing it as a variable, so it's fine, but it's totally fine to use it even though the variable doesn't explicitly have user contact info as its type."
          },
          {
            "time": "[00:05:10]",
            "text": "All that matters is the structure lines up So, we already talked a bit about this declaration syntax. Type information on the right side of the equal sign. The convention is to use title case for names of type aliases and interfaces for that matter. And Just like variables, you can only have one type alias of a given name in a given scope."
          },
          {
            "time": "[00:05:43]",
            "text": "Seems weird for me to say that but that limitation does not exist for interfaces. So this would break for type aliases, but it would not break for interfaces. So we're gonna look at how a type alias can clean up some code that we've seen before. And in this case, we're back to our coin flip where we return an error sometimes, a success case in time."
          },
          {
            "time": "[00:06:17]",
            "text": "A success case if the coin lands the right way, we're gonna look at how this code can get cleaned up. And remember, this implementation is gonna be the same in both cases. So we're really gonna focus on this function signature. This is how we could clean it up with type aliases."
          },
          {
            "time": "[00:06:38]",
            "text": "So we could say here is the tuple for our error case. Here's the tupple for our success case, and then below here, we can define the third alias that describes the union type, right, the or between the two. By the way, this pipe here, this extra pipe, that's just auto code formatting, doing its thing."
          },
          {
            "time": "[00:07:04]",
            "text": "It is not harmful, but it does. It's also not necessary. Doesn't make things a little bit more readable because you can sort of just go, follow the line straight down. Look how much nicer this return type is compared to this whole thing. It's just a little bit more easy to read."
          },
          {
            "time": "[00:07:29]",
            "text": "All right, let's talk about, I'm calling it inheritance, it's pseudo inheritance, right? But how would we take an existing type alias and create something that sort of builds on top of it? So in this case, it's very similar to what we saw with when we were studying this and the intersection type."
          },
          {
            "time": "[00:07:52]",
            "text": "Special date has everything date has. Analytics effectively extends although we're not using an extends keyword, but we're accomplishing something equivalent, right? We're saying date is a type. And I'm gonna take everything that it's giving me. And on top of that, I'm doing some other stuff. So this is a good use case of this."
          },
          {
            "time": "[00:08:13]",
            "text": "This intersection type operator, not truly inheritance but has the exact same outcome."
          }
        ]
      },
      {
        "name": "12-interfaces",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What about interfaces? So interfaces are more limited than type aliases, in that they can only be used to define what we call object types. And object types are things that are conceivably look kinda like a class instance are an object with properties. Important to realize that union type operators anything like this, make something not an object type."
          },
          {
            "time": "[00:00:31]",
            "text": "That's a little bit more complicated than an object type, right? Because it's like, it has these two possibilities, it could be one or the other, and interface cannot describe that. It could describe what's being used within something that uses one of these operators for sure, but not this whole thing."
          },
          {
            "time": "[00:00:52]",
            "text": "You could not describe that with an interface, so it is more limited. Just like type aliases you can import and export interfaces from modules, just like type aliases, they completely compile away and disappear as part of your build process. Inheritance has a lot more formality around it with interfaces."
          },
          {
            "time": "[00:01:14]",
            "text": "So TypeScript calls, keywords like extends, and we're gonna talk about another one in a moment. Implements, calls these things heritage clauses, and that they are used to describe ancestry in an object oriented hierarchy of some sort. Extends is used to describe inheritance between like things. Implements is used to describe inheritance between unlike things."
          },
          {
            "time": "[00:01:46]",
            "text": "So we can see that classes can extend from classes, right? We've seen this in JavaScript. Interfaces can extend from other interfaces. But when working with classes and interfaces, that's when you're gonna wanna use this implements keyword. And what you're saying here is I have this interface, and it describes the properties."
          },
          {
            "time": "[00:02:14]",
            "text": "And potentially the methods, like this is the way you would type a method, right? I'm gonna eat some food. We'll talk about void a little bit later just for now it's doesn't return anything. So we'll eat some food. When you say Dog implements AnimalLike, what you're saying is, Make sure that my Dog class does everything that an animal like interface requires."
          },
          {
            "time": "[00:02:44]",
            "text": "Every instance of dog should make AnimalLike as an interface happy, right? And we're missing this eat method. So this is a good way, interfaces are a great way to define contracts between things. And to say maybe I have these five or six different classes, maybe they all have some support for logging or for, I don't know."
          },
          {
            "time": "[00:03:13]",
            "text": "Some common like cross-cutting thing that your code base needs, it could define an interface, you could use that interface for many classes. And you're assured that TypeScript will make sure each of these has what it needs. So we can see that the error we saw above goes away as soon as we add the method."
          },
          {
            "time": "[00:03:31]",
            "text": "So now our class is complete, it implements everything that AnimalLike demands. Now, if you've ever worked with a programming language that supports true multiple inheritance, you'll understand that it's probably a good thing that JavaScript doesn't allow us to do this. By that we mean subclasses that have multiple base classes that may mix with each other in funny ways."
          },
          {
            "time": "[00:04:00]",
            "text": "Multiple inheritance makes things wildly complicated. This is a way to have multiple facades. To have a class that aligns with multiple contracts. I'm calling these contracts, right? It's a commitment to do everything the interface says you must do. You can implement many interfaces. So here we've got a class called LivingOrganism, we've got AnimalLike we've got CanBark."
          },
          {
            "time": "[00:04:28]",
            "text": "So these are both interfaces here. And we can see that the dog can have a base class. And it can implement as many interfaces as it wants down here. No problem, no problem at all. So it is possible. And I'll pop this out in the in the playground here so I can play with it a little bit."
          },
          {
            "time": "[00:04:50]",
            "text": "It is totally possible if you had a type alias that looked like this, You can extend or you can implement, [LAUGH] right? A type alias, we're seeing that right here. However, you're kinda asking for trouble here. Because as soon as this type alias becomes more complicated, the compiler is going to object."
          },
          {
            "time": "[00:05:16]",
            "text": "So I prefer to exclusively use interfaces with this implement keyword, because the rules that interfaces demand that you align with guarantee that they will work nicely with classes. Imagine a case where you're using this type in a bunch of different places. Sometimes with the class, sometimes to define the argument of a function, you may find it useful to add something like this but your object oriented inheritance is not gonna work there."
          },
          {
            "time": "[00:05:52]",
            "text": "Basically if we had this here, it would kind of imply that your constructor for dog, like I'm gonna run new dog and I might get a number back, that's weird. It was theoretically possible in JavaScript with like proxies or some other exotic stuff. It's not what you want, [LAUGH] it's not what you almost certainly trying to do."
          },
          {
            "time": "[00:06:18]",
            "text": "So yeah, you could use a type alias here as long as it's not something like this, right? It would have to just be an object type. So I recommend, just use interfaces with implements. All right, interfaces are open. You may have heard about this. You may have read about this."
          },
          {
            "time": "[00:06:36]",
            "text": "What does it mean? It means that unlike with type aliases, we can have multiple declarations here, right? Where we've got interface AnimalLike, interface AnimalLike. We have a twice in a file. If this were a class or a variable or function, something like that, we would be screamed at saying, look, you already defined this thing, I already have something by this name."
          },
          {
            "time": "[00:06:59]",
            "text": "You can't do that again. You can't write on top of it or whatever, whatever you're trying to do, you can't do it. Well, with interfaces, you absolutely can. And what effectively is happening here is up here we're saying we have one method it's called isAlive and down here, we're augmenting the interface."
          },
          {
            "time": "[00:07:20]",
            "text": "We're basically saying, look, there exists this AnimalLike thing add on top of it, an eat method. And note that the fact that we're doing this down here, It's a pervasive change that's happening. It doesn't matter that we're doing it lower down in the code, the eat method is clearly available right here."
          },
          {
            "time": "[00:07:42]",
            "text": "In fact this would have ramifications throughout your project. If you had this in one file your eat method, as a result of this would pop up everywhere. This is not a localized thing. This is a holistic across your app change potentially. Anywhere that you're using this AnimalLike type, you would see this change."
          },
          {
            "time": "[00:08:07]",
            "text": "You would see this eat method. Why is this useful? Why would I care about this? Where and how is this useful? I've highlighted it for you because it's probably a burning question. Well, sometimes we pin things on the globals, right? Like we add stuff to the window object."
          },
          {
            "time": "[00:08:27]",
            "text": "Maybe there's some emerging thing that will soon be available in JavaScript and you wanna code as if it's their promise that finally might be an example of this. It was only recently standardized, right? So you may have to tack some things on to an interface that already exists."
          },
          {
            "time": "[00:08:47]",
            "text": "And you can see that we're able to do that here. So window, this is like the window that's available in your web browser, right? Window.document, you're used to running this, right? So by just having this little piece of code here, we're augmenting window, we're changing it, such that, We've got all of this stuff on here, right?"
          },
          {
            "time": "[00:09:13]",
            "text": "But we've also got our example property, so we're sort of tacking something on. You'll find little things like this. You may think of like, globals are bad, right? We don't wanna do this, but you'll find that you're consuming some library. The type information is incomplete, you just wanna tack this one thing on, this is a way to do it, this is a good way to do it."
          },
          {
            "time": "[00:09:38]",
            "text": "Augmenting an interface. Because they're open, you can always add to them. So which one to use and when? Most of the time to be honest, it's completely up to you. There are fewer and fewer advantages as time goes on to fewer and fewer places where one makes any more sense than the other."
          },
          {
            "time": "[00:10:03]",
            "text": "However, A couple clear, Choices to make in some scenarios. Number one, if you're using anything that does not align with this idea of an object type, right? Where if you're using this union type operator, you must use a type alias, you cannot use an interface. Number two, this is my recommendation not a hard constraint."
          },
          {
            "time": "[00:10:32]",
            "text": "But if you want to use something that it's designed for a class to consume, like class dog implements, can eat food, or something like that. I would advise strongly that you use interfaces for that because you will by making that decision never find yourself in a place where the type you're creating becomes incompatible with object-oriented inheritance."
          },
          {
            "time": "[00:10:58]",
            "text": "Number three, if you deliberately want consumers of your types to augment your types, you must use an interface. Cases like this will become more clear in the intermediate TypeScript course. But there are situations where, A user of your code might sort of inject stuff into your interfaces so they can describe the code that they've written, which may be interacts with a library that you've written."
          },
          {
            "time": "[00:11:32]",
            "text": "But interfaces because they are open and type aliases are not, interfaces are the tool for this job. Finally, let's talk about recursive types. So by recursive types, I just simply mean types that are self referential. So if we look at this, let's pretend we just want nested arrays of numbers."
          },
          {
            "time": "[00:11:53]",
            "text": "How would we describe the type for this? Well, you could do it as follows. We could say, nested numbers is either a number or an array of nested numbers. So recently this is a TypeScript 3.7 feature. Type aliases started to support this. You used to have to use a combination of interfaces and types in order to accomplish this, but now, this becomes a lot easier to write."
          },
          {
            "time": "[00:12:22]",
            "text": "You're just saying it's a number or an array of myself. And as a result, we can do something like this. And you can see that .push is validated as it should, because it wants numbers or arrays of numbers, or recursive arrays of numbers. Thomas asks the question, kinda going back to interfaces here."
          },
          {
            "time": "[00:12:47]",
            "text": "Does augmentation of interfaces persist across files? Yes, type checking should be a holistic operation that's performed on your entire app at once. So, there is no such thing as local augmentation of an interface. It's a whole set of constraints for all of your code as it all fits together, including your dependencies."
          },
          {
            "time": "[00:13:13]",
            "text": "And that's type checking is all of that at once."
          }
        ]
      },
      {
        "name": "13-json-types-exercise",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we're going to begin a collaborative exercise. And what I would like to see us do here is, write some types using interfaces or type aliases, and then what makes sense to you. But we want these types to describe any valid JSON value. And I have for your convenience brought a portion of the JSON specification, and so we wanna make types that describe what we're seeing on the screen here."
          },
          {
            "time": "[00:00:36]",
            "text": "So a value can be an object, an array, a number, a string, false, true or null. So you can I mean, I've taken these words right out of the spec document, but we can take false and true that's Boolean, right? So it's numbers, strings, Booleans, No, and then arrays and objects that include those things, but we couldn't have a function for example, functions don't belong in JSON."
          },
          {
            "time": "[00:01:04]",
            "text": "Make sense to everybody. If you've worked with JSON before, I'm almost certain. So, this is your starting point code, and what you have here are some positive test cases, all these should pass the TypeScript should be happy with these and then negative test cases. So these should fail and the errors you're seeing here are because they're not currently failing."
          },
          {
            "time": "[00:01:29]",
            "text": "This Ts expect error this special comment, this tells the compiler that it should yell at us, if it doesn't find an error here. So the fact that they're not failing, because right now we're saying, look these things are anything right? So it's happy with a function when it shouldn't be, that's why we call these negative test cases."
          },
          {
            "time": "[00:01:53]",
            "text": "We got to suppress the errors we're seeing here by making it so that this does not type check. So how are you going to attempt this exercise, and we can work on it as a class together for sure. But I'd like you to have a local copy of this and play with it so that you can sort of poke around and help us get to an answer."
          },
          {
            "time": "[00:02:20]",
            "text": "Just hit this try button and we can see the same errors right here in the TypeScript Playground. So, basically, your job Is to make it so that these three types become the right thing that describes JSON. So here's how I want you to think about this, and I'll go one step further and I'll say it's important for this task that we're looking at right now."
          },
          {
            "time": "[00:02:51]",
            "text": "So, the way TypeScript parses this file, it's a Java's functions, it'll go down and it'll say, JSON object noted for that. Let's keep scanning down and let's keep looking. Look, there's a JSON array, there's a type like that. All right, well, I know where to go if I need to know about that, and it keeps going down and keeps going down and it sort of finds the fact that all these things exist."
          },
          {
            "time": "[00:03:22]",
            "text": "And then later on, it goes back and it starts looking at the right hand side of the equals. So as a result, there's no, it's almost like there's a hoisting effect here in that as long as you're on the right hand side of the assignment operator here. You have access to any type alias that exists in scope, and that by the way is also how the recursion works, right?"
          },
          {
            "time": "[00:03:47]",
            "text": "A lot of implementations of Recursive structures like these, they have to do with sort of scanning through and separating, declaring that something exists from how it's implemented. That's a common way to address circular referencing cuz the core problem there is, well, how can we know what it is when it's referring to things that haven't been defined yet."
          },
          {
            "time": "[00:04:12]",
            "text": "But if you do it in two pieces, so, you're good to go. Okay, let's get started here. So, I really like failure driven development. I like to have a bunch of errors and I can sort of SWAT at them and make them go away piece by piece. And right now, we're in this situation where we're just like way, way, way too flexible."
          },
          {
            "time": "[00:04:37]",
            "text": "We're letting anything pass through, that's why our positive test cases are all passing and our negative test cases are largely failing with the exception of this big int thing, which apparently is fine. Apparently that it's already failing, interesting, so cool. Let's just tighten things up a little bit more and let's start from sort of the narrowest, the most specific constrained side of things, and then add things until we get all of our cases passing."
          },
          {
            "time": "[00:05:16]",
            "text": "So for now, I'm gonna define a new type here. We'll call it a primitive, and let's just say for now it's a string. So JSON values, they can be strings, they can be numbers, or Boleans, or No. So here we're making good use of our union type operator, string or a number or Boolean or No, those are valid JSON values."
          },
          {
            "time": "[00:05:54]",
            "text": "And down here we can see our negative test cases about they are happy because without this comment, this is failing type check. So with the comment it's now happy, but we're missing our array case and our object case. And certainly the nesting aspect we won't even know until we address these two, I don't think we have much hope of addressing nested raise, object, strings, and numbers."
          },
          {
            "time": "[00:06:27]",
            "text": "That's sort of the most mixed of our cases. And I'm just gonna say so we have an object and an array, I'm gonna say that primitive or an object or an array. Cool, now we're back to failing, why are we back to failing? Can someone guess, when we have this code here, why did all of our negative test cases light up?"
          },
          {
            "time": "[00:06:56]",
            "text": "So function, somehow functions happy now, anyone have a guess, in chat or on Zoom, what if I did this? Like we're back to Eddie, somehow we're back to Eddie. Yes, Joshua. And Teresa, very good, both of you. So what we've done is we've performed, we've used this union type operator with an any."
          },
          {
            "time": "[00:07:29]",
            "text": "And I want you to think about it kind of like multiplying by zero in that, we were fine here when we just had it as a string or a number or a Boolean or no. But as soon as we do this, it becomes an any because it's almost like zero times anything is zero."
          },
          {
            "time": "[00:07:49]",
            "text": "Well, whatever type you like, or any, is any sort of just eclipses all of the other type information that you have there. Very good Joshua and Teresa, so okay, well we'll have to solve that, how would I type this JSON array? Like anyone have any ideas? No peeking at the answer, I know it's on the website but don't ruin my fun."
          },
          {
            "time": "[00:08:24]",
            "text": "Conceptually, what is an array in JSON? What kind of values does it contain, okay. Bala's got number, number or string, Teresa, you've got another good one. So we couldn't do this, we could try to exhaustively do this but remember we've also got arrays of arrays like a JSON array of JSON arrays, that could be objects in my array."
          },
          {
            "time": "[00:08:54]",
            "text": "So really, I wanna just say, look, a JSON array is an array of JSON values. There are many ways to implement this, this is just the way I'm choosing to do it, so JSON oops. It's an array of JSON values, and now if I were to take this JSON object thing out, cuz that's still an any at this point, look, our array case got happy, so that's great."
          },
          {
            "time": "[00:09:28]",
            "text": "Even if we nested this, even if this became a string it's still happy. So really we just need to describe these objects somehow, how would we describe an object like a JSON dictionary maybe. Anyone have ideas?"
          },
          {
            "time": "[00:09:28]",
            "text": ">> Index signatures."
          },
          {
            "time": "[00:09:28]",
            "text": ">> Index signature, very good. So that looks like this."
          },
          {
            "time": "[00:09:59]",
            "text": "And then we can bring it back into the fold, and there we are positive cases happy negative cases happy. So I saw some other things in the chat. I'm not gonna call any names cuz I don't wanna I like that people are collaborating, even if the answers aren't quite there, if we had this so this was one of the answers I saw in chat."
          },
          {
            "time": "[00:10:24]",
            "text": "What are we saying here? What's the difference between this and that. This is a tuple of length one that contains a JSON value, it's always gonna be one long, which means this case here would fail, but this case here would pass. So we wanna make sure that we use this double box, square bracket notation right double square bracket to say this is an array of arbitrary like not a tuple."
          },
          {
            "time": "[00:11:07]",
            "text": "But there we go, and this is definitely a recursive type because an array is expressed in terms of values and values expressed in terms of arrays. It's looping and looping all over, but it's fine because remember all the compiler does is it goes through and it says noted these things exist types of the following names."
          },
          {
            "time": "[00:11:29]",
            "text": "And then it sort of has a placeholder for those in memory and then on the right it says, okay, well, I have a placeholder for this, I don't know what It is yet, but okay, whatever JSON value is you'll have one here. And then it kinda goes through and sorts things out."
          },
          {
            "time": "[00:11:47]",
            "text": "But there you go, this would be suitable if you use the fetch API and you have a wait fetch that JSON something this, right? Maybe you could say, instead of returning any promise, maybe the value that comes out of this promise is a JSON value doesn't contain functions, only JSON."
          },
          {
            "time": "[00:12:19]",
            "text": "All right, if you want to look at the solution it's down here behind the spoiler warning. So if you wanna look at it later and poke at it, maybe on your own time if you like try different implementations. See if you can make this work with interfaces or a combination of the two, this is a really useful thing, everyone needs types for JSON."
          },
          {
            "time": "[00:12:43]",
            "text": "But maybe one day it'll be part of what TypeScript ships part of the standard stuff that comes with it."
          }
        ]
      },
      {
        "name": "14-functions-function-overloads",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's time for us to dive a little bit more deeply into functions and there were a couple of these early topics we needed to tackle first. The union intersection operators for sure and these named types, right? Like interfaces, type aliases, so now we're ready for this and we already talked about argument types and return types."
          },
          {
            "time": "[00:00:24]",
            "text": "Now we're gonna go deeper, so we're gonna talk about defining Callable types, by that I mean, interfaces that describe functions. Interfaces are type aliases rather, that describes something that can be invoked, or something that can be constructed using the new keyword. We're gonna talk about function overloads and I won't even attempt to give you a sneak preview of what that is because it's, if you've never seen it before, it's kind of a wild concept."
          },
          {
            "time": "[00:00:58]",
            "text": "We'll talk about typing this, If your function has a special need for making sure that whenever it's invoked, it's, this scope is a specific thing. And then finally I think we covered this a little bit, but we'll touch one more time on function return types, and best practices, so let's jump in."
          },
          {
            "time": "[00:01:24]",
            "text": "Type aliases and interfaces, they both provide some capacity for defining a call signature. So this is an interface we're used to seeing instead of this thing that I've highlighted, we're used to seeing a bunch of different property names, right? Instead we have parentheses and within them what appears to be an argument list, and then a colon, and then a return type."
          },
          {
            "time": "[00:01:48]",
            "text": "So, this is a callable thing, in a type aliases form, this is what it would look like and note that we're using a fat arrow here kind of like an arrow function, whereas up here we're using a colon. These are totally equivalent, these top two and we can see here, we benefit when we do something like this to define functions stored on variables, we benefit from having defined these call signatures."
          },
          {
            "time": "[00:02:21]",
            "text": "We don't need to have type annotations on function arguments. Usually you always need to, well that's not gonna use usually an always in same sentence, but with regular function declarations, you must include argument types because there's no way to infer them. In this case, all of the type information you need is on the left side of the assignment operator."
          },
          {
            "time": "[00:02:47]",
            "text": "So we know this is a number, we know this is a number and we know we should be returning a number, you don't need to state that information again. This is great for things like callbacks, right? Where it just saves you from having to add more and more type annotations."
          },
          {
            "time": "[00:03:04]",
            "text": "Sometimes we don't return anything from functions and so, scream in the chat or on zoom. What is the function return if we have no return statement in JavaScript, like if we capture the return value and try to use it, what is it? Is it 42? Undefined, great, it's undefined, so functions if they don't return, what we get when we attempt to use their return value is undefined."
          },
          {
            "time": "[00:03:31]",
            "text": "Well, JavaScript has a way of, sorry, TypeScript has a way of describing this and it's with a void return type and this means specifically that the return type of this function should not be used, it should be ignored. So we could type these functions as undefined, right? So, here's our callback, we have this is a higher order function to run some function in four seconds and here's the thing to run, right?"
          },
          {
            "time": "[00:04:02]",
            "text": "It returns undefined and then here's another one invoke in five seconds, and its return type is void. So, note that this little arrow function here, it happens to return something, why? Because, although we hardly ever use it Array.push actually returns a number that I mean, I don't even know what this number represents."
          },
          {
            "time": "[00:04:32]",
            "text": "We think of it almost like an entirely state modifying method that doesn't really return something useful, it happens to return something. So, the void case is quite happy with this, the undefined cases not, so there's a difference between saying the return value of this function should be ignored."
          },
          {
            "time": "[00:04:56]",
            "text": "Versus, I promise I will always return undefined, a void callback here you're fun, returning whatever you like, you will be encouraged to not use that value within the body of this function. But it's fine if you happen to return something, whereas in this case up here, you may not return something versus here it's like do what you like."
          },
          {
            "time": "[00:05:22]",
            "text": "Void is happy with whatever because we're not going to use it, right? So, that's the difference and important difference between void and undefined, void should only appear as a function return type. You should not be using it anywhere else because what it means is the return value of this function should be Ignored and left unused."
          },
          {
            "time": "[00:05:44]",
            "text": "Let's talk about construct signatures for a moment, this is another area that is sort of rare, cuz oftentimes we just define classes which kind of have this sort of functionality built in. But we have the ability to do this, so here's an example of a Date constructor, and it looks just like a call signature, except we've added this new keyword in front of it, that's it."
          },
          {
            "time": "[00:06:10]",
            "text": "So now, if I were to create something that I'm calling, my Date constructor, set it equal to the date, class itself, not a new instance of date. Now you see the TypeScript perfectly happy to let me instantiate, you probably won't come across this very often, but if you see it, I want you to know what you're looking at."
          },
          {
            "time": "[00:06:29]",
            "text": "This, you should come across function overloads, so, because this is a Kind of abstract concept, I wanna motivate the existence of this thing, function overloads with a potential use case. So, let's imagine a situation where we wanted to create a function that allows us to register what we're calling a main event listener where that means, the primary event of whatever DOM element we appear to be referring to."
          },
          {
            "time": "[00:07:03]",
            "text": "So, in the i frame case, if we're past an i frame, I want us to be setting up a post message callback, like we're communicating with the i frame, right? That's the main event you care about for an i frame, if you don't believe me, let's pretend that it is and then form would probably want submit, right?"
          },
          {
            "time": "[00:07:26]",
            "text": "That's a big, meaningful event that's associated with the form, so we could give it a shot by creating two types that represent sort of our event listeners, one that receives form data, one that receives a message event and this is for the i frame. And we could say, all right, so my first element here my first arg it's one of these two types of elements, it's either the form or the i frame and then here we've got the handler for the form or the i frame, right?"
          },
          {
            "time": "[00:08:01]",
            "text": "We certainly can handle both cases and I can get the zeroeth i frame on the page and I can try to handle this event. So here's the i frame, something's already looking a little bit off here, right? Because we're not getting any type hint, we're just getting an any, so that's not good, we're allowing a lot of possibilities here."
          },
          {
            "time": "[00:08:28]",
            "text": "Basically, we don't have any sense of saying the first argument passed to the function has any effect on which second argument we should accept. So, to put this more concisely, what we want, is when we get a form to strictly be dealing with submit, and when we get an i frame to strictly be dealing with post message, not a combination of the two, that might not make any sense."
          },
          {
            "time": "[00:09:01]",
            "text": "So, function overloads help us solve this, and effectively what we're doing here is we're saying I have one implementation in my function, but I wanna define types for two specific entry points. One that does the form stuff with the right element and the right handler, and one that does the i frame stuff with the right element and the right handler."
          },
          {
            "time": "[00:09:29]",
            "text": "This ensures that I have two specific prescribed ways of doing things and I'm not left with all of the flexibility that I really don't want to handle such as this in combination with that, that would be sort of like crossing our wires. So, we can see here if we get our frame and get a form, this case works for handling the frame, we can see we have type information here, there's our message event and then in the form case, this works as well."
          },
          {
            "time": "[00:10:07]",
            "text": "Let me show you what a failing case look like, basically, like let me show you what we can't do anymore, and that would be something like this. Actually a better way to Illustrate this is just to show you what the autocompletes look like. So, normally we just get autocompletes like this and when we open this up we would just see like, here's what you should type, but, look, we got one of two and two of two, we kind of have two options."
          },
          {
            "time": "[00:10:36]",
            "text": "For what we can do here, the form way, or the i frame way and note that we don't actually, we're not offered the arguments that are described on lines 14 and 15 of this piece of code. No one's showing us In a union type, right? Not for option one, not for option two, right?"
          },
          {
            "time": "[00:11:02]",
            "text": "It's one or the other, we have two choices for the function, we're not allowed to mix. And what we're seeing here is that we can see this, we can see this, this here is effectively hidden, that's part of what is allowing us to do this. It basically means that this is sort of what's invoked behind the scenes, we can make this whatever it needs to be in order to handle all of the cases we care about."
          },
          {
            "time": "[00:11:29]",
            "text": "But we can have very specific entry points that allow us to avoid handling these combinations of things that we have no intent of allowing. So, we would call these two heads of the function and then this often is referred to as an implementation of the function and this is the only thing that has the braces, right?"
          },
          {
            "time": "[00:11:51]",
            "text": "So, an important thing to think about as you consider using function overloads, is that the implementation has to be compatible with the heads. So, the problem I've created here is I think I just deleted the first argument for this middle bit here and basically what the implementation is the error message that we're getting is that there's just no way for all of these to line up."
          },
          {
            "time": "[00:12:23]",
            "text": "They kind of need to be specific case one, specific case two for the heads, and then an implementation that's general enough to handle anything that might come in. But in this case it's sort of broken, right? Meaning, we're only accepting one element here, it's, we need something else, if we were to, for example, just say look, I'm gonna take another argument, And we need to see the fact that, we have this type here, we need to allow for a possibility that an i frame element might come through."
          },
          {
            "time": "[00:13:01]",
            "text": "So, this almost, it has to be general enough that it could type check against any combination of the head above it. So, these are almost like specific cases that live within the type described by this hidden piece. It's a really powerful tool that lets you have greater opportunities for code reuse, because you can have something that is very carefully designed with specific entry points, while having some very general shared logic that backs all of those function signatures."
          }
        ]
      },
      {
        "name": "15-this-types-best-practices",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, when we talk about this types, what we mean is the type of this within a function when it's invoked. And this has the most relevance when talking about freestanding functions because methods on classes, they kind of already have this wired up in a convenient way. Here is example of what we might care about this, so a button or a DOM element of any kind."
          },
          {
            "time": "[00:00:28]",
            "text": "If we wire up a handler, like a click handler of some sort, when the buttons clicked, this function will be invoked and this within the function will be whichever DOM element emitted the event. So, if we tried to operate on that, we would kinda be busted on it because what we're being told here is look, I don't know that you wired up my click handler to a Dom element."
          },
          {
            "time": "[00:01:00]",
            "text": "Like you could be using it that way or a different way, but you can't start consuming this, unless you tell me what it should be, so I can help you stay on the tracks, right? And use it responsibly, so in this case, we happen to be fine, because we have no opinion about this, right?"
          },
          {
            "time": "[00:01:25]",
            "text": "We can directly invoke it takes the argument as it should, but it's the use of this that's kind of causing an error message to pop up. So what we need to do is define what's called a this type and it's sort of just an argument that's passed behind the scenes, which makes sense to me because that's kind of, when you think about how function apply, function call works, right?"
          },
          {
            "time": "[00:01:52]",
            "text": "We pass this along with the arguments there, it's part of the information that goes to the function when we want to invoke it, so it kind of makes sense that it's included alongside the arguments. And now we can see that we're fine and, in fact, that's the type of this it's an HTML button element."
          },
          {
            "time": "[00:02:13]",
            "text": "And down here now we're busted on that, because the only safe way of invoking this click handler It would be either using function call like that, or creating a bound version of the function. And if we look at this bound handler, it may not show it on the tooltip, no, it does show it on the tooltip, so now notice that my click handler has this HTML button element."
          },
          {
            "time": "[00:02:42]",
            "text": "While the act of binding this, it means that we're creating a new function that doesn't care about which this, is being used because we're baking the right context into that function that bind returns. So it makes sense that this bound handler, you can just pass it in an event, because it's already got the right this."
          },
          {
            "time": "[00:03:08]",
            "text": "If anyone here have seen this pattern before, where you're doing function bind, to hook things up to DOM elements, maybe in a react component, right? This is kind of a common way of like you pull methods off of your class and you say this dot action equals this dot action dot bind, so there you go, this is the kind of thing we're talking about here."
          },
          {
            "time": "[00:03:37]",
            "text": "And bind call and apply, at least for modern versions of TypeScript, should work very very nicely with the concept we just talked about. So, let's end our section on functions by talking about best practices, I already asked you to explicitly define return types. So, here's an example of a piece of code, where if we made what appears to be an innocent change, so you see here we're fetching some data and then if the promise resolves, we'd like to log it to the console."
          },
          {
            "time": "[00:04:12]",
            "text": "What if over here, when we decode the body of our response, we start to only do that for successful responses only, right? We add a guard around it. Errors would start to pop up, where we consume the result that the promise resolves to, right? You start to see these errors where they break as opposed to where you need to fix it, right?"
          },
          {
            "time": "[00:04:44]",
            "text": "This is the change, right? Get data now has the possibility of returning undefined, you can see it right in the tooltip or promise that resolves to undefined. I'd like my errors to pop up closer to where I must fix them, we did talk about that a little bit."
          },
          {
            "time": "[00:05:04]",
            "text": "And so, this is what you would see if we had this explicit return type and this error right on the function, and it's really clear how we can address it."
          }
        ]
      },
      {
        "name": "16-classes-access-modifier-keywords",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> TypeScript takes the JavaScript concept of a class and layers, some really useful stuff on top of it. We're going to talk about access modifier keywords, private, public protected. We're gonna talk about private fields. And then I'm going to show you how properties work, which is a shorthand that will come in, t's very useful because without it, TypeScript classes can get really verbose as you define class fields that sorta originate from constructor arguments."
          },
          {
            "time": "[00:00:38]",
            "text": "So let's talk about class fields for a moment. In the JavaScript world, you've probably seen code like this where we take in arguments to the constructor, and we kinda tack them on to each instance of the class. Part of what we get as a result of this is like, the instance of the class isn't a well defined type, meaning we don't know necessarily what's on it."
          },
          {
            "time": "[00:01:04]",
            "text": "We're very used to knowing upfront, like what's gonna be here, these are the things that I can expect on this interface. And that's not true if we can write arbitrary logic in the constructor and just start tacking things on. As a result, if we look at the way TypeScript analysing this, we can see that yes, it knows that this is an instance of a car, but it's not gonna provide us any kinda type safety around which methods we can invoke."
          },
          {
            "time": "[00:01:30]",
            "text": "And furthermore, all the arguments, the constructor arguments end up being any as well. So we need to add type information to this situation and get into a world that's providing us with that useful feedback we have seen so far in the course, where the wrong types of arguments will start to present error messages."
          },
          {
            "time": "[00:01:50]",
            "text": "So this is what the equivalent code would look like in the TypeScript world. And I want you to notice a few things. First, we state the possible class fields and their types up front. Second, obviously, just like a function call signature, we have types for all the arguments passed to the constructor."
          },
          {
            "time": "[00:02:15]",
            "text": "And then this code remains unaltered, where we sorta take everything the constructor received and we can now safely tack it onto the interface, or sorry, on to the instance of the class. We are now rightly stopped when we try to invoke a method that doesn't exist. And we're rightly stopped when we attempt to, like pass arguments to the constructor in the wrong order or just otherwise fail to meet the demands of what this wants to receive."
          },
          {
            "time": "[00:02:45]",
            "text": "On top of this,TypeScript adds access modifier keywords. And here what I'm saying is, I just want to acknowledge this code is getting very verbose. Like the word make is here, here, here and here. So it's like four times for each property. We're working our way up towards a simpler way to write this."
          },
          {
            "time": "[00:03:07]",
            "text": "We need to talk about access modifier keywords first. So access modifier keywords, you can find these in Java and C#, they all mean the same thing broadly across a wide range of programming languages. Public means everyone can see something. Protected means a class can see something and also subclasses can see it and then private means they're only visible to the class itself."
          },
          {
            "time": "[00:03:37]",
            "text": "And when I talk about something can be seen, I mean class fields or methods. So we use these words to indicate the visibility of class fields and methods. So, here you could see, all right, we're exposing these class fields to the outside world. Maybe we have a VinNumber that the car class can see and any subclass of the car can also see."
          },
          {
            "time": "[00:04:02]",
            "text": "But maybe there's this door lock code that we can unlock all the doors of the car. We wanna keep that private to the car, not even subclasses can see that. So I want you to see a couple things here. First, this pattern, right? So, doorLockCode is private. But you can certainly provide, you can sorta open up access to subclasses by defining a method or sometimes people define like a getter and a setter property, it's not just about keeping things hidden so that people don't peek at these values."
          },
          {
            "time": "[00:04:42]",
            "text": "I mean, if you're running your app in a browser, you can't keep secrets there coz you're sending all your code to your user. But you can control the pathways that people will take in order to get certain things done. So if you wanted to unlock all the doors and use your door lock code in a specific way and not expose that directly, you could do that."
          },
          {
            "time": "[00:05:06]",
            "text": "And you could say this is a private thing, but I allow it to be used in some form through protected method. Let's look at a subclass here. So sedan extends car, sit in can see a VIN number just fine. That's protected. It cannot see this door lock code because it's private and it's only accessible within the class car."
          },
          {
            "time": "[00:05:36]",
            "text": "And here, we're kinda applying the same pattern again. So we have a public function that's called unlock, which calls this protected method unlock all doors. So you see we can use this way to control visibility into what's available on instances of this class as a mechanism of providing a nice surface for people to interact with, where they're not able to get a directly modify state."
          },
          {
            "time": "[00:06:08]",
            "text": "And this might lead us if we have a different locking mechanism on this car, we can now safely change that up here, right? Nobody can possibly see this. So we can feel confident that if we change it, we're not going to break anybody, as long as this method still does what it's supposed to do."
          },
          {
            "time": "[00:06:28]",
            "text": "So it's a great encapsulation tool. A lot easier than just sorta overloading your constructor and using that scope as private, which is another common pattern. And obviously, from the outside of this class, so here Here's our sidin class. This is the ending brace of our class declaration. And here we're creating a sedan, we can see this public thing, but we can't see this protected thing, and we can't see this private thing, right?"
          },
          {
            "time": "[00:07:06]",
            "text": "So it's saying this is protected, and it's only accessible within the car and its subclasses So that's private, public and protected. And this limited exposure concept is really what I just described. The ability to take something that is hidden and provide controlled access to it. Through, you know something that is more visible, like exposing a private thing through a protected method, something like that."
          },
          {
            "time": "[00:07:41]",
            "text": "Just a warning. JavaScript is least client side JavaScript things that run in browsers. Please don't use this as a mechanism for storing like auth tokens or encryption, keys, anything like that. This is really just about encapsulation, not not security right? And furthermore, these access modifier keywords they disappear as part of the build process."
          },
          {
            "time": "[00:08:14]",
            "text": "So anyone who puts like a debugger in your program, they'll be able to see all of your fields there. So it's not, this is again, just fancy linter. This is not really private at runtime. JavaScript recently got the concept of private class fields. You can recognize these because their name begins with the hashtag as of TypeScript 3.8."
          },
          {
            "time": "[00:08:37]",
            "text": "These work really nicely in TypeScript. This is private at runtime. They're a little more difficult to access. But again, I would not advise you to put encryption stuff here. There's one last thing that's kind of like an access modifier keyword. I say kind of because it can be used in combination with other keywords."
          },
          {
            "time": "[00:08:59]",
            "text": "It's called read only. And this will yell at you if you attempt to reassign. Values. It's not about mutability, it's about reassign ability. So think of it more like const and less like a frozen array of some sort. It's really about not pointing year to a new number in this case."
          },
          {
            "time": "[00:09:28]",
            "text": "Keep in mind, giving it an initial value in a constructor is totally fine. After it receives its initial value, that's when it starts monitoring, and watching, and making sure that you don't assign it to something else. Great, we've made it through access modifier keywords. Now let's talk about puram properties."
          },
          {
            "time": "[00:09:52]",
            "text": "The more concise way to write classes in a way that doesn't involve the word make 1234 times each property we have, that will become a class fields four times we have to write that word So this is the abbreviated, well, this is not the abbreviated syntax, but this is the before, and here's the after."
          },
          {
            "time": "[00:10:20]",
            "text": "Put them both on the screen at the same time. So it looks kinda strange, but the key thing is we have an access modifier keyword. Before our constructor arguments. And it means exactly the same thing. The code on the bottom is going to compile to exactly the same thing as the code on the top."
          },
          {
            "time": "[00:10:42]",
            "text": "I can prove it to you. Let's go to the TypeScript playground. Let's pop this out and look at the JavaScript that it creates So what's happening here is we're saying, I have a constructor argument, and I'm going to call make. I also have a class field of the same name."
          },
          {
            "time": "[00:11:06]",
            "text": "And in my constructor, please store what I received. In my class field puram properties to constructor parameter, and it becomes a class property. And this is the only time you'll see an access modifier keyword like this next to something other than a method or a class field So, the most important thing I can tell you, this is like a common snag people hit is we have to study what happens around constructor logic."
          },
          {
            "time": "[00:11:47]",
            "text": "Class field initialization, these puram properties, right? There's a lot of stuff that's sort of going on as we instantiate things. So I've created for us an interesting situation here. Where we have a class field with an initializer oops. And don't don't worry about console log like not returning anything."
          },
          {
            "time": "[00:12:14]",
            "text": "We just want to see when the console log happens. Right? We have a super call. We have one of these which sort of that involves an assignment to a class field. So understanding the order of operations here is really important. Right? When is this going to get invoked?"
          },
          {
            "time": "[00:12:34]",
            "text": "What happens before what? Well, when we compile it out, we can kind of see. And thankfully, I've written. Class field initializer here, custom constructor stuff. So we should hopefully be able to recognize this when we see it in the compiled code. So, let's look at this. So first what happens is super, then we have these puram properties, followed by class field initializers."
          },
          {
            "time": "[00:13:01]",
            "text": "And only then does our constructor code actually run. That's right here, right? This is the last thing to run. So that's the order of operations. Prim properties, other class fields, and then our custom constructor stuff. And before everything, the absolute first thing, Is the super call. When in doubt, write a small example pass it through the TypeScript playground."
          },
          {
            "time": "[00:13:30]",
            "text": "That's all I basically did here. So that you can see that this happens, right? So, when in doubt, make a small example and kick the tires. And although it's possible to put stuff before super. You can't combine it with these parameter properties, or class field initializers. Once you have those super must be the absolute first thing in your class or in your constructor So I can prove that to you."
          },
          {
            "time": "[00:14:10]",
            "text": "If I take this away, And that now we're fine. So it's it's these things this automatic constructor behavior that Makes it so that pre super logic is forbidden."
          }
        ]
      },
      {
        "name": "17-top-types-any-unknown",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're gonna discuss is honestly one of my favorite in TypeScript and it's this chapter and the next one. So we're gonna start with top and bottom types, which are types they can hold anything and types they can hold nothing. And then type guards and narrowing."
          },
          {
            "time": "[00:00:17]",
            "text": "So we saw a little bit about type guards already, like type of, instance of, but we're gonna learn how to write our own type guards. So the first thing I want us to talk a little bit about is thinking about types in terms of what is called set theory."
          },
          {
            "time": "[00:00:39]",
            "text": "And this might sound a little bit scary cuz set theory gets very complicated. But I just want you to think of it from the simple idea that we can think about types as defining a set of values that a variable or a function argument might be. So if we were to say that x is of type boolean, what we're really saying is, you may select anything from the following set of values, true or false."
          },
          {
            "time": "[00:01:16]",
            "text": "It can be one of those two things and the set describes all allowed things that x could be. That's as far as we need to go with set theory. So let's think about y being a number. So we could use what's called set builder notation. Hopefully, this is human readable enough."
          },
          {
            "time": "[00:01:39]",
            "text": "But we could say there exists a thing y such that y is any number. And if we imagine the same kind of concept is dealing with a boolean, which only has two possibilities, y you could think of as having a similar set. But within that set is any number that's allowable in the world of JavaScript."
          },
          {
            "time": "[00:02:04]",
            "text": "So just a couple more examples to sort of hit this point home. Here is a union type that could be one of three specific numbers. So there's the set of things that it could be. Null, actually is its own type, at least with strict null checks turned on, which you should make sure that remains turned on."
          },
          {
            "time": "[00:02:29]",
            "text": "But that's one thing that that could be. And here's an optional variable or an optional property on some object type that could be exactly the string pineapple or it could be undefined. Hopefully making sense so far. So type just describes a set of things that you could find in the variable that type describes."
          },
          {
            "time": "[00:02:56]",
            "text": "Great, so let's talk about top types. Top types are types to describe anything and we've already seen one of these, any. So the set of things that any could be it's any value allowable in JavaScript. It could be a function, a number, a string, a big int, a symbol, null could be absolutely anything, right, anything allowed in JavaScript."
          },
          {
            "time": "[00:03:32]",
            "text": "And that's what makes it a top type. It's the most general most flexible thing that exists in this type system. There's another top type called unknown. So we're gonna talk about any first and then we can go and look at unknown. Obviously, any is quite flexible. You can just think of it as playing by the same rules as regular JavaScript."
          },
          {
            "time": "[00:03:58]",
            "text": "Obviously, there are risks around using any. This is clearly at runtime going to be a number, but I'm reaching into it as if it's got many, many nested things and they're not going to be there. This will result in a runtime error. Now I got this question earlier, is it wrong to use any?"
          },
          {
            "time": "[00:04:18]",
            "text": "Is there any time where it's the appropriate thing to do? And my answer is yes, there are times when it's absolutely appropriate. A good example is console.log. If we look at the type of console.log, it has a rest parameter here. So it takes any number of arguments you like, each of which is an any."
          },
          {
            "time": "[00:04:41]",
            "text": "This is appropriate because console.log can log just about anything to the console. There's no reason to impose additional constraints here. Any describes accurately what you should be doing here. So it's the absolute right thing to use. This is not something that should be tightened up. This is correct."
          },
          {
            "time": "[00:05:00]",
            "text": "All right, let's look at unknown. Just as with any, you can see that I can put a number in it, a string, document, a function like set timeout, seems a lot like any. But here's the key difference. Unknown can't be used unless you narrow it, right? Unless you use a type guard with it to check it out, to make sure that it's acceptable for use."
          },
          {
            "time": "[00:05:33]",
            "text": "So it's almost like it comes with a warning label that says, you must verify that this is what you think it is before you go ahead and do something with it. So in this case, you can see, yeah, we can put any value into it that we like, but we can't reach in and start accessing it directly."
          },
          {
            "time": "[00:05:53]",
            "text": "We must do something like this. So you see my unknown, right at the time that we're checking it before we established that it could be a string, it's an unknown. And then down here, it's a string. So we're free to use it as a string. And then here's another condition where it's an unknown."
          },
          {
            "time": "[00:06:14]",
            "text": "But as soon as we make it into this code block, hey, it's a number, and we're free to use it as a number. So it's as flexible as any in terms of its ability to hold things, but it places an extra responsibility on whoever uses this value to kind of check it out first with the type guard."
          },
          {
            "time": "[00:06:33]",
            "text": "So those are the two top types. So practical uses for a top types. One key place where you will make heavy use of this is if you convert a project from JavaScript to TypeScript. I do not advise that you go straight from untyped or dynamically typed JavaScript code and then try in one big pass to convert everything perfectly, to have really strong, I just used the strong word to describe types, shouldn't do that."
          },
          {
            "time": "[00:07:09]",
            "text": "To make a very specific well articulated constraints with types and just try to convert the whole thing in one big code triage, that's dangerous, right? Your odds are you're gonna break something cuz it's just a lot of potential to change behavior while you're doing that. It's common to define some reasonable types where it's easy, where it makes sense, and to leave a lot of anys in there, and to sort of clean those up in successive passes as you sort of tighten things up, tighten things up."
          },
          {
            "time": "[00:07:42]",
            "text": "So any is really useful for sort of work in progress mid conversion states. And it's also useful where you frankly just don't have any idea what's going on. Like you have no compile time ability to verify things. An example would be you just received a fetch response and you decoded it from JSON."
          },
          {
            "time": "[00:08:06]",
            "text": "And you might think you know what it is based on the endpoint, but can you really be sure? What if that API goes down and it starts sending you error messages? You might wanna verify that. That might be a great use for unknown, values received at runtime from your data layer."
          },
          {
            "time": "[00:08:24]",
            "text": "This works really well with discriminated unions by the way. Remember where we had that tuple where there was the success and there was the error. So maybe you receive an API response and on every API response, there's a little key where if you see that property there, that's a strong signal that you know what the rest of the object looks like."
          },
          {
            "time": "[00:08:43]",
            "text": "So you can receive it as an unknown, check for the presence of the key. Okay, now we know what it is and you have a nice type for that thing. It's a great thing to use for data layers."
          }
        ]
      },
      {
        "name": "18-bottom-types-never",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, let's talk about the opposite of top types, a bottom type. Bottom types describe things that can hold no possible value. So you can think of it almost like you're free to choose anything within an empty set, that this variable will be happy to hold, right?"
          },
          {
            "time": "[00:00:25]",
            "text": "It's like anything you want, and you may pick it from this perfectly empty box, [LAUGH] that is never. Sounds like a really abstract concept, and if you're like me, if this is the first time you've heard about never, you're wondering what is the point of this thing? Is it here just because somebody loves math, and because they feel like they want some great symmetry in the universe?"
          },
          {
            "time": "[00:00:50]",
            "text": "Or is there something that I can actually do with this that is useful? And I'm pleased to tell you, it's the second one, there is something very useful you can do with it, and that thing is exhaustive conditionals. So let's look at this situation. We've got a class called car, a class called truck, and then a type called vehicle, which can be either car or truck."
          },
          {
            "time": "[00:01:18]",
            "text": "And let's say that we wanna do something with our vehicles. And we just have a vehicle, we don't know whether it's car or truck, in fact, behind the scenes I have something called obtain random vehicle, but just for now, say, it's one of the two. So, what we can do is say, okay, we got the type car here, we're gonna handle the truck case."
          },
          {
            "time": "[00:01:41]",
            "text": "Great, it's a truck we can call the tow method. If it's a vehicle, sorry, if the vehicle is a car, we can call drive, and that's something that's only available on the car, okay, like class. Apparently trucks can't drive, apparently, I don't have a truck. So, great, what's left?"
          },
          {
            "time": "[00:02:02]",
            "text": "What's left after we've eliminated the possibility that it's car, and we've eliminated the possibility that it's a truck? What else could this thing be? It's kind of a trick question, the answer is nothing. There's nothing else that could be, nothing, all that's left is never, there's nothing else that could be."
          },
          {
            "time": "[00:02:34]",
            "text": "We've taken care of 100% of the cases of things we know about, right? Like cars and trucks, and there's nothing else this could be. So the fact that we're saying this ends up as never, that's another way of saying we've handled all of the cases. We have an exhaustive conditional that handles every possibility of this vehicle being one of the things, right?"
          },
          {
            "time": "[00:03:04]",
            "text": "So, let's see what happens if someone comes along and adds boat. So what they've done is they've created a class boat, and they've added boat as one of the things of vehicle could now be, could now be a car, or a truck, or a boat. And I haven't touched the rest of the code."
          },
          {
            "time": "[00:03:28]",
            "text": "Look what happens here. We see, wait a minute, this vehicle, when it gets into this last else clause, there's something left over, it could be a boat, right? This isn't a never, there's not nothing left over after we handle car and truck, there's boat leftover, and we're alerted to this now."
          },
          {
            "time": "[00:03:52]",
            "text": "So, imagine a world where this stuff here, the car, the truck, the boat, the vehicle type, this might be defined in some other file, maybe in a project with 10,000 JavaScript files. Someone alters this, and now all of the conditions, all of the different places and the rest of the code base, where they're looking through, they wanna make sure they handle every case that this thing could possibly be."
          },
          {
            "time": "[00:04:18]",
            "text": "Now you see all of these nice errors light up, where you know you have to go in, and handle the boat case now. Either deliberately handle it or deliberately not handle it, but attention is needed, right? These are places if they have something down here that says, basically, like up here my vehicle had better be a never, right?"
          },
          {
            "time": "[00:04:43]",
            "text": "Or saying, I'm gonna create a variable of type never, and the only thing that can fit in never is never, it's the most specific, finicky type there is in TypeScript. It's only happy with other nevers. So, this is only gonna work if there's nothing left, and down here, there's boat left, and so this conditional is no longer exhaustive."
          },
          {
            "time": "[00:05:12]",
            "text": "The way I like to handle this is I create, and I have the same code, if you look for this code like my GitHub account, you probably see a couple dozen projects pop up. I should really just put it in the library so I can use it that way."
          },
          {
            "time": "[00:05:28]",
            "text": "But I use this unreachable error all the time, and it takes as an argument and never, and it has a message as its second argument. So, the purpose of taking a never as the first argument is, I wanna be able to pass something into it that will have a compile error unless it's a never, right?"
          },
          {
            "time": "[00:05:51]",
            "text": "So that's about creating a compile error at the right spot. The message is so that if for some reason, maybe have been lying in my types like cast something, something was an any, and it's like weekend my types in some way. If I ever reached this line and I ever actually throw this error in code that I didn't think I could ever reach."
          },
          {
            "time": "[00:06:14]",
            "text": "I get a very clear indication that something was really weird here, and my assumptions about being unable to reach this line of code, had been broken. And I have to take a close look at what actually is going on here. And the way I would do this, is I would say, instead of up here where we create a variable and we set my vehicle equal to something, down here in this last else block here, I would throw the error, right?"
          },
          {
            "time": "[00:06:44]",
            "text": "And in this case, I get a compile error because boat is leftover, and I'm alerted to it. So by kind of wrapping this in an error subclass, we know that one of three things will happen, depending on whether things break and how they break. So, first, we've written our types, well, everything is handled before we even reach that else clause, we never entered the else, right?"
          },
          {
            "time": "[00:07:16]",
            "text": "And everything's happy, so that's great. Another thing that could happen, we catch this code change at compile time, which is the example we're seeing in this error message here, right? Someone added boat, this piece of my code needs an update, I'm alerted to it, and I can give it some attention, that could happen, that's what we're seeing here."
          },
          {
            "time": "[00:07:41]",
            "text": "Finally, if somehow something slips through, I at least get a good error message and I at least know that I thought I could never reach this thing. And I get a description here, I mean, maybe be more descriptive than this, but I could say, I didn't even think this was a possible vehicle."
          },
          {
            "time": "[00:08:05]",
            "text": "Maybe you log out what this thing is, so that it becomes more actionable for you and you'd go back to this code and you'd say, where did boat come from? My types don't suggest that boats possible, how did we end up with a boat? And you would track that down."
          },
          {
            "time": "[00:08:20]",
            "text": "So, it's also important to remember this works really well with switch statements. And the only difference is you would throw your unreachable error in your default case clause, right? That's it, whatever it is, it's sort of the fall through. If any of your specific cases with type guards aren't met, this is the thing you thought could never happen, but if it does happen, you get a nice error message."
          },
          {
            "time": "[00:08:46]",
            "text": "Exhaustive conditionals, this is cool stuff and if some programming languages support a more formalized version of this, like rust, I believe, it demands that every conditional you create is exhaustive, right? You have to write in your no ops explicitly. So this gives you the ability if you choose to use this never concept in this way, you can do the same thing for your code."
          }
        ]
      },
      {
        "name": "19-type-guards-narrowing",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, we've talked about top types, bottom types. Let's talk a little bit about type guards, and narrowing. So we have already addressed a bunch of different kinds of built in type guards, right? So I've created a value here that could be it's not quite an any but it could be a bunch of different things."
          },
          {
            "time": "[00:00:20]",
            "text": "And we can see a bunch of different ways that we can narrow it down, get a branch of code that will execute only in a specific scenario. And then within that code block, we can treat it in a more useful way, right? Like, as it stands, there's not much you can do with value given that it's so varied like what it might be."
          },
          {
            "time": "[00:00:42]",
            "text": "So here we could say, okay, it might be a date, so we use instant serve as a type guard. Type of, right? That works just fine. Checking whether something's undefined or not, the type of is great for that. Checking against a specific value that's a perfectly fine type card to use."
          },
          {
            "time": "[00:01:00]",
            "text": "Truthy, falsy checks are fine. Just beware, of course, empty strings and zero and false are all false II values. So if you have something like it's Boolean or undefined, truthy, false, you might catch something you're not intending to catch, right? Some built in functions have type card capabilities like array.is array, right?"
          },
          {
            "time": "[00:01:25]",
            "text": "So we can see that value comes in could be a bunch of things. But within this block, it can only be a couple of length one that contains a number. Property presence check with this in keyword, right? That's saying is does there exist an owned property called date range, within value."
          },
          {
            "time": "[00:01:54]",
            "text": "And then of course, you can always like make a couple checks and then whatever's left over, that'll be what's left over. So that's sort of like a reverse type guard, right? Can carve away the parts that you don't want. And all that's left is what's left. So those are built in type guards."
          },
          {
            "time": "[00:02:12]",
            "text": "And I think this is an exhaustive list. But let's talk about user defined type guards because often, we want to operate on a much higher level than simply saying, is this a string? Is this a number? We more want to think about if you're building the front end masters website, you'd want to say is this a learning path or is this a course?"
          },
          {
            "time": "[00:02:35]",
            "text": "Or is this an instructor or is this a user account? And that's a lot more complicated. It's harder to think about how you might squeeze these kinds of things together to achieve that same level of creating a branch and knowing that it's this more complex object as you go down that path."
          },
          {
            "time": "[00:02:54]",
            "text": "So that's where user defined type guards come in handy. And here's an example of how ugly things could potentially get, right? So if we wanted to see, is maybe car doesn't look like a car. Well, in order to do this safely, given that it's an unknown, right, remember, we can't use this unknown until we narrow it down with a type card and check it out and make sure it's what we think it is."
          },
          {
            "time": "[00:03:22]",
            "text": "So you'd have to see okay, does it? Is it knowledge like Could it be null or undefined? Well, we eliminate that with this. And then Okay, does it have like is it an object of an object type? Does it have make model and year our make model and year strings numbers."
          },
          {
            "time": "[00:03:40]",
            "text": "Do you could do this. Let's say you were willing to do this, right? I would argue, you're already out of your mind if you want to write a bunch of code that looks like this. But let's pretend you're out of your mind. So, even if this did work, Eventually, you're gonna wanna refactor this."
          },
          {
            "time": "[00:03:59]",
            "text": "You're just gonna wanna take that same code that's sort of a bunch of different stuff in your conditional. You move it out into a function just so that your code can look like this, right? But the problem here is, even though these are all type guards, there's nothing about his car like there's nothing about this function that says, hey, TypeScript, you should regard the true or false value that this function returns."
          },
          {
            "time": "[00:04:29]",
            "text": "As an indication of what the type the argument is, right? Like, right now, even if we added type annotations here, right? Even if we said this returns a Boolean instead of an any there's nothing that tells TypeScript that something special about that Boolean that it has any bearing on what should be assumed about the argument we passed in."
          },
          {
            "time": "[00:04:56]",
            "text": "And so even the imperfect narrowing effect that we had when we had all this stuff up here, like at least we saw that it was an object, right? I mean, really, that just came from this here. But we don't even get that here. It's back to unknown. We're like back to square one."
          },
          {
            "time": "[00:05:14]",
            "text": "So user defined type guards are the solution to this problem. And the problem we're trying to solve is TypeScript has no idea that the return value of his car like has anything to do with what we passed into it. So here we go. We're going to make this a user defined type guard."
          },
          {
            "time": "[00:05:36]",
            "text": "And we're going to start by talking about an is type card. Value is foo, right? So we're going to see that syntax somewhere in a moment. So here we go. It's a function is car-like. It takes an argument. Typically, you're going to want this argument to be something very flexible."
          },
          {
            "time": "[00:05:56]",
            "text": "Why? Because you're going to reach into it. And you're going to check for the presence of things. You're probing, right? You're inspecting it, you can't assume that you know what it is yet, but you need it to be flexible enough to perform the validation, that makes sense. And then what makes this a type guard is the special way of writing its return type."
          },
          {
            "time": "[00:06:19]",
            "text": "So we can say effectively that like Yes, his car like it returns a Boolean. But that Boolean should be taken as an indication of whether value to test conforms to the type car like. And we can write our same implementation here. But look at this. Out here, it's unknown."
          },
          {
            "time": "[00:06:49]",
            "text": "And within this block, it conforms to the interface. And it's only because you're telling TypeScript to trust you. So, this is very important. This type guard can be your best friend or it can be your worst enemy. Because let's just completely do something crazy. What if we did this."
          },
          {
            "time": "[00:07:19]",
            "text": "Just anything you give me, I'm just gonna say it's always car like. Well, there it is, I'm not narrowing the value anymore if that's what's happening. So there's our -19. It'll be change this to x. Like apparently -19 is a car like, like I can access make model and year on this thing."
          },
          {
            "time": "[00:07:49]",
            "text": "No errors, None, no little red dots in my scroll bar here. So the type car is only as good as your alignment between the actual checking logic that you implement and the claim you make, about what that logic means means in terms of the type, of what's passed in."
          },
          {
            "time": "[00:08:16]",
            "text": "If your logic here is flawed, you're gonna run into big problems, because type scripts got to do exactly what you say. Right now I'm saying everything's carlike. And so -19 apparently has a property called year on it, TypeScript doing what I'm telling it to do. So just be really careful about these."
          },
          {
            "time": "[00:08:40]",
            "text": "These are again, I said this before I want to say one more time. These type guards are the glue between compile time validation and runtime behavior, you got to make sure that your compile time validation and your runtime behavior match up. And if they don't, you're gonna be lying to yourself here, right?"
          },
          {
            "time": "[00:09:01]",
            "text": "You're gonna be allowing yourself to comfortably reach in and pull things off and operate on values that should be erroring. Let's look at the other type of user defined type card. And it follows this format, asserts value is foo. So, here's what the return type looks like. I've changed this very slightly, right?"
          },
          {
            "time": "[00:09:25]",
            "text": "But that the return type is changed a little bit. The type guard itself if the check is the same check we were performing before, if it is found to not be car like we throw. So if you pass through this function and we haven't thrown your car like that's what we're saying here."
          },
          {
            "time": "[00:09:52]",
            "text": "If this function finishes without throwing, that means value to test his car like so effectively this function asserts that the value to test is car like. As a result, we can do something really cool here. We don't have to use a conditional because we're sort of using the return versus throw branching, well, I don't necessarily agree that that's control flow."
          },
          {
            "time": "[00:10:20]",
            "text": "It is definitely a true statement that will only reach this line down here if we pass through the function without throwing, right? But this is great for modeling, things that are in test suites or things that really are exceptional validation where if, like you don't even know how to proceed unless this is car like."
          },
          {
            "time": "[00:10:45]",
            "text": "So we want to get something more specific like we get we can't operate on this waltz and unknown and we legitimately do want an error to be thrown if this is some weird value. So in a might be the right thing to do here. But this is the other kind of type card that you can use."
          },
          {
            "time": "[00:11:02]",
            "text": "I commonly will use both where I would create something that's like is car-like and then I would consume this and kind of wrap it in something that'll throw it in error. So I get both of the funding is typed guard. And then I'll use that same little Boolean returning function in my asserts type guard."
          },
          {
            "time": "[00:11:29]",
            "text": "So here's a terrible example of type guard. And you can see like, well, I already showed you an even more terrible one. But here I'm assuming that all false things are no. Well, this will make you think zero is now an empty string is now like the false Boolean value is no, obviously, there are false things that are not no."
          },
          {
            "time": "[00:11:50]",
            "text": "But again, TypeScript will. It will follow your instructions, right? So in this case we have empty and we have zero. And we're here saying, if this value is no then log and unfortunately, we're just catching way, way, way too much with this type card. And we're never going to be able to get here, right?"
          },
          {
            "time": "[00:12:14]",
            "text": "It's claiming that It's impossible that we'll get here."
          }
        ]
      },
      {
        "name": "20-nullish-values",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The next topic we're going to discuss is nullish values and the three specific kinds of values that I'm talking about are null, undefined and void. So we're gonna talk about each of those three when I advise you use each of them. And then we're going to discuss the non-null assertion operator where you cast away any possibility of something being undefined or null."
          },
          {
            "time": "[00:00:26]",
            "text": "And then the definite assignment operator which can be used in some interesting edge cases around class initialization, or instance initialization, so null. Null indicates that there is a value for something and that value is nothing. I wanna be clear that different people have different opinions about this, when to use null, when to use undefined."
          },
          {
            "time": "[00:00:55]",
            "text": "But this has served me well, so for example, if I receive a null return value from a function or I find null on a class field, I take that to mean it's almost a 404, right? Like a not found, nothing's there or nothing's there yet, well really just nothing's there, like something's arrived and that is nothing."
          },
          {
            "time": "[00:01:22]",
            "text": "Undefined, I take this to mean that either we haven't gotten to providing something or we're not ever going to provide you with something. So here's an example of a form, maybe we're like monitoring how long it takes for a user to complete this form. And completedAt is a property that is undefined because they haven't completed it yet."
          },
          {
            "time": "[00:01:50]",
            "text": "And when they complete it, we will get a value so I prefer to use undefined for cases like this. Void as we said before, this should be used explicitly for function returns and it means that the return value of the function should be ignored. If you wanna learn or refresh yourself more about how to use void, you can look at the functions chapter where we show the impact of using void versus an undefined return type on callback types."
          },
          {
            "time": "[00:02:25]",
            "text": "So that's null, undefined and void, so now let's talk about these two operators. First, there's a non-null assertion operator and you may think of this as kind of similar to optional chaining, if you've ever used that, this sort of dot, I think it's click. Yeah, it's like dot question mark, something like that, I don't use it very much, to be honest."
          },
          {
            "time": "[00:02:51]",
            "text": "But that sort of allows you to reach deeply into an object and if at any point in accessing a chain of property something is found to be undefined, it will sort of just give up, just evaluate out to undefined and just sort of skip it. Non-null assertion operator is sort of the last or the less forgiving variant of this."
          },
          {
            "time": "[00:03:15]",
            "text": "Here's an example, so let's say we have a grocery cart which can contain fruits and vegetables. We initialize it without either and we try to kind of reach into this and say like, okay, I hope fruits is there because I want to treat it like an array and push stuff into it, but this array might not be there."
          },
          {
            "time": "[00:03:38]",
            "text": "In fact, it's not there, because we initialize this to an empty object. We're correctly being busted, on trying to use something that might not be there. Well, if we use this non-null assertion operator, this exclamation mark right here, we're telling TypeScript to disregard. Got Glenn Marth, I think I actually might have a typo, I do have a typo, this is the typo."
          },
          {
            "time": "[00:04:08]",
            "text": "That's a good catch, so it should not be dot bang, it should be bang dot. [LAUGH] Yep, very good catch, thankfully, my code example works because it's actually running TypeScript behind the scenes and it compiled. So this is working in front of our eyes, but I'll make that correction, thank you."
          },
          {
            "time": "[00:04:28]",
            "text": "So we can see that the possibility of fruits being undefined has sort of been thrown out, we're just saying please disregard TypeScript. I know what I'm doing, I'm the software engineer here, just do what I tell you to do. And as a result, we can kind of proceed through, I use this a lot, but never in app or library code."
          },
          {
            "time": "[00:04:52]",
            "text": "I use it like crazy in test suites because I prefer test frameworks and assertion libraries to be clear that will regard a throw as a test failure. So if this is my test case, where I have nothing, I don't have a fruits array in my grocery cart, and this throws."
          },
          {
            "time": "[00:05:15]",
            "text": "That's a failed test and that I'll treat it as a failed test, it's almost like a little mini assertion I think this is beautiful in a test suite. I don't like it in app code because it's a pretty hard failure to hit and I would much rather use a type guard and set and check to see if this is undefined."
          },
          {
            "time": "[00:05:35]",
            "text": "And then let's reach into it, I think that is a more fault tolerant way of handling this kind of situation. Because this in almost every case like this is this could have a real possibility of being undefined. I don't even like the idea. If we were to do this, I don't even think that this is justified because you're like I slightly inattentive refactor away from moving this somewhere else where you might not have that guarantee."
          },
          {
            "time": "[00:06:15]",
            "text": "I prefer to have my guarantees by way of type cards that will actually do some runtime thing to evaluate whether something's there or not there. Compared to this, which is just saying force the type system to forget about the possibility of undefined. That's a dangerous copy paste away from creating problems for you."
          },
          {
            "time": "[00:06:38]",
            "text": "But great in test suites because throwing errors in test suites, when things turn out in an unexpected way. That's a test failure, that's great, that will tell you something's wrong, you can go and fix it. All right, definite assignment operator, it's the same exclamation mark syntax used in a different place and that place is on class fields."
          },
          {
            "time": "[00:07:06]",
            "text": "So here's an example of something, essentially a slightly relabeled piece of code that I have in production right now. And it's a class that has to do something asynchronous as part of its setup procedure. So constructors can't be async but they can kick off an async method as they finish."
          },
          {
            "time": "[00:07:31]",
            "text": "And so what I do here is when the constructor is invoked, I say I've got this setup promise and I kick that off. And I say, we begin in a non setup state and I'm going to, Chain in the promise returned by this method here, right? So that means that this setup promise will only resolve once this thing is done."
          },
          {
            "time": "[00:08:00]",
            "text": "And then when everything's done, I'll flip that, his set up flag and say, okay, we're now ready to go. So I'm getting an error here and I'm seeing that this property has no initializer which is true. And it is not definitely assigned in the constructor, what does definitely assigned mean?"
          },
          {
            "time": "[00:08:22]",
            "text": "It means that TypeScript wanted to see, it wanted to see something like this, which I guess I could have done. It has no idea if or when this is going to be invoked. And so it's not willing to, doesn't wanna give me a guarantee that this property, this class field will get its value."
          },
          {
            "time": "[00:08:47]",
            "text": "Now if something's directly in a constructor, TypeScript can understand that. It can analyze it and it can say, if we instantiate this thing and then we say, here's a thing with async setup. Well, by the time I give it to you, it will have a Boolean value there because I saw you set one on the constructor but down here, it's not so sure."
          },
          {
            "time": "[00:09:07]",
            "text": "Now, in this situation, I know something that TypeScript doesn't and that is that the callback you pass into a promise constructor, it is invoked synchronously. Which means that by the time we actually get that new promise, this thing that I've selected, that little callback, it's already been invoked and it's already finished."
          },
          {
            "time": "[00:09:31]",
            "text": "And I will definitely have my Boolean value there but TypeScript, It doesn't have a way of saying, well, this is a synchronous callback. And this is an async callback and I know about the runtime behavior here. It just has no way of describing that but in this case, this code, it's actually okay."
          },
          {
            "time": "[00:09:50]",
            "text": "So, We could add something here, I'll just have to show you in the example. All we'd have to do is add the exclamation mark. This right here, the definite assignment operator, it's saying, look, I will assume responsibility for making sure this thing gets its value. A great place to use this is component lifecycle hooks."
          },
          {
            "time": "[00:10:22]",
            "text": "So no matter what component library or framework you use, there's often like there's the constructor logic. And then there's some initialization process that happens later, maybe it's when the component's initially rendered or when it's about to render and maybe you take care of setting some stuff up there."
          },
          {
            "time": "[00:10:44]",
            "text": "So realistically, you're not doing much with this thing, Until it's set up, and maybe it's rendered. So you might say, I know yes, after your constructor runs, this thing is not gonna be there. But realistically, for all things I care about, we can act as if it'll be there, so that's the kind of time where you might wanna use this."
          }
        ]
      },
      {
        "name": "21-generics",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We have now reached the culmination of TypeScript fundamentals v3, and that is generics. So generics are a way of creating types that are expressed in terms of other types. And the benefit of doing this is it allows for a greater opportunity to reuse code across your app."
          },
          {
            "time": "[00:00:23]",
            "text": "And that'll become clear as we get deeper into this topic. Because this is an abstract concept, I want to begin by leading us up to why we should care about this? What's the scenario we can see where we're missing something from TypeScript? And that will help us understand why should we even care about this thing?"
          },
          {
            "time": "[00:00:46]",
            "text": "So let's go back to an example that we've used before in this course, and that is a dictionary, right? We have this dictionary called phones and under an arbitrary key, we can store a three part phone number. And we can see that all of these properties look very, very similar."
          },
          {
            "time": "[00:01:06]",
            "text": "So sometimes it's convenient to organize our data in dictionaries and sometimes it's convenient to organize data in arrays. So it would be nice if we had some sort of utility that let us transform data that was in one type of collection into the other. So let's deal with this as our starting point for our data."
          },
          {
            "time": "[00:01:29]",
            "text": "It's a object that has three parts for a phone number. It's kind of customerId now, so it's just a ten digit phone number. But we've got a customerId, areaCode, phone number, and we have a list of them. What we want in the end is something that looks like this, where effectively we have this key value data structure, a dictionary, where each member of what was in the array, it's stored under a particular key."
          },
          {
            "time": "[00:02:00]",
            "text": "In this case, it's the customerId. Now we're gonna start by implementing a very specific solution that works for exactly this use case. And then as a second step, we're gonna see if we can make it more generalized and kinda get a feel for where we're at at that point."
          },
          {
            "time": "[00:02:19]",
            "text": "So we wanna go from this to this. So we will need one thing along the way and that's the the mechanism for producing a key that we use for storage of each object on the dictionary. And in order to make sure that we're on our way to a generalized solution, we're going to want the color of this function to provide us with the mechanism of obtaining that key."
          },
          {
            "time": "[00:02:46]",
            "text": "So part of what we're gonna ask for here is a little callback function, sort of a higher order function approach to solving this problem. So our function signature could look like this, we've got this PhoneInfo type and then a function that we can use to transform a list of these PhoneInfo things to a dictionary of the PhoneInfo things."
          },
          {
            "time": "[00:03:16]",
            "text": "Here's that little id callback that I mentioned earlier, where in addition to being provided the list, we're also provided with this function that can be used given a PhoneInfo, obtain a string. And we will use that string as our key. This is throwing an error right now for obvious reasons like we're not returning anything."
          },
          {
            "time": "[00:03:40]",
            "text": "We said we'd return a dictionary, currently we're not returning anything at all, quite understandable. So implementing the function itself is not really the point of what we're talking about here, it is pretty simple. We can start by defining the dictionary and we'll start with it empty. We'll iterate through each member of the list will generate a key using the function that were provided."
          },
          {
            "time": "[00:04:07]",
            "text": "And then we'll use that key to store that member of the array in the dictionary and then ultimately at the end, we return the dictionary. So that's the whole algorithm, loop, find the key, shove it on the dictionary, and then return the dictionary at the end, not too bad."
          },
          {
            "time": "[00:04:28]",
            "text": "So we can actually run this in the TypeScript playground and convince ourselves that this works. So the way you do that is you go click on Logs. As in Console Logs, that's where this will show up, and then hit Run. So here we go, this is our input."
          },
          {
            "time": "[00:04:48]",
            "text": "And then down here is where we're doing the log and we're seeing each of these objects stored in the dictionary under a key. So we can see that it appears to work, great. So let's attempt to make this a little bit more general. And the approach we're gonna take is find every reference to this PhoneInfo type and let's replace it with the most general type that we have, an any."
          },
          {
            "time": "[00:05:17]",
            "text": "So we used to have an array of PhoneInfos here, so it's an array of any. Our idGen callback used to take a PhoneInfo as an argument, now it takes in any. And then we used to return a dictionary of PhoneInfos, but we return a dictionary of any's now."
          },
          {
            "time": "[00:05:36]",
            "text": "Nothing else in this function has changed, none of this has changed, it's all the same. So really it's just about the any's that appeared in the function signature. Now if we wanna try this out, we can, now I'm going to comment this last line out because it's really just to illustrate a point."
          },
          {
            "time": "[00:05:57]",
            "text": "But if we run this, go to Logs and Run, we can see that now we're able to use this on a different type of array, right? These are not PhoneInfo objects, these are just objects that have a name property. And I have my little callback that describes what am I using as my key?"
          },
          {
            "time": "[00:06:18]",
            "text": "How am I storing these on the dictionary? So we obviously get the correct result at runtime, but the problem is we've lost all of our useful type information. Everything that comes out is in any, so in making this more flexible, we've had to relax our types, so much, that we don't get any of that validation."
          },
          {
            "time": "[00:06:44]",
            "text": "That is basically the point of TypeScript, right? In relaxing this so that it can handle anything, we're back to JavaScript level type safety, which is not much. That's the problem, we need a mechanism of allowing flexibility without giving up all of our type information and generics provide the ability to do that."
          },
          {
            "time": "[00:07:19]",
            "text": "So the first thing we'll need to do is define a type parameter. You can think of type parameters as arguments for types. They're kind of function arguments, but there are four types. Just like functions can return different values given different arguments passed to them, type parameters can influence what generic types end up being."
          },
          {
            "time": "[00:07:45]",
            "text": "So we're gonna go ahead and do a couple things here. This is gonna be our new function signature, so there are some things that have been added here. And we're gonna talk about exactly what each of those pieces of syntax mean, just so we slow way down and we understand what's going on."
          },
          {
            "time": "[00:08:07]",
            "text": "So first, we have this angle bracket t thing to the right of the name of the function, right? It's this thing right here, so what is this, it is the type parameter list with one type parameter in it. You can think of it like the equivalent to the round parentheses for a function argument list."
          },
          {
            "time": "[00:08:32]",
            "text": "So if we had many type parameters here, it might be t,x,y, something like that. The convention is like a common convention you will see but it's not a limitation by any means. It's to use capital letters, often the letter T is used. And this you can trace that back to the use of a similar feature set in C++, where they would call these template classes."
          },
          {
            "time": "[00:09:03]",
            "text": "It's the same thing, you could remember T for type or T for template, so that's what this is, it basically says there exists a type parameter t. The second thing, right instead of receiving a list of PhoneInfos or an array of PhoneInfos, we're receiving a list of T's."
          },
          {
            "time": "[00:09:27]",
            "text": "So what's that all about? Well, what's going to happen is on a per invocation basis, you might end up with a different type T. So if we were passing this, a list of PhoneInfos, T would be PhoneInfo. If we were to pass it a list of strings, T would be string."
          },
          {
            "time": "[00:09:51]",
            "text": "So what we're gonna see is that every time we use this function, TypeScript's going to use the type of the array. This first thing that the function receives, it'll use that to figure out what T should be. So it's gonna infer what T is on a per usage basis depending on the array we pass in."
          },
          {
            "time": "[00:10:20]",
            "text": "This is a much simpler example that kind of boil things down to the absolute most small atom that we can talk about here. We could define a function here that takes an argument and just wraps it in an array, like it's a tupple of length 1. And whatever we give it, it's gonna return a Tupple of 1 with that thing in it, that's all it's doing."
          },
          {
            "time": "[00:10:52]",
            "text": "So let's look at the return types of this function. Up here you can see it's like wrapInArray<T>, right, arg is T, and it returns this. While we pass it a number, look, the T turned to a number. We received an argument of type number, we return a tupple with a number in it."
          },
          {
            "time": "[00:11:13]",
            "text": "Here's the date, here's the date, and here's the date. I could do a RegExp, we could do whatever we want. This type, it's almost like it's morphing to accommodate our needs depending on the argument we pass to it. So it's like auto detecting what T should be, and returning the right thing to us as a result."
          },
          {
            "time": "[00:11:38]",
            "text": "So let's go back to our example again, our listToDict example. So we talked about this type parameter list, right? Just saying T exists, we talked about how we're saying, I'm going to receive a list of arguments. I'm gonna receive an argument and it's defined in terms of T, that's gonna help TypeScript infer what we should get for T."
          },
          {
            "time": "[00:12:01]",
            "text": "So now we have this line here, that's our id generating callback and we're using T here as well. So this means a couple of things. First, that we're going to get the use of type checking within this callback. And the second is we're going to effectively ensure that the type of thing or callback is designed to work with is the same thing that the array has within it."
          },
          {
            "time": "[00:12:31]",
            "text": "So if we had something like this, here's our array, it's an array of dates, this arg is a date, we'd better be treating it as a date. We can't give it a function that's designed to generate ideas for anything else, its gotta be happy with working on dates."
          },
          {
            "time": "[00:12:59]",
            "text": "The last thing to look at is the return type. So we can see that here, it's just a dictionary of T's. And similar to how in our tiny, tiny example, right, we had a return type that looked like this. And we can see that the type of what comes out of the function changes depending on what we pass in."
          },
          {
            "time": "[00:13:23]",
            "text": "Similarly down here, we're gonna get a different kind of dictionary out. So let's put all of this together and take a look at our original example. So all we've done is we've brought the algorithm back in, it's a very simple little looping process here. And let's look at our tool tips as we attempt to use this."
          },
          {
            "time": "[00:13:47]",
            "text": "So here we're getting a dictionary out and we're passing in just objects with a name property. And look at the dictionary we get out, it's got an index signature, where each value that's found in the dictionary, it's just an object with a name. Let's look at a different example, here's our phoneList, right, a array of customer ids and phone numbers."
          },
          {
            "time": "[00:14:16]",
            "text": "Well, you can see that the type has sort of adapted here. It's inferred what T should be, and it's gonna return the right kind of dictionary. So now, unlike our example where we used any, and where we lost all type information as we pass through this function, we tried to make it flexible enough that it would work for any list to dictionary transformation."
          },
          {
            "time": "[00:14:45]",
            "text": "Unlike the any based approach, we're actually maintaining all of our type information. It kind of passes straight through. So we can run this in the TypeScript playground and we can convince ourselves that it works. So up here, this is our first dictionary, that is this right here and then down here this is our second dictionary."
          },
          {
            "time": "[00:15:14]",
            "text": "What we're doing here, I'm just gonna look back at the function signature here. What we're doing here is we're saying on a per invocation basis, we will figure out what T is and for that invocation T serves as a way of defining a relationship between things. Meaning, the dictionary I will give you is related to the list you gave me."
          },
          {
            "time": "[00:15:42]",
            "text": "The callback you'd better give me must be related in terms of type to what's in your list. It serves as sort of a linkage between all of these things and it allows us to remain flexible without basically widening our type and making it so general, so nonspecific that we lose our safety."
          }
        ]
      },
      {
        "name": "22-dictionary-map-filter-reduce",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this is a little exercise. And our motivation is as follows. So we have a dictionary here. It's a bunch of a bunch of fruits. They have a color, and they have a mass in grams. We have an interface, the type parameters can be used with interfaces here."
          },
          {
            "time": "[00:00:24]",
            "text": "You see I'm saying it's a dictionary of type T. Well, what can I find in this dictionary? A bunch of Ts, right? So you can use this however you like. So what we want to do is create array.map array.filter and array.reduce, but for dictionaries. And below this, I have a test suite similar to what we saw for the JSON types exercise."
          },
          {
            "time": "[00:00:54]",
            "text": "So I'll give you, I'll say, two minutes, just to read through this. And then I would like your help in implementing this. But just look through the test cases so you can try to understand where we're going with this. So at the bottom of the starter code, of course, we have the usual Try button, when we click that, we should find ourselves on the TypeScript playground."
          },
          {
            "time": "[00:01:27]",
            "text": "And I would like you to click this Logs tab, and we can run the code. And right now, nothing is gonna be able to run cuz we haven't really defined these functions. But once we have something a bit more reasonable as our starting point, we should start to see some good feedback there."
          },
          {
            "time": "[00:01:47]",
            "text": "So, really, around these lines here, this is what we want to change. We don't wanna modify anything above or below this point, just these three functions here. And the way these are defined, they're the absolute most generalized functions that we could possibly have. Meaning they take any number of arguments, which could be anything, and they return anything."
          },
          {
            "time": "[00:02:14]",
            "text": "So, if it's our job to implement these, I think I'm just gonna pick one to start with. And filter seems like a good place to start. So I'm gonna begin with that one first. So this is going to need to have a type parameter, and we'll call it T."
          },
          {
            "time": "[00:02:36]",
            "text": "In fact, all of these will need at least a T, possibly a second parameter. And let's just think about these in terms of like what they take in as arguments and what they return. And we can worry about sort of filling in the algorithm once we have that pinned down."
          },
          {
            "time": "[00:02:52]",
            "text": "So filter, it's going to take in a dictionary, Of type T. And it's gonna return a dictionary of T, as well. It's just gonna have fewer properties on it. It's gonna be the subset of properties on the dictionary that meet some certain condition. And it's the caller's job to state what that condition is."
          },
          {
            "time": "[00:03:23]",
            "text": "And for now, we can just return an empty dictionary. And we'll also define the filter. Call it filterCb, for callback. This is going to take in an argument of type T and return a boolean. And we can move these onto multiple lines to make it really easy to see everything."
          },
          {
            "time": "[00:03:55]",
            "text": "So there's our first argument, there's our filterCb. Now we may need more callback arguments here, I know from using array filter, array reduce, sometimes you get the id here. Let's only worry about that if we absolutely need to. So that's filter. Map, so map is used to transform a collection of one thing to a collection of something else."
          },
          {
            "time": "[00:04:21]",
            "text": "And the transformation is defined by a mapping function. So we might need two type parameters here to represent the before and the after. So we could have T, and then let's say U.. U comes after T. So, like filter, we're going to take in as an argument, input, A dictionary of Ts, and what we're gonna return is a dictionary of Us."
          },
          {
            "time": "[00:04:56]",
            "text": "And our mapping callback is going to take as an argument, a T, and return a U. We'll start out by just returning an empty dictionary, which is technically the right type to return, it's just not a meaningful thing to return right now. Reduce is a little more tricky, let me just see if the test suite works without me defining the signature for reduce."
          },
          {
            "time": "[00:05:27]",
            "text": "Nope, we're gonna have to do reduce as well here, no problem. So the point of reduce is to iteratively, while processing a collection, build up and eventually return a singular value of some sort. And the iterative assembly of that value is to be defined by a reducer function."
          },
          {
            "time": "[00:05:53]",
            "text": "So, again, input, a dictionary of Ts, and then we have whatever value you're looking to arrive at, let's call it V, ffor value. So we're gonna actually return a V, not a dictionary. And we could have a reducer. And let's do a multiline, as we did before, Just to spread things out."
          },
          {
            "time": "[00:06:19]",
            "text": "So this is going to take a current value, which will be V, And then an item from the dictionary, which will be a T. And it'll return V, right? So sometimes reduce is great for a summation, where you have a running total, you add each item to the total, ultimately return the whole total."
          },
          {
            "time": "[00:06:46]",
            "text": "So this is gonna take our running total, the thing that we might factor into the total. And then here's the new total that would be returned by the reducer. We also have an initial value, which will be a V. We can get away with just returning the initial value right away here."
          },
          {
            "time": "[00:07:13]",
            "text": "Let's go back to filter and tackle this. So what we're gonna do is iterate over the dictionary, so we'll create a new dictionary that we aim to return. And then we'll iterate over the dictionary we're given, see which values pass the filter, and if they pass the filter, we'll add them to the new dictionary."
          },
          {
            "time": "[00:07:32]",
            "text": "So we end up returning the subset of properties that pass through the filter. So call this toReturn, eventually will return it. This will start out empty. Great, and we can take advantage of the for of loop. That's a really nice thing to use when iterating over an object like this."
          },
          {
            "time": "[00:08:14]",
            "text": "We can verify that this is the right thing to do. Let's see, input. Maybe it's the for in loop that I'm thinking of. Yep, it is. Yeah, for us is for an iterable. This is iterating over the properties of an object. So here we've got our input. Here we see that key is a string, that's a good signal that it's probably the dictionary key."
          },
          {
            "time": "[00:08:42]",
            "text": "Great, so we could say thisValue is the input dictionary, And retrieve an item by key if the filter callback passes when we give it this value. We're gonna add this to the dictionary. toReturn[key] = thisValue. Great, so that filter, that should work. Let's look at map. So I'm gonna start with the same code as we use for filter, cuz a lot's gonna be similar."
          },
          {
            "time": "[00:09:28]",
            "text": "The difference here is we have just a mapping callback that transforms from original dictionary to whatever, it transforms each item from A to B, whatever those things are. So the thing we'll eventually return, it's a dictionary of Us, not a dictionary of Ts. So we'll just make that little adjustment there."
          },
          {
            "time": "[00:09:49]",
            "text": "We're still gonna iterate over the input dictionary. We're still going to grab the value for each key. The difference here is we're always going to append things to the new dictionary. It's not a condition, it's a transformation. So we'll say toReturn. And then this is gonna be a map, mappingCb."
          },
          {
            "time": "[00:10:20]",
            "text": "So effectively here, for each, We're going to get value and then perform the transformation. I wanna look at my type errors here and see what's going on. So it looks like our map dictionary, one of our tests, it wants to be provided the name of the item, the key, rather, right?"
          },
          {
            "time": "[00:10:47]",
            "text": "So we can go back up top and make sure we accommodate that. So key is a string. And we'll just pass that along here. Great, no more errors. Seems like that was the only little extra feature of a callback we had to add. Let's run this code. Great, now we're starting to see some tests passing, and see where we're at."
          },
          {
            "time": "[00:11:14]",
            "text": "So we have a failed assertion here around reduce. Makes sense, we haven't really implemented reduce yet. But let's check out, so map, sorry, let me zoom in here, somehow I got scrolled, there we go. So we're passing all of our tests for map, we're passing all of our tests for filter."
          },
          {
            "time": "[00:11:36]",
            "text": "We're actually passing some tests for reduce already. We have only one test that hasn't passed yet. And that's because reduce is just first making sure that we return something, if it's a truthy thing. So this is the meaningful test that we still have to pass. So let's look at reduce."
          },
          {
            "time": "[00:11:57]",
            "text": "So we're gonna start out with an initial value. This is gonna be a let declaration, Because we'll keep writing over it with every loop over the array, or the dictionary, rather. So we'll first initialize the value with what we're given, we'll return it at the end. We're still going to loop, so I'm gonna borrow some of that code from filter."
          },
          {
            "time": "[00:12:25]",
            "text": "Just the for in loop. And this actually, while conceptually a bit abstract, it is implementation wise pretty simple. So the new value is reducer. And we'll pass in the last thing we had for the current value and the item. Let's try to run this and see where we're at."
          },
          {
            "time": "[00:13:05]",
            "text": "All right, looks like we passed all the tests. So we just wrote higher order functions for dictionaries using generic types. These will work for any dictionaries that you might have in your code base. And you'll preserve all of your type information as your collections pass through these functions."
          },
          {
            "time": "[00:13:29]",
            "text": "Hopefully this illustrates why type params and generics are an incredibly powerful tool. We get the ability to use these flexibly without giving up all of our type safety."
          }
        ]
      },
      {
        "name": "23-generics-scopes-restraints",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The last topic we're going to talk about in TypeScript Fundamentals V3 is generic scopes and constraints. So these are some final details I want to add to the concept of generics, so you can start to make use of them in practical applications. Scopes and constraints have to do with where you can use type parameters depending on where they're defined."
          },
          {
            "time": "[00:00:28]",
            "text": "And minimum requirements you can impose on type parameters such that you can consume them within your function. And that will make a little bit more sense what I mean by that as we get into that topic. So again, I want to begin with a motivating use case, why would we care about scopes and constraints?"
          },
          {
            "time": "[00:00:53]",
            "text": "What would be missing if we didn't have these things? So constraints allow us to describe a minimum requirement for a type param. And that is important in order to be able to use, for example, the things within this list beyond what we have seen so far. So we just dealt with this list to dict function while we were passed a callback that's used to generate IDs."
          },
          {
            "time": "[00:01:23]",
            "text": "But let's say we were building something out for a data layer, where every object that we're working with has a property on it called ID. Maybe it's coming from sequel database or something where there's just always this primary key. It's always going to be there, and we always want to use that as the mechanism for storing it in dictionary."
          },
          {
            "time": "[00:01:49]",
            "text": "Well, we don't need this callback anymore, but we do have to define this assumption about what the bare minimum requirement for the kinds of things we expect to be in this list. We need to define that somewhere. So let's dig into this. So the function signature we'd like to arrive at, we'd like to change from something like this to something that kind of looks like this, right?"
          },
          {
            "time": "[00:02:25]",
            "text": "So, previously, we kind of had a list of any's here or some other very specific type, but we need everything to at least be an object that has an ID on it. It's a minimum constraint that we need, why? Because as we store items in the dictionary, we're gonna reach into this item, and we're gonna retrieve a property off of it called ID."
          },
          {
            "time": "[00:02:51]",
            "text": "We didn't have this requirement with the first version of this algorithm. Right up here, we were given a function that we could use to get these IDs. Whoever was calling this function, it was their job to tell us what to do. We simply just said, you gave me a callback, I'm going to use this item with the callback."
          },
          {
            "time": "[00:03:10]",
            "text": "I have my ID, I don't need to know how this callback works, you handle that you provide it to me. Well, now we need to be able to reach into this, and grab an ID. So we need everything we receive to have an ID. Here's how this would work."
          },
          {
            "time": "[00:03:32]",
            "text": "This would be the naive approach that would fail, right? If we just tried to say, I have a type paramater T, I get a list of T's, effectively this thing becomes pretty pointless within the function. So if we look at this, so I've got my item here, I've got a T in this callback."
          },
          {
            "time": "[00:03:53]",
            "text": "If I try to get an autocomplete on this thing, there's nothing there for me to use. I cannot safely do anything here, why? Because T could be anything, it could be a list of nulls. I can't safely do anything because there's no minimum requirement for what kinds of Ts I'm willing to accept."
          },
          {
            "time": "[00:04:18]",
            "text": "So we need something better, we need something that allows us to always have that ID there. So what we need to do is describe this constraint. And I'm showing you kind of a one line diff version of the change that we need to make. Because it's useful to understand where the information moves as we start with the non-generic version of our function, and move to the generic version."
          },
          {
            "time": "[00:04:45]",
            "text": "This here, right, this is the minimum base class of minimum constraint we need this stuff to align with. It kind of moves into two places here, one like the array nature of this. We put that over here, but we've got this constraint on that type parameter now. And you might be wondering, are we using extends again, yet again, right, extends."
          },
          {
            "time": "[00:05:15]",
            "text": "What does this have to do with the extends that I already know about? Well, it's kind of related, at least conceptually, in that when you have a subclass that extends from a base class, you're kinda guaranteed to have all of that base class functionality. All of the class fields that were there, all of the methods, and you might have more."
          },
          {
            "time": "[00:05:36]",
            "text": "But at minimum, you are gonna have everything that can be expected of the base class. While here we're saying I can be given any T, but it has to at least meet this base requirement. That's the best I can do at helping you at unifying this concept of extends across everywhere it's used."
          },
          {
            "time": "[00:06:10]",
            "text": "So let's talk about scopes as they have to do with type parameters. In the world of variables, we know that inner scopes can see things that are available in outer scopes. For example in here, I am able to see bowl, and I'm able to see apple, I can see both, right?"
          },
          {
            "time": "[00:06:33]",
            "text": "You can you can see from the inside out, but not the outside in type parameters work a very similar way. So here we have a higher order function that's used to create a tuple. So you give it the first thing that goes into the tuple, and then you give it the last thing that you want to see in the tuple, just a tuple of size two, right?"
          },
          {
            "time": "[00:07:00]",
            "text": "So ultimately, what's gonna happen, if we look at the usage here, we've got a tupleCreator. And that returns a function, and then we finish the tuple by giving that an argument. So everything's gonna start with three, but then it'll finish with null or finish with this array of numbers."
          },
          {
            "time": "[00:07:22]",
            "text": "And I just wanna make it clear that here you can see we're allowed, just as in this case above where down here we can access both fruit and, sorry, both apple and bowl. Here, we can access both T and S because inner scopes can see outer scopes. Just be careful you don't make things too complicated with this."
          },
          {
            "time": "[00:07:46]",
            "text": "But a more pragmatic example might be you have a type parameter that's on a class. And then you have a method that has another type parameter of some sort. So finally, the last thing I want to leave you with here are some best practices around using generics. So first, make sure you remember that the point of these type parameters and of generic types is to relate multiple things, right?"
          },
          {
            "time": "[00:08:24]",
            "text": "In the case of our list to dictionary example, we're saying the list I'm given is related to the callback. They're of the same type, they both involve a T, right? And then I returned something that has a T in it, so they're all linked. If you're not using a type parameter more than once, you can end up casting inadvertently, basically, forcing TypeScript to regard something you have as a different type."
          },
          {
            "time": "[00:08:58]",
            "text": "So let's look at this, let's look at what's going on here. We've got a function here that says, return as string. Shouldn't be called returning a string, but return as something. So we give it an argument which isn't any and it returns a T. But look, we can give it a window, and we're gonna be forced to specify a type parameter explicitly here because nothing can be inferred here."
          },
          {
            "time": "[00:09:27]",
            "text": "We're not like accepting a T, we're just returning a T. But effectively, what ends up happening here is Windows passing straight through. But we've changed its type to a number, and this is should be obvious why this is dangerous, right? It's typecasting using a different mechanism. And typecasting is typically done with this as keyword where we're saying, look, just I know this is a window, but I want you to regard it as something else."
          },
          {
            "time": "[00:09:57]",
            "text": "So when doing a code review, you might be scanning through to see if someone's written as, but this is typecasting too. A single use of a type param, right, it's only used here. This will have the same effect, it's just a harder problem to catch in a code review."
          },
          {
            "time": "[00:10:17]",
            "text": "See two or more times, that's where you want to use type params. This here, we call this convenience casting, and if you're gonna cast, cast in a way, that is obvious for code reviewers. It may be what you want to do, but you want to have that discussion, and you want it to be clear that you're going to change the type of this thing."
          },
          {
            "time": "[00:10:47]",
            "text": "So you want to define your type parameters as simply as possible, and in a way that allows you to take advantage of all of the static analysis and the inference that TypeScript has to offer. So in this case, notice that, sorry, we have two options. We can either say T is a type, and that type extends from an array of HasIds, versus down here we could say T extends HasId."
          },
          {
            "time": "[00:11:29]",
            "text": "And the benefit here is basically your types are gonna get a lot dirtier, and depending see the tool tip here, it's sort of being inferred differently. I mean, it's kind of strange, right? The list is a T, T extends an array of HasIds, let's see what the return type is here."
          },
          {
            "time": "[00:11:54]",
            "text": "Look at that, look at what the return type is, it's a has ID or an undefined, whereas the return type here, it's a T or undefined. We've actually lost a type parameter here, isn't that interesting? And that's because when the return type is analyzed, we don't know what T is, right?"
          },
          {
            "time": "[00:12:14]",
            "text": "This is a list, all we know is it's at least a HasId, but the build time analysis can't figure out what the return type should be until it's actually called. And that is a problem that is why we have lost the T in the return type here. So you don't need to understand too much about why this is bad, but the best practice is to sort of push your type parameters down to the lowest level, the simplest way of describing them as you can."
          },
          {
            "time": "[00:12:50]",
            "text": "And then in your argument list, of course, you don't have to just take T straight up as an argument. You could take an array of Ts, a promise that resolves to a T, whatever you like. And there you can see the type checking will do its job more easily and more successfully."
          },
          {
            "time": "[00:13:07]",
            "text": "And then finally, the last thing I want to leave you with is don't make things generic unless there's real value in doing so premature abstraction is bad. It makes it hard for you to understand your own code, and for others to understand your code. So just make sure that you start out with simple things, and don't get into generic hell, where everything has 15 type params, and just becomes hard to even think about what's going on."
          },
          {
            "time": "[00:13:38]",
            "text": "These type parameters should have a purpose, you should have a small number of them, and just don't let the complexity get out of control."
          }
        ]
      },
      {
        "name": "24-wrapping-up",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Just to recap all the ground that we've covered today. We started with a little introduction to TypeScript, and compiled our first TypeScript programmer, saw the compiled result. We changed our module types. We changed our language level, we saw the difference in output. We talked about variables, values, objects, and arrays."
          },
          {
            "time": "[00:00:21]",
            "text": "A little bit about tuples, and we learned about type annotations, and index signatures, ways to define the types of collections of data. Then we moved on to talk a little bit about theory for type systems. Different ways of categorizing type systems, and a little bit of set theory to describe union and intersection types."
          },
          {
            "time": "[00:00:44]",
            "text": "We gave our types names, using interfaces and type aliases, and defined some recursive types that we can use for any JSON value. Then, after talking about functions and classes, my favorite part about functions is those multiple function heads. We talked about top and bottom types. These are those extreme types that can be anything at all or nothing."
          },
          {
            "time": "[00:01:12]",
            "text": "And within extreme types, we talked about that cool example for exhaustive conditionals, where you can make sure that you handle every possible scenario. And you kind of end up with no pieces of the pie leftover, absolutely every scenario handled. And you have compiled time enforcement of that, which makes it really easy as you introduce new possibilities into your code base, they're caught for you."
          },
          {
            "time": "[00:01:38]",
            "text": "We built some user defined type guards and learned assertion type guards, and conditional type guards. Talked a little bit about nullish values, talked about generics, built up a little standard library for working with dictionaries. And then finally, scopes and constraints for type parameters. That is a lot of ground to cover."
          },
          {
            "time": "[00:02:00]",
            "text": "And that will put you in a great position for taking intermediate TypeScript, where we're going to dig even deeper into these topics. And now that we've conquered generics, we're ready to go with some even cooler concepts. Thanks so much for coming today and hope you had a good time."
          },
          {
            "time": "[00:02:19]",
            "text": "I hope you enjoyed the course."
          },
          {
            "time": "[00:02:19]",
            "text": ">> So back to the user defined type course, do you remember that CarLike example?"
          },
          {
            "time": "[00:02:19]",
            "text": ">> The car, sorry, let me go back to that. Type guards, and you wanted CarLike, the assertion ones or the is one?"
          },
          {
            "time": "[00:02:19]",
            "text": ">> It doesn't matter, I was wondering is there some sort of a more deliberate wave."
          },
          {
            "time": "[00:02:48]",
            "text": "It's shaking for your object type, especially that something I believe you'll find that most. It's a chaser, right, you came across it more than you should."
          },
          {
            "time": "[00:02:48]",
            "text": ">> Yeah, so you're wondering are there, I think you're saying this seems like a very low-level API. Are there higher level more declarative ways to inspect an object to figure out what types are on it?"
          },
          {
            "time": "[00:03:17]",
            "text": ">> Yes, maybe some sort of a utility that's been around."
          },
          {
            "time": "[00:03:17]",
            "text": ">> There are those utilities, and they do exist. Here's the trick though. Type checking at runtime is not free. And especially, if you're running this code on a very hot path, like a performance sensitive path. You may not want to be doing too much with a mystery library that may be doing some heavy things."
          },
          {
            "time": "[00:03:45]",
            "text": "It's kind of tricky to solve in the general case, but they do exist. I'm just not prepared to endorse any particular one. Cuz I'm really looking for simple and performance for things like this."
          },
          {
            "time": "[00:03:45]",
            "text": ">> So what are your advice exactly when it comes to this? Cuz I see a lot of repetitions in place."
          },
          {
            "time": "[00:04:06]",
            "text": ">> Yes. So my advice-"
          },
          {
            "time": "[00:04:06]",
            "text": ">> [INAUDIBLE] Is start to define a couple of fives and add some assertions, and type guard too is gonna be like a massive chunk."
          },
          {
            "time": "[00:04:06]",
            "text": ">> It does get a bit messy. My advice if you're at all able to do this is to push this problem into your API layer, where effectively every one of your, We're talking about values discovered at runtime really, that's often where you're gonna be using type guards."
          },
          {
            "time": "[00:04:44]",
            "text": "That discriminated union thing where, I see that there's a property called kind, and I see that there's this label on it. Once you can do that and you can say, well, if I see this thing here, this c tag on it, I know that the whole thing, I know what it's gonna be."
          },
          {
            "time": "[00:05:02]",
            "text": "That's a powerful idea. GraphQL has some support around this as well, where based on the query you make and some things that you can do at build time. You can have some pretty strong guarantees given that it sort of one central definition of a type that ends up both in your client and server code."
          },
          {
            "time": "[00:05:21]",
            "text": "That's also common approach. So anything where you have a well structured convention, this kind of code ends up being a lot cleaner, in that you have a few type guards that are heavily reused. And they sort of end up being nested, right? You could have a type guard that's, is this a single record or a collection?"
          },
          {
            "time": "[00:05:41]",
            "text": "Once you figure that out, okay, well, what's the type of this item in the collection? And they sort of stack up in that way. Does that make sense?"
          },
          {
            "time": "[00:05:41]",
            "text": ">> Yeah, thank you."
          },
          {
            "time": "[00:05:41]",
            "text": ">> There is one more I wanna leave you with, it's my favorite type guard of all time."
          },
          {
            "time": "[00:06:02]",
            "text": "It's this one. This will be an intermediate course for sure. We don't have to make it the assert. So, now we're mixing two things, right? It's a type guard that is generic. So, in this case, what this lets us do let, Something like that. So you could say if (isdefined(x))."
          },
          {
            "time": "[00:07:01]",
            "text": "And you can see here, it's a number. So you can start to make these type guards, involve type params with these type guards. And effectively what we're doing is we're saying, we're peeling away the undefined. This is why I don't wanna use the definite assertion operator. It's because I can write this, and it's something that will actually do the checking for me."
          },
          {
            "time": "[00:07:23]",
            "text": "And then it'll let me throw a meaningful error instead of cannot find too fixed on undefined, some weird, just letting it explode wherever it's gonna explode. But kind of getting clever with these things is is often time well spent."
          }
        ]
      }
    ]
  }
]