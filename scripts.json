[
  {
    "courseName": "devtools",
    "sessions": [
      {
        "sessionTitle": "0-introduction.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hey everybody, welcome to this course, I'm really excited about it. This is my third time doing a DevTools course. But this is a brand new format, which I'm really excited about. The DevTools have added a lot of new cool things over the last year, which I'm excited about."
          },
          {
            "time": "[00:00:14]",
            "text": "And this one's gonna be a little bit differently paced in that we're going for a nice introduction to DevTools. So we'll kind of cover it later, but I'm hoping this course will be a really good tool for people whether you're absolutely brand new, been using them a little bit for a little while or are pretty comfortable and just looking for cool kind of tips and tricks and ways to be more productive."
          },
          {
            "time": "[00:00:35]",
            "text": "This whole course is one single repo that repo it's a link here for github.com./jkup/mastering-devtools. Or if you're not able to click on that, you can just go to github.com/jkup. Let me close this. And you'll see it's right on my home page, this masteringdevtools link. And it should be, I've tried to make it as easy as possible."
          },
          {
            "time": "[00:00:59]",
            "text": "So it's got instructions on it. You just clone the repo, CD into it, npm install and npm start. And the only requirement is Node, which comes with npm. So kinda the way that the course works is these pages which you can have locally if you have the repo, I'm just running the repo here so you can kind of see, I have mastering Chrome DevTools."
          },
          {
            "time": "[00:01:19]",
            "text": "I did my npm install. And now I can just do my npm start, and it'll load up the server. Then I go to localhost :3000, and this should be the exact same course that you all have. Just some important links to kind of refer back to. This is the course repository where this course is hosted."
          },
          {
            "time": "[00:01:34]",
            "text": "The official docs to Chrome DevTools are always a really good place they've been especially over the last couple years. They've put a lot of good content on there. They've got cool demos themselves. When they do updates, they mark them in there which is really good. And if anybody needs to get ahold of me, this is my Twitter handle, Jkup and my email address."
          },
          {
            "time": "[00:01:53]",
            "text": "And I love talking about DevTools and the course so please feel free to message me. That'd be kind of an interesting to start because I feel like DevTools are an interesting topic where I'm really passionate about them. I feel like a lot of people find a lot of value in them but they're a little bit of an interesting topic because you won't necessarily find them on the job application, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "It wouldn't be like needs Chrome DevTools experience. So I thought it'd be kind of cool to talk about why I think it's important to learn DevTools. I do think it's just a level up in general, like it's a really cool way to better understand code, better understand performance, all those things."
          },
          {
            "time": "[00:02:33]",
            "text": "It's a great tool for finding bugs quickly. I think that if you're somebody who's really comfortable with the stuff that we'll go over today, so like using the console using a step through debugger, using the audit tools, performance, all that, you'll be able to find bugs at work and fix them a lot faster."
          },
          {
            "time": "[00:02:50]",
            "text": "It's a really cool way to start your journey down web performance. This is not a web performance class, but it really touches on a lot of web performance topics. So it helps you learn network requests, CPU, memory, all these things. And if you are a web performance expert, you will come back to DevTools a lot and use them when you're auditing sites when you're finding bugs or issue."
          },
          {
            "time": "[00:03:12]",
            "text": "And then one of my favorite things about them is it's like when I got started doing web development, my favorite thing was to browse the web, find a really cool website and then learn how it worked. That was what I did when I was beginning. And I feel like the DevTools are a really incredible way to still do that."
          },
          {
            "time": "[00:03:30]",
            "text": "I'll visit a website, and it'll have a really cool animation, and I'll really wanna know how it works. And of course back in the day, it was probably just like a single HTML, a single CSS, and a single JavaScript file. So I could download the whole site and play with it."
          },
          {
            "time": "[00:03:44]",
            "text": "But these days sites are a lot more complicated but DevTools make the complicated site very easy to understand. Like how an animation happens, what CSS they're using for a cool piece that you see, or how they're getting things to load so quickly, all sorts of stuff like that."
          },
          {
            "time": "[00:03:58]",
            "text": "So I think they can be really fun for just playing, exploring, learning too. I also kind of wanted to make a note if you look around, there's all these great courses that exist all over the web, especially on front end masters. And a lot of them come down to this idea of creating, right?"
          },
          {
            "time": "[00:04:16]",
            "text": "There are about how to create react applications or how to create angular applications. But there's not a lot of courses out there that teach you what to do, congrats, you have an app and it's launched and you have users. What do you do now? And I find that a lot of people for their day-to-day job are in that situation where they're debugging things that the users find, or they're dealing with user complaints about speed or they're trying to make the site load faster, something like that."
          },
          {
            "time": "[00:04:42]",
            "text": "And so I think this is cool because it works across all platforms, whether you have an angular site, react site, a node site, a Java site, whatever, you can really learn a lot and get a lot of value out of the DevTools. Cool. So kind of a general high level course outline."
          },
          {
            "time": "[00:04:59]",
            "text": "So we'll start with a little bit of history on how DevTools came to be and kind of leading from where we started up to now. Then we'll do a walk through the panels. I kind of like it so we'll open the DevTools together. We'll click on each panel and we'll do not necessarily a high level, a medium level view of each panel, what it's good for, what we can use it for all these kind of different things like that."
          },
          {
            "time": "[00:05:20]",
            "text": "So we'll walk through those. And then I break the course into different sections. So we'll do a section on editing websites, one on debugging websites, one on network performance, one on CPU performance, one on memory performance. And then we'll wrap up with doing full audits. If you were coming into a brand new site, or you're looking at an old site with fresh eyes, how would we do a top down audit."
          },
          {
            "time": "[00:05:43]",
            "text": "A little bit about me. I'm John Kuperman, an engineer at Adobe and I work on the Creative Cloud. Before that I worked on the brave browser and I worked on twitter.com. I blog over at JohnKuperman.com and I really like teaching workshops on DevTools and accessibility."
          }
        ]
      },
      {
        "sessionTitle": "1-devtools-history.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this is the first section called the introduction. And what we're gonna learn in this is the history of the browser DevTools. We're gonna take a little bit of a walk down memory lane or maybe not for the younger folks watching, but what it was like interacting with the DOM in the early days."
          },
          {
            "time": "[00:00:16]",
            "text": "And then we're gonna kind of cover the groups that I think this course is really best to benefit. So again, this is an introduction course, so we assume very little knowledge of the DevTools. So if we start at the very beginning, the way to open the DevTools, you have kind of two options, keyboard shortcuts or using your mouse."
          },
          {
            "time": "[00:00:36]",
            "text": "And so you can right click on any website, and you can click Inspect, and it'll open this, typically, it starts as a bottom panel. You can also use keyboard shortcuts, I've got two of them here, so you can use Command+Option+C on your Mac, or Control+Option+C does the exact same thing, it opens the DevTools."
          },
          {
            "time": "[00:00:53]",
            "text": "So we get these open and we have this thing that we're looking at, typically, depending on the keyboard shortcut user on the elements tab. And one of the ways that I like to start this off is by having people just think for a second about, if you had to describe what are you seeing here, how would you describe that?"
          },
          {
            "time": "[00:01:10]",
            "text": "And it's interesting because I feel like a lot of people, and this is not a wrong answer, but a lot of people say, you're looking at HTML and CSS, right? I mean, that's kind of what you're looking at. But the reason that I think it's so interesting is cuz it's not necessarily true, right?"
          },
          {
            "time": "[00:01:24]",
            "text": "It is HTML and CSS for sure, I'm not gonna argue that, margin zero is CSS so that a body tag is HTML. But you're really looking at this fully parsed browser rendered DOM, right? If you think about looking at raw HTML, you would have a very hard time clicking on the body and learning that it had background color of this gray."
          },
          {
            "time": "[00:01:46]",
            "text": "Because you'd have to look at the body, then you'd have to search your code base for some CSS. And you'd have to look at see if there was any body tags and all that. So this is not source code, this is after the source code has been sent down, the browser has done all its work and we're gonna get into what that work is later, and this fully interactive DOM is what we get here."
          },
          {
            "time": "[00:02:05]",
            "text": "And that's an important distinction because, back in the day, we didn't have this cool fully interactive DOM, we literally did have just the HTML and CSS. And so, this screen still exists, if you right click on your browser, and instead of going to Inspect, you View Page Source."
          },
          {
            "time": "[00:02:22]",
            "text": "And so, if you view the page source, you actually get the text content that gets sent down with the page. So here's my CSS which is in line, and then here's my HTML down here. And so, this is interesting, you could still kind of poke around at it or you could copy it all and put it into an ID or something like that."
          },
          {
            "time": "[00:02:40]",
            "text": "But, one of the big things that used to be super painful back in the day, was like let's say that you wanna check something's value in JavaScript, right? That's something we all do, probably all the time, we're like, wait a minute, this link isn't working, what's the value of link right now or what is foo equal."
          },
          {
            "time": "[00:02:54]",
            "text": "So what we used to do back in the day was with a lot of stuff [LAUGH], and some people haven't even messed with alert before. So, if I right click and open up the DevTools, and I go to the Console tab, and I type alert, hi, this used to be the thing back in the day, and I hit Enter."
          },
          {
            "time": "[00:03:10]",
            "text": "You'll see you get this browser rendered thing at the top of your screen that says, hi. So this is pretty cool and at first it kinda looks like, okay, I get it, it's like Console log, but it comes on the top of the screen, that's fine. But alert has a lot of limitations, for an example, if you are to go back in the DevTools again, and go to console and you were try alert anything that's not a primitive, like let's say an object."
          },
          {
            "time": "[00:03:35]",
            "text": "So I do name, and we make this a little bigger, name, Jon, and I tried to alert that you'll see I don't get named Jon, I get this two string version of the object. So, it says alert Object Object. And so, the thing that we used to have to do back in the day if we wanted to read the values of an object, was we would put them in a loop, like a for loop."
          },
          {
            "time": "[00:03:56]",
            "text": "And then we would log out each key and value, and we'd alert each one of those. And so, then you'd reload the site and it would get like an alert, and you click OK, OK, OK, until the whole thing went through. And so, the DevTools offering this interactive DOM, this ability to console log complex statements and complex types, like objects and arrays, is a really gigantic improvement."
          },
          {
            "time": "[00:04:17]",
            "text": "So, yeah, back in the day we're working, we have view page source, we have alert, those are kind of our tools for debugging. And then this really cool tool comes out Hexie's Live Dom Viewer, so I'm gonna open this in another tab. So this was like, you can kind of see it's actually quite similar, in a sense to the DevTools."
          },
          {
            "time": "[00:04:35]",
            "text": "But this was this really great tool, we're able to do things, like make an h1 Hello world, and we're able to see not only the markup, but we're able to see what the DOM is, and we're able to see a preview of it, all in real time. It was like [LAUGH] this is really mind blowing tooI, I know it's something that we take for granted nowadays, but it was this great thing."
          },
          {
            "time": "[00:04:58]",
            "text": "So you could grab that view source, and you could put it in here, and then you could actually start looking at the DOM structure, what it looks like. All these different things you can mess with it and see updates in real time. So that was great, and then and this is like a very old school, this tool came out, Firefox Firebug."
          },
          {
            "time": "[00:05:14]",
            "text": "And it was the very first built in browser extension that was a DevTool. And one of the things I always like to point out is that, if you use your imagination a little bit, this thing that came out, whatever, 20 plus years ago or something like that. It doesn't look too different than what we have today, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "I mean, if you look at this, you've got your HTML structure over here and you've got the corresponding CSS over here. We've kind of moved things around and all that but, essentially, Firebug comes out and sets this gold standard for development experience. There's a ton of stuff I can't do, of course, cuz it's a long time ago, but this was a giant change in how people built and edited and debugged websites."
          },
          {
            "time": "[00:05:55]",
            "text": "And so, Firebug was this incredible tool, kind of first of its kind, and a few years ago back in 2016, they officially sunsetted it. A lot of the core got moved into Firefox itself, Firefox comes with its own DevTools now, but it was sort of this big moment for us."
          },
          {
            "time": "[00:06:11]",
            "text": "Where we had all of a sudden our efficiency sped up, like a hundredfold and we could debug complex things. And we could just do, all this stuff that we couldn't do before, that's a really cool tool. And I was very sad when it got sunset just cuz it's kind of the end of an era."
          }
        ]
      },
      {
        "sessionTitle": "10-quick-edits-solution.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So let's go through this exercise together, so the first two things we can do just via the elements tab. So the very first one, I'm gonna open up the DevTools, and use this selector to find the list that we're in and see that it is an unordered list and so you can just double click to edit it UL and then hit enter."
          },
          {
            "time": "[00:00:21]",
            "text": "That'll change it so you'll notice it goes from numbered to dots. The second one is interesting, it's probably the easy, there's a couple different ways you could actually do it. The easiest way probably would be to look for an event listener so if we again use this, select the link here, then go over to event listeners and we can see that there's two this one is this color scheme for my code."
          },
          {
            "time": "[00:00:45]",
            "text": "So that's not it this one's a click listener and so if we click on it, it'll take us to the sources and it'll actually take us to the actual function that's calling it. So the button in the block quote is kind of interesting. So if we remember from the specificity class, we would see that the element selectors, the weakest class, the next than ID, and then inline styles are the strongest, but the very, very strongest thing is an important tag."
          },
          {
            "time": "[00:01:18]",
            "text": "So it should be this yellow color the other way that we could do it though, because DevTools helps you cheat, which is awesome is we could just find the block quote in the DOM here. And then we could just go to the computed tab and then we can just see that yellow is the color that wins out here so we can actually see it before it's even rendered."
          },
          {
            "time": "[00:01:39]",
            "text": "So that's yellow and then for the last one, can you find out the border color, the one with this ID again, a couple different ways we could do it. You can always just scroll through them [LAUGH] and you can look for it that's no problem at all. You could also cheat a little bit by doing something like document get element by ID and then passing that ID in and this way we'll bring the element in here."
          },
          {
            "time": "[00:02:02]",
            "text": "And sort of like we covered before you can see right where my mouse is now that if I hover on it, it says it's down but we can also right click and we can scroll it into view. And we can see this is the card with that ID and it has a border of green."
          },
          {
            "time": "[00:02:17]",
            "text": "So any questions on this exercise? And then I had a couple questions that came in in between that I wanted to go through, but if anybody has anything on the this exercise itself, I'd love to hear. So the question was, how did we find the JavaScript for when you clicked this link up here?"
          },
          {
            "time": "[00:02:33]",
            "text": "How did we get there? So I open up DevTools and I'll go to the elements panel and I wanna be over here on the event listeners panel. And so what the event listeners will do is it'll show you any and all event listeners on the currently selected item over here."
          },
          {
            "time": "[00:02:50]",
            "text": "And so the easiest way to do it is to use the selector to get the link and now that the link is hovered we'll see that over here up here at the click listener. And this click listeners on the link, and it actually has the JavaScript file and the line number so if you click that, it'll take you into the sources right on that line."
          },
          {
            "time": "[00:03:09]",
            "text": "Again, a lot of these are easy with like the cleaner exercises like often you'll as your the code gets bigger and more complicated. It might be a little bit obscured away with like a helper function, but this is at least get you on the right track for finding it."
          },
          {
            "time": "[00:03:24]",
            "text": "And we work with debuggers later we'll see that finding the line can actually be super helpful once you set a breakpoint on it, which we'll do in another section. I had one really good question earlier too, which I wanted to answer, it's actually very similar to this one that we just covered."
          },
          {
            "time": "[00:03:40]",
            "text": "It was like the element breakpoints where you're resetting a break on over here. And the question was, okay, well, what if you're using some kind of framework like let's say you're using React, so won't be as simple as like, div enter text equals hello, could you do it that way?"
          },
          {
            "time": "[00:03:55]",
            "text": "The short answer is actually the same, which is you can set a breakpoint do the thing, yes, it will open a react function, but you can walk the call stack back to the your specific application code. And we'll do some really cool stuff with debuggers later but that's the short answer."
          },
          {
            "time": "[00:04:10]",
            "text": "The longer answer, though, is if you're using a framework and that framework has its own DevTools, which we'll cover at the end, that would probably be your best bet. So if you get the React DevTools, and then you look at the React elements panel, which would be a new DevTools over here, that can show you specifically why a component rendered, right?"
          },
          {
            "time": "[00:04:29]",
            "text": "So that would be like hey, this render because you clicked this thing like that, it'd be a lot more helpful but you can do it without the React DevTools. You'll just have to look at a big long call stack and you'll have to look at the file names and you have to walk back until it's not core react Jes dot j s anymore until it's your actual application."
          }
        ]
      },
      {
        "sessionTitle": "11-workspaces.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So now we're kinda moving into the sources tab. And the thing that I always like I have these two screenshots here, like when you really think about the sources tab, it's sort of like your customer, your ID built into the dev tools. So, here's like the exact same file open in my dev tools and then open in my ID, which I use VS code."
          },
          {
            "time": "[00:00:18]",
            "text": "So you have like the center panel, which has the code in it line numbers and everything. You got the left sidebar, which is like a tree that you can kinda walk just like this one here. And the difference is you got all these great debugging things on the right, which will play within the debugging section."
          },
          {
            "time": "[00:00:33]",
            "text": "But you can even hide those and then just deal with this so you can really just use it as your ID Which is what we're gonna do in the next exercise. It's got a lot of your favorite things in it like so for example, if I open up dev tools here, and I go to sources, and let me get rid of this little console Jordan, if anybody's wondering about this, you can go to the data dot here."
          },
          {
            "time": "[00:00:55]",
            "text": "And you can do show console door or you can use the Escape key. And that'll give you a console overlaid on any non console panel. So you can be on the elements with the console or the network with a console or sources with a console and then you can just XOR escape to hide it."
          },
          {
            "time": "[00:01:11]",
            "text": "That's really useful sometimes if you just wanna log something out and see it. So if I go here, you get a lot of the things that work in your current ID. So for example, if I do a command P which in VS code will open a fuzzy search on the files, I get the exact same fuzzy search here."
          },
          {
            "time": "[00:01:27]",
            "text": "I can bring up any file like that. A lot of the same shortcuts for commenting and all that stuff will work. So I'd really encourage you to when you're in sources just to try whatever feels natural and see if it just happens to work here. Cool. So yeah, it's like your full ID and we're gonna play with that a lot as we play with workspaces."
          },
          {
            "time": "[00:01:48]",
            "text": "So workspaces are super, super cool. They're what let you persist your changes to disk, but it wouldn't be super cool thing without some super serious limitations on it. So before we get too far excited with workspaces, let's talk about what it can and what it can't do. And so the limitation if you think about apps, and you think about kinda what we're doing here, if there is a one to one correspondence between what you kinda send down over the server and what you author on the server and what you author and what you view in the website."
          },
          {
            "time": "[00:02:24]",
            "text": "And what I mean by that is like If you make an index at HTML, then when I hit your website, the same index HTML that you hand wrote is gonna come to me, right like it's the same file just automatically transferred. If you write a node app, and you use a templating language like moustache and you hand write a moustache file, the templating language, we'll turn that into an index dot HTML and send it to me, right?"
          },
          {
            "time": "[00:02:48]",
            "text": "That's kinda how that's working. So in the first example, you write HTML, it sends HTML. There's a one to one example that'll work great with a workspace no problem. And the second example, we're using a templating language. That won't work with a workspace because if I update my index dot HTML on my laptop inside the workspace, your server doesn't really have a way of knowing which template file to update."
          },
          {
            "time": "[00:03:12]",
            "text": "It's it's that would be too complex. So in those situations, you can still persist your CSS and your JavaScript changes to disk. But you cannot persist your HTML changes to this because you're not actually writing HTML. And this is also sadly true. With tools like react where again, you're not writing the HTML, you're writing JSX and react is turning it into HTML."
          },
          {
            "time": "[00:03:37]",
            "text": "So, in the dev tools, you'll see index HTML. But there as you know, there really isn't an index dot HTML on the server. It's like an index.js or like 20 js file. So there is a limitation there. Sometimes it's confusing, but it's basically, like if the thing that's on my dev tool laptop is the exact same thing that is in my code, then it's easy to persist."
          },
          {
            "time": "[00:03:58]",
            "text": "If it's not, then it's not gonna persist. So oftentimes, the sad reality is with like the current tech stacks are very pill chain heavy. Like I'm sure a lot of you at work or like, you use react and you use bubble and use a templating engine and all these different things or use a CSS preprocessor."
          },
          {
            "time": "[00:04:17]",
            "text": "That will mean that the workspace idea won't work for you. But if you are working with vanilla CSS, or vanilla JavaScript, or vanilla HTML, then workspaces will be awesome. So does that make sense? I'm gonna pause if anybody has questions, and I know that's like a very good, kinda a confusing concept."
          },
          {
            "time": "[00:04:34]",
            "text": "So let me just pause for a sec if anybody has any questions on that."
          },
          {
            "time": "[00:04:34]",
            "text": ">> Yes, I have. Can we just save the changes and for example from the website google.com and save the changes and reload the page so we can just load the external JavaScript but with our changes?"
          },
          {
            "time": "[00:04:57]",
            "text": ">> Yeah, you can. That's a great question. So it's like, can we, instead of like saving to disk, let's say and updating actual source code, can we set it up so that we can persist changes through a refresh basically. And we will cover that in another section. The short answer is yes, there are still some limitations."
          },
          {
            "time": "[00:05:14]",
            "text": "Some things we can't save. But for the most part, yeah, you can set it up so that like you can change the JavaScript and it'll survive a refresh, but it won't actually write to your local, the code bases file system. But yeah, we will be able to do that."
          },
          {
            "time": "[00:05:28]",
            "text": "And that's not using workspaces that's just built in with the dev tools networking tool, but we can do it there, which is cool."
          }
        ]
      },
      {
        "sessionTitle": "12-workspaces-exercise.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're gonna move right into another exercise. This one's on workspaces. Again, we'll take like 15 minutes to work on it or, but I'll be here for any questions that people have. So, the idea here, there's full instructions. So you'll want and let me go through the instructions live and then you all can try it."
          },
          {
            "time": "[00:00:20]",
            "text": "So the idea here is I'm gonna go to my node app, which is running this local thing. I'm going to kill it for now. And then what we have let me open my finder to my Dev Tools repo. So we have this workspace folder here, and this just very simply has an HTML, JavaScript and CSS file."
          },
          {
            "time": "[00:00:39]",
            "text": "And so we want to do two things. One, I wanna open the index.html file with Google Chrome. So I right clicked on it and clicked open. And that you can see it's opening like a file, not a HTTP. So it's opening this file and it should look like this, this little to do list."
          },
          {
            "time": "[00:00:55]",
            "text": "And then the second thing we'll wanna do is we'll want to open up the Dev tools, inspect here, go to sources. And again, these are all written down step by step here. So we want to go to source and then I'll go back to my finder my file system."
          },
          {
            "time": "[00:01:09]",
            "text": "I'll grab this whole workspace folder here. And I'm just gonna drag it on to the sources, and it should change into this thing. And so the two things we're doing are one, we're opening the index file in Chrome, and then we're dragging our source code for it onto the sources tab."
          },
          {
            "time": "[00:01:25]",
            "text": "And that should prompt this little warning up at the top saying hey, Dev Tools wants to access your local file system. Is that what you really want? And we'll say yes allow. And when those steps are done, you should see that the workspace is synced by over here in the left, you should see these little green icons next to each one."
          },
          {
            "time": "[00:01:43]",
            "text": "So again, so kill the current node app. Go to your sources panel, go to your Windows Explorer or your finder if you're on Mac and get the project and open its index.html and then go back a level and grab the whole workspace folder and drag it into the sources panel here should prompt you with this."
          },
          {
            "time": "[00:02:02]",
            "text": "Do you want to allow you say yes and then you should see these things all green. And if you have any questions, let me know when it is set up. I have a couple of little things these little To Do List tasks that you can do and what you should be able to see."
          },
          {
            "time": "[00:02:16]",
            "text": "For example, if I go into my style.CSS, and at the same time I go into my Real ID, and I open my workspace style.CSS. So these are the same file wrapper you can see, I should be able to make a change here, like height 100 pixels and then hit Command S to save or Ctrl S and then go back here and actually see the real file has changed on my file system."
          },
          {
            "time": "[00:02:40]",
            "text": "That's what we're going for there. So again, the setup is kind of the part that I really want you to get the experience with. So, yeah, opening that new file, then taking the folder and dragging it into the Sources tab, and if you want to play around with the exercises, awesome, but the setup and getting it to actually persist is the big thing."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Can we save the changes in Sources panel html.css.javascript? Sometimes it doesn't work."
          },
          {
            "time": "[00:03:00]",
            "text": ">> Yeah, so if it's sinking, like if it's green, and it says that it's linked, then it should absolutely work. But yes, sometimes they can get into, I've seen him get into a weird state before I used to be a lot more problematic."
          },
          {
            "time": "[00:03:23]",
            "text": "So, if you run into any problems, what I would do is I would on the left here, go to the File System tab. Then I would right click on the folder and remove it from the workspace entirely. Say Yes, I'd like to get rid of it and then I would just start over again just take the thing and drag it back in here, click Allow over here and it should go all all green like that."
          },
          {
            "time": "[00:03:44]",
            "text": "So you can see here I got into a weird state because I had an existing at it. Saved when I deleted it and grabbed it all over again. And so again, like I would just go in here, remove it. Okay close this out so it's not still with active changes, drag it back in here."
          },
          {
            "time": "[00:04:04]",
            "text": "Allow, and now they're all green again so if they're green they're persisting."
          }
        ]
      },
      {
        "sessionTitle": "13-workspaces-solution.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We had a couple of really good questions and comments. Important one was that, folks are finding, they open the dev tools. So I'm on my Mac and the the workspace is actually on my Mac. And so, when I do things if I do body back ground blue, or something like that, it live reloads in real time."
          },
          {
            "time": "[00:00:20]",
            "text": "But a couple of folks were doing things either via remote workspace or via windows subsystem Linux, and they're finding that the changes, they do persist. So if you go and you type stuff and you hit save, and then you look in your editor, it'll be there. But the live reloading won't happen over and WSL."
          },
          {
            "time": "[00:00:36]",
            "text": "Let me go through the kind of solving these and then we'll do pause for any questions that anybody had going through it. So yeah, so I kind of got everything all set up and got my green dots here. And then so the first thing was centering the page title."
          },
          {
            "time": "[00:00:51]",
            "text": "So I'll go and grab that and the elements over here. I can either do it there, or I can go into sources, the CSS, and I can do something like I'll add a new selector for h1s. And I'll do text align center. So I'll do that. Change the background color so I can kind of go into elements and grab the body."
          },
          {
            "time": "[00:01:14]",
            "text": "Maybe add a new selector or something like that, background color 333. That looks real bad, eee looks better. And then the last thing was some JavaScript. So what I was hoping was you would type in a new item, and you'd hit Enter, and it should add it to the list."
          },
          {
            "time": "[00:01:34]",
            "text": "So if we type in a new item, we hit Enter, nothing happens. We go to the console, and it's logging it, but nothing's happening. So we can go into the sources tab and we can look at the JavaScript and we can see, it's grabbing the form field, it's grabbing the list of items."
          },
          {
            "time": "[00:01:50]",
            "text": "It's pre-populating with these three items, and it calls this render function which will set the, HTML the list to empty. Then we'll go through each one of these items and it will create a new item and set the inner text to or create a new list item and set the inner text to the item."
          },
          {
            "time": "[00:02:11]",
            "text": "And so what we really want to do is when on the form when you add an event listener and you type something in, we check the key to see if the key is entered, which I already have in here. And we are logging the form value but we really wanna do is we wanna just push that form value on to the list of items here."
          },
          {
            "time": "[00:02:29]",
            "text": "And so we should be able to do something just like items, push and save that. And now when we come here and we hit Enter, I'm gonna close these, you can see you know, hello, something like that. It will add the item. So yeah, again not super important getting these things right but more important getting the workspace set up and actually playing around with the elements panel seeing what works, what doesn't."
          },
          {
            "time": "[00:02:50]",
            "text": "Playing around with the sources and then seeing that it actually updates your if I do workspace index or main.js. We can see my new items push code has made it to my file system. So that is workspaces. Again, the kind of TLDR there is it won't work for a lot of situations."
          },
          {
            "time": "[00:03:08]",
            "text": "But if you are in a situation where it'll work, it can be a really nice way of editing things really quickly and seeing the changes right there."
          }
        ]
      },
      {
        "sessionTitle": "14-step-through-debugging.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we've kind of made it through the editing section, so we've learned how to do quick edits, we've learned how to do sources, and we've learned how to do workspaces. And now we're gonna move into the debugging section in the workshop. And so, this one will be different where we won't be altering any HTML or CSS."
          },
          {
            "time": "[00:00:17]",
            "text": "We will be altering some JavaScript but more importantly, we're gonna be looking at broken things and trying to get a better idea of why they're broken or how they're broken. So, one concept that's great is step through debugging, and I find the room is usually kind of split on this."
          },
          {
            "time": "[00:00:33]",
            "text": "Where some people are super familiar with it, and maybe they've even done it before or at least they understand the idea. And other people, especially people who haven't programmed in other languages aren't really sure what it is. And so the idea is that a step through debugger, so when you put a console log in your code, which is how a lot of people debug JavaScript."
          },
          {
            "time": "[00:00:53]",
            "text": "The code will run and then it'll hit the console log, log it out, and then it'll keep running the application state. So a contrived example of where that has shortcomings would be, you console log the link that you're about to do an API call to and it's wrong."
          },
          {
            "time": "[00:01:09]",
            "text": "And then you're like well wait, what set it to the wrong thing, but it's too late, the application states already finished. Then you'd have to refresh the whole thing or work through the whole workflow again, in order to get back into that application state. And the contrived example of a link being set wrong might not be great, but if you can imagine an app with a really big workflow."
          },
          {
            "time": "[00:01:26]",
            "text": "Like you have to go to the site, you log in, you add something to your shopping cart, you go to the coupon page, you enter the coupon, that's where the bug is. So if you console log something, and then you get the wrong value or not value we're expecting, now you have to go manually through that whole step again to get it."
          },
          {
            "time": "[00:01:43]",
            "text": "That differs a lot from step through debugger, so a debugger statement unlike a console log, will actually completely pause the application execution, it will not go forward until you tell it to. And so, that can be a lot more powerful because instead of just getting your console log right, you can pause and you can spend as long as you need."
          },
          {
            "time": "[00:02:03]",
            "text": "Looking around, changing things, walking back, walking forward, again, you can really just pause the whole app and look around. So, I guess the way I usually think about it is like, console log is great for a lot of tasks, like straightforward tasks, like if you're just like, what's the value of my post ID or something like that."
          },
          {
            "time": "[00:02:20]",
            "text": "There's no need to use a debugger for that, you can easily just console log it, but when something's really wrong and you wanna take your time and really explore it. Or when you've console logged three times and you keep getting the wrong thing, there might be a really good time to use a debugger instead and actually poke around, cool."
          },
          {
            "time": "[00:02:39]",
            "text": "So, this lesson is pretty short, but it's a little bit heavy, so I'll kinda go through it and then we'll take as long as we need for any questions before we go into the exercise. And feel free to have me go back through things, anything that's helpful. So, I'll go ahead and I'll right click, and I'll click Inspect, and we're gonna be in the Sources tab this time."
          },
          {
            "time": "[00:02:58]",
            "text": "So let me close all of these, so if I first go to Console before we get to Sources, we can see I have this function just for demonstration purposes that's just logging in the background, it's just an interval, and it's just logging things out. And so, if we click over here, we can go to this Debugging js file, and we can see I tried to make the whole workshop not very js heavy."
          },
          {
            "time": "[00:03:18]",
            "text": "So the basic idea is a set interval which we'll get called regularly, getting called every ten seconds. And it does this code where it's just got a couple things, so it calls function1. Function1 is here, function1 sets a constant then calls function2, there's an if else, then it calls either function3 or function4, that's like the whole thing, again, the JavaScript is not very important."
          },
          {
            "time": "[00:03:38]",
            "text": "So if I wanna figure out what's going on, let's say, I wanted to see if function3 gets called or function4 gets called, I'm not sure. I can start at the very beginning and you can really go anywhere you want. And if you hover over these numbers here, you'll see a little gray bar up here, and if you click on one, it'll turn blue, and that means a breakpoint is set."
          },
          {
            "time": "[00:03:55]",
            "text": "At the same time, you can see over here on the right sidebar, it keeps a list of all the breakpoints that you have currently, and you can see when is set. So the ten seconds have gone by, so the function gets called, and here we pause. So you can prove it's paused in a lot of different ways but, for an example, you won't see any more console logs here, because it's not getting called over, and over again, anymore, it's been fully paused."
          },
          {
            "time": "[00:04:16]",
            "text": "And if you had a more robust website with application state doing things, you would notice it was paused as well. So when something is paused, we use the left sidebar we're using for Workspaces, now we can kind of move that away cuz it's not super important. And then the center panel with our source code, we usually use that to set one or multiple breakpoints."
          },
          {
            "time": "[00:04:36]",
            "text": "But when those are set, then it becomes less important and the right sidebar becomes the important thing that we're looking at. So let me minimize all these and we can kind of go through because they're all very different, and we'll actually go bottom up. So, all the ones here are just different break points, right?"
          },
          {
            "time": "[00:04:53]",
            "text": "So we learn how to do a DOM Breakpoint, in one of the earlier lessons, that was when you right click on an element in the elements path panel. So if we were to go here, right click on body, Break on, subtree modification. Now we're to come back to Sources, we would see that there's now a DOM Breakpoint in here."
          },
          {
            "time": "[00:05:10]",
            "text": "So this is just keeping a list, cuz if you're debugging something really hairy, eventually you'll probably have breakpoints all over the place, and it's kinda nice to be able to have a central place for it. So I'm gonna go back to elements, and I'm just gonna remove this breakpoint, cuz we're not using it."
          },
          {
            "time": "[00:05:23]",
            "text": "Back to sources, XHR Breakpoints are really interesting, we can cover those in a bit. But the basic idea with XHR Breakpoints is that if you have an app, this used to happen to me all the time at Twitter, so we have twitter.com, and it's doing constant API calls, right?"
          },
          {
            "time": "[00:05:41]",
            "text": "It's getting your timeline, and it's getting your friends, and it's getting your following list, and who to follow, it's all these different things. And all have that would be wrapped in a single function, right? Like a helper function like fetch or Twitter API or something like that. And so, there'd be a problem with one of them that I really wanted to debug."
          },
          {
            "time": "[00:05:58]",
            "text": "But when I put a breakpoint in the helper function, as you can imagine, it would pause every single time, and so I'd be clicking play, waiting for my one to come. So what you can do is these XHR Breakpoints, you can click plus here, and it's really nice."
          },
          {
            "time": "[00:06:11]",
            "text": "It says break only when the URL contains, and so you could do tweets or something like that or at Adobe, you could call it, do something that's only the Photoshop service or something like that. And then the helper function you don't need a manual breakpoint in, it'll actually tell you when an XHR or a fetch request happens with that in the URL."
          },
          {
            "time": "[00:06:30]",
            "text": "That can be really helpful, again, it's very powerful but only in niche situations, right? If you have too many function or too many network calls, and you really wanna breakpoint on only one of them, you can use those. But for mostly today, let me pause this, for most today we're just gonna be in the regular breakpoints, and this will be a list of things where you have actually clicked."
          },
          {
            "time": "[00:06:51]",
            "text": "So if I go through and I click a bunch of stuff, you can see this list is populating. Go back down to just zero here, cool, then we'll see Scope here, so this is really nice. So, if you've done any of the great front end masters courses on advanced JavaScript or anything like that, you know there's a lot of talk about scope and how JavaScript variables are scoped."
          },
          {
            "time": "[00:07:16]",
            "text": "Var versus con scoping and this scoping, and all this different stuff like that. This can be a really nice way to see what this is set to, currently undefined, and what scope you're in for the different functions, like what's in scope. So you have the local scope, which is the set interval, and in it, you have access to four top level things, function1, function2, functions3, function4, and this is undefined."
          },
          {
            "time": "[00:07:38]",
            "text": "Then you have the Global scope, right? And that's gonna be the window in this sense, again, not a JavaScript class, but it could be really cool to go back and rewatch one of Kyle Simpson's JavaScript classes. And while he's doing the examples, open up this sources panel with your own example and actually be able to just see everything that you have access to in your Local and your Global scope."
          },
          {
            "time": "[00:07:57]",
            "text": "So this will just be all the stuff that's on the window object, right? So we'll go ahead and close that, close that, and close that. Now the Call Stack, right now you can see the Call Stack is one line item long. Because this is in the global scope, there's a single anonymous function, which is this anonymous function right here, which is this one, and that's the whole call stack."
          },
          {
            "time": "[00:08:18]",
            "text": "But as we go further stepping in, it can be really good as the Call Stack expands to see, watch it expand basically. And this kind of ties in earlier a lot of people were talking about how real world apps often use frameworks, they often use helper functions. And so, putting a simple debugger or an HTML DOM Breakpoint, might not get you exactly where you need to be."
          },
          {
            "time": "[00:08:40]",
            "text": "Because that event listener that DOM breakpoint it's being done by a helper function or it's being done by reactor angular. And so, this Call Stack is really great because while it will start with angular react, something like that. It will end up being really long and you can back trace all the way through until you see a file name that you recognize, right?"
          },
          {
            "time": "[00:08:57]",
            "text": "So, often it'll look like react.js, and then eventually it'll be my helper component.js, and then eventually it'll be current debugging view.js. I'm like, that's the one, so you can click on that. You can also do a really cool thing with these, when you're using frameworks and things like that."
          },
          {
            "time": "[00:09:15]",
            "text": "Which is you can find any script that's like a third party library, and you can right click on it, and you can click Blackbox script. And what that'll mean is your basically, I don't wanna see that in my call stacks anymore, and I don't wanna see it on my breakpoints anymore."
          },
          {
            "time": "[00:09:30]",
            "text": "So, I really recommend that if you're, again, if you're using one of these UI libraries, react or view or something like that, and you know the bug is not in the react library itself. So you don't wanna see 30 call stacks of react for your two call stacks of your application."
          },
          {
            "time": "[00:09:43]",
            "text": "You can right click on react.js and blackbox it, and then it won't show up here anymore. And then Watch is really cool, basically, you can add watch expressions at any time and we'll do this in a minute to keep an eye on any variable as things move through."
          },
          {
            "time": "[00:09:58]",
            "text": "So the equivalent of like, let's do this as an example, so the equivalent of going into our code here. So if we go into debugging.js, and what we wanna do is we wanna, what we used to do would be we would console.log(foo), right? That is a common thing we would do, obviously, it is just set to a string here."
          },
          {
            "time": "[00:10:19]",
            "text": "And then you would, let us say, you would hit play on it or remove this breakpoint, you would see when it gets called for the first time, it will set foo and then it will console log it, right? That is like a stuff that we do pretty often."
          },
          {
            "time": "[00:10:30]",
            "text": "So here it goes, it logs foo and then a log some other thing. So the equivalent in a breakpoint would be to go ahead and delete this console log and save it again. And then put a breakpoint in here, the same line where we added the console log, and then add a watch expression for foo."
          },
          {
            "time": "[00:10:45]",
            "text": "And so now it'll wait until it hits the breakpoint at which point, so we hit the breakpoint at which point, the watch expression fool is here, those are equivalent things basically. So you can see, this is like a lot more setup work than console logging. So, only use it when you have a need to use it, but it's also a lot more robust."
          },
          {
            "time": "[00:11:02]",
            "text": "So if I go ahead and remove this breakpoint set one back at the beginning, and hit play again, it'll go through and it'll stop here. And so, all of that has just been like what the UI is, so now let's get into what step through debugging means. And step through debugging has to do with these buttons over here."
          },
          {
            "time": "[00:11:21]",
            "text": "And so, basically, when you get caught in a breakpoint, and you can always tell up here there's this little thing that says we're paused in the debugger, you have a few options, right? One button is to be like, I don't care about that resumed script execution. So, if I hit this, it would go away it would finish cuz I have no other break points."
          },
          {
            "time": "[00:11:36]",
            "text": "And then nine seconds later when it triggered again, it would just break here, again, and I could keep hitting play every ten seconds. Some other options that you can step over to the next function call, so if you're on one, you can step over two or you can step into the current one."
          },
          {
            "time": "[00:11:51]",
            "text": "So, say I had function1 and function2 and I stopped at function1, step over would send me to function2 and highlight it. Step into actually take me as we can see here, into the guts of function1, so now we've stepped into this function. And so, you can basically walk down or walk back out, any application."
          },
          {
            "time": "[00:12:12]",
            "text": "Again, there's something to keep in mind because of how this works. So if you think about the JavaScript execution stack, and it's going line by line, it's executing things. You can always step over something, you can always step into something. But when you step back out, it can't time travel, it doesn't go back in time, it steps out and goes to the next line."
          },
          {
            "time": "[00:12:31]",
            "text": "So, if you're here on function1 and I step out, it will not take me back to function1, again, cuz it can't go backwards in time, it'll take me to the end of the function. And then if I hit play, I have to wait for another function when we get called."
          },
          {
            "time": "[00:12:43]",
            "text": "Just gonna pause for a second, if I can make that more clear, if anybody has any questions, I'd love to answer those now. Just on execution being paused and the choices that you have to step over into out of or play on. Yeah, the question was I still don't understand what's going on with watch."
          },
          {
            "time": "[00:13:01]",
            "text": "And so, watch lets you put any expression in here, so you can put a variable name or a function name or anything like that, and as it gets paused, you can see what it's set to. So let me make an example, let me deselect this and play on just, we get back to the screen and we go into the code here."
          },
          {
            "time": "[00:13:18]",
            "text": "So inside function1, we set foo to foo, right? And then we call function2 and we pass foo into it, and then we check if foo is foo, which it will be and we call function3. So let's take function3, we'll pass foo into it, and then we'll receive foo here, and then we'll do foo equals bar, and we'll set that here."
          },
          {
            "time": "[00:13:39]",
            "text": "Does that make sense to kind of the JavaScript level? So, we set a variable to something and pass it in, pass it in again, and now we change what the variable is set to. Does that make sense? Okay, so we'll save that and we'll restart, and we'll put our breakpoint back here."
          },
          {
            "time": "[00:13:56]",
            "text": "And we'll give it a couple seconds till it gets caught in the breakpoint. Okay, great. So as of this point, we have foo in our watch expression and it has not been defined, so it's unavailable, it would be undefined if you were to console log it. But we'll step into function1, and you see that on this line it hasn't executed yet."
          },
          {
            "time": "[00:14:18]",
            "text": "So as we know from JavaScript hoisting, the declaration has been hoisted but the evaluation hasn't happened, so it says foo is undefined. Into the next line function2, at this point foo has been defined, so now it's set to foo. So it's basically, it's like anytime the variable changes, the watcher updates here."
          },
          {
            "time": "[00:14:36]",
            "text": "So if we step into function2, we can see that foo is still foo, and then we step in, we can see that we get into this call a function3. Where we pass it in, step in again, and we can see again this line 18 hasn't executed yet. So as of this time, foo is still foo, but when we step into the very next line, now foo has been changed to bar."
          },
          {
            "time": "[00:14:55]",
            "text": "So the watcher is like anytime this variable updates, let me know, and that's really important because if we didn't pass it in, then foo would go back to undefined, because it wouldn't be in that scope. But it's basically, the watchers are the same, the watcher is basically the equivalent of wherever we currently are in, we have the blue line is of doing a console log of whatever you put in the watcher at that line."
          },
          {
            "time": "[00:15:20]",
            "text": "That's like the same thing, it's just the way of logging out values. Cool, and so, again, so the kind of thing to do when you're debugging code would be to figure out where the problem is. That's always the first thing that you wanna do, like what function has the problem or whatever."
          },
          {
            "time": "[00:15:37]",
            "text": "So if you're getting something like foo.bar is undefined, you're like, okay, and maybe you would see that in your console, you'd see foo.bar is undefined. And you'd click on the file name over here, and it would take you into the Sources tab where you're calling foo.bar. And then you can put a breakpoint on it, or you can put a breakpoint right after it."
          },
          {
            "time": "[00:15:53]",
            "text": "And you could watch all the foo and see what properties foo does have, does it have a bar? No, does it have a bar, maybe does have that those kinda things. So you can really take as long as you need paused in this execution state, and kinda when you're done, you can hit play and it'll play it through."
          }
        ]
      },
      {
        "sessionTitle": "15-step-through-debugging-exercise.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let me walk through the exercise itself. So there's an unordered list here on this exercise debugging called ui id catfacts. So if we inspect the DOM and we go to elements and we go inside the article inside div. We can see here this URL of ID of catfacts."
          },
          {
            "time": "[00:00:21]",
            "text": "And what's supposed to be happening, we have this file public exercises debugging.js in our repo exercises debugging. So here it is. So it's supposed to be happening is it's fetching this API of catfacts. It's calling to JSON on, then it's taking the results. It's going through each of them."
          },
          {
            "time": "[00:00:43]",
            "text": "And it's making a new list item and appending it, but something's wrong. So what we're supposed to be seeing here under here is a list of facts about cats is a list of facts about cats. But something's going wrong with it. And so the idea is to start with the console, see if there's any errors and then from there, put a step through debugger and and figure out what's going wrong and and how to fix it."
          },
          {
            "time": "[00:01:05]",
            "text": "And so that's the exercise. Before we get started do we have any other questions on it? And again, we'll meet back afterwards and we'll go through the whole thing together. So the question is, you use the debugger and you end up with a lot of breakpoints, how can you get rid of a bunch of them, I don't know off the top of my head."
          },
          {
            "time": "[00:01:22]",
            "text": "So let me let me get in this console log here and see if I can find it. So let us see we have a bunch of them. So it is so you have them all in multiple files, everything like that. So you can't do it from here. You can come over to the sidebar with the break points over here."
          },
          {
            "time": "[00:01:36]",
            "text": "Then you can right click on one and remove all breakpoints, and that'll get rid of all of them from all the files and then you just hit play one more time and it'll play through with no more breakpoints."
          }
        ]
      },
      {
        "sessionTitle": "16-step-through-debugging-solution-and-q-a.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so we got some really good questions during the exercise. So I think I'm going to solve the exercise with everybody together and then I've got I think three that I saw and then if anybody else has any will go through those two. So yeah, so for the step 3 debugging Like usually when you have error, the console is always like a good place to start, like usually anything that throws will end up in the console."
          },
          {
            "time": "[00:00:28]",
            "text": "So the first thing I see is like this type error. So the console is a nice way to get to the sources tab as opposed to looking through the file yourself. So I'll go ahead and click on it and it'll take me over here and this specific error was documented, that new element is not a function."
          },
          {
            "time": "[00:00:44]",
            "text": "So if I go to my sources over here. Then maybe do like a Google search or something like document new element. I can see that the actual API is create element, not new element. So we can go ahead in our ID. We can go ahead and change that to create element."
          },
          {
            "time": "[00:01:04]",
            "text": "Then I'll hit save, and then I'll refresh. So now there's no more console error and I saw some folks kind of getting to here. It's like, okay, it's not a JavaScript error, but why is it rendering like this giant list of undefined. So we go back into our sources and we can just do something set a breakpoint."
          },
          {
            "time": "[00:01:23]",
            "text": "And so I'll set a breakpoint and then I'll refresh the page. So we hit this break point, it stopped here, I can use the watch over here. So for example, I can watch on li, and I can see that it is in fact, a list item. So that I mean that looks good."
          },
          {
            "time": "[00:01:38]",
            "text": "And then I can add another watch item and I can make it item. And so I can see as an object with a bunch of stuff. So what it looks like we're doing is we're setting li.innertext to item.fact. And we can see if we hover over the fact is set to undefined whereas item is set to an object."
          },
          {
            "time": "[00:01:57]",
            "text": "So I can go ahead and I can browse in here, trying to see what's going on here. I can see that there isn't a fact property, but there is a text property. So I can go back to my code here and change it from item fact to item text and hit save again."
          },
          {
            "time": "[00:02:14]",
            "text": "I'll remove this break point for now and refresh. And now we've got all these facts about cats, which I'll try very hard not to read and in fact move on with the rest of the content but a couple of things here. There's a couple different ways you could solve it."
          },
          {
            "time": "[00:02:30]",
            "text": "Again, I'm kind of just trying to highlight like, I think normally what I would have done was console logged item here, but it is kind of nice to combine like the debugger was like actually like take that second to breathe and look around at the function. Look around with the object, see what you have access to, what you don't."
          },
          {
            "time": "[00:02:46]",
            "text": "It's kind of a nice way to do it. We got a couple questions that were really good. So one question was about what you put in watchers. And it was like, do you have to specify what you put in the watch? Or can you just watch everything? So the answer is that you do have to specify what you put in the watch."
          },
          {
            "time": "[00:03:03]",
            "text": "You can't put like a wild card in. But if I go ahead and I refresh here, or maybe make a breakpoint here and play to it, I can close what's in my watchers and I can look at my scope. And so if you come down here into scope and you'll get local scope, you can see everything that you do have access to in this function."
          },
          {
            "time": "[00:03:21]",
            "text": "You can also see everything you have access to in the global function. So if you wanna browse what you have access to scope is the place to do that. If you want to keep an eye on a very specific one watch is the place to do that. We had another question was my extensions are getting in the way, and so you kind of have two options."
          },
          {
            "time": "[00:03:40]",
            "text": "If you notice a Chrome extension is getting in the way one is to open an incognito window and do the same thing there. The other one is you can go to Window and extensions. And then you can just deactivate all of them here so that that won't uninstall them, right like here, you can just deactivate LastPass and close it and then refresh the site again so you can kind of go either way."
          },
          {
            "time": "[00:04:00]",
            "text": "It is a tricky thing. It's bitten me a lot before in real life production cases where I'm experiencing something and it turns out to be a Chrome extension. So I think it's a good idea to either turn them off. One other cool thing you could do is I oftentimes, like I'll have Chrome as my daily driver for my browser."
          },
          {
            "time": "[00:04:17]",
            "text": "And then, I'll download Chrome Canary, which is their like, pre release, build. I'll use Chrome Canary with zero extensions. That'll be like my, what I use for dev tools, whereas like Chrome will be like what I use for browsing. So you have a couple of different options there."
          },
          {
            "time": "[00:04:29]",
            "text": "But it is good to keep in mind that that the extensions can break it."
          },
          {
            "time": "[00:04:29]",
            "text": ">> I have a quick question for the watch."
          },
          {
            "time": "[00:04:29]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:04:29]",
            "text": ">> If you're setting the watch do you also have to set a breakpoint on this specific element that you're watching where those specific variables that you're watching?"
          },
          {
            "time": "[00:04:43]",
            "text": "Or good at if you set it, let's say after the elements when you call it, would that still work?"
          },
          {
            "time": "[00:04:43]",
            "text": ">> Yeah. So basically what this is gonna do is every time a breakpoint gets hit, it will update the values in here. So like if you had like a function that set foo and then way later you put a break point it would still have access to foo because that's totally fine but as for like keeping track of, it'll update every time you either hit a break point or like you step in or out of a function that will update then."
          },
          {
            "time": "[00:05:19]",
            "text": "So it doesn't really matter where you place it but this will only post data when you've like hit a breakpoint basically. Somebody had asked, okay, without doing workspaces, is there a way to get your changes so that they will persist through a refresh, right? So not necessarily writing to disk and that whole thing, but I just want to be able to like change some JavaScript, refresh the page and see it execute."
          },
          {
            "time": "[00:05:43]",
            "text": "There is a way to do that. And so to do that, you come over here to the left panel, where we were on page before, and you click over here to overrides. And what you have to do is you have to create or give Chroma folder to store all these little diffs and it can be literally anything."
          },
          {
            "time": "[00:06:01]",
            "text": "So you can click Select Folder for overrides, you can make your own folder that's no problem. Like I can make a folder and call it like FUBAR or something like that. You could put it in your documents so you can make it, Chrome, local overrides folder, anything like that, it's fine."
          },
          {
            "time": "[00:06:16]",
            "text": "When you select it, you'll have to go through the permissions process or like allow and your OS might ask to. But once that is that, then we can do things like we could go to the body. We could do you know, like background color red or something like that."
          },
          {
            "time": "[00:06:31]",
            "text": "And now when we refresh, it'll stay red. And we can do that with our sources panel and our JavaScript, everything like that. So if you're that's, that's always good for like, if you're, especially with JavaScript that runs once, I think somebody had asked about this earlier to where it's like, you load the page and you make an edit and you want to see it and then you refresh which gets the page from the server again, so you've lost your edit, like that kind of thing."
          },
          {
            "time": "[00:06:52]",
            "text": "So if you go to sources overrides and set up an override, you'll be able to get that"
          }
        ]
      },
      {
        "sessionTitle": "17-network-performance-network-waterfall.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So this I have broken out into three sub chapters, because they're kind of three different ways of looking at performance. The first one that we'll cover is network performance. That's going to be like things coming over the network to from your servers to your users. The second section is going to be CPU performance."
          },
          {
            "time": "[00:00:15]",
            "text": "So that's going to be like the page has loaded. And now the users doing stuff and how slow is that? And the third one is gonna be memory. And that one is also gonna be kinda on page load. But it's gonna be how much memory your app is allocating, do you have a memory leak, things like that."
          },
          {
            "time": "[00:00:31]",
            "text": "So those would be the kinda three sections. So we start with network performance. One thing I always find really interesting Is every time some company does a study the metrics they come back on for how important page load is always kind of blows my mind. So I have like a couple of things that I was just able to find where it's like Walmart Amazon, finding that 1% increase in earnings for every 100 milliseconds that could shave off their webpage speed."
          },
          {
            "time": "[00:00:58]",
            "text": "Is like, hugely substantial amount of money, just things going faster. And I think we all know it at a certain end when it gets really bad. You go to a website and it's like spinning and spinning and spinning, like I'll just go find a different website. But I'm always amazed that when you look at the aggregate, like how many users that you just lose, with even small like barely perceptible slowdowns Yahoo saw a 9% increase in traffic for every 400 milliseconds they improved."
          },
          {
            "time": "[00:01:25]",
            "text": "That's like less than half a second. Huge increase. And Google's as it loses 20% of their traffic for every 100 milliseconds they take to load. That one makes a little bit more sense because you, you really expect Google to be instant like google.com, bing.com you expect those to be Really, really fast because you're not there to stay here or there to go to another place.And then these just interesting numbers like in the one to three second range as your page is loading people up."
          },
          {
            "time": "[00:01:54]",
            "text": "Probability of leaving goes up to like 32% as it extends to like one to five seconds. It's like 90% And then bounces just increased like over 100% more bounces as you go past that 5% five second range so you can really losing a lot. You can get a lot of this info if you use like Google Analytics or something you can see how many people bounce but, but it's a little bit harder to measure because Google Analytics like depending on where you put it in your script, People might even leave before it loads, right."
          },
          {
            "time": "[00:02:24]",
            "text": "And so it's it's probably even worse than that. So that's kind of the importance of this network stuff. And I think it's always important to, to have a little bit of like empathy for your users. This is really common where like, you'll be at some big company, maybe and you're like in."
          },
          {
            "time": "[00:02:41]",
            "text": "San Francisco in the United States on a brand new MacBook Pro. And you're like my site is really fast, right? Like it loads like right away and it's really good. And then, there's like so many places with worse internet connection and there's so many people on worse devices."
          },
          {
            "time": "[00:02:59]",
            "text": "And then you start thinking about well what about people using it on mobile devices on worse internet connection? I mean, it really, it really can be a very different experience based on where you are. And I think even people living in like very modern high internet speed cities like if you take the train somewhere and you go in a tunnel and you lose your connection, like we all know That frustration right or you're like at an airport, and all of a sudden everything is crawling like."
          },
          {
            "time": "[00:03:22]",
            "text": "So I think it's really important to not just test on, the maximum the best possible conditions, but to think about your user base. Again, with a good analytics tool, you can get a lot of this like, You actually have a lot of users in this region or that region."
          },
          {
            "time": "[00:03:37]",
            "text": "And there's tons of stuff you can do, which is kind of what we're going to be covering So yeah, we're gonna kinda learn network terminology, and then what the Network tab can do. So if I go ahead and I open the Network tab here, we've sorta seen it once already."
          },
          {
            "time": "[00:03:53]",
            "text": "And let me go ahead and click this cog and disable screenshots just for now because they take up a lot of room, and then I'll refresh the page. So Like we covered at the very beginning, you see like this list in order of every network request your app made."
          },
          {
            "time": "[00:04:06]",
            "text": "And the bigger the app, the more network requests you'll see, especially as there's like analytics and tracking code and ads and all these images and, everything's a network request. So you'll see the name of the request here. You will see the status, again this isn't like a web fundamentals class, but it dev tools kind of taps into everything, so, for those that know like network status is like 200 is okay, a 400 is usually like a client side error, 500 range is like a server side error, all these different things."
          },
          {
            "time": "[00:04:39]",
            "text": "It's nice to see these, they'll actually go red when the error and error as well. The type that it is documents, stylesheets images all that the initiators kind of interesting because you can kind of get this waterfall view of like, okay your document came in that called a JavaScript file and that called a JavaScript file and you can kind of like watch it."
          },
          {
            "time": "[00:04:57]",
            "text": "There's also a kind of a cool tip and trick which is you can hold Shift as you move around. And when you hold shift over an item, it'll turn everything that item called Red. And if that item was called by something, it'll turn that green. So you can see like this font here, the font was called by network dot html, that screen and it called two other files."
          },
          {
            "time": "[00:05:23]",
            "text": "Those are rad. It's just kind of a neat way of like visualizing what happened. You can also see the size. And when this is cached, like if you use compression and caching, you'll see that on this as well, and you can see how long it took to load."
          },
          {
            "time": "[00:05:36]",
            "text": "And then you get this really cool waterfall. So this is what happens when you hover over these here. You get this waterfall, And the waterfall like if you have a request that's taking a really long time, the waterfall can help you figure out where in the process that request is getting stuck."
          },
          {
            "time": "[00:05:51]",
            "text": "And we'll cover that in a second because that's kind of a pretty in depth one. But it's also worth noting that if you right click on any of these, there's actually a lot more columns that you can add So you can add like the path, the URL, what domain they came from, you can add cookies that were set the priority of it all those kinds of things."
          },
          {
            "time": "[00:06:10]",
            "text": "And again, just to give a bit of context here before we go into the waterfall terminology we've kind of seen like a script and or an HTML file, we'll call scripts we'll call CSS call images, all these things, but it's really important to know that on the browser level, you get like a certain number of requests, which is, I believe, either five or six depending on the browser that you can do at one time."
          },
          {
            "time": "[00:06:34]",
            "text": "So if you tried to call like 20 images, it would send out six requests, you know, for the six first images. And then as they come down, then it would start filling like a queue basically where I would call the next images. So it's worth knowing right away that you can't just do unlimited requests."
          },
          {
            "time": "[00:06:50]",
            "text": "And if you think about it, that's where we get this culture of like concatenating our JavaScript files or using CSS sprites instead of images. Because there's a performance gain to be had by having less total requests. So for those familiar with that, who have like bundled their JavaScript together or who have stuck images into a sprite or bundle their CSS, that's why it's because we're limited to the number of resources."
          },
          {
            "time": "[00:07:12]",
            "text": "But the other thing that's really interesting is that Rather than just going down your HTML, and just like in queueing everything it sees like script, CSS, CSS, CSS, you know, going through, the browser's really smart, and it tries to figure out things that it thinks will be higher and lower priority."
          },
          {
            "time": "[00:07:31]",
            "text": "And then it goes down a priority list which is like really great because otherwise. If you think about it, you could put like an image tag and then a CSS tag right after it and the CSS you need that styles your page and the images like I mean, it's you do need the image eventually, but it's usually more additive."
          },
          {
            "time": "[00:07:48]",
            "text": "So what chrome will do is it has this whole system in place where it'll be like, I think these are the top priority. I think these are medium. I think these are lower priority. And that way you don't have to restructure your HTML in a weird way just to get things to load."
          },
          {
            "time": "[00:08:00]",
            "text": "So you can actually right click here and you can do priority and it will add this new column. And it's kind of cool to play around with where you're like, like it views, my HTML obviously, and my CSS is the highest priority. Then it gets to this PNG here I've used that as low priority."
          },
          {
            "time": "[00:08:17]",
            "text": "And then back down here, these font files that are needed to render high priority these two PMGs low JavaScript, medium. It's kind of interesting to see how the browser thinks about it. And it sort of makes sense where usually the HTML and the CSS are like the vital things, like get the site to display and then JavaScript is like."
          },
          {
            "time": "[00:08:35]",
            "text": "Probably somewhat important, but usually it happens after the page load the JavaScript kicks in. And the images are like the lowest importance thing. It's just kind of an interesting thing to see. Does that make sense to everybody that kind of sucks. Six total requests at simultaneous requests and they're more advanced than you would think."
          },
          {
            "time": "[00:08:53]",
            "text": "Cuz Chrome and Firefox and Edge all have a system to figure out what the priority order is. Let me know if you have any questions on that."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Is there a way to change their priority order? Because I remember you can defer scripts."
          },
          {
            "time": "[00:08:53]",
            "text": ">> Yeah."
          },
          {
            "time": "[00:08:53]",
            "text": ">> And the head does that."
          },
          {
            "time": "[00:09:11]",
            "text": "What does that do to the priority order?"
          },
          {
            "time": "[00:09:11]",
            "text": ">> Yeah, so you can override it. You can You can make things like higher priority. Well, so there's a couple ways you can override it. Yeah, you can move things up to the head. So like Google Analytics will be like, for example, I want my JavaScript to be in the head please, which will make it a higher priority by itself."
          },
          {
            "time": "[00:09:31]",
            "text": "You can also do things like you can like preload images, you can be like, this one's really important. And then you can Yeah, exactly on the on the other side, you can defer and that says this is less important, right? So yeah, so you can go in and you can either preload or defer."
          },
          {
            "time": "[00:09:46]",
            "text": "And you can also move things around in the structure so that they're, you know, higher up or whatever. And that and that will override these. Yep. So the waterfall is interesting, because I feel like it's largely ignored. And then one day you'll have a thing like this happens to me all the time at work will be like, Hey, Why is this taking so long?"
          },
          {
            "time": "[00:10:03]",
            "text": "And I'll be like, it's this call this API call. And then my boss will be like, well okay, but [LAUGH] Whose fault is that? Right? Not that my bosses mean, but they'll be like, well, what's the problem? Is the problem like the response is too big, is the problem that the service is too slow or that we're too slow or, So this can be really interesting."
          },
          {
            "time": "[00:10:21]",
            "text": "So it provides this really nice colour coded timeline for things that can really help you dive in. And when you're making a ticket, especially if you're like a front end engineer making a ticket for a service engineer, it can help a lot and be really impressive. Again, like one of the themes of this is like Dev Tools helps you cheat a little bit."
          },
          {
            "time": "[00:10:37]",
            "text": "They can be really impressive where you're like, Hey, this is a DNS issue or like, Hey, this is an SSL issue. They're like, Whoa, How did you know that? It's like I'm really cool, so what I've done here because of [INAUDIBLE] I've sort of broken down the waterfall in order and the colours used here are the same colors that combatbtwo of these."
          },
          {
            "time": "[00:10:56]",
            "text": "So, the first colors you'll see which is at the top are white and grey and those are queueing installed. Queuing is exactly what we just talked about. Either there's higher priority stuff, or it's the same priority, but we've already hit our 6 total connections. So I gotta wait."
          },
          {
            "time": "[00:11:11]",
            "text": "Or and this is very rare. The browser is doing some work and just needs a second, that's fine too. And so then they'll show is stalled the entire time that they're stuck queuing so you can see how long they waited. Then the next three are kinda green and orange."
          },
          {
            "time": "[00:11:25]",
            "text": "Those are like setup things happening. One is DNS lookup. So we all know that we were crest like google.com. But that's not a computer's address, right. That's a domain name. So it has to go to the DNS service and find what server to actually reroute to. So if that's slow, that's something going on with DNS routing, not not our company."
          },
          {
            "time": "[00:11:43]",
            "text": "Then it sets up the initial connection, right? So the TCP connection SSL connection, there could be a problem in there. If you're using a ServiceWorker. Like if you have a progressive web app, you can see another orange bar for ServiceWorker setup like it's being bootstrapped. And then purple ServiceWorker has been set up, it's starting to respond."
          },
          {
            "time": "[00:12:00]",
            "text": "Now green is an interesting one green and blue are like the data has gotten on the server and it's coming to you finally, green is waiting time to first byte which is a metric that a lot of sites use to mark performance of their services, which is you know, I say give me food at PNG, and then I will my computer chrome will mark when I get the very first byte of data, the very first packet of data comes over."
          },
          {
            "time": "[00:12:24]",
            "text": "I can use that to kind of gauge how quick my connection between the server and the client are. And then content download is how long it takes for all the rest of the bytes to get over. This one's interesting because this can be largely a client issue, right?"
          },
          {
            "time": "[00:12:38]",
            "text": "If I have a JavaScript file that's like 100 kilobytes, it's going to take a very different time to download In that San Francisco, you know, high speed internet connection than it is if you're on the train, and you're going through a tunnel or something like that. But it can be really nice to kind of categorize things like the white and gray means that too many requests, right?"
          },
          {
            "time": "[00:12:57]",
            "text": "And we're just the browser's just stuck. Not even working on those requests, yet. So you can kinda concatenate your scripts, image sprites, all that cool stuff. The green and orange is like stuffs being set up on the service side. So maybe there's like a hiccup with the DNS registry or the SSL some Something like that."
          },
          {
            "time": "[00:13:16]",
            "text": "The waiting time to first byte is slow. It's a service issue. So you can go to your service, you can be like, hey, time to first byte is really slow. Maybe it's a database problem. Maybe the servers are overwhelmed or they're just slow, something like that. And when content download becomes an issue, you can't just blame the user."
          },
          {
            "time": "[00:13:31]",
            "text": "So you'd have to figure out what you can do to make the content smaller, right? If people are just you know, waiting and this is something that we see Lot of especially in this like modern world where it's so easy to go shopping for new JavaScript libraries, you just keep adding them to your code base."
          },
          {
            "time": "[00:13:44]",
            "text": "You know, you're like, I need a calculator app and I need this. I need that or whatever the things get really big and you'll see large content download times."
          }
        ]
      },
      {
        "sessionTitle": "18-network-performance-q-a.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> What is the correlation between priority and waterfall?"
          },
          {
            "time": "[00:00:00]",
            "text": ">> The waterfall will show the actual statistics for that particular request, right like that request. But the priority is how the browser chooses which order to fire things in. So if you have a lower priority item, you will see that it spends time either queueing or stalled."
          },
          {
            "time": "[00:00:23]",
            "text": "If you have more than six, both conditions have to be met. If you only have six total items, the lowest priority gets fetched at the exact same time as the highest priority. But if you have more than six requests, that's images, scripts, CSS, all that stuff, then you'll see lower priority items will spend time queuing whereas higher priority items will not spend time queuing cuz they'll go right away."
          },
          {
            "time": "[00:00:44]",
            "text": ">> So for the waiting, that's specifically an issue with the server side code, or it could be like you said something with the database, that's it, and usually you have to look there to find a way to speed it up?"
          },
          {
            "time": "[00:00:44]",
            "text": ">> Yeah, that's a great question, so time to first byte and waiting, are those always server side issues or could they be front end issues?"
          },
          {
            "time": "[00:01:02]",
            "text": "I mean, technically it could be front end if your connection is so bad that a byte takes a while, there could be some issue there, right? If you're on a really, really weak connection, your time to first byte will be slow as well."
          },
          {
            "time": "[00:01:02]",
            "text": ">> But typically, since it's such a small amount of data, if you see a slow time to first byte, it usually means that between the server getting the request and giving the very first piece of data back is taking a long time, something in there, whether it's server processing the requests or something in the database or something like that."
          },
          {
            "time": "[00:01:33]",
            "text": "It could potentially be something's slow for you, but for example, if other websites are loading great for you and then your website has got a slow time to first byte, that's almost guaranteed to be a server issue."
          },
          {
            "time": "[00:01:33]",
            "text": ">> And did any of these also take into consideration the user's machine?"
          },
          {
            "time": "[00:01:52]",
            "text": ">> So they don't normalize data, they won't say for you this is doing what, Lighthouse for the audits will do something kind of like that. They'll say, this is pretty good for a slow device, something like that. But these are just going to show simply the time taken."
          },
          {
            "time": "[00:02:09]",
            "text": "So if we do a refresh here, it's just gonna say, how many milliseconds it's spent at each phase. So it's spent six queueing, DNS lookup was four milliseconds, and then you can see that the time to first byte took 60, which is very fast, but you can see just pure milliseconds."
          },
          {
            "time": "[00:02:26]",
            "text": "So no, it doesn't normalize the data at all."
          },
          {
            "time": "[00:02:26]",
            "text": ">> I have an equation. What is the initiator columns about? Yep, so the initiator is who requested that. So if you think about you have an HTML file that has a script source main.js in it. So main.js' initiator would be index.html cuz index.html is what called that."
          },
          {
            "time": "[00:02:52]",
            "text": "And then if in that script source you did a fetch for food.jpg, then food.jpg's initiator would be main.js cuz that was who initiated it. So it's like, why did you call this thing? It's like, so it's like this one, we have this, give a refresh here, we have this network.html."
          },
          {
            "time": "[00:03:14]",
            "text": "So we have network.html, that was initiated just by the server, right? That's always the the main thing you get is an HTML file. But then if you look at all these, you can see the initiator network called the JS, network called the PNG, network called this CSS file."
          },
          {
            "time": "[00:03:30]",
            "text": "But the CSS file called these other two CSS files, so you can see the initiator is different for that."
          },
          {
            "time": "[00:03:30]",
            "text": ">> I just had a question. So if we do a cmd F on the network panel, there is a joy version opens up to the right. I was wondering how can we use that, this one, yeah."
          },
          {
            "time": "[00:03:49]",
            "text": ">> So this one's kind of interesting. So you have kind of two options here, you have one is the option just to filter, to kind of filter this list down, right? And so you can do things like if you search for net, you can do something like that."
          },
          {
            "time": "[00:04:03]",
            "text": "You can also do, I think it'll support some amount of regular expressions or whatever. Yeah, the other option that you can do is you can do this kind of more advanced search by cmd+F or ctrl+F. And now when you search for things in here, it'll actually parse all the response data as well."
          },
          {
            "time": "[00:04:21]",
            "text": "So you can like a lot of these will have headers. So basically the filter here is gonna search your names, right? That's what it's gonna search. The search bar here is gonna search the names, all the response headers, all the request headers and the resulting response body itself."
          },
          {
            "time": "[00:04:37]",
            "text": "So you can really kind of filter through. We're almost done with the network, but I do have one call that I like to do which is rightfully, we obsess about network performance. It's a good thing to obsess about. And the faster you get your site, the happier users will be."
          },
          {
            "time": "[00:04:51]",
            "text": "But I do feel like sometimes we get really carried away with this idea of, and actually the jesup question is a great segue of, well, if we can just really compress everything and send it over, then we've solved our problem, right? So we'd take this gigantic thing of JavaScript and we compress it and send it over the wire and that's great because it's fast over the wire."
          },
          {
            "time": "[00:05:11]",
            "text": "But I do want to always caution people that as we compress more and more and as we send more and more JavaScript specifically instead of images over the wire, parse time becomes a really big bottleneck as well and it's something to keep in mind. So the idea with compression being you take a JavaScript file, it's 10,000 lines long, you run it through Gzip, and you get a much smaller file, which is great, cuz smaller files travel faster over the wire, but they have to be uncompressed on the client's machine, right?"
          },
          {
            "time": "[00:05:43]",
            "text": "Their browser will uncompress it. And they still have to parse that giant amount of JavaScript. So I do think that compression is great, we should compress everything. There's a lot of websites that are gzip everything or whatever and they'll check a website to make sure that everything is being compressed and broadly is even faster."
          },
          {
            "time": "[00:06:00]",
            "text": "But we need to keep in mind that at the end of the day, we really should be trying to limit the amount of JavaScript that we send over the wire too. Those are always huge wins because even if we can get the network request quick, the parse time is really substantial."
          },
          {
            "time": "[00:06:15]",
            "text": "There's this post by Addy Osmani here that I linked to, which is well worth the read on itself, but it's called JavaScript Startup Performance. And it's just all about kinda like the cost of JavaScript. So I took this picture from it, which I really liked for people that want a better idea of how kinda these things work like after the JavaScript makes it over the wire and is uncompressed."
          },
          {
            "time": "[00:06:37]",
            "text": "It still has to get parsed and turned into the DOM tree and it gets compiled and optimized. All this stuff has to happen on this large amount of code. So while we shrink our images and bundle and shrink our JavaScript, all that, trying to send less JavaScript over the wire is vitally important to speed."
          },
          {
            "time": "[00:06:54]",
            "text": "And you can do really cool things. You can asynchronously load bundles if there's a web pack front end masters course where Shawn shows how to split your bundles up and only load what you need at page load and bring stuff in. So there's a lot of different ways we can think about it."
          },
          {
            "time": "[00:07:08]",
            "text": "Network's really important but parse time is really important too. And there's a little graph, the same JavaScript file. So you're on your nice desktop computer and it takes 200 milliseconds, which is well within a fine range for everything to parse, but you move over to a mobile device that has a worst CPU and it can take over a second to parse the exact same file."
          },
          {
            "time": "[00:07:26]",
            "text": "So just to call out on that stuff. Cool, any questions about that?"
          },
          {
            "time": "[00:07:26]",
            "text": ">> When you go to the size, right, when you're in your Network tab, you're looking at the size column. If I were to refresh this page right now, and not a hard refresh, but just a refresh, I don't see it on your screen, but I see some assets showing up as dis cache [CROSSTALK] memory cache?"
          },
          {
            "time": "[00:07:54]",
            "text": ">> Yeah, I have this cache disabled. So if I unclick that, yeah, so these are just things that the browser has been able to optimize for you. So these items that are just CSS file items that are just being cached on your disk, so they won't have to load."
          },
          {
            "time": "[00:08:11]",
            "text": "So you can see the page load time goes down to zero milliseconds. This is similarly true, you'll see it if you cache responses to yourself, right? So if you set cache headers on your network requests, then you'll see those reflected there as well."
          }
        ]
      },
      {
        "sessionTitle": "19-measuring-real-user-performance.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the very last thing I wanted to cover as network stuff is the idea of measuring real user performance. So this is a really cool idea. It was actually something I didn't get into until later in my career. So what we would always do is we would like, again, we are like authoring a web app, and we look at it on our machine and we are like, it is pretty fast or whatever."
          },
          {
            "time": "[00:00:22]",
            "text": "We know the amount of milliseconds that it takes. And then somebody even asked a question earlier about like, but does it normalize that data based on your network conditions? And it does not. But I think that's hinting at a really a larger question, which is like, okay, but how fast is it for your average user or like how fast is it for the bottom 10% slowest user computers?"
          },
          {
            "time": "[00:00:43]",
            "text": "Or something like that. And so this idea came around a long time ago of shipping some code that would like sort of get the time that it actually takes on their actual computer and send it back to you. So at its like absolute simplest, you could stand up a service that takes like maybe a username and event like the page to load and a time, right and you could have a database that stores all that."
          },
          {
            "time": "[00:01:07]",
            "text": "Then you could ship some JavaScript in your actual app that looks like this. And let's say this for loop that's doing nothing is your page to load or whatever. So you could do like a start time using date time. And then you could do some expensive thing and then you could do an end time."
          },
          {
            "time": "[00:01:21]",
            "text": "And then you can figure out the difference yourself by doing n minus star and then you could send that to this cool service. You can be like, whoa, like most people, it takes one second. But look at this, a few 100 people, it's taking 30 seconds what's going on there."
          },
          {
            "time": "[00:01:35]",
            "text": "And you can learn all sorta cool stuff like, we have our data centers in the US. But we're getting a really big, African bumping users. We should get a data center out there. We should do something like that. So this happens to us a lot like at Twitter at startups."
          },
          {
            "time": "[00:01:49]",
            "text": "You'll see your app will go big in a new place that it hasn't been big before. And all of a sudden everybody's kind of crossing over the the data takes a long time. So this can be really cool to A, see what how it performs on slower computers but B, to recognize when something has changed, like you have a new country city zone that's getting really popular and you wanna go add some resources to it."
          },
          {
            "time": "[00:02:12]",
            "text": "So this is what we used to do. But then we got this really cool thing called console time, which is way better. So instead of doing the math ourselves, we could just console time we could pass in a string. Now we do the thing when it console time and the same string and then it keeps track of it."
          },
          {
            "time": "[00:02:28]",
            "text": "It prints it out for us, which is like super cool. And it's also more accurate it prints it out down to a more finite number. So then that was the cool thing to do for a really long time. And now we have an even cooler thing, [LAUGH] which I get really excited about, which is the performance API."
          },
          {
            "time": "[00:02:46]",
            "text": "And so, again, these are all doing the exact same thing, right? But it's like, instead of console time and console time, and you do performance which is a global.mark, and then performance.markend, and then you can print out, mark and measure is the technology, so then I print out a random string, and then which two things to compare."
          },
          {
            "time": "[00:03:05]",
            "text": "So this is very much the same as, up here where I would do like console and start. But the cool thing about doing it this way is not only do you get that time, but it actually is like a standardized thing that other browsers recognize. So if you run some code like this, and let me see if I have some going, Yeah, so if you run some code like this and you do a performance measurement, which is what the tab we're gonna cover next."
          },
          {
            "time": "[00:03:34]",
            "text": "But if you do a record, and then you refresh the page, and then you stop the recording, we can ignore a lot of stuff. But we can see that my mark and measure actually made it into a brand new section called Timings in the Performance tab where I can actually see how long it took."
          },
          {
            "time": "[00:03:48]",
            "text": "I can interact with that. So it's like way cooler than console logging out, and minus start or whatever you do a performance mark and a performance measure, and it'll actually show you in the Performance tab, exactly how long it took and what it was doing and cool stuff like that."
          },
          {
            "time": "[00:04:02]",
            "text": "So these are really cool to add something like this, whichever approach you take is fine. And to stand up some kind of service that receives all of it. And you can really see how long it's taking your actual users to load your actual code. The performance API also has a bunch of really cool stuff."
          },
          {
            "time": "[00:04:18]",
            "text": "I'm not gonna cover it in depth, but I did just wanna show you so just on any random site, you can do something like Performance get entries by type, and then you pass in a type. So I'll print this get entries by type of resource. And it'll actually show me all eight of the resources at grab, which is the exact same stuff that you see over here."
          },
          {
            "time": "[00:04:37]",
            "text": "But you can start like brainstorming like as you get more into this stuff that you could totally build your own Tooling, around, for example, you could just take this, and you could send it to your service. So your user sending it in, and now you can see the network waterfall, for your users in real time, as opposed to just you using your app."
          },
          {
            "time": "[00:04:55]",
            "text": "Things like that. You could do paints. So every time the browser has to do a repaint, and you can see what was it called? What did it? What triggered it? How long did it take? All these really cool things. So it's basically the same API that Dev Tools is using to do its like network stuff and things like that."
          },
          {
            "time": "[00:05:11]",
            "text": "But now you can not only harness it by making custom scripts where you can actually grab that user data and send it to a service, you can re better understand how long all these things are taking. This was really cool. I would just if I were you, I just do like a performance."
          },
          {
            "time": "[00:05:26]",
            "text": "And then do a dot and just check out all these like very, very cool things that it can do. And MDN has really great docs on the performance API, which I've linked to up here. It really opens up like a whole world of stuff you can do."
          }
        ]
      },
      {
        "sessionTitle": "2-elements-network-panels.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Hello, I mean this course is made for anybody but who I think I have content in this course for types of people that I think will get the most out of it. So I think anybody with little to no experience using Chrome DevTools, I hope to be able to walk you through each panel, what they do what they're good for, all that stuff."
          },
          {
            "time": "[00:00:18]",
            "text": "Probably when I pull people the most common group that I get are people who have used the Network and the Console panel before. They console log stuff, they've checked it or they've looked at the network overview and they have seen what comes in. But they've really never clicked on any of the other panels before."
          },
          {
            "time": "[00:00:34]",
            "text": "Maybe they clicked on it and it seemed overwhelming so they clicked away from it. So I'm hoping this will be a really nice introduction to the rest of those panels as well as learning a lot more about network and console. And the third group is people that are comfortable with the panels, but working to learn some tips and tricks."
          },
          {
            "time": "[00:00:50]",
            "text": "One thing I always love, I love keyboard shortcuts, I love experiments, I love little known things, little things that I pick up along the way. So all my workshops that I do, I try to fill with as many little tips and tricks sections as possible. Cuz I find them just really fun and they kinda help me speed up."
          },
          {
            "time": "[00:01:08]",
            "text": "All right, so now we'll move into the next lesson, which is what can the DevTools do? And so this lesson really we're just gonna go through each one. And we're gonna start playing around with them on a very high level, but just seeing some actual stuff that we can do with the DevTools."
          },
          {
            "time": "[00:01:24]",
            "text": "And then we'll get down into the course format for the rest of the course afterwards. So I kinda have two things I wanna point out before we go into it. One is a little bit about not feeling overwhelmed with stuff. I find a lot of times when I sit through workshops, there's so much incredible information."
          },
          {
            "time": "[00:01:42]",
            "text": "And sometimes I start getting a little bit stressed that I'm not gonna be able to retain all of it, right? I'm like, I gotta remember that, and that, and that, and that. So if I were to give you advice, I would say that I think it's more important to know what they can do, then how they can do it."
          },
          {
            "time": "[00:01:57]",
            "text": "Cuz if you know what they can do, you can come back to this final masters course, or you can look at the Docs or you can even just look at the DevTools and try to figure it out for yourself. So if I were to ask for one big takeaway, it would be only just try to remember I've seen DevTools can do this really cool CPU thing now I know exactly how to read a flame graph, right?"
          },
          {
            "time": "[00:02:14]",
            "text": "Those are kind of differences. And the other one, which is something we were talking about a little bit earlier, is that the Chrome extensions like plugins that you add to your browser can and often do mess with DevTools data because they can and often do mess with how you actually render websites."
          },
          {
            "time": "[00:02:31]",
            "text": "And this can lead to really inaccurate reporting. And this has bitten me a lot of times at work before. So my suggestion is, if you're doing something important, like you're auditing a customer's website, or you're trying to find if there's a memory leak on your page, I would either go ahead and disable all of your extensions, which you can do up at this window extensions tab."
          },
          {
            "time": "[00:02:52]",
            "text": "Or just open a new incognito window for the site that you're viewing, incognito windows by default have the extensions turned off. So I think that's always a good tip because there's a lot of stuff going on with these Chrome plugins that you might see new scripts being added to the DOM."
          },
          {
            "time": "[00:03:08]",
            "text": "You might see network requests being rejected or new network requests, all sorts of stuff that can be really tricky to figure out why it's happening. And it's often just a Chrome extension that you have. Awesome. All right, so let's begin with walking through the panels. So I'm gonna go ahead and I'm gonna open the DevTools."
          },
          {
            "time": "[00:03:26]",
            "text": "And we're gonna kinda go down this little list of high level things, and we'll just play with a little example of them so we can kind of see them visually happen. So the first panel is the elements panel. And I guess actually, before I go into each panel, it should be worth noting that these tabs can be dragged and dropped, and they persist in whatever order they're in."
          },
          {
            "time": "[00:03:45]",
            "text": "So if you see yours in a different order than mine, it's probably just because I've dragged mine around, nothing to worry about. You can drag these around until whatever order you want. But on the website is the order that I'm gonna be going through them in. Cool, so the Elements panel."
          },
          {
            "time": "[00:03:59]",
            "text": "So again, you're able to play with all the HTML and CSS. I find it's really interesting when in doubt, try double clicking something cuz it's really interesting what you can interact with here. So for example, some things might be more obvious like we can go ahead and take the body element here, and I'll click on it."
          },
          {
            "time": "[00:04:17]",
            "text": "And we can kind of scroll through all the CSS that applies to it. And so, we could do things like you can see the background color is gray. So I could change the background color to red and in real time the background of the website will update or purple, something like that."
          },
          {
            "time": "[00:04:32]",
            "text": "You can also change the actual property though. So, instead of background color, you could change it to color entirely. And now you'll see this is getting crossed out because there's two colors. But I would say always try double clicking on stuff. You can even double click on the selector itself."
          },
          {
            "time": "[00:04:50]",
            "text": "So if we set this back to background color, and I'll go through this auto select here, and that's purple, we could change this from body to div, something like that. And now you see the body has gone back to being its default color but every div on my site is now purple."
          },
          {
            "time": "[00:05:05]",
            "text": "And so there's a lot of different stuff that you can double click on. Another one that surprises me the first time was that if you take an element over here, like let's say this h1, let me scroll up a little bit so we can view it together. This is this title element that says lesson 2 here."
          },
          {
            "time": "[00:05:19]",
            "text": "You can even double click on the element itself. And so you can change it from an h1 into an h2. So there's two cool things here, one that you can edit the HTML. But two, if you notice over here, I know it's quite subtle, but If you change an opening tag, Chrome DevTools will automatically change the closing tag for you."
          },
          {
            "time": "[00:05:36]",
            "text": "So you can just change the opening to an h2 and hit Enter and there we go, it gets smaller. So I'll change this back to an h1, and we'll scroll back down to the lesson. You can also change classes and IDs. Again, the thing that might be more obvious you can see here we have an article with ID of main."
          },
          {
            "time": "[00:05:53]",
            "text": "The thing that might be more obvious is that we can change the ID from main to app or something like that. And you can see that explodes a lot of the CSS cuz I was using main as a selector. So I'm gonna go ahead and set it back to main."
          },
          {
            "time": "[00:06:04]",
            "text": "But the thing that might be less obvious is that you can actually double click on the ID portion itself and change it to maybe a class name of main instead, which still breaks because my CSS is looking for an ID. So pretty much everything in here is double clickable, which is really cool."
          },
          {
            "time": "[00:06:20]",
            "text": "You can also do things like, we saw that you can update these styles. But you can also do a lot of cool things for example, you can add a brand new style so we can click on this plus sign over here. This is on the right sidebar. And we can create a new style rule."
          },
          {
            "time": "[00:06:38]",
            "text": "And so, if we had one, we wanted to be more specific than, ID of main, we could do the default one is article of main. And so you can see whichever thing you've clicked on when you click new style, it kinda tries to pull a very specific selector for you."
          },
          {
            "time": "[00:06:52]",
            "text": "But you can put anything you want in here, like class of foo or something like that. These are also drag and droppable. So if you grab on to one of these like the h3, you can move it above the h1. And that will see back up here my course is now out of order."
          },
          {
            "time": "[00:07:07]",
            "text": "The h1 down here and the h3 over here. Yeah, so I finally have done like a really good job of making this page, sort of like Apple does with their products where it's pretty intuitive or like the thing you'd wanna do. I would just give it a try."
          },
          {
            "time": "[00:07:20]",
            "text": "[LAUGH] Always give it a try if you wanna make a new selector, drag stuff around, move it anything like that. Cool, and we'll get into a bunch more stuff cuz the elements tab can do amazing things later, but that's kind of the high level view. The Network tab."
          },
          {
            "time": "[00:07:34]",
            "text": "So this one, the basic idea is if you go to the network tab and then you refresh your page when you're on it, the probably most common thing that we do and let me hide a bunch of this other stuff for now, is we look at the stack of all requests sent."
          },
          {
            "time": "[00:07:49]",
            "text": "And so this is pretty cool. It's basically if you think about how a webpage works, right? You hit the server and the server always gives you an index.html, right? Or whatever, a file name.html. It's always the beginning, right? Because HTML is what we need for the very first request."
          },
          {
            "time": "[00:08:04]",
            "text": "So always see the top one here being an HTML or they call it document type over here. And if you click on it, you can actually see what the response is. I do have inline styles which might be a little bit confusing, but this is an HTML file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then what it will do is it'll walk this file and it's looking for any references to external resources, right? So when we do HTML, we often put links to CSS or script tags to JavaScript. Those are two very common things we do. We also put image tags, right?"
          },
          {
            "time": "[00:08:35]",
            "text": "And so as it's walking this, it'll say every time it's like, you need a CSS file, it'll go out and it'll fetch that. And so you can kinda see the network sort of works that way where it fetches the document, it reads through it, eventually it sees that I'm linking to a script."
          },
          {
            "time": "[00:08:48]",
            "text": "So it goes out and fetches that script. This is called prismjs I use it for my code snippet styling. And then it'll keep reading and keep reading and then eventually it gets to a font tag. I use a custom font in here, so it goes out and fetches that."
          },
          {
            "time": "[00:09:03]",
            "text": "So yeah, this is basically in order every request that was sent, and a bunch of cool information about it, like the http status, who initiated it, what type it is, how big it is, how long it took all sorts of great stuff. And we'll get into some really cool ways that you can actually diagnose a lot of really cool things including server issues, all from the network panel the DevTools when we cover that in the network section."
          },
          {
            "time": "[00:09:29]",
            "text": "So yeah, you can measure all sorts of page load stuff, so you can look at how long each file took. But you can also look down here at these really important events. So when we use a tool like Google's Lighthouse, which we'll cover later or web page test, any sort of tool to measure the speed of our website."
          },
          {
            "time": "[00:09:45]",
            "text": "The two events that it's always looking for like when did DOMContent loaded file and when did unload file. And so those are both built right into the DevTools here where you can see when they filed. You can also watch your site load in real time. This is like a lesser known thing that they offer."
          },
          {
            "time": "[00:10:03]",
            "text": "So if you click this setting cog up here, not the top one for all Devtools, but this one over here for network settings you can do capture screenshots. And then if you refresh again with capture screenshots, you can actually see when we audit sites later we will actually be able to watch the HTML come in unstyled, and then an image load and then a font come in and restyle everything."
          },
          {
            "time": "[00:10:26]",
            "text": "So we'll actually be able to see kind of all that stuff happen in real time. So these are the screenshots of the site loading. And then we're able to inspect request and response data. So when you're working with JavaScript, and especially when you're working with API's, so if you're at work or if you're doing a side project and working with some API especially when it's not working, they'll often ask for data about the headers sent either by the API or to the API."
          },
          {
            "time": "[00:10:53]",
            "text": "And so if we take like this request for prismjs, and instead of looking at the response, I'm gonna make this a little taller. We go over here and we look at the headers, we can get a lot of information from it, so you can see what response headers were sent down from the server."
          },
          {
            "time": "[00:11:07]",
            "text": "And you can see what headers you sent in your fact requests. These are gonna be the default ones, cuz it's just a script source. But this comes in really handy where oftentimes at a job your service will have some kind of request ID, some way of identifying it."
          },
          {
            "time": "[00:11:22]",
            "text": "And the service team will often ask you for that ID, because they wanna be able to look it up in their logs and see what went wrong, something like that. So that's a really common example I face where I say, hey, this user status API is broken. And they're like, well, can you give me an example request and I give it to them."
          },
          {
            "time": "[00:11:38]",
            "text": "And they're like, okay, well, can you give me your request ID. So then I come into the DevTools, I refresh and I look for the request ID header. So that happens a lot."
          }
        ]
      },
      {
        "sessionTitle": "20-on-page-performance.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the on-page performance or the CPU lesson, and so we're gonna be messing with the performance panel. We're gonna learn about how to read the flame graph, how to find page jank, we're gonna learn about a bunch of really cool little tools that it has to kind of help out along the way."
          },
          {
            "time": "[00:00:19]",
            "text": "And before we get into that, I kinda wanted to talk about the way that we're viewing performance these days, so Google has this rail philosophy which I really like. It's the rail performance philosophy, and it's kind of four different things to think about, four different considerations. One is general app response time, so that would be, we've all been there, right?"
          },
          {
            "time": "[00:00:40]",
            "text": "Where we met on a website and we click a button and it doesn't interact in any way, I have no idea, what did it get my clicked and not get my click, these kind of things. So some type of response really quick for the user, so they know that you've received what they've done, the second category is animations."
          },
          {
            "time": "[00:00:57]",
            "text": "So whether it's a cool scroll animation, or something moving, or something really vital you're making a game or whatever, animation speed is really important especially cuz it gets really choppy. Idle time too, I'm sure you've all heard or people say this a lot, but JavaScript is single threaded, we're not going into too much JavaScript detail, basically it can't do multiple things at once."
          },
          {
            "time": "[00:01:24]",
            "text": "And so what we often do in our application code is we just, send it I need to do this and this and this. I have all these ideas of stuff I wanna do and we just in a big file, just do all this stuff, but if you keep the thread really busy, it's hard for your app to be interactive, right?"
          },
          {
            "time": "[00:01:41]",
            "text": "Your app is not interactive when the thread is busy and so, making sure that you batch up your work, which we'll cover a little bit. You can go a long way with making it so, I don't know if you've been there before, been on a mobile site and it's loading you try to scroll it."
          },
          {
            "time": "[00:01:53]",
            "text": "And you can't even scroll it, cuz everything is so clogged up it's so busy you can't even move it? That's what idle time is, and last one is load, so both the on page load, we covered with the network stuff, but also as you're changing things up, make sure the loading time is smooth."
          },
          {
            "time": "[00:02:08]",
            "text": "And Google's kind of broken it down in this cool way, so the zero to 16 millisecond, which is really, really small, everything feels really good to a user. Once you get 60 to 100 milliseconds, I think under 100 milliseconds they still can't tell the difference between immediate and 100 milliseconds or under."
          },
          {
            "time": "[00:02:33]",
            "text": "As far as the way our eyes and brains perceive things, but once we get up above 100, you can immediately feel it, right.? And so, I think one thing that's fine if you stick under 1,000, then it still feels like 1,000 milliseconds so one second, you still feel engaged in that task maybe."
          },
          {
            "time": "[00:02:53]",
            "text": "But you're definitely feeling that there's been a change, some requests and some perceptible amount of work happening. And then kind of over 1,000, it's a problem, things are taking too long, people lose focus and then once you get over 10,000, which is 10 seconds, you can see a lot of abandonment."
          },
          {
            "time": "[00:03:09]",
            "text": "So I think that the 0 to 16 is amazing, that's for our animations that should be our goal. 0 to 100 is totally fine for actions, if I click, add to cart and it takes 100 milliseconds to update the cart, totally fine it still feels good. 100 to 1,000 starts feeling, okay, maybe I asked a lot I can see that it's taking a while but it's still enough for people to keep focused, and I want you to go over that, people start losing focus a lot."
          },
          {
            "time": "[00:03:34]",
            "text": "So it's basically kind of the same thing that we did with network, except this is different because they are on the page at this point. But, with a lot of these very modern single page apps, the slowest loads sometimes aren't the initial load sometimes it initially loads fast and then you click something and it takes a long time."
          },
          {
            "time": "[00:03:51]",
            "text": "There's a terminology one, but I find this a really good educational terminology so, people mentioned page jank a lot on web performance talks. And it's interesting cuz it basically just means lag, or stuttering, or jittering, what the official definition is any stuttering, juddering or halting that user see as a site is not keeping up with refresh rate."
          },
          {
            "time": "[00:04:15]",
            "text": "But I remember a long time ago, I would always hear about refresh rates, hertz or frames per second or whatever, and I sort of get that you want more frames per second? You don't want less frames per [LAUGH] second, but I didn't fully understand, what's going on here?"
          },
          {
            "time": "[00:04:34]",
            "text": "And so I got this definition that I found on the Google Docs that I really like, so it's, okay, it starts with your display refresh rate. And so, most of the devices today refresh their screens 60 times every second. And in order to always look very smooth, the screen is hi, I'm about to refresh browser do you have anything, and the browser needs to be able to serve up a frame."
          },
          {
            "time": "[00:04:59]",
            "text": "So that's you can kinda think about constantly happening, your monitor is like, hey, I need to go. What do you have in the browser cool, here's a frame and that's happening 60 times a second. And so if you do the math on that every 16.66 milliseconds, you have to have a new frame ready to go, that is how often one new frame will go out the door, and so it would be tempting to say."
          },
          {
            "time": "[00:05:20]",
            "text": "So you need to never do so much work with an animation, that you don't have a new frame ready every 16 milliseconds. But the reality is there's actually, you don't get the full 16 because the browser has housekeeping work and stuff to do. So really, each animation needs a new frame to serve up in ten milliseconds, and if things get too blocked, where every 10 milliseconds, it doesn't have a frame to show."
          },
          {
            "time": "[00:05:43]",
            "text": "So for example, you're just asking for a full repaint constantly in the browsers trying to get it done. It won't have one for the monitor so, it won't give one and that results in dropped frames basically, so you'll be losing frames there. And so this seems like a lot if you're not doing heavy video game animations, but it's worth thinking about even if you're just doing a cool wave of animation, or a background, or a parallax scroll or something like that."
          },
          {
            "time": "[00:06:08]",
            "text": "There's all these ways that we can be pragmatic and we can try to be better about making sure that there's a frame to go every 16 or every 10 milliseconds, cool. So, think at that point, we can kinda open up and kind of peek in, just before we get into talking about jank and things like that."
          },
          {
            "time": "[00:06:26]",
            "text": "I just kinda wanted to explain, how we should think about it with the rail model, and what these kind of times mean as far as losing frames. So the Performance tab, so go over and we'll click on it, and there's kind of two options here, option one is to this one where you do a refresh and that'll show you the actual creation of the page performance."
          },
          {
            "time": "[00:06:48]",
            "text": "And option two, is just to start a Recording where you can do whatever you want, interact with something and then hit Stop, and those are four different use cases, right? One you wanna know, especially if you have a react or angular app, how does it assemble the app."
          },
          {
            "time": "[00:07:01]",
            "text": "What's the page performance like when it's bootstrapping, the other one is man this add to cart button takes a long time what's going on here? And so, if we do one here a Refresh and Profile and then hit Stop, we can kind of see all these different things happening."
          },
          {
            "time": "[00:07:15]",
            "text": "So, the screen is always for sure the scariest cuz there's just so much happening, but I wanna try really hard today to make it a little bit less scary, a little bit more understandable. So, I think if we view it in sections, that's one of the best ways we can do it, so I'm gonna try to kinda minimize, toggle up a couple of things here, okay?"
          },
          {
            "time": "[00:07:34]",
            "text": "So we sorta have three sections, we have this summary view down here, which I'm gonna minimize I'm gonna get to that one last. Then we have up here, this is a section I know it's a little bit hard to see my mouse, but above my mouse. And up here is a separate section, and that's showing three things layered on top of each other, one of them is the frames per second."
          },
          {
            "time": "[00:07:57]",
            "text": "So we'll be looking for big jumps in that if we lose frames, the other one is what the CPU spends its time doing. We'll see a bunch of different colors in there, which will relate to the summary section, and then the third one is just network traffic, and so that's one thing."
          },
          {
            "time": "[00:08:13]",
            "text": "So if you ignore all of these, and we just focus on this top thing, we can kind of, I'm gonna click here and I'm gonna drag an area to kind of Zoom in and focus on it. So I click and drag there, so we can kind of see that there's three different things going on, you can see across the bottom that the network is busy the whole time is our site's loading."
          },
          {
            "time": "[00:08:31]",
            "text": "It's doing stuff with this blue bar, you can even see right here, it stops being busy, as soon as everything is loaded there's no more blue bar. You can also see that there's two little seconds where we actually go up in high frames per second, there's two little jumps here, right one here and one here."
          },
          {
            "time": "[00:08:47]",
            "text": "And for the most part it's completely clear, and those frames per second jumps, tie in very nicely to the CPU doing work, and that's almost always going to be the case, right? The CPU is telling the browser to re-render stuff and you'll see stuff at the same time, and then the last part for this section is the colors."
          },
          {
            "time": "[00:09:06]",
            "text": "So if we zoom in even closer here, we can see there it might even be a little hard to see. Unfortunately I can't make this bigger but there's yellow, purple and green, then mostly yellow, little purple and a tiny bit of green. And if we go back to the Summary tab, we can kind of see what the colors mean, so the color yellow is script running."
          },
          {
            "time": "[00:09:24]",
            "text": "So if you had a for loop or Fibonacci generator, some JavaScript that's running, blue is network, so we don't see any blue that would be waiting on something to load. And then we get into rendering and then repainting, and so the rendering is heavy math that the browser is doing calculating."
          },
          {
            "time": "[00:09:40]",
            "text": "If you say this needs to be 200 pics by 200 pics and float left, then the browser has to figure out how to size it and where to put it. And then once it's figured that out, then the browser actually repaints that area of the screen so, I'm gonna take a little pause there."
          },
          {
            "time": "[00:09:54]",
            "text": "So we haven't gotten into the the big middle area, but we've looked a little bit at, okay. So we can reload or we can Record while we're doing stuff, and we get these kind of three sections up here, showing the frames per second. What work the CPU is doing and the network traffic, how are people feeling about that so far?"
          },
          {
            "time": "[00:10:13]",
            "text": "I know this is for years I just ignored this tab because it was too overwhelming for me so, if you're feeling pretty good about that, then you can see we did a refresh. And the page starts loading all this network stuff, you can even see back here it was just doing system work."
          },
          {
            "time": "[00:10:29]",
            "text": "Something the browser's doing as refresh happens, then we get into here and you can see, okay, now some work happens. There's some scripts running, frames per second shoot up a little bit, there's some rendering and painting that happens, and it kinda goes back down to just hanging out."
          }
        ]
      },
      {
        "sessionTitle": "21-performance-panel-page-jank-tips.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, so I think that sort of sums up this top area, which is like a pretty nice kind of high level view, what's going on? Are we having any issues? And we'll see in the exercise that the dev tools are really good when there are issues like when you're having page jank they just start highlighting stuff with red both up here and in the main section, which is really nice because you can just kind of open it up and see if there's problems."
          },
          {
            "time": "[00:00:25]",
            "text": "So now moving into this section, this one used to be less complicated, but I think it's way better now. It used to just be a single column for all the different stuff going on, but now you can see that all of these little columns are titled by different things that are happening."
          },
          {
            "time": "[00:00:43]",
            "text": "And so you can see like the network requests as like I request my fonts and things like that. And it has a lot of the data that we saw on the previous one like you can see the time it took and the priority it had which is really nice."
          },
          {
            "time": "[00:00:55]",
            "text": "That was the exact same stuff we saw on the Network tab earlier. You can also see all the frames and we'll take a look specifically that when we start doing some real GPU heavy stuff. The timings one we had already seen, right? That if you do any performance marking measure, the stuff will show up here which can be really nice."
          },
          {
            "time": "[00:01:16]",
            "text": "Actually don't know what the experience one does [LAUGH]. I've never used that one before. I think it's part of this. Yeah, I'm not sure. And then we can see the main thread here, right? So again, JavaScript being single threaded, this is where all the work will kick off."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we had like a big for loop or if we have, calculating something or you have react, parsing the JSX tree and generating stuff, see all that going on in here. We can check out all the rasterizing that happens on the site as it loads. We can see if any work that the GPU is doing, what work it's doing."
          },
          {
            "time": "[00:01:47]",
            "text": "And then we've got a couple of other things here that I honestly I'm not sure exactly what they do, but this like child IO thread and the compositor. So for the most part we're just going to be we use timings when we do our own performance market measure."
          },
          {
            "time": "[00:02:00]",
            "text": "The network, one is really helpful to associate. A big request came in and then I started getting page jank, but it's not as helpful when you wanna see what's what's really going on. But for the most part, we're going to just stick in this main thread. This is where we're going to be able to see a lot of stuff as it's happening."
          },
          {
            "time": "[00:02:20]",
            "text": "So let me close this for a second. So as we kind of get into things, I think it's, it's important to look at specific examples, which we'll do and we'll kind of figure some stuff out but it's also important to know understand some high level concepts. And the high level concepts are both things that you can do to avoid page jank and performance problems."
          },
          {
            "time": "[00:02:41]",
            "text": "But they're also they explain a lot about what frameworks do and like why these frameworks exist and how they work under the hood and things like that. And so the first thing that you can do is there's an API on the window object called requestAnimationFrame. This is really great."
          },
          {
            "time": "[00:02:56]",
            "text": "And the basic idea is that instead of doing a thing, like changing the size of something right? By doing like dev.style.width equals 500 pixels, you can take that and you can pass it in as a callback to request animation frame, that same thing. And what that says is I do want you to do this, but you don't need to interrupt everything and do it."
          },
          {
            "time": "[00:03:18]",
            "text": "Before you do the next window, repaint, please do a request animation, please do this piece of task. So like an idea of how things can go really awry is this code up here. So this looks like pretty normal where you're like, you grab a thing from the DOM, you grab its height, and then you change its height and then you grab another things height and you change its height, and you just kind of like doing your work, right."
          },
          {
            "time": "[00:03:39]",
            "text": "You're just like grabbing three things and changing their heights or whatever, but the order that they happen in really matters because when you do read that it can cache that. So now anytime you refer to h1, it's got that value cached, right? So it doesn't need to hit the window again."
          },
          {
            "time": "[00:03:55]",
            "text": "But then you do a right it invalidates the layout right now we have no idea how tall this thing actually is rendered to be. And so when we if we write vanilla code that interacts with the DOM, we can get into this bad habit of like doing reads and writes back and forth."
          },
          {
            "time": "[00:04:09]",
            "text": "And we're never able to cache those values like we're always just wiping out the or invalidating the cache. And then rereading and rereading and rereading. So one approach that you could do is you could like pump all of these reads and writes into a request animation frame. So the kind of way I like to look through it is like let's say you have a site by yourself and you're aware of this."
          },
          {
            "time": "[00:04:31]",
            "text": "So you write this code, you're like, This, this won't do. I kind of wanna do all my reads together and then all my rights that's like a that'll make things a little better. So you do that. But then you add a bunch of other people onto your team."
          },
          {
            "time": "[00:04:44]",
            "text": "Now it's gonna get really annoying. It's like no, you can't just read the DOM, you got to go over here. And this is where we do our DOM reading. This is where we do our DOM writing, it gets really obnoxious. So what you could do is you could put all of those reads and writes into a request animation frame so that way, you're only invalidating the layout right before it gets repainted anyway for another frame."
          },
          {
            "time": "[00:05:04]",
            "text": "But the important takeaway here is maybe not to use requestAnimationFrame all the time. But the important thing is, this is one of the really cool benefits that using a front end framework will do is all of these frameworks will do this stuff for you. So if you're like in react and you say, Set the height on something or rerender, a new component, it won't interrupt to do it."
          },
          {
            "time": "[00:05:22]",
            "text": "It'll wait until the next animation frame fire, so I think the bigger takeaway here than using this API all the time is that this is one of the really cool benefits from using some open source front end framework is they'll do stuff like this for you. Another thing you can do web workers, so if we load a page and we see in kind of, this like center area here, if we see a bunch of big yellow JavaScript stuff like I had an example here of like, calculating Fibonacci or something like that, where it's like, it's really busy, the process is really busy."
          },
          {
            "time": "[00:05:56]",
            "text": "You can offload that stuff to a web worker, which essentially gives JavaScript the main thread back to handle the actual website. There's a lot of cool talks on web workers and stuff like that I have a very basic example. So you can like grab two things like you can grab an input form and a feet on a div to display some stuff in If you can check if the window dot worker API exists, like if this browser supports it, and if it does, you can instantiate a new one."
          },
          {
            "time": "[00:06:23]",
            "text": "And then you can basically send messages with a post message command and you can receive messages with an on message command. So for example, like a contrived example, if you have a bunch of cool animations on your screen, but you have to calculate a really big number If you don't use a web worker when the calculation's happening, those animations are going to just stop, right?"
          },
          {
            "time": "[00:06:41]",
            "text": "They're gonna freeze there because the main thread's being used to calculate the number. And as we mentioned a little bit ago, you could also get around this by moving all those animations into CSS, which would free you up there. But in lieu of that, you could take the big calculation, you could toss it to a web worker that'll split off another thread, do your calculation and then answer back."
          },
          {
            "time": "[00:06:59]",
            "text": "Meanwhile, the animations go smoothly. Web Workers are a whole separate topic. They have restrictions like they can't mess with the DOM. But they're really great for kicking off any kind of big tasks like If you do any kind of Frontend processing for your ads or something like that, which ones got clicked on, which ones got seen and you have all this math to do."
          },
          {
            "time": "[00:07:17]",
            "text": "That's a great example of when to use a web worker to free up the main thread. The next one use a framework. I meant to put an asterisk here, this is a warning. I'm not a gigantic framework proponent. I'm not like you should always use some framework for your apps."
          },
          {
            "time": "[00:07:32]",
            "text": "Not at all. But I do think if you're getting into a problem where you're trying to do something like anything with animation heavy working on a game working on a really flashy website, and you start seeing these page jank problems, then using some kind of framework and doesn't have to be a react style."
          },
          {
            "time": "[00:07:49]",
            "text": "It could be like a D3 style or something like that. One of the big benefits is they will batch up this work for you and do those things. And then the last thing is just like again, kind of back to the Network tab, the idea of reducing complexity."
          },
          {
            "time": "[00:08:03]",
            "text": "So this is like, you can be amazed at all the things like even like a long, CSS selectors like, DIV UL Li span ,or something like that take more processing power than shorter UI like, selectors like a class name or something like that. Just like kinda a million things that ,you could do."
          },
          {
            "time": "[00:08:19]",
            "text": "But I think the big ways to do it are,using web workers for expensive stuff and using requestAnimationFrame for batching up all of your writes and, reads and things like that. I know those are a little weird because they're covered but not covered in depth like this isn't going to be on web workers or RIF."
          }
        ]
      },
      {
        "sessionTitle": "22-layout-thrashing-exercise.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We have an exercise here. This one starts to get a little bit harder. So if folks are struggling with it, there's like absolutely no problem with just waiting until we go over the whole thing together. But this is like a really cool opportunity. I would just suggest to at least play around with the Performance tab and start looking at it."
          },
          {
            "time": "[00:00:21]",
            "text": "So the [LAUGH] idea is it's about layout thrashing. Well, we've been talking about it's about page jank, and things like that. So you can see right now, we've got these ten little Frontend Masters logos, and they're just animating around, on the screen here. And they're really smooth, at least for my screen."
          },
          {
            "time": "[00:00:35]",
            "text": "They're very smooth. And as you start adding more, and more, and more, I have a very new laptop, but, it gets to the point where they're very not smooth. I'm not sure how it's coming in, but like on my screen, they're like very jittery. And so, this is a kind of a multi part task."
          },
          {
            "time": "[00:00:52]",
            "text": "I'm going to remove some sort of back down. So the first one is to make it jittery, keep adding 10 or 100 until it gets jittery. And when it's jittery, like we'll add a couple like this, we'll open up the dev tools. We'll go to performance and we'll record like just one second, let's say."
          },
          {
            "time": "[00:01:08]",
            "text": "So another like tip for when you're doing the recordings is there's a lot of information to process. So the shorter that you can keep your recordings to the better. If you try to record like 10 or 15 seconds of stuff, you'll just have way too much data it'll take too long to parse, and it'll be too much to look at."
          },
          {
            "time": "[00:01:26]",
            "text": "So the exercise here is to get it to the point where it's janking to do a performance recording on it. And then we'll want to one, look at all the ways that Dev Tools tells you. There's page junk, which I'm sort of kind of giving away here with like these big red bars and things like that."
          },
          {
            "time": "[00:01:45]",
            "text": "So that's one, see if we can figure that out. And then the other thing is, can you figure out from just the main thread view, what function is causing the page junk? Just to look at, read through it, scroll up and down. One thing I should mention is navigating is a little bit tricky here."
          },
          {
            "time": "[00:02:01]",
            "text": "So let me go back and record again. So I'll just record for one second and stop it. So we're just gonna be looking in the main thread. But navigating is really hard to do. So if you scroll like up and down, you'll see that it doesn't actually move you up and down."
          },
          {
            "time": "[00:02:17]",
            "text": "It moves you like you're zooming in. I don't know if you can see these bars up here. So as what I would think would scroll me down actually zooms in and zooms out over a specific section of time. And so what you'll wanna do if you wanna actually scroll up and down, like here or something like that, you'll wanna hold Shift while you scroll, and that'll allow you to actually move up and down the call stack."
          },
          {
            "time": "[00:02:39]",
            "text": "So you can see this whole thing, this is the whole second of me running. You can zoom in on a little bit. We should be able to see what type of stuff was happening here. This is on the optimized example still, but there's only ten of them. But you can see that the frames per second are high, they're looking pretty good."
          },
          {
            "time": "[00:02:57]",
            "text": "You can see that there's a lot of free time, that's those slashes through, and the time that is spent it looks like it's spent between, if we go back to this summary, and drag it up. Between scripting and rendering looks like it's pretty evenly spent. So the idea here will be to do the exact same thing, but after you've hit add 100 enough times so that there's actual junk happening and take a look at how different it looks."
          },
          {
            "time": "[00:03:18]",
            "text": "How you can identify that there's definitely a problem here and see if you can kind of figure out just by peeking around in this main thread, what tasks are happening when the page jank is starting to happen?"
          }
        ]
      },
      {
        "sessionTitle": "23-layout-thrashing-solution.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So we already kind of looked at what it looks like on normal. So let's add, I think for me, it's adding 400 or maybe 500, I start seeing some really significant junk. So I'll do the recording for one second, again, always recommend keep the recordings as small as possible cuz there's just so much data."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really cool, so, hopefully this should look very different this time, with all of that stuff, than it did the last time. And there's a couple of things I wanna draw your attention to one, is the red lines across the top, in the frames per second. So, those red lines are where it lost a frame, right?"
          },
          {
            "time": "[00:00:32]",
            "text": "Or it dropped a frame, so, it should be really obvious when you load up a worksite or something like that, get it in that state where you're worried about it, do a recording. And you should see, Chrome is like telling you hey, there was some serious issues here."
          },
          {
            "time": "[00:00:46]",
            "text": "In a very similar vein, under the experience panel here, you see this layout shift in red, which I'm not 100% sure on what it means, but it definitely relates to the frame dropping in some ways. Something's going on there, another thing that you can see is that whereas before, the chart here for the CPU was mostly small mountains with a lot of free time, though white and gray slashes."
          },
          {
            "time": "[00:01:12]",
            "text": "And now it's basically 100% CPU for the entire time it's running the app. You can still see it kind of comes in these waves, there's little bounces, but it's just a massive amount. So if we go ahead and we expand the main tab, we can kind of see every app has its own very unique personality, right with how things are working."
          },
          {
            "time": "[00:01:35]",
            "text": "And so you can kind of see here that what keeps happening is every 100 milliseconds some tasks is getting fired, and something is going on that's causing again, you can see more red saying that the task took too long. There's probably junk or whatever. When you're looking at the thread, what you don't care about is how tall things are."
          },
          {
            "time": "[00:01:57]",
            "text": "That's fine because that's complexity of your code is all it is. So if you have, my example with debugging where you have function one calls, function two calls, function three, let's say you just had 100 of those, you would have a really long execution stack, but it would happen really quickly cuz all it's doing is calling another function."
          },
          {
            "time": "[00:02:15]",
            "text": "So when you're looking at this thing, if it goes up and down 100 or something like that, that's nothing to worry about. What you do wanna worry about is the ones that are too wide, because as we said before, every 16 milliseconds it needs to have a new frame to send basically."
          },
          {
            "time": "[00:02:31]",
            "text": "And so you're looking for long wide ones or the problematic ones and the really long call stacks are not a problem. And so you can see here, we only had 16 milliseconds to produce this frame. And this animation itself took 129 milliseconds so that is a lot of drop frames happening there."
          },
          {
            "time": "[00:02:50]",
            "text": "In a similar way, the way that you can find the problematic function or the problematic code is to go down the call stack and find the last long one before they get really small. So if you think about it, it's if you have a if you have a function called Fibonacci, and it takes forever to generate a Fibonacci number."
          },
          {
            "time": "[00:03:10]",
            "text": "And you wrap it in a function called foo, and all foo does is call Fibonacci, foo will look long too even though it's not really doing anything cuz it's the parent of a long function, right? And so you'd see foo Fibonacci but what so you wanna do is you wanna keep looking at the long ones until you get to the last long one who itself only called a bunch of short ones, because the short ones, aren't gonna be a problem."
          },
          {
            "time": "[00:03:34]",
            "text": "And then you know the last long one is going to be the closest that you can get to the problematic function. Does that make sense, I know that it's kind of a confused, so in this example, we see that the task took too long. And we wanna know what caused and so we can see this is long, long, long then we get to App update long."
          },
          {
            "time": "[00:03:51]",
            "text": "And then after app update, if we were to zoom in here, we would just see that it's calling a million tiny any little short ones. So, if we wanted to know what function was the problem here, app update is the last long one before a bunch of the short ones."
          },
          {
            "time": "[00:04:06]",
            "text": "And then you can do cool things, so you can click on app update if we wanted to kinda see what's going on. And we can bring back up this summary view here, once we click on any cell you can see this is changing. So we can click on the last long one and then we can go and open the actual file where the function got called boom here."
          },
          {
            "time": "[00:04:25]",
            "text": "So again, from the performance, you find whichever cell that you wanna investigate, and then you look at the summary, which you might have to drag up a little bit and then you click on the file name. So one thing that you'll notice that's really cool is after you've done a performance audit, when you look into sources, Chrome will save how long the function took to run in the sidebar here, of all the stuff that it was able to see."
          },
          {
            "time": "[00:04:48]",
            "text": "Which is really cool, so you can see this app update took a super long time, took like well over a second, almost 1.5 seconds. And then as you start looking into it, so that basically gets us to the JavaScript code that's causing our problem. In this case, we can see that it's doing a lot of reads and writes right, where it's going through each one of these little Chrome Dev Tools things and it's looking to see so it's reading them to see if it has a class name."
          },
          {
            "time": "[00:05:16]",
            "text": "And then if it does have that class name, it's reading them again to get the offset from it. And then it's reading the current position against the max height of the screen that it's in. So it's doing really, really heavy calculation right and it's doing them in an inefficient order where it's like read, write, read, write, read, write, just like we saw before."
          },
          {
            "time": "[00:05:35]",
            "text": "And what's really cool is that there's this optimize button on here and literally all this is doing is it's batching those things so that they're done without invalidating layout just like we were talking about in the example before. And so even with this many hundreds and hundreds of them, if you click optimize, you can see that they instantly smooth right up."
          },
          {
            "time": "[00:05:54]",
            "text": "So it's not just don't do heavy lifting, the web is very capable of doing heavy lifting. But it's important to know how these layouts happen because if you optimize around them, like do all your reads and then do all your rights, and you put both of those in request animation frame you can get a really smooth animation even though it's still doing a lot of really heavy work."
          },
          {
            "time": "[00:06:13]",
            "text": "How are folks feeling about that? Any questions?"
          },
          {
            "time": "[00:06:13]",
            "text": ">> You said something about getting the opportunity to dig into the call stack. So, cuz when we clicked on thrashing.js that did take us to sources."
          },
          {
            "time": "[00:06:13]",
            "text": ">> Right."
          },
          {
            "time": "[00:06:13]",
            "text": ">> But there was nothing in the call stack on the right. So, I think I'm missing a piece of the puzzle."
          },
          {
            "time": "[00:06:32]",
            "text": ">> Yeah, no, absolutely, no, that's great. So yeah, the question was about that I mentioned earlier that when we're looking at performance, we'll be able to look into the call stack of how it got there. But when you clicked on one like we did, and you clicked on the link, which is what we had done earlier, it didn't actually take you to sources with a call stack, right?"
          },
          {
            "time": "[00:06:52]",
            "text": "We got to App update and we clicked on this and it was not paused at a debugger. So we've got two options here, option one is we can now that we've gone to sources, we can set a debugger, right? We can set a breakpoint there and then let it hit again and when it hits again, we'll get the full call stack over here."
          },
          {
            "time": "[00:07:08]",
            "text": "So that's option one, option two is back over here on this performance panel, where we can actually see where these things came from, this one's not a good example because it's literally just animation frames are firing. Every time, but If this was wrapped in a function or something that you would still see the call stack here as well."
          },
          {
            "time": "[00:07:30]",
            "text": "So it's kinda up to you if you just want to peek at it, the call tree can be really good for that if you just wanna see where it came from. If you really wanna understand it better then I would recommend clicking on the file name and then adding app update is here, so then adding one here and then you're able to see."
          },
          {
            "time": "[00:07:46]",
            "text": "But again, this example is not great for that because it's just request Animation Frame firing. But if you did have something calling other stuff like react generating, you will see that all here in the call stack."
          }
        ]
      },
      {
        "sessionTitle": "24-running-node-js.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Last thing I wanted to show before we move on, which is really cool and people have asked about this is that and this used to be much harder but since node.js is just a wrapper around the js. Which is the same JavaScript engine that chrome uses, you can actually very very easily run your Node.js apps through the devtools as well So I'll demo that."
          },
          {
            "time": "[00:00:20]",
            "text": "So basically, I'm just going to go to my terminal and I'm going to kill the app that I currently have and clear the page. And then instead of running, so I was running NPM start, which is set to run node server.js. This is how I've been running the app."
          },
          {
            "time": "[00:00:36]",
            "text": "You can now go and you can change it to do node dash dash inspect. And do the same thing. So it'll still load the site just like normal, but now when we open up the devtools, we'll see this little node.js icon up here. And if we click on that, we can actually see it pops out its own."
          },
          {
            "time": "[00:00:52]",
            "text": "Kind of got two devtools, right? You've got devtools inception going on. But you can click on like profile, for example. And you can do a full profile and then we'll like refresh the app and then we'll stop the profile or something like that. And so you can do all of these."
          },
          {
            "time": "[00:01:08]",
            "text": "Let me move it over to the flame chart that we're used to. You can do these things. You can actually watch my little Node sample app started up right where it's like it's a fast defy app. And it's like walking ASDs as it walks the mark down all this like really cool stuff."
          },
          {
            "time": "[00:01:21]",
            "text": "So doing it with like a web server is like pretty cool, but like one thing you could do that would be really interesting is if like you're using Web pack, and your build times are slow. You could actually do run node inspect and then call web pack and then you could open it up in here with a profile and like do the same exact thing, right?"
          },
          {
            "time": "[00:01:38]",
            "text": "You can walk any kind of node command line application and see it. So I have like a little example that I'll just do with you all, but you can feel free to follow along with but in the server.js file, I have this like silly little function commented out, which is FUBAR so you can uncomment it."
          },
          {
            "time": "[00:01:55]",
            "text": "And then you can go up and in the get lesson page, you can uncomment it being called. Now save that, now go back to my terminal, and I'll start node with the inspect flag. And then I'll go back to my devtools. And I'll click the node icon again here and I'll start recording then I'll go back here and I'll refresh the page and then I will stop recording."
          },
          {
            "time": "[00:02:18]",
            "text": "And we can actually see like inside this fast defy which is the framework I'm using get this like FUBAR function, so we're actually seeing like the node server trying to process stuff. And you can see it's it's reading and markdown, and then it hits this thing. So you can do a really nice, just like we did with the front end code."
          },
          {
            "time": "[00:02:33]",
            "text": "You can do it with all your back end code. Here's my server.js file. Here's how long it took to do this silly thing, all that stuff. So this is really cool, because when you start looking into it, there's like a lot of stuff that we use day to day that's just a node app."
          },
          {
            "time": "[00:02:45]",
            "text": "And so just the idea of being able to run, the Chrome devtools that you're used to on the node app can be really cool."
          }
        ]
      },
      {
        "sessionTitle": "25-memory-leaks-memory-heap-snapshots.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So the last lesson around performance is going to be on memory. Another call out that I just wanted to make before we go too much further is that I can't remember exactly when I think very soon there's going to be another course coming in front end masters."
          },
          {
            "time": "[00:00:15]",
            "text": "It's on the work schedule for advanced dev tools stuff that Omar is going to be running, he does all sorts of good stuff. So if you are like these are meant to serve as kind of like your introduction into like, okay, I get what the performance tab does and I know what I'm looking at and I see paging and stuff like that but if you're interested in finding out a lot more on like, he's going to do I think real life case studies and like a bunch of really cool intricate stuff into like memory, CPU, network, all that stuff."
          },
          {
            "time": "[00:00:40]",
            "text": "Stay tuned for his class because it's coming pretty soon. So yeah, the basic idea with memory. So JavaScript as a lot of people know has garbage collection to it, right? So you don't need to actually declare and purge your memory. But with garbage collected languages, you can end up with what we call memory leaks, but they're basically like stuff that you've forgotten about."
          },
          {
            "time": "[00:01:04]",
            "text": "So like, one example would be if you make too many DOM nodes, and you don't clean up after them, so if you're like making a table, a lot of people use like virtual scrollers. And what those will do is they'll render like 20 frames of the table and then as you scroll, it'll reuse the top ones and replace them in the bottom, things like that so you don't end up with a huge DOM."
          },
          {
            "time": "[00:01:25]",
            "text": "But if you didn't use a virtual scrolling, you just tried to render like a million table rows or something like that. It would take a lot of memory and you'd start noticing a real performance hit after a while. Another thing that can get you is, this one's a little bit tricky."
          },
          {
            "time": "[00:01:38]",
            "text": "But when you think about code, like you're often interacting between the DOM and JavaScript, like we've been doing it a lot today. So for example, we'll like in JavaScript will do document.create element LI right? And so we have a list item but it's in memory only it hasn't been attached to the DOM yet."
          },
          {
            "time": "[00:01:58]",
            "text": "And then we'll do that LI that we did, we'll do like body.add child and we'll pass that and now LI it's in the DOM. And so one thing that can happen is that those references to the in memory ones that you never did put in the DOM or you put in you took out if you don't know those out or delete them somehow those can just grow and grow in memory as well."
          },
          {
            "time": "[00:02:18]",
            "text": "And so the kind of most important thing that you want to do is like, establish like, if you have a memory like that's like the first step right? Before we go diving too deep into it, so we really have like three tools for it. And one of them is a caveat of the course because it is in Chrome, but it is not part of the Chrome Dev Tools, but it is a very cool tool that Chrome offers."
          },
          {
            "time": "[00:02:40]",
            "text": "And so that one is the Chrome Task Manager. So if you go up to the top right, then you click on the three dots, and then you go to more tools Task Manager. You get this really cool thing that I didn't know existed for a super long time."
          },
          {
            "time": "[00:02:53]",
            "text": "And so this is basically like your activity manager, but just for what Chrome's doing. So it'll show all the tabs that you have open. It'll show all the services that it's running everything like that. Now, it doesn't work right off the bat because it just shows its memory footprint and its CPU."
          },
          {
            "time": "[00:03:08]",
            "text": "But what we really wanna know is do I have a JavaScript memory leak, so we can right click on the headers here, and we can go over to JavaScript memory and we can add that new column here. And so now we've got JavaScript memory so we can see that the right now my front end masters tab with the chat is taking up a lot of memory."
          },
          {
            "time": "[00:03:26]",
            "text": "And then my Google search is taking up some memory. My tab is taking up less memory, those kind of things. So one thing that's cool, let me kind of reorganize stuff a little bit here. So I'll close these just to kind of simplify stuff. And then I'll drag, let me grab hold of my browser here."
          },
          {
            "time": "[00:03:45]",
            "text": "I'll drag this over, and then I'll kind of set this up. So what I want to be able to do is kind of do both at the same time, right, I want to see my tabs. And I also want to see the memory usage. So if we take like this tab here, it's using two megabytes of JavaScript memory basically."
          },
          {
            "time": "[00:04:01]",
            "text": "And then I made all these buttons that make a bunch of DOM nodes or make a bunch of detach nodes or something like that. So we see that it's at 2700. And as I start kind of clicking on it takes like a second or two, we can see it spike up really high right to 6000."
          },
          {
            "time": "[00:04:16]",
            "text": "I know that's really small. I can't find a way to make the text bigger. But this is like one cool thing you can do. So to be a memory leak, you would open up the task manager, enable JavaScript memory, highlight the tab that you're worried about. And then do whatever you're worried about."
          },
          {
            "time": "[00:04:30]",
            "text": "Are you worried that it has a memory leak is it just sits there, are you worried about that has a memory leak as users interact, do whatever it is, and kind of keep track of this because ideally, all the memory that we allocate, we should also be purging, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "So if we're creating DOM, we should destroy DOM. If we're creating a big array, we should get rid of that big array, those kinds of things. So you should always be able to find it that way. Another way that you should be able to find it ,let me fullscreen this again and refresh, is actually back on the Performance tab from the CPU one."
          },
          {
            "time": "[00:04:57]",
            "text": "One of the reasons I think that it seems so confusing is because it's just doing so much, but when we're on the Performance tab, we can click on memory here. So if we do a recording, and let's say we go back to our page and we do some stuff and clicking on these buttons that I know use a memory then I stop it."
          },
          {
            "time": "[00:05:15]",
            "text": "We can see down here these kind of gains in memory and so memory usage like if it goes up and over and back down is never a bad thing because it's there for us to use, that's totally fine. What you always want to look for is this kind of jagged, like sawtooth."
          },
          {
            "time": "[00:05:29]",
            "text": "If it's like climbing, that means it's seeing kind of using something, it's not purging, and then it's using more and more. So you can see this kind of pattern every time I click the button, it consumes more memory. It also gives us kind of a nice breakdown. So it'll show us what memory is used by the JavaScript heap, what of it is documents, what of it is like DOM nodes being created, event listeners or GPU memory being used."
          },
          {
            "time": "[00:05:51]",
            "text": "So that can kind of start getting us in the right direction. We use the task manager to see if we have a leak, just watching the JavaScript memory. And then we can use the performance profile to see what type of thing is causing this issue. And then the third thing we can use is, of course, the memory panel itself."
          },
          {
            "time": "[00:06:09]",
            "text": "So let me dock these back to the bottom. So we've got three options here for viewing memory. One of them is just to grab a heap snapshot. So it just grabs everything that's in memory at the time and shows it to you. So for example, I could do a snapshot like this, it takes a second and it shows this big list of items."
          },
          {
            "time": "[00:06:30]",
            "text": "So this list we're going to be looking at in a couple of different ways, but the basic idea is that we'll see the type of item like what it was constructed by like a UL list item or just an internal system stuff or an array, things that should be familiar and then it'll show these couple of things that show shallow size, distance, and retain size."
          },
          {
            "time": "[00:06:50]",
            "text": "Distance for the most part we can ignore. It means distance from the window object, from the global, basically like how far deep it is. But shallow and retain size are really important. So the shallow size is like, how big is that thing? So if you have an array of a million, how big is an array of a million?"
          },
          {
            "time": "[00:07:09]",
            "text": "Retain size is important because of how garbage collection works. So garbage collection works via this mark and sweep process. I don't know if anybody's ever heard of mark and sweep before. Basically it grabs everything that there is and it gives it like a flag like false. And then it starts from the window and it walks every single thing that the window is pointing towards and everything it's pointing towards and everything all the way down the tree."
          },
          {
            "time": "[00:07:32]",
            "text": "And everything it touches, it flips the false to a true. So it's like I've seen you, I've seen you. And then at the end of the pass, anything that still has a false flag can be deleted, right? Because nothing's pointing to it. And so the idea again being if you have an array of a million and you have a function called foo, and all food does is it points at that array of a million."
          },
          {
            "time": "[00:07:53]",
            "text": "So it's like array equals another big array of a million, then array of a million is the big thing, but since foo is pointing to the array of a million, the array of a million will stay as long as foo has something pointing to it. So it kind of like it's basically you can have like an object, and the object can be pointing to a key that has an array that's really big."
          },
          {
            "time": "[00:08:17]",
            "text": "As long as that object stays in memory, it has to keep everything the object points to in memory too, because it doesn't know when those could be accessed. And so what can happen, with these DOM nodes that I talked about earlier, as you can accidentally still have a reference to something that you don't care about anymore."
          },
          {
            "time": "[00:08:33]",
            "text": "So like a good thing would be like you create the LI, you stick it in the DOM, but you still have that LI. If you never know it out, it'll just stay in memory like forever basically. And so, that's all a long winded way of saying that you'll get two different things, one of the shallow size is the actual size of the thing, the retained size is how much memory could be free if that thing were deleted."
          },
          {
            "time": "[00:08:55]",
            "text": "And the difference being like you could have an object with just two keys on it so very small shallow size, but one of those keys points to a gigantic array of like a million so the retain size is very big, because the only reason that array is sticking around is because of your object."
          },
          {
            "time": "[00:09:10]",
            "text": "Does that make sense, I'm gonna pause for a second on that. So that's like basically as long as something has a pointer, it stays in memory. So if you add anything to the window object, as long as the window object stays, which it always will, that thing stays."
          },
          {
            "time": "[00:09:22]",
            "text": "And so you can kind of get this difference in like how big is the thing? Okay, but how much memory kind of clear up if I deleted that thing, meaning that thing and anything that it's the only pointer to, so yeah, back onto the memory pad. So we've got the heap snapshot, which is great."
          },
          {
            "time": "[00:09:36]",
            "text": "Another tool that we have, which is really useful is allocation over time. So we can basically see when memory is being allocated over a period of time, sort of like the performance or we're measuring across time. So like you could demo this pretty easily by starting a time allocation, starting record and then hitting one of my buttons and will see that every time I hit a button a whole bunch of memory is allocated."
          },
          {
            "time": "[00:09:59]",
            "text": "And we can also see that it never goes back down. It's not like a shape like that. And so if I stop my recording here, I can see, let me make this a little bigger. That things are getting bigger. I can sort by shallow size I can see."
          },
          {
            "time": "[00:10:12]",
            "text": "So the system in parentheses that's like its own stuff. But I can see that these arrays are really big and they're full of these detached HTMLLIElements. So if I were to look into the code just so we can kind of get a picture of what we're doing that's causing this it shouldn't be too much of a surprise that we're making a whole bunch of UILIElements and we're never knowing them out."
          },
          {
            "time": "[00:10:32]",
            "text": "So like we're attaching them but we're not getting rid of them in memory, they just stay in memory. Is that kind of making sense? So I know it's contrived, like a for loop of 1000, where you're creating elements or whatever, but the idea being that you can kind of start in the memory panel, see if you have a leak or how much is being used."
          },
          {
            "time": "[00:10:50]",
            "text": "You can also see what's taking it up over time. Cool. So the last thing, which was probably like the most common question I got, last time I did the course. But Chrome has added a really cool feature for it is like, people would always ask, okay, like I see I have a leak."
          },
          {
            "time": "[00:11:06]",
            "text": "I know that there's a problem. How do I figure out what it is, like what's causing it? Where's it coming from, because you have these big complicated apps. And so chrome added this really cool thing, this allocation sampling. And so what this does is it lets you kind of record again over time down here, but what it's going to do is instead of, just let me go ahead and stop that, it's coming up."
          },
          {
            "time": "[00:11:32]",
            "text": "Let me delete this, let me start one and then do something that takes up memory. I think the problem I keep running into is, if no memory is being used, then the profiles will be empty. And this is just a flat page. So start one, click one of the buttons."
          },
          {
            "time": "[00:11:48]",
            "text": "Now this is actually going to tell you instead of just all there's a bunch of arrays, or there's a bunch of UlLIEelements, it's going to tell you what function is causing that problem. This is like great. It's like something I've been waiting for years and years because a lot of times complicated apps are like, yeah, I see that I have event listeners."
          },
          {
            "time": "[00:12:06]",
            "text": "And there's a bunch of detached event listeners, but I don't know what's creating them or something like that. So being able to go from memory allocation to actually pinpointing you in the sources panel which function is causing things is like a superpower. It's really convenient. So yeah, I think the kind of TLDR with memory is the first way to do it is get the task manager to even see if you have a problem."
          },
          {
            "time": "[00:12:31]",
            "text": "Like is it allocating a lot of memory, and if so, is it going up over time? If it does having a problem, then I would go into the Performance tab and do a performance recording and then I'll get you a little bit of like a visual on like what type of problem is it?"
          },
          {
            "time": "[00:12:43]",
            "text": "Is it like JS heap? Is it DOM nodes? Is an event listeners? That kind of thing. And then coming in here and actually taking a look at like, what's allocating? How much is it eventually going for the allocations snapshot so you can see what JavaScript is causing those things."
          },
          {
            "time": "[00:12:59]",
            "text": "It won't always be this clear obviously, usually you'll have a couple different things that are big and taking up room. But this can really help you like narrow down what's causing stuff and what's not going away. One thing I forgot to mention that you can do too, is there's a forced garbage collection button here."
          },
          {
            "time": "[00:13:14]",
            "text": "So another thing that would probably be useful because sometimes you allocate memory for a long time, but you do get rid of it eventually when garbage collection happens. So for example, if we go back to the heap snapshot, we can start a recording. And then we can like generate and then we can try to garbage collect and we should see it go back down to zero, but since it's not, that's like a way we can be sure that there is a leak, right that there's not stuff."
          },
          {
            "time": "[00:13:40]",
            "text": "We're not using it and garbage collection doesn't take it away. That's a problem. Yeah, so the question is when you're looking at memory in the Performance tabs, you're looking at kind of the chart at the bottom, are you looking to see if the JavaScript heap goes up and down or if any of them are not going down?"
          },
          {
            "time": "[00:13:57]",
            "text": "And it's really if any of them are Jiggs sign up, it doesn't matter which one, then that's some sort of problem because they should all go back down to a stable level after any big allocation should always go back down. Or at the very least, it should go up and go flat."
          },
          {
            "time": "[00:14:13]",
            "text": "Like, let's say you have an app where you just rendering like 10,000 things and that's just what you're doing. So it should go up and then it should stay, but it should not keep climbing like the only reason it would be climbing is if it was miss properly allocated or it's just not being garbage collected."
          }
        ]
      },
      {
        "sessionTitle": "26-what-can-slow-down-a-website.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's always fun, like it's fun to go to a new site and just give it like some kind of audit, like a very high level view of like, what's going on with it, i remember this one time as an antidote, i was doing an interview. I was interviewing for a job and one of the questions was what can slow down a website [LAUGH] I've only guys ranted for like 45 minutes I was like kind of disappointed when the interview was over."
          },
          {
            "time": "[00:00:23]",
            "text": "I was like I still have more things, so it's kind of wanted to talk through some of the things that I've seen very commonly slow down websites, and I always kind of group it into like back end and front end stuff. Obviously, those groups they don't really hold true today as things have gotten very complicated [LAUGH] when you have server less sites or you have a front end service team and then a back end service team, but I really mean you have the user's computer and then you have where your code is stored at your data center and kinda one or the other side."
          },
          {
            "time": "[00:00:55]",
            "text": "So when you think about back end things that can slow down websites, Database calls can happen a lot like me the database is an index property. I properly I know Brian Hall just did like a huge course on front of masters on introduction to databases. Sure it covers a bunch of great stuff on like being efficient queries, but I've seen it often where you have a lightning fast server but a really slow my SQL database and that's just going to slow down the request."
          },
          {
            "time": "[00:01:19]",
            "text": "The server can be slow Or there can be not enough servers, it's just overwhelmed and it's having a hard time responding. The network can be bad, this can kinda both into front end or back end, so either some calls between services can be too slow network connection or from the client to the server can be slow."
          },
          {
            "time": "[00:01:40]",
            "text": "And those are really interesting to fix because there's lots of different things you can do, you can put your static assets out on a CDN can be great. There's also all sorts of cool serverless technologies that let you host your code in multiple places, basically like a CDN for dynamic stuff."
          },
          {
            "time": "[00:01:58]",
            "text": "A lot of bigger companies will have data centres located strategically all over the world, or they'll buy like a small presence like a pop or something like that in certain areas to make connections faster. There's a lot of interesting stuff you can do there, and then the last thing which you talked about a little bit is compression."
          },
          {
            "time": "[00:02:16]",
            "text": "I wanted to give like a quick shout out to jesup and brotli here because they also kind of belongs in the network section. But there's two compression formats that browsers actually understand which are g zip and brotli. Which means that if you use them to compress your code and send that compressed code over the wire."
          },
          {
            "time": "[00:02:36]",
            "text": "The browser doesn't need any extensions or anything special to be able to uncompressed your code and read it back out, which is great. So it's Think of it as like a zip format that all browsers understand, which means that you should be probably compressing everything that you use, so for example, if you have like a node app, let's say use Express node or whatever, then you would just wanna look for like unexpressed node, compress, plugin, right, some kind of middleware."
          },
          {
            "time": "[00:03:03]",
            "text": "They all have these, whether it's like a Java app or a Ruby app or whatever, you just want something that's gonna jesup all of your requests that gets sent over and all your static assets as well. So compression is great, on the front end, we see a lot of things these days, one of the things I see most often are really large JavaScript bundle sizes."
          },
          {
            "time": "[00:03:23]",
            "text": "That's probably 90% of the cases that I diagnose, come down to that where it's like people say like, can you try to stick under like 2,3, 4 100 kilobytes of JavaScript and then you go look at some of these sites, and you're looking at like 5 6 7 megabytes of JavaScript."
          },
          {
            "time": "[00:03:40]",
            "text": "And it's just, it's so easy, i mean, it's so easy to get set up, you need a cool thing and you go to NPM and you find the cool thing and you NPM install it and you just add it and like before long you've got, just so much code."
          },
          {
            "time": "[00:03:56]",
            "text": "This could be its whole own class, so I'm not gonna go too deep into it, but reducing the dependencies you have is great. Making sure that you're your bundler is optimized is great and another thing is taking advantage of all the modern things. I said Webpack is very flexible, you can say, hey, I need this, but I don't need it on page load, so just download it asynchronously."
          },
          {
            "time": "[00:04:18]",
            "text": "There's lots of really cool things you can do with bundlers to make the site faster, too many files we kinda covered this already. I always like doing audits at the end even though audit is the easiest on a technical level. It also kinda nicely wraps up all the stuff that we've been learning as you're like, yeah, we kind of covered that, so we covered in the networking section that you can only do 6 synchronous requests at a time."
          },
          {
            "time": "[00:04:41]",
            "text": "So if you have Like 700 images that need to come down, it's just gonna be queuing installed for a really long time. Again, with images, just like JavaScript, you can make a lot of them asynchronous if you don't need it for the actual page load, like if it's just presentational or if it's below the fold, like down, scroll lower, just make a may synchronous."
          },
          {
            "time": "[00:05:00]",
            "text": "It can be a huge savings, Images also are tricky like, they can be uncompressed they can be too big. So I we see this a lot where in your CSS you'll have like image style, width 500, height 500 great, and then you hover over the image, and it'll be like, well, the natural size of this image is like 2600 by 1400."
          },
          {
            "time": "[00:05:24]",
            "text": "And it's like, well, why are you sending this like giant image over the network if you're only going to render it in a very small way. The other thing is that images have all of this metadata, so if you open as someone who works for one of the largest Companies that puts that metadata [LAUGH] there."
          },
          {
            "time": "[00:05:39]",
            "text": "When you open something and like Photoshop or whatever, it's gonna save all this really, really handy stuff so that when you open it again, you know has all this history and what file or what program it was last edited with all this stuff. It's really good for keeping local files but it's really bad for the web, so if you use something like image optimizer, or any number of cloud services do the same thing they'll like trim all this metadata off."
          },
          {
            "time": "[00:06:04]",
            "text": "One, it can be a security issue, we often read about hacks where like Exif, data was left on images and people could find where they were posted from. Number two its file sizes, you don't need all that metadata just makes the image bigger, so would they call that as lossless image compression."
          },
          {
            "time": "[00:06:19]",
            "text": "That's the thing to look into, which is making the image smaller without losing any quality, that's basically what it means. So images to large images on compressed, unused JavaScript and CSS, this one could be another kind of workshop, so Chrome dev tools can tell you unused code. But the story is like never really that simple, right, because you'll often have CSS that's there to style a modal that the user just hasn't clicked on yet."
          },
          {
            "time": "[00:06:45]",
            "text": "So it's not really unused, it just hasn't been used yet, so I think the better thing to do is to use the bundle async stuff. So like use your Webpack, like dynamic imports or whatever bundler you're using to be like, hey, my that modal the JavaScript and the accompanying CSS does not need to come on page load."
          },
          {
            "time": "[00:07:04]",
            "text": "It can come later, is a good way to do it, CSS in the document body, that's another one is where you put stuff will trigger when, so if you put stuff in the head versus the body the CSS and the body will be like an asynchronous, like a lower priority loads, then it'll cause everything to kind of warp in afterwards."
          },
          {
            "time": "[00:07:27]",
            "text": "But then a lot of JavaScript libraries, like analytics ones always want you to put that in the head, which will then block a lot of the thing. So you are like waiting on Google analytics before your page loads, so really tricky and last one, browser caching. So setting cache headers on your server, and then respecting them in the browser is great, i actually over the break I had seen some questions over E tags which I think now is a good segue into."
          },
          {
            "time": "[00:07:55]",
            "text": "So I mentioned E tags earlier is like a standard, that people use for, caching something until it changes basically, and so they're not necessarily for free though. So the E tag is a header that your server will need to set, and you can look it up on MDN, but it's just E tag, and so your server will send an E tag header with a unique hash to like the file."
          },
          {
            "time": "[00:08:18]",
            "text": "And then the client also needs to do some work, the client will need to with the fetch request send an F non match header itself and this is all you can find this on MDN. But basically the server will need to send the unique hash, and then the client will need to send only give me a new file if it's not this hash and and that's how they can kind of communicate very quickly together."
          },
          {
            "time": "[00:08:39]",
            "text": "So these things are a little confusing but there, hugely important when you're, working on a big site that has like user uploaded images that can change but they don't change very often. So ideally, you would cache them all but sometimes you need to purge that cache."
          }
        ]
      },
      {
        "sessionTitle": "27-simulating-network-conditions.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Another thing, before we get into Lighthouse, is that dev tools can do some really cool stuff simulating conditions. So I'm gonna go ahead and open the Element Inspector. So on the Network tab, if we go to these settings down here, I'm sorry, where is this? There it is."
          },
          {
            "time": "[00:00:16]",
            "text": "Sorry, it moved it. So on the Network tab, this little drop down here, you can throttle network conditions. So you can look at, for example, all the way to offline, but you can look at a slow 3G connection or a fast 3G connections. So we can see my site loads pretty quickly almost instantly, but then on a slow 3G connection, you can see it kind of spinning and spinning here."
          },
          {
            "time": "[00:00:36]",
            "text": "So that can be a really cool thing. You can simulate these connections and see, well what is somebody going to experience if they're on a really bad network? The other thing they can do is in the Performance tab, under their settings, you can actually do CPU throttling, too, which is really cool."
          },
          {
            "time": "[00:00:51]",
            "text": "If you remember in the network lesson we talked about how bites over the wire isn't the only thing. Parse time can also be hugely important for page load. So what if you are worried about parse time? You can come into the Performance tab, you can set a CPU throttle, and then you can reload the page there, and you can see how long it actually takes to parks all your JavaScript on a slower connection."
          },
          {
            "time": "[00:01:12]",
            "text": "So that's really cool. So you can, yeah, you can throw out the network and you can throw out all the CPU. Very, very useful if you want to get a little bit of that empathy of what users will see on slower connections. Another aside I wanted to make is that let's say you have kinda trimmed your code down, so it is what you need it to be."
          },
          {
            "time": "[00:01:35]",
            "text": "Moving things around so that, while it will load slowly it loads well, can be very important. So, for example, sites that are entirely client side rendered, like a react site where you just render a div main from the server with nothing in it, then React boots up and then React populates it."
          },
          {
            "time": "[00:01:52]",
            "text": "What if you put a nice static HTML file and instead, so that was a really slow connection, while React is parsing, the user at least get some good HTML and some CSS, stuff like that, and this can be done in a number of ways, but the network throttling can be really cool to watch how your site loads, and it can give you some ideas into things that you can do to at least make the experience better, even if people do have to wait a few seconds for the whole thing to load."
          }
        ]
      },
      {
        "sessionTitle": "28-lighthouse-audits.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is really, really cool. So, Lighthouse is the last tab we're gonna kinda cover here. When I did this talk last time, Lighthouse wasn't in the panel, and was it's own separate website. It's a open source initiative that came out of Google. It's really well maintained with all these rulesets and tests for web performance."
          },
          {
            "time": "[00:00:24]",
            "text": "And I used to have this advice where I was like, if you're doing a local app, you got to use Audit. But if you have an app on production, go check out lighthouse. It's like the best. And now Lighthouse is here in the tabs, which I'm like, just very giddy over because it's just so good."
          },
          {
            "time": "[00:00:38]",
            "text": "All the rules are open source and online and a ton of people contribute to it. And it has all these different categories, which are somewhat self explanatory. They're maybe a little complicated, but so performance is going to be initial page load performance, very similar to what we've been doing manually with the network stuff."
          },
          {
            "time": "[00:00:57]",
            "text": "Progressive Web App is going to check, does it service worker does it work offline. Does it have a manifest? All these great things for progressive web apps which we're not building right now, best practices is gonna be just a lot of normal stuff about the images and compression and all those different things."
          },
          {
            "time": "[00:01:15]",
            "text": "Accessibility is hugely valuable, I have an accessibility course on front of masters but making sure that interactive elements can be done via the keyboard, making sure that color contrast works well for people with different vision impairments. All sort of things like that making sure screen readers are going to have an easy time reading your content, to non sighted users."
          },
          {
            "time": "[00:01:35]",
            "text": "And then SEO, just making sure that you're doing kind of the basic things for Google to be able to track your website well and for other search engines to track as well. So I think for now, let's just go through, let's just generate a mega report. And this is keeping in mind that we know that we're not a progressive web app."
          },
          {
            "time": "[00:01:50]",
            "text": "We know we don't have any of those features. So, you click what you want, and then you click Generate Report and it's gonna do a bunch of stuff in the background. It's going to refresh the page and stuff like that. And so you get this very, very nice easy to parse, 0 through 100 score on all the different categories."
          },
          {
            "time": "[00:02:08]",
            "text": "So you can see it's pretty cool. I found that we're not a progressive web app and instead of giving you a bad read score, it's just kind of grayed it out. We get 100 number Performance, 90 on Accessibility, 93 on Best Practices, 78 on SEO. So let's just start looking through."
          },
          {
            "time": "[00:02:23]",
            "text": "These are like, sometimes I think about things that I'm like, you could probably just make money just by offering people who have business websites and aren't super tech savvy, probably just honestly like run Lighthouse, print it out and go talk to them about it. It's so valuable even though it's free, it's just so cool to be able to see."
          },
          {
            "time": "[00:02:43]",
            "text": "So on the Performance tab, that's the onload performance. We can see all these great things like how long it took for the first contentful paint, how long it took before the site was interactive. For those of us that work at big companies, we probably have a few of these metrics that are mandated, like time to first byte or first contentful paint."
          },
          {
            "time": "[00:03:02]",
            "text": "Those will be things that we need to keep the app on a certain time. So first contentful paint is like we talked about on there when the page renders the first time and time to interactive. I've seen this on some slower sites where it's loading that is blocking the main thread where you can't click on things, you can't scroll, you can't click on a button."
          },
          {
            "time": "[00:03:20]",
            "text": "So that's time to interactive before. The main thread is free enough that you can do stuff again. Largest contentful, paint, layout shift, all these different metrics. And what's really cool with these is if you get one red or yellow, it'll flag you with a page for each and every one of them where you can click on the page and go to this really nicely maintained dock for like, well, why am I getting that?"
          },
          {
            "time": "[00:03:43]",
            "text": "What can I do? What's the problem here? I know I'm gushing over it, but it's just so awesome. Lighthouse is such, such a great resource. Cool, so kinda scrolling down. You can also see, I know these are all mini. Remember I said that if you have the Dev tools not popped out, the screenshots will be really tiny."
          },
          {
            "time": "[00:04:01]",
            "text": "So here is just little tiny screenshots of what's going on up there. And then it has suggestions. So here it can says the only suggestion normally you get a lot is that you could save 100 milliseconds or something like that if you eliminated render blocking resources, and specifically if I extend that it's the custom font that I use."
          },
          {
            "time": "[00:04:22]",
            "text": "So I have a custom font. It's pretty small. But if I got rid of it, then I could speed things up a lot. The other thing you could do is, you can do that. Have you ever loaded a site and it loads with a system font and then it changes into being a custom font."
          },
          {
            "time": "[00:04:36]",
            "text": "You guys do that. I mean, it's gonna be a lot faster or not maybe a lot, but it'll be somewhat faster but at a worse user experience. So kinda your choice. And then here's all the things that, these are not marked red. So, if they were I could go and read into those more, if I was messed something up."
          },
          {
            "time": "[00:04:53]",
            "text": "And then here are the ones that are passed audit. So you can see these two. These are all the things that would flag, if you're on a production site, and it had any of these issues. Next one accessibility. Same thing, it just gives you immediately useful, very helpful stuff."
          },
          {
            "time": "[00:05:07]",
            "text": "So it's like, this HTML element doesn't have a Lang attribute. And it has this whole important thing about screen readers. If you don't set a language on the HTML element, they will use the user's default language. So if you are a Spanish speaking user on a Spanish screen reader, and I have an English website, but I don't set the Lang, it's going to try to read it in Spanish because I haven't set the Lang."
          },
          {
            "time": "[00:05:29]",
            "text": "So, immediately very, very useful stuff that you honestly could just go, just follow along and kind of fix all these things. Then again choose all the passed audits that we got. I will give a caveat here. Accessibility testing like automated testing has come such a long way. And I know that sounds a little cliche, but it's especially true with accessibility, like really nothing beats the real thing."
          },
          {
            "time": "[00:05:52]",
            "text": "Nothing beats actually getting a user on and trying to tab around and make sure, because things might have tab index, but they might be unintuitive or clunky. And Chrome Dev Tools won't be able to catch that. So this is a really good starting point. These are easy things to fix, but accessibility is very subjective."
          },
          {
            "time": "[00:06:10]",
            "text": "For making a good experience, it's a little bit harder to Lindt and better to have somebody on your team that knows how to use a screen reader and knows how to tab around and make sure that it feels good. That feels nice. Another thing, best practices, missing one where there's no doctype set."
          },
          {
            "time": "[00:06:28]",
            "text": "So again, on the HTML, you might how you usually do like doctype HTML, or whatever, sort of a relic back to the old days where we had, before HTML5, we had all these specific doctypes and these specific modes that browsers would. But again, you can go to the Learn More and it'll just tell you to put doctype HTML at the top of your page."
          },
          {
            "time": "[00:06:47]",
            "text": "And then here are the audits I passed. Coming to SEO, I don't have a meta viewport tag. And so this helps mobile devices know how to scale so they don't have to pinch to zoom. Have you ever loaded a site on your mobile device and it's like super mini, and you're trying to zoom into it?"
          },
          {
            "time": "[00:07:02]",
            "text": "So this meta viewport can help with that. And there's no meta description. Again, not an SEO class, but these are things that help the search engine know more about the page so that they can index it better. Cool, and then PWA. I failed a bunch of things, but it's not a PWA."
          },
          {
            "time": "[00:07:19]",
            "text": "That's okay. So it said, hey, we went offline and we expected to 200, we didn't get one. It doesn't have any service workers at all. There's no web app manifest. I mean, these are things we know because it's not a progressive web app. But if you do have one working on mobile@twitter.com, and you want it in the App Store and you want to, make sure that you pass all these PWA tests as well."
          },
          {
            "time": "[00:07:40]",
            "text": "Cool, and then it's got a bunch of meta information, just about what slowed down at use, what site it was, all these kinda great stuff."
          }
        ]
      },
      {
        "sessionTitle": "29-wrapping-up.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Two things that are sort of outside scope for this course I didn't want to go too long, but I think are very cool. Puppeteer for all those that don't know Google's chrome can be called from node in a headless way. So folks that do like, what's it called end to end tests on your websites."
          },
          {
            "time": "[00:00:18]",
            "text": "So, maybe you'll have one actually opens a tab logs in does stuff like that? Puppeteer is a great tool for that. There's also some other tools like WebDriver, and things like that. But when you think about the performance API that we covered earlier, you can do some really cool things with puppeteer WebDriver, where you could have it log in and record some metrics and save those metrics or I like to do like CI workflows."
          },
          {
            "time": "[00:00:41]",
            "text": "I always have this like philosophy that If you can't lint it, test and make a CI rule for it, you shouldn't bother somebody on their code review about it. You know, it's like let the computer do that. Don't you change? So, one thing that I like to do is I have a few I called my performance budget."
          },
          {
            "time": "[00:00:58]",
            "text": "I think Alex Russell from Chrome, maybe coined that term. So, I have my performance budget. And we use puppeteer, puppeteer logs of performance API. If they're greater than certain numbers, it flags the PR. So when you go to put a PR up, things are a little bit too slow."
          },
          {
            "time": "[00:01:13]",
            "text": "And then it's not a person yelling at you. It's just a simple rule there. So, there's a lot that you can do there, combining the performance API with Puppeteer. Similarly with Lighthouse, they have a CI that you can call from node as well. So, you can do a very similar thing where you could say, on every PR spin up the website, hit it with Lighthouse, and if it gets less than 100 flag PR, you could do something like that, which is very cool."
          },
          {
            "time": "[00:01:36]",
            "text": "I think that would be a little bit more going into like Jenkins or CI jobs and that's a little outside of scope, but it's just something cool to think about.cool. So, basically the last thing that I just wanted to talk about kind of in Lieu of Puppeteer and lighthouse."
          },
          {
            "time": "[00:01:51]",
            "text": "CI are just some other cool like parting notes because we've kind of gotten through all the heavy stuff. One thing that's really cool our Chrome Dev Tools experiments, so if we right click and we go into inspect and then we go to the settings cog up here. You'll see a lot of different stuff which is cool that you can kind of control the display."
          },
          {
            "time": "[00:02:09]",
            "text": "You can do light mode, dark mode, you can control how the panels are defaulted laid out. Remember in the sources debugging, I said you could right click and you could black box a script if you didn't want it seen. If you want to remove one that you've black box, you can come here and do so, the devices over here is where you can emulate different devices."
          },
          {
            "time": "[00:02:30]",
            "text": "So you got all sorts of cool defaults that you can set, but one that I wanted to bring attention to is experiments. So, before things launch, they always come out here in this experiments tab. And so you can take a look through there's always really neat stuff in here, It's like use as is enable at your own risk [LAUGH] all this stuff so they're not documented."
          },
          {
            "time": "[00:02:52]",
            "text": "A lot of times you have to poke around to see where they even are, you'll enable somebody to get on the memory tab. No is on the performance. I see it now. But there's always a really cool stuff. Some of this stuff doesn't make it in to Dev tools."
          },
          {
            "time": "[00:03:06]",
            "text": "But this is really neat stuff that you can kinda play around with and see. There's another little one that I wanted to show which is, if we go to the dot.da and show the console drawer, and then we go to its dot, dot, dot, there's a bunch of little stuff that you can see here."
          },
          {
            "time": "[00:03:25]",
            "text": "And so one thing that I always like to do is, you can like click on like rendering for an example. And there's all this endless cool things that you can do, but you can do something like paint flashing. That's one of my favorite things to do. Then anytime Chrome is repainting like as i over things, it'll show you in this cool green outline."
          },
          {
            "time": "[00:03:49]",
            "text": "And so this could be really cool. You have a big react app and it's going kinda slow. Sometimes it might be repainting the whole site just when you're trying to change a really small thing. And this would be a really great way to figure that out. So you just go into it."
          },
          {
            "time": "[00:04:03]",
            "text": "Dev Tools, open the console drawer and then data dot here and you can see all sorts of just really neat stuff. Yeah, there's all sorts of amazing things that you can add. But each one of them each one of these just has a list of checkbox. Here's another one that I really like."
          },
          {
            "time": "[00:04:18]",
            "text": "This frame rendering stats. It just shows the frames per second as I scroll around and the performance of it, things like that you can see how much GPU memory it's using. So, I can just like very high level, get an idea of cool stuff like that. So, those are probably the two I use most often paint flashing and the frame rendering stats, but just be aware that there's a whole bunch of cool little extra things that you can add."
          },
          {
            "time": "[00:04:40]",
            "text": "You know, to the bottom drawer as well. The other thing we got a lot of good questions earlier in the workshop about, does this work react with Angular? So the answer is always going to be yes. Like for example, if you do an HTML break point, it will show you what JavaScript caused, but we talked about, it's going to be very deep inside the react reconcile."
          },
          {
            "time": "[00:05:03]",
            "text": "Whatever. So, I really recommend checking out these, the separate Dev Tools. So react has one view has one, angular has one. So, these are Chrome extensions that you can use and there. They're so good like I use this just every day at work so for react I this is not a react focused class by any means, but you can instead of you have your regular elements tab."
          },
          {
            "time": "[00:05:26]",
            "text": "But then you get a components tab and in that it shows the actual whatever you named your react components over here, and shows what props they get what hooks they have, like all this like amazing stuff. So, while the answer is always yes, you can use the elements and the elements, break point, even if it's a react app."
          },
          {
            "time": "[00:05:44]",
            "text": "The longer answer is, but look how cool it is. If you use the specific framework Dev Tools you can get so much information. And then we looked at the Performance Tab, it has its own what they call profile. It's a specific react Performance Tab. It works the same way a recording and you stop it, but it'll specifically show you this is a heavy render and it's caused by this hook, it speaks the language a lot better."
          },
          {
            "time": "[00:06:10]",
            "text": "So, if you're working on a big angular app or react app whatever it is check out their Dev Tools, because they're I'm this just seems to me so much time every day. I worked on a project ones back in the day that was too big. For the react Dev Tools they'd crash and it was such a hit to my productivity where I was man."
          },
          {
            "time": "[00:06:28]",
            "text": "I would open it every day and they'd crash every day. So, they've fixed that since then. But these are a really great way to kinda work around that. Awesome, and my very last lesson is just kinda where to go from here. Another huge shout out, I think I'll be able to find it on when it's scheduled for."
          },
          {
            "time": "[00:06:47]",
            "text": "Because unfortunately, I forgot, but there's an advanced web tools course coming on May 17th. From humor, he's been like for years we've been I don't know him, but I've known him as the other Dev Tools content creator in this space. There's the two of us. So, I'm really pumped that he's gonna be coming on."
          },
          {
            "time": "[00:07:06]",
            "text": "He's really in depth performance audits and all these like real world cases. He's just such an expert. So that advanced class is going to be super cool. The official Dev Tools Doc's are always a good place to look for things. They're all linked here in the project. And then I've also linked my Twitter."
          },
          {
            "time": "[00:07:24]",
            "text": "I love talking about stuff. If any of you have reached out to me in the past on stuff, I'm always geek to DM about cool Dev Tools stuff or whatever. The Chrome Dev Tools have a Twitter link as well. And then my very last shout out is there's this new initiative web dot Dev."
          },
          {
            "time": "[00:07:37]",
            "text": "I'm not sure if people have heard of it. It's like this big web community. I think Google kind of owns it but a lot of open source contributions from a lot of people. It's so cool. They have all these topics, on such a playground like all this cool stuff."
          },
          {
            "time": "[00:07:55]",
            "text": "Web vitals progressive web app is all free, really high level content they worked with, the framework teams when react and angular and they work with a web host teams like netlify universe, and they. They just worked with like everybody to get these extremely high quality articles out there."
          },
          {
            "time": "[00:08:12]",
            "text": "So, if you're looking to learn something new, I just love this, I read new articles on it all the time. Otherwise, thank you so much. I love doing these workshops and I love meeting people and hanging out and talking about Dev Tools. So thank you very much for hanging out with me today."
          }
        ]
      },
      {
        "sessionTitle": "3-performance-console-security-panels.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> All right, performance. So, I [LAUGH] had sent out a tweet a while ago about what people would love to learn more about web dev tools and like pretty much across the board I got that people are scared of the performance tab. That's like a very [LAUGH] common response that I found from people."
          },
          {
            "time": "[00:00:17]",
            "text": "But it's really not that scary, but it is very, very powerful. For a little bit of context, it used to be two different tabs. They've kind of combined into one, and it has a lot of data. And so, the kind of high level view of how to use this is you go to the Performance tab, you click on this record button."
          },
          {
            "time": "[00:00:33]",
            "text": "You interact with the site, doing anything you want, and then you click stop. Some top level advice is to keep your recordings as small as possible so they keep you from being overwhelmed with like ten seconds worth of data. So, I usually, if I'm nervous about like filling in a form, I'll click Record, fill in the form quickly and click stop."
          },
          {
            "time": "[00:00:53]",
            "text": "Try to keep it contained as much as possible. You can also deselect things depending on what you're looking at. So, right now I have memory showing down in this section. Let's say I'm not concerned with memory right now, I can just hide it. I also have the same screenshots from the Network tab, which can be really useful."
          },
          {
            "time": "[00:01:08]",
            "text": "You're seeing how your JavaScript causes stuff to render, but if you're not looking for it at the time, you can just deselect it. And so, what you'll kind of be left with here is a little bit of showing how the website painted itself over time. So, this is your frames per second across the very top."
          },
          {
            "time": "[00:01:24]",
            "text": "And this is the CPU usage across the bottom. And then, you'll see all these different frames down here. So, you can see almost everything is gonna happen in the main thread. But you can see stuff like when it's rasterizing, when it's using the GPU, all those different things."
          },
          {
            "time": "[00:01:38]",
            "text": "We'll have a full lesson on performance auditing and stuff like that. But the basic idea is you hit Record, you do something that you're worried about, and then you hit Stop. And you can come in here and you can look for like, is there page jank? Like is it lagging?"
          },
          {
            "time": "[00:01:52]",
            "text": "What's the main thread doing? How busy is it? What's the memory usage? Or what's my CPU usage? Is it getting too high? All sorts of things like that. I think it's best to come in here with a specific question in mind, that also helps reduce how overwhelming it can be."
          },
          {
            "time": "[00:02:06]",
            "text": "So, it'd be like, I really wanna know if I have a memory leak. That's what I care about. So, you can turn on the memory, you can do your thing and you can look for a memory leak and we'll do that in the appropriate section too. Console, probably the most popular one."
          },
          {
            "time": "[00:02:22]",
            "text": "It's really cool, it's a JavaScript repo. So, you can type stuff like console.log('hi'), and it'll type hi. You could do var foo = 'foo', and it'll save that. And then later, you can do foo. That's pretty straightforward. Anytime you put a console log in your code, it'll log out here."
          },
          {
            "time": "[00:02:42]",
            "text": "But there's also some really other cool things you can do. Like for an example, you can go into the elements tab, and you can find an element like let's say this article, you can click on it. Then you go back into the console tab and you can do dollar sign zero."
          },
          {
            "time": "[00:02:55]",
            "text": "And dollar sign zero is a shortcode for whatever I last clicked on in the elements tab. So, if you hit enter, you can see it brings this article into the console. So, now if I wanted to manipulate it, like I could do, addEventListener, click or something like that."
          },
          {
            "time": "[00:03:12]",
            "text": "You can take an element from the elements tab, you can bring it into the console, you can mess with it there, which is pretty cool. All right, next is the Security tab. Again, this one's pretty straightforward. It just gives you an overview on the security for your page."
          },
          {
            "time": "[00:03:25]",
            "text": "So, it is the de facto standard these days that all sites should load over HTTPS. There's all these really cool resources, like Let's Encrypt, which gives you Just free SSL certificates. And so if you go to any website and you click any open dev tools and click on the security, it'll give you an overview."
          },
          {
            "time": "[00:03:43]",
            "text": "And the reason that there's an overview is one, it'll tell you if the actual index dot HTML file, like the main request was served over HTTPS. But it'll also tell you if any subsequent requests were served over HTTP, which can be insecure. So, you could have a fully secure site, and then you add like an embed for a video or something like that."
          },
          {
            "time": "[00:04:01]",
            "text": "And that might be over HTTP, which still leaves you vulnerable. So this is cool. Basically, on the high level, you want to open it and you want to see green. That's what you want. If you open it and you see green, everything's good. If you see any orange or red, it'll give you appropriate instructions for why it's doing that."
          },
          {
            "time": "[00:04:17]",
            "text": "It also lets you view the SSL certificate itself if you have any reason to be viewing that."
          }
        ]
      },
      {
        "sessionTitle": "4-sources-application-memory-panels.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The sources tab, this is one that I feel like it's kind of underrated. It's basically a full ID and so over this course we'll learn how to do. We'll learn how to use the courses tab for step through debugging, which is really cool. So instead of just console logging, we'll be able to put a break point, we'll be able to pause the whole execution stack at that break point and kind of move around."
          },
          {
            "time": "[00:00:23]",
            "text": "We can check the call stack, like how we got there, what functions got called. We can keep an eye on certain variables, like watch a variable and see how it changes over time. But we can also use this really cool thing called work spaces, where we can drag our project into the dev tools, and after we set it up correctly, everything that we edit will actually persist to disk."
          },
          {
            "time": "[00:00:43]",
            "text": "So normally if you're in the elements tab, and you're messing with the CSS, I don't know who's gotten into this before. This happens me all the time, so I'll be like working on design I'll go into my elements tab and I'll get it perfect right. It's like the CSS look at the site looks like exactly perfect, but I've been working for like an hour."
          },
          {
            "time": "[00:00:59]",
            "text": "When I'm ready to ship it, I'm like, I don't even remember what all I changed at this point. Like I added so many classes and I added so many selectors and styles like, it's really difficult to figure out what you change. And so workspaces can be really cool cuz you still get that instant feedback of working in the sources or elements tab."
          },
          {
            "time": "[00:01:15]",
            "text": "But you can actually hit like Ctrl S or command S and it'll save it to disk, so we have a whole exercise on that for later. You got the application tab, I usually refer to this one is just storage as like a way of thinking about it. So this is where you'll come probably primarily to look at all the different ways we have of like caching and serving things locally."
          },
          {
            "time": "[00:01:36]",
            "text": "So that's like local storage, session data, cookies, index db, all sorts of stuff like that. It's also the place that you come if you have a progressive web app with a ServiceWorker. So if you have a service worker, it also has a service worker tab, where you can see is there a worker is it being registered, what it's doing all sorts of stuff like that."
          },
          {
            "time": "[00:01:55]",
            "text": "It's also maybe most commonly used to come into the storage and click clear all site data. That's probably what I use it for the most right so when you're like, you know you're in a weird state and you cache something or you're messing with sessions or cookies and it's everything's bad."
          },
          {
            "time": "[00:02:11]",
            "text": "You just come in here click clear site data, refresh the page and get a nice clean start. We've got the memory tab, so this one is very specific to your memory consumption. But it's really cool, so you can take a heap snapshot, which is like show how memory is currently being used in my app."
          },
          {
            "time": "[00:02:30]",
            "text": "You can do a timeline so you can like the profile or the performance page, you can record over time, and you can do stuff and you can see what you're doing that's using memory or not. And then there's this new tool which is like probably one of the things I'm most excited about, which is you can allocation sample."
          },
          {
            "time": "[00:02:46]",
            "text": "And that'll help you now that you have a memory leak hypothetically, it'll help you figure out what job script code you're using that's actually causing that memory leak. Because in the past it's been really easy to find out that you have one and it's been much more difficult to figure out why you have one."
          }
        ]
      },
      {
        "sessionTitle": "5-lighthouse-device-emulation-element-finder.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Then we'll cover the Lighthouse tab. This one's great. This has been kind of a cool story to watch. So years ago, Chrome came out with this idea of Lighthouse. It used to have an audit tab, which kind of did similar things that came out of this idea of Lighthouse."
          },
          {
            "time": "[00:00:13]",
            "text": "It's like fully open source. It's contributed to by all these great people and it's just cool rules for, your site should have a first paint in this much time. Or if you say it's a progressive web app, it should work offline. Or if it should be accessible for people with disabilities or you should be taking advantage of Google's SEO recommendations, all this stuff."
          },
          {
            "time": "[00:00:36]",
            "text": "So they came out with this idea of Lighthouse and it used to live on its own website. And so in my last time teaching this course, I was use the audit if it's a local site. And if it's not a local site, go to Lighthouse and use Lighthouse."
          },
          {
            "time": "[00:00:49]",
            "text": "Lighthouse is awesome. But now Lighthouse is fully integrated with the dev tools itself, which is great. So you can do it all on a local site. Just to explain what I mean by that. If you have a great site like web page test is one of the best ways of like analyzing your site, but you have to a URL and hid it, right?"
          },
          {
            "time": "[00:01:05]",
            "text": "So if you haven't published your app yet, you can't use that website to measure it. So the dev tools are great, cuz even like we are if you're just on a local host, you can still run it. So I haven't published yet, but I wanna know how it's doing."
          },
          {
            "time": "[00:01:17]",
            "text": "So Lighthouse is this full page audits, we'll talk about all these great stuff its get. It's the place I'll always recommend starting if you're trying to gauge performance of a new app. Come here, it'll give you so much feedback before you have to dive into the weeds of network memory CPU."
          },
          {
            "time": "[00:01:34]",
            "text": "And also it can do other cool things, it can emulate devices. So this little button over here to the left,, you can click it and it will give you all these different options for exact screen sizes. So for folks that do a lot of front-end work and design, you can see exactly what your site will look like on a pixel two or something like that."
          },
          {
            "time": "[00:01:52]",
            "text": "And more than just shrinking your screen, this will actually send the appropriate headers. So if you have a server that reads in the request header and says, it's a mobile device, go here. Otherwise, send this. This will convince you that it is a mobile device. You can zoom in and you can actually test out."
          },
          {
            "time": "[00:02:08]",
            "text": "I hope you can see, but my mouse cursor is turned into a little touch circle. And so you can test out touch events too, which is which is really nice. Click that to go back and the last thing is this nice little element Finder. I use this a lot and I see people not using this a lot."
          },
          {
            "time": "[00:02:24]",
            "text": "So if you're looking for a specific element like this emoji or something like that rather than going into elements and trying to like drill down into it this way, you can click on this and then you can start moving around and it'll hover on different things. And whatever your click on, whatever it's hovering, it'll focus that."
          },
          {
            "time": "[00:02:40]",
            "text": "So I click on elements and it clicks it in here, and I can find that emoji really quickly. At the end, we'll go into a bunch of different settings and some experiments and some really cool stuff that you can do over here. But that's kind of the cover for the most part."
          },
          {
            "time": "[00:02:53]",
            "text": "The other thing that's important is you can choose where it's docked. So you can go to the right, to the left or pop it out. And one thing that's kind of interesting when we did the network tab, right, we did screenshots, but the screenshots you can see are really minor."
          },
          {
            "time": "[00:03:07]",
            "text": "And the reason is since we have the dev tools open here, Chrome only has to render this exposed part of the screen. So you won't get a full screenshot of your app, unless you go here. Pop them out and then you refresh. And now that Chrome actually has to render the full site, you'll get full size screenshots."
          },
          {
            "time": "[00:03:25]",
            "text": "So that's kind of the high-level view of each panel. We're gonna be spending a lot of time in each one. But just so when you see them, you can be, I know what that one's for. That one does memory stuff for that one checks HTTPS or that was the step through debugger, those kinds of things."
          }
        ]
      },
      {
        "sessionTitle": "6-quick-edits-css-html-scroll-into-view.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> It's worth noting that there's a really cool feature that the DevTools offer. Which is if you own an Android device like an Android tablet or an Android phone, you can actually plug it into your computer and you can test your local apps on that Android device. It's not covered in this course but I do have a link to a really good doc on how to get that set up and going."
          },
          {
            "time": "[00:00:18]",
            "text": "That can be really good because, I think we've all seen it before where we use an emulator or like we control the screen to the right size and it looks perfect. And then it actually gets out on a user's device and it's not quite the same, they render a little bit differently."
          },
          {
            "time": "[00:00:32]",
            "text": "So being able to render your web app on a real android phone or Android device can be really valuable. And a lot of big companies will have device labs of some sort. Well, they have a bunch of old phones and stuff like that. So that can be really good."
          },
          {
            "time": "[00:00:44]",
            "text": "So quick edits, I'm going to go ahead and open my DevTools again. And this time, I'm gonna pin them back down to the bottom of my screen. So we've kind of seen this one already. We can go ahead and we can edit any CSS we want. So if we wanna change like the font color to red, or if we want to change the font family."
          },
          {
            "time": "[00:01:06]",
            "text": "Let me change this back to black so you can read it, I'm gonna change the font family to Arial or something like that. Anything we do over here will get reflected here. We can add new CSS rules. So I did show this already a little bit, but you can click this plus and you can make any rule you want."
          },
          {
            "time": "[00:01:22]",
            "text": "So you could do body nav or something like that. Or you could do a new ID of foo or a class of foo. You can do anything like that. You can edit the HTML. So we saw in the beginning that you can edit the tags by double clicking, you can edit the ID by double clicking."
          },
          {
            "time": "[00:01:41]",
            "text": "You can even edit the content here though by double clicking. So if we scroll up to the top here, I can change, Hello world, and I can hit enter on that, and that'll change. You can even for sometimes because you'll have a lot of content, you can right click on it and you can click Edit as HTML."
          },
          {
            "time": "[00:01:57]",
            "text": "And that will take the current element and it will give you this like really nice text editor. So maybe that's more comfortable and you can move around, add new lines, things like that. Depending on what you wanna do. Scroll into view is one of my favorite ones. So I work on a lot of infinite scrolling applications, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "And they get really long. And sometimes we'll have a bug, I'll be able to use the DevTools to figure out which, let's say we're working on Twitter, or we've got 100 tweets on the screen. And I can figure out the ID of the tweet. That's a problem, but I don't know where it is yet."
          },
          {
            "time": "[00:02:33]",
            "text": "So for an example, I'll use this inspector and I'll click on the Scroll into view, list item. And so here I have it in DevTools. So if I was to scroll all way down and I really wanted to mess with it, I can hover on it and I know this is subtle unfortunately can't make it larger."
          },
          {
            "time": "[00:02:49]",
            "text": "But, let me move to a clear area, when you hover on it, it will either show. If you put your eye up here, where my mouse is, it will show either a little arrow saying the items above where we are. Or if I was to go too far and hover on it, you'll get another little arrow here saying the items below where we are."
          },
          {
            "time": "[00:03:09]",
            "text": "So this used to be the best way we had to deal with it as you would hover it in DevTools and you would listen to the instructions. You scroll a little bit. It's still low, you'd scroll a little bit like I went too far. It's high now, all that."
          },
          {
            "time": "[00:03:19]",
            "text": "But now what we can do, let's say we're all the way at the bottom of the page is we can right click on a DevTool. And then click Scroll into view. And it'll actually move the view part right around the element that we have, which can be really helpful."
          },
          {
            "time": "[00:03:31]",
            "text": "Again, if you work on either just long or infinite scrolling websites. Console shortcuts, so I did cover $0 already. So if you click on an item and you go into the Console New $0, it also keeps some history. So we clicked on article, then we'll click on nav."
          },
          {
            "time": "[00:03:48]",
            "text": "So if we go back to the console $0 has now become nav, that's the thing that we clicked on most recently. But $1 will stay article. So it goes back through three so you can kind of keep some history of the different elements that you're working on. You can hide and show elements, which is kind of cool."
          },
          {
            "time": "[00:04:03]",
            "text": "So if I scroll up to this, Hello World, and I hit h it will hide or show the element, this can be really nice when you're kind of doing some design. You wanna move some stuff around, but the text is in the way or something like that. You can hide it."
          },
          {
            "time": "[00:04:16]",
            "text": "You can also, there's just times where you can just right click and just delete the item, right? And that will actually take it out of the DOM. So you notice the difference. Let me refresh the page. When I go to this h1, and I hit h, it sets it to display or visibility hidden, which means it stays so the space around it stays."
          },
          {
            "time": "[00:04:34]",
            "text": "But when I either hit the delete key or right click delete, it actually plucks it from the DOM and the DOM adjusts. Refresh again. You can simulate state. This is another cool one. So if we take this and we go find one of my links like this Quick Edits, so we've got Quick Edits down here."
          },
          {
            "time": "[00:04:51]",
            "text": "You can click this colon hov and you can simulate a lot of different state like hover active focus, all these things. This is really funny because I pair program a lot and sometimes I'll be pairing with someone who's working on a hover state. And they'll be like doing like this, like they'll be hovering over it."
          },
          {
            "time": "[00:05:08]",
            "text": "And then they'll be looking down here in the style section trying to see what's changing. So you can really just put the hover state on it. And now I can fully see what hover CSS is applied and I can edit it."
          }
        ]
      },
      {
        "sessionTitle": "7-quick-edits-computed-styles-specificity.txt",
        "timeFrames": [
          {
            "time": "[00:00:02]",
            "text": ">> All right, we can also get computed styles. I'm gonna cover this a little bit later. But CSS is kind of an interesting language because it doesn't have a compile time or it doesn't have errors in the same way that maybe JavaScript does. So for example, if we wrote some CSS that was, class of foo background red, and then right afterwards we wrote, class of foo background blue."
          },
          {
            "time": "[00:00:27]",
            "text": "How is CSS supposed to deal with that, right? We've got this kind of conflict. In JavaScript we throw an error or it would just assign the latest one that's been given, right? If you did like var foo equals red foo equals blue. It would just set it and it's just a constant with error."
          },
          {
            "time": "[00:00:42]",
            "text": "But CSS is a little bit weird. And it's also weird because, the CSS when you write it isn't aware of the structure of the DOM, what it will be when it actually renders. So that sounds complicated, but I don't think it really is. So let's say we write CSS where we write, all divs are blue and anything with the class of foo is red."
          },
          {
            "time": "[00:01:04]",
            "text": "That seems like pretty straightforward, right? Divs are blue things with foo are rad. But then let's say we make a div with the class of foo. Now all of a sudden CSS has a problem, right? Because you've told it now two different things apply. And so what it does is it follows these rules called CSS specificity, and it's basically a big giant fight, [LAUGH] right?"
          },
          {
            "time": "[00:01:24]",
            "text": "Where they all the selectors that exist on a given element fight. And so Estelle has this really great website, which I've linked to here called CSS Specifishity. And it's a little comic which kind of helps you understand how these CSS rules play out. And so you can see each type of selector in the top left, a cute drawing in the middle, and then it's kinda score down here."
          },
          {
            "time": "[00:01:50]",
            "text": "So you can see the weakest selector of all is the star, the asterisk, and that will apply to everything universally. So sometimes you'll see like asterisk, margin 0, padding 0 on a website. So just kind of by default, stuff doesn't have padding. And then we get into an element selector, and then we get into a double element selector, then more and more selectors."
          },
          {
            "time": "[00:02:10]",
            "text": "So if you have a ul with an li with a span in there, if you do span, blue, li span, red ul li span yellow, it'll be yellow cuz that's the most specific. Because it's got three in there. Then it goes into classes, then it goes into an asterisk with a class anyway kind of follows the whole way up."
          },
          {
            "time": "[00:02:31]",
            "text": "But what's kind of important to know is that element selectors are the weakest type of selector besides the asterisks. And then it classes are also pretty weak. And then as you get up IDs are pretty strong. And then inline styles like in your HTML so if you do div style equals background blue is really strong and the only thing stronger than that is an important tag."
          },
          {
            "time": "[00:02:52]",
            "text": "Which we all try to keep probably out of our sights, but they find their way in anyway. But that's just like, this isn't a CSS class. But that's a high level view which is needed for this next section because CSS has a really hard job where you author it, and it runs having no idea what DOM what HTML is gonna run on."
          },
          {
            "time": "[00:03:11]",
            "text": "And so it needs these are rules for when there's conflicting information. So computed styles back to where I was before, is really cool. So you can click on an element like let's go find this h2 here. And then instead of being on the styles tab, which is probably the one we spend most of our time on, you can click computed."
          },
          {
            "time": "[00:03:29]",
            "text": "And what computed is going to give you is a list of like okay after the fight happens, [LAUGH] I don't know how else to phrase it besides the fight. But after a CSS specificity rules are all applied, these are the things that won, right? These are the things, so if you had for an example, we can take the h2, and we can say okay, h2s are all blue, right?"
          },
          {
            "time": "[00:03:52]",
            "text": "And so that h2 turns blue. And then, but it's got an idea of quick edits, right? So we go ahead and we make a new selector and we do quick edits and we do okay. Well, quick edits, those are all red, right? And so as we'd expect, it turns red because an ID is stronger than an element, right?"
          },
          {
            "time": "[00:04:09]",
            "text": "But when you work on big apps with a lot of teams all contributing stuff, it's never quite this simple. It's like two selectors, right? It's like everybody's bringing selectors to the table. So you're like every component has its own stuff and different teams write different stuff. And, oftentimes people come up with these solutions like scoped styles or BAM or all these different things to try to deal with this cuz it gets really difficult."
          },
          {
            "time": "[00:04:33]",
            "text": "When I work at Twitter which is a massive web app, I can't tell you how many times I would get a ticket like extra boarder appearing on tweets when you're logged out and you are viewing this and reply. And I'm looking at CSS to try and find specific role, it's like ul li so the idea of tweets and class of active tweet, all that stuff."
          },
          {
            "time": "[00:04:51]",
            "text": "Really confusing. So computed styles can be really great because you can go to computed styles, you can try to find the thing you are looking for like, why is it red, right? You can find that color is red, that's fine. Then you can click this little caret here, and it'll say, look, here's a list of all the things that change the color, and here's the one that won out, right?"
          },
          {
            "time": "[00:05:11]",
            "text": "And so if you click on this little arrow next to the one, it'll take you back into the styles tab, right? So we've gone from key to back in the styles, and it'll show you where that is. So computed is really cool. It also shows you the full box model."
          },
          {
            "time": "[00:05:26]",
            "text": "Again, this is not like an HTML or CSS class, but I assume a lot of people have heard the term box model before, the HTML box model. And so it's basically it's like you have a thing and it has a size, but then it has padding potentially, then it has border potentially, then it has margin potentially."
          },
          {
            "time": "[00:05:43]",
            "text": "This is a really great way of visualizing it for any element. So you can see the element has a size 1200 by 38. It has no padding, no border and a margin of 33 on the top and 8 on the bottom. This is gonna be really cool too when you're just trying to visualize how stuff's gonna render."
          },
          {
            "time": "[00:06:00]",
            "text": "Yeah, and so this is a great tool, especially for big apps where you're trying to figure out why something is the way it is. You can just go ahead and refresh, you can be like why is this black cover on it? See there's only one rule, click on the arrow and it will take me right to the actual line that sets the color to black."
          }
        ]
      },
      {
        "sessionTitle": "8-quick-edits-html-breakpoints-themes-accessibility.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> HTML breakpoints, these are another really, cool thing. So this is like an anecdote, but I had this job once where I was working on a tool. And the tool was essentially this giant table that was populated with data in real time. So like little cells of the table table would always change and I was really new on this team."
          },
          {
            "time": "[00:00:20]",
            "text": "And we had a bug where when one would change, sometimes it would go blank, it would like update and it would go white and the bug was to figure out why that was happening. And so this is like back to the very first slide of like dev tools can kind of help you level up If I was not good with dev tools, I would have done what everyone else would have done."
          },
          {
            "time": "[00:00:40]",
            "text": "I would have either asked around, or open the code and start trying to find what code populates the table, stuff like that. But knowing Dev tools, you can do these really cool things. So, just like we'll learn how to set break points in our JavaScript code in the next section, you can set break points on your HTML code."
          },
          {
            "time": "[00:00:58]",
            "text": "So, if I go to like the HTML element way up here, and I right click it, I'll get this break on drop down. And so, what this is doing is it says when one of these three things next happens, I want you to pause JavaScript execution. And I want you to show me what JavaScript caused the HTML to change, which is really very powerful."
          },
          {
            "time": "[00:01:21]",
            "text": "So you have three options, which is whenever the subtree is modified, and if you think about the DOM being a tree, so elements have children, elements of children elements all the way down, right? And so if you go to the HTML, which is the top element, and you say when the subtree is modified, that will mean anything on the app."
          },
          {
            "time": "[00:01:38]",
            "text": "But if you had a table like in my anecdote, you'd go to the table and do it there. You could also do when attributes are modified. So that would be if we did it, let's say on this h1. It wouldn't change if the text changed, but it would change if the ID changed like an attribute."
          },
          {
            "time": "[00:01:52]",
            "text": "And then the third option is break when a node is removed. Again, this can be really helpful, so as a little contrived example, I'll do break on for the HTML subtree modification, so anything changes in the subtree break? I think I have an old one clicking around here, which I'll get rid of."
          },
          {
            "time": "[00:02:09]",
            "text": "Okay, so now you can see this little blue breakpoint on the HTML. So then I can go into console, and I can do like document, get element by ID. Let me find one that exists idea main, so go back here. Grab this main, and I'll do main dot inner text equals high, something like that."
          },
          {
            "time": "[00:02:31]",
            "text": "So I changed the articles inner text to be high and before it even processed, I get this. I get this breakpoint here and my DOM where everything is, is paused. And if I click on the call stack, again, we'll get into debugging later. I just want people to be aware that they can do this cool thing it'll actually, show me the line that changed that bit of HTML."
          },
          {
            "time": "[00:02:52]",
            "text": "So I think this is one of those things that is really powerful for ultra specific situations. Like you'll be in a situation where the website is behaving strangely. And you have no real idea what's doing it in the JavaScript. Being able to figure out exactly what line of JavaScript is altering the HTML can be really useful."
          },
          {
            "time": "[00:03:09]",
            "text": "So I'll go ahead and play through here and go back to elements. As you can see the whole site turned into the word Hi."
          },
          {
            "time": "[00:03:09]",
            "text": ">> I followed along with the debugger example and mine is just stuck on when I updated the inner text to Hi,"
          },
          {
            "time": "[00:03:09]",
            "text": ">> Do you see up at the top of the screen a little I think it's like a yellow bar with a play button on it."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yeah,"
          },
          {
            "time": "[00:03:30]",
            "text": ">> You can hit that to play through. And I think it'll, get you there one more time and you hit play again and then it should go through."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Okay."
          },
          {
            "time": "[00:03:30]",
            "text": ">> Yep, and then the other way to do it. Yeah, that button should always be there."
          },
          {
            "time": "[00:03:42]",
            "text": "I think there's me we do this again, so you should have this play button up here. I think there's also a way to just like deactivate back here on the sources tab, you can deactivate all break points, and then if you hit play, it just won't stop again, which can be nice."
          },
          {
            "time": "[00:03:58]",
            "text": "So you can kind of leave them on, you can also then at any time go back to elements and right click breakout and then remove the thing and then the blue circle should go away. So then we have a finding event listeners to this is like very much in common with the HTML break points where we can see something going on with our app, but we're not exactly sure where it's coming from."
          },
          {
            "time": "[00:04:21]",
            "text": "So, like for example, you click on a button and it does something and you want to know where that JavaScript comes from. So that's what this third tab over here event listeners is for. And so you can see this is a static HTML site. So there is not really any event listeners except for this one that my code highlighter uses."
          },
          {
            "time": "[00:04:40]",
            "text": "But if you were to do some code like make a button and then add event listener, click to it or something like that or if you're in react and you did an unclick event or anything like that, those will all show up here. When you click on the items you could like click on different items and see if they have any event listeners this way."
          },
          {
            "time": "[00:04:57]",
            "text": "Color formats is another cool one, this one was added a few years ago, but I really like it. So you can see over here we've got border top and then it's like this reddish color. So we can pretty easily edit the hex codes, right, but another thing you can do is you can click on the color itself and it opens this like really nice color palette."
          },
          {
            "time": "[00:05:16]",
            "text": "You can drag it all around, so let's do something like, let me close this and let's take like the body and we'll do background color and we'll click on that. So now you can kind of drag it all around and really find the exact color that you're looking for."
          },
          {
            "time": "[00:05:32]",
            "text": "You can change all the kind of hue and saturation and transparency and all that stuff, and it'll give you the hex code. Another really cool thing is this section down here as the lower half which populates like colors themes. So for example is material UI, you can again, you can click on an element click on the actual square of the color, click on these this little toggle here, and then click on material UI."
          },
          {
            "time": "[00:06:05]",
            "text": "And now it'll populate this nice little section here. So as we're doing stuff, like we can choose the body background from material UI colors, which is Google's color theme, but the thing I use it for more than that, and let me refresh real quick, so I get rid of that yellow is I'll go to here."
          },
          {
            "time": "[00:06:20]",
            "text": "Click on this and then I'll click on page colors. And what this does is it's dynamically reading the colors on the current page and then generating a color scheme out of those. So this is like the actual blue that I use up here. You can also see that when you scroll off of this modal, it turns into one of those really cool like zoom things."
          },
          {
            "time": "[00:06:39]",
            "text": "And so you can like hover over if you wanted to get the hex for this blue, or this white or this red or anything like that. So these are all really cool, so it's got like an eyedropper. It's got all the kinda Hue Saturation stuff, it has multiple different formats RGBA, HSLA, hex and then it's got this really cool theme picker here."
          },
          {
            "time": "[00:06:58]",
            "text": "So there's like a lot here for when you're designing stuff. There's also a cool little Dev tools trick, which is you can go back to body and hover, you can shift click on any color box, and it'll instantly convert it between the color format. So I know some people at their jobs like we all use HSLA or we all use RGB or something like that."
          },
          {
            "time": "[00:07:18]",
            "text": "So you could just like Set it to a thing that you know like a hex, and then you can shift click on it to turn it into RGB other stuff that does it has this accessibility panel. The accessibility panel is really nice for when you're doing stuff like, we do a lot of stuff at work with making our sites keyboard accessible."
          },
          {
            "time": "[00:07:34]",
            "text": "So everything that you can do with a mouse you should be able to do by tabbing around with the keyboard. And so this can be really nice where it shows this accessibility tree. And you can see like what items have tab indexes or which ones have any kind of ARIA."
          },
          {
            "time": "[00:07:47]",
            "text": "Attributes on anything like that will be in here. And it can be really helpful when you're just trying to look at like, is this getting tap index or does this have my Aria label that I put on or anything like that will be in this tree."
          }
        ]
      },
      {
        "sessionTitle": "9-quick-edits-exercise.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> This is the first exercise. And this is all about the quick edits that we just learned. So it's to take this actual page here. And can you change this from an ordered list to an unordered list? Clicking on this link ,makes a pop up here. But can you find the JavaScript that calls this event, and then the third, one's like a little bit of a quiz, but there's a way to cheat."
          },
          {
            "time": "[00:00:21]",
            "text": "And like I said, dev tools helps you level up. So I have a button and when you click the button, this block quote gets rendered, right? And it gets rendered with this class, this ID and this inline style and I also have CSS on the page, which has an element selector, a class selector and an ID selector with important."
          },
          {
            "time": "[00:00:40]",
            "text": "And so the question on CSS specificity is can you guess what color it will be? But the dev tools cheat is let's say you forgotten all the specificity stuff already. Can you use dev tools that actually view what color it'll be before it gets rendered to the DOM?"
          },
          {
            "time": "[00:00:54]",
            "text": "And then the last one is there's a whole big list full of cards here. And when we wanna do is we wanna find the border color of the one with an ID of 12345678. And so can you use the dev tools to put in that ID and actually get to that card and view the border color."
          }
        ]
      }
    ]
  },
  {
    "courseName": "react-intermediate",
    "sessions": [
      {
        "sessionTitle": "0-introduction.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Welcome to intermediate TypeScript, I'm Mike North, I'm a Senior Staff Engineer at LinkedIn, and I work in the developer productivity and happiness org. My job is predominantly helping make our COI and our UI ergonomics around developer infrastructure great. And TypeScript is a huge part of that, and that's why I'm a great person to speak to you about TypeScript today."
          },
          {
            "time": "[00:00:26]",
            "text": "Among the top goals that I have for this course is, number one, I wanna make sure that I package and pass onto you all of the key learnings that I have gained through many hours of helping guide and tutor others around TypeScript. So you're going to see a lot of little pieces of code throughout this course, that you can copy and paste right into your own app, and they can solve some of the common problems that I get a lot of questions about."
          },
          {
            "time": "[00:00:58]",
            "text": "By the end of this course, I also want you to be able to understand complicated type information. And I'm gonna show you a sample of where we're going to be, by the time this course wraps up. This may look scary right now, but take my word for it, we'll know how to break this down and how to troubleshoot it, and how to understand it, by the time we get through intermediate TypeScript."
          },
          {
            "time": "[00:01:23]",
            "text": "What should you already know by the time you start to take this course? Well, first, you should have a lot of experience working with regular JavaScript. We're going to be making extensive use of classes, functions, a sync await, promises, so you should be very comfortable working with those concepts."
          },
          {
            "time": "[00:01:42]",
            "text": "You also should have equivalent knowledge to what we cover in the TypeScript fundamentals of V3 course. In particular, you should be comfortable working with basic types for functions, objects, arrays, and tuples. And you should have crossed the threshold where you understand how generics work, at least with one or two type parameters."
          },
          {
            "time": "[00:02:07]",
            "text": "And this is something we cover in TypeScript fundamentals V3. Finally, make sure you brush up on index signatures, that's going to be a very important part of some of the more advanced topics that we're going to cover today. It's also worth stating that practical experience will aid you in terms of connecting the concepts were talking about today, to real-world situations."
          },
          {
            "time": "[00:02:30]",
            "text": "So it's helpful if you've worked in a code base that consumes type information for common libraries like react. We've spent a lot of time making this workshop as easy to use as possible. So, all you're going to need, is this website that we're working on today and the official TypeScript website."
          },
          {
            "time": "[00:02:54]",
            "text": "We've brought a lot of the features of VS Code right into your browser, so we'll be able to clearly see examples that highlight what's going on. And we'll be able to write our own code, and even write some code to pass some tests. As of the time we're recording this course, I have made four types of courses for Frontend Masters, and the way I think about them is as follows."
          },
          {
            "time": "[00:03:20]",
            "text": "TypeScript fundamentals and intermediate TypeScript are core courses, and most of our time together is gonna be spent in a lab environment. The idea here is that it's easy to teach these concepts in small controlled examples. And once we turn the light bulbs on, once we understand how things work, that makes it easier to take that knowledge and apply it in a more practical situation, and that's where these electives come into play."
          },
          {
            "time": "[00:03:47]",
            "text": "Production grade TypeScript and JS TS Monorepos, in those courses, we build an app together step by step. And that's where you can look for the applied techniques and the real world design patterns. We assume, in those courses, that you have already substantial experience working with TypeScript. And this is where you can learn to build things for production and at scale."
          }
        ]
      },
      {
        "sessionTitle": "1-declaration-merging.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> The first topic we're going to discuss today is declaration merging. And this is the phenomenon by which types, and values can piggyback on top of each other. And they can be treated as a single named entity in your source code. By the end of this chapter, you'll be able to look at tooltips in Visual Studio code, which is the same tooltips that we see on this website."
          },
          {
            "time": "[00:00:24]",
            "text": "And you'll be able to make sense of exactly what's going on. Am I working with the type? Am I working with the value? How can I tell the difference? In this example, we have two what I'm going to call identifiers. And what I mean by an identifier is just a named thing that's defined in a single place."
          },
          {
            "time": "[00:00:45]",
            "text": "So we have one identifier called Fruit, which is a type. We know that, because it's an interface. And here is an identifier called banana, which is a value. TypeScript allows us to stack multiple things onto a single identifier. In this situation, we can see that we've named our interface, and our const variable the same thing, right?"
          },
          {
            "time": "[00:01:08]",
            "text": "They both fruit both with the capital letter. And we can see when we look at the tooltip for the interface, it's clearly just an interface. When we look at our variable, clearly it's just a concept declaration. But look at what happens when we attempt to export this as if we were exposing it outside of this TypeScript module."
          },
          {
            "time": "[00:01:28]",
            "text": "We can see this tooltip contains both, there's our const declaration, and there's our interface. These are actually two things stacking on top of the same word, Fruit. There's actually a third thing that we can stack onto this tooltip, so to speak unto this word, and that is a namespace."
          },
          {
            "time": "[00:01:51]",
            "text": "So in this example, we can create a class called Fruit with a static function on it. Now, we can create a namespace. And you can think of this as serving a very similar purpose as static class functions. And then finally we have a type called Fruit. So, if we hover over this export, and look at the tooltip, now we have three things class, interface, and namespace."
          },
          {
            "time": "[00:02:18]",
            "text": "So this is three things in one. Now you may be wondering when I'm importing stuff from other dependencies, how do I know what I'm working with? Well, I'm going to give you some investigative tools that you can use. To probe around, and to figure out what exactly is on one of these identifiers, right?"
          },
          {
            "time": "[00:02:42]",
            "text": "If I'm given Fruit, how can I test whether it's a class, sorry, how can I test whether it's a value, or a type, or both, or maybe neither? So, here are our tools. First, let's begin by creating a value, a type, and a namespace. And we've given them obvious names, so that when I put them up the screen here, you can remember what's going on, right?"
          },
          {
            "time": "[00:03:10]",
            "text": "So we've clearly got a value here. We've clearly got a type, which is just an empty interface. And then here we have a namespace. So you know something is a value if in a let or const declaration like this, you can put it on the right-hand side of the equal sign, and you get no error."
          },
          {
            "time": "[00:03:33]",
            "text": "If we try to do the same thing with the type, like we're doing down here, you can see that the compiler is not happy with us. And it's telling us is a type only refers to a type, but we're trying to use it as a value. So this alerts us to the fact that this is purely a type, there is no value part to this identifier."
          },
          {
            "time": "[00:03:58]",
            "text": "Let's look at a similar test but four types. So if we try to put this on the left-hand side of this assignment operator, and we get no error. That's an indication that this identifier can be treated as a type. And look what happens down here, if we try to do the same thing with a value, we get an error message."
          },
          {
            "time": "[00:04:20]",
            "text": "The thing we're using, it refers to a value, but we're trying to use it as a type here. So that failure tells us there's no type piece to whatever is on this thing, which is purely a value. Now, there's no equivalent test for namespaces, although the tooltips make it fairly obvious what's going on."
          },
          {
            "time": "[00:04:45]",
            "text": "So you see the word namespace on the left of the tooltip, that is a clear indicator. So you'd have to hover over it in order to figure out what exactly is happening there. While we're talking about namespace, some of you may be wondering, what's the point of these things?"
          },
          {
            "time": "[00:05:01]",
            "text": "And maybe you haven't seen them before, and you're wondering why they're even part of TypeScript? Well, an important aspect of TypeScript is it needs to be able to describe existing JavaScript libraries. Just think about when TypeScript was first made, and when they were trying to gain adoption. They needed to be able to say, here's type information that matches this existing library, which is written in regular JavaScript."
          },
          {
            "time": "[00:05:31]",
            "text": "So they needed to be able to type things like jQuery. And if we go to the jQuery homepage here, we can see some example usage right on the front page. So if we look down we can see, all right? Sometimes we're invoking this dollar sign thing as a function."
          },
          {
            "time": "[00:05:48]",
            "text": "And then down here, it appears that we're grabbing things off of the dollar sign, and they themselves are functions. So let's copy that code over, right? So this is basically the same code, it represents the same code. And we need to be able to describe types that can allow us to do these kinds of things."
          },
          {
            "time": "[00:06:13]",
            "text": "Here's how we might accomplish that. You can see here we're defining a function whose name is dollar sign. And we pass a selector in this could be up here, like h1 tags with a class title. And we're going to get all matching elements in a node list, as return value."
          },
          {
            "time": "[00:06:33]",
            "text": "In addition to that, to support this use case here, with .ajax, we need dollar sign to be a namespace that kind of stacks on top of that function of the same name. And that's what's allowing us up here to invoke this directly. And to use some of these functions that are sort of dangling off of the main function here."
          },
          {
            "time": "[00:06:58]",
            "text": "That's where namespaces are useful. Now, writing a library in this way. It's sort of leftover from the old way of consuming JavaScript dependencies, where you'd add a script tag to your app. And you would find that when all of your scripts have loaded, there's this global variable that has been tacked on to window or something, dollar sign, right?"
          },
          {
            "time": "[00:07:26]",
            "text": "And you could grab that, and basically access all of the capabilities of a library through that global variable. We don't really write things that way in modern JavaScript code bases. Now that we have modules, and better ability to consume third party code in that way. But we still need to be able to describe types for some of that old stuff that's lying around."
          },
          {
            "time": "[00:07:49]",
            "text": "So my advice is don't use namespaces too much. Don't focus on them too much. Cuz they're really about backwards compatibility, and not something that you often find is added to modern code bases. So now that we have a basic understanding of declaration merging, and how we can sort of sandwich or stack multiple things on a single named identifier."
          },
          {
            "time": "[00:08:19]",
            "text": "I want us to take a look back at the way classes work. So let's say that we have a class, like what you see on the screen now. It has three fields, each of which is optional, name, mass, and color. And then, it has a static functions. So, you could think of this, as a kind of a backup constructor of some sort."
          },
          {
            "time": "[00:08:42]",
            "text": "Sometimes you find that that's a good way to use static functions, a good use case for them rather. So if this is our class, let's apply the tests that we just discussed, and identify whether this is a value, or whether this is a type. So first we can test for value."
          },
          {
            "time": "[00:09:02]",
            "text": "And our test is to put it on the right-hand side of the assignment operator, and see if we get an error, and we don't. That means Fruit is a value. And when we take a look at this value. We can see that there's this createbanana thing, but note that we do not see color in this list."
          },
          {
            "time": "[00:09:21]",
            "text": "The reason is the value here is the class itself, not an instance of Fruit, it's the the factory or the constructor, right? We're seeing createbanana. We're seeing call, which indicates that this is kind of a function like classes or functions. So we would call this the static side of the class."
          },
          {
            "time": "[00:09:46]",
            "text": "Now, if we take that exact same identifier, and we test whether it's a type, the test is positive. The Fruit identifier is also a type. And when we look at the available completions here for the letter c, we can see that color is the only thing that's showing up."
          },
          {
            "time": "[00:10:07]",
            "text": "That's because when used as a type, this class is an interface that describes an instance of the class. So if you've been using classes, all along, now you know that they are a value, and a type of the same name stacked on top of each other. And depending on the context in which you use it, whether it's in the value position over here, or the type position over here."
          },
          {
            "time": "[00:10:35]",
            "text": "You're using one piece of it, or the other. So you've been making use of declaration merging, all along."
          }
        ]
      },
      {
        "sessionTitle": "10-indexed-access-types.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Let's talk about Indexed Access Types. The concept here is we're going to grab a piece of type information from another type using something that feels like a property key. So let's imagine we have an interface called Car, we can grab just the type of the color property here."
          },
          {
            "time": "[00:00:28]",
            "text": "Using, it kind of looks like the square bracket access notation for taking something off of a dictionary or accessing an element of an array. Note that although when working with values using the square brackets, we know that we can use .notation, right? So if we have a dictionary, and we saw this we probably say, well why don't you just doing like car.color?"
          },
          {
            "time": "[00:00:56]",
            "text": "That will not work here, this must be using square brackets. And you have to pass a string literal type into it. So there is some enforcement of a constraint here, so color is present on key of car. But look what happens if we use something that's not on car."
          },
          {
            "time": "[00:01:20]",
            "text": "So you'll get an error message. There is some validations helps catch spelling errors or if you were to remove something from car you think it's unused, then have confidence that all of these index access types will light up. And of course you can repeat this pattern, right? So if we only wanted to have the red part of car color, we could say give me color, and then within that just grab read."
          },
          {
            "time": "[00:01:52]",
            "text": "And so you could see these boxes, these square brackets applied over and over. Interestingly, if we pass a union type through this indexed access type, we get a union type out. So year is a number, color is red, green, and blue on an object. So you can see here it's, I call this projecting, right, you can almost sort of send your union type of keys into this index access type."
          },
          {
            "time": "[00:02:27]",
            "text": "And you get arguing union type of types of the values instead of types of the keys. Pretty straightforward concept, it's just sort of accessing a piece by name. And I know I use similar language to describe, extract, and exclude. Hopefully you can see the difference between what we're looking at here which is grabbing a chunk of an object type as is."
          },
          {
            "time": "[00:02:54]",
            "text": "As opposed to the conditional type with the infer keyword, where we were grabbing the constructor or looking at the construct signature, plugging up the argument out of that. That's a much more heavy handed way to do things behind the scenes it's also much more expensive to do things that way."
          },
          {
            "time": "[00:03:12]",
            "text": "This is cheap, this will not really affect your performance. Okay, last big concept and it's a big one, this is like a triple size section here, it's mapped types. So let's take a look at that."
          }
        ]
      },
      {
        "sessionTitle": "11-mapped-types.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> We're about to see all of the concepts we've talked about today come together through something called mapped types. This is the most powerful tool, in my opinion, for transforming types, right, taking some type, making it another type in a very organized and deliberate way. Where does mapped types get its name from?"
          },
          {
            "time": "[00:00:26]",
            "text": "A great way to remember it is it's kind of like array.map, if you're familiar with that, in that what we're about to see it feels sort of like looping behavior. Where we're iterating over all the keys of something and we're producing a type for a value. Again, we're purely talking about type information here, but the mental model of array.map and looping through and providing that transformative logic that you'd define with the callback for array.map."
          },
          {
            "time": "[00:01:00]",
            "text": "That's conceptually gonna fit pretty nicely with what we're about to see here. Let's take a look at the basics. So if you recall from TypeScript fundamentals V3, or equivalent experience in the wild, index signatures. You've seen index signatures before, hopefully, and this is what they look like. Note that we have kind of an arbitrary word here describing a property key."
          },
          {
            "time": "[00:01:30]",
            "text": "It's an arbitrary property key with an arbitrary name, meaning for a dictionary, if I access any key at all, I'll get this value type out. And then here is the value type. So this is like a generic type for a dictionary. I mentioned this in the fundamentals class."
          },
          {
            "time": "[00:01:46]",
            "text": "I'll often say I want t or undefined here, because there's always a possibility that when you access something on a dictionary, it might not be there. And I want to keep myself honest and to make sure I check for the presence of a thing when I grab it out of a dictionary."
          },
          {
            "time": "[00:02:03]",
            "text": "So we could see here, we can create a what I'm calling a fruit catalog. It's a dictionary of fruits, it'll start out empty. Here I'm kinda illustrating the problem I just talked about. But when we access any key we wish despite the fact that this is empty, we see we get a fruit back."
          },
          {
            "time": "[00:02:21]",
            "text": "So this what we're passing in for the t and we're kinda threading it through. This is an index signature, we've already covered this before. I'm gonna introduce a new concept here. And why did need a new concept? Because the only thing an index signature allows us to do is say for an arbitrary key, here is the type you can expect to receive."
          },
          {
            "time": "[00:02:47]",
            "text": "What if we have something more specific than just a narrow string? Or sorry, something more specific than any string rather. What if we have a list of properties and we wish to use that and not just the Wild West like you could put fruitCatalog.turnip or whatever you want, right?"
          },
          {
            "time": "[00:03:11]",
            "text": "We don't want that, we want something a little more deliberate. Well, this mapped type is gonna allow us to do something like this. Now, because in my mind at least, when I say the word dictionary, that means this very flexible key value store where I can hang whatever I want on an arbitrary key."
          },
          {
            "time": "[00:03:30]",
            "text": "So I'm gonna actually call this something different, given that we're no longer gonna be in the world of arbitrary keys. We have a set description of the keys we wish to use and then we have some value types. So we're gonna call that a record, and to avoid collision with something that exists in TypeScript already, I'm gonna call this MyRecord, right?"
          },
          {
            "time": "[00:03:53]",
            "text": "Just to avoid colliding with an existing type. So here's what's going to change. This is our interface as before, and here is the new signature. And we can look at these side by side in a moment. But for now, I want you to look at the fact that when I access cherry and apple, I get a type of fruit that's coming out."
          },
          {
            "time": "[00:04:19]",
            "text": "But when I try to access pineapple, we get nothing. Pineapple does not exist on MyRecord, and cherry and apple are here. So it seems that we're able to say, here are the specific property keys that I wish to use. Whereas with the index type, it was kinda like put it anywhere in this object and I will hold it for you."
          },
          {
            "time": "[00:04:43]",
            "text": "So let's compare these two signatures side by side. On the top, we have this mapped type and on the bottom, we have the index signature. And I've hidden out the type for the value here, because really, that's not what these signatures are all about. We can put whatever we want there in that dot, dot, dot."
          },
          {
            "time": "[00:05:03]",
            "text": "We'll talk about that later. Right now let's just look at the stuff that's on the left side of the colon. So index signature, the name doesn't really matter. I mean, you can put something there if it will help the reader understand what you're trying to do, maybe it's customer ID or something like that."
          },
          {
            "time": "[00:05:23]",
            "text": "Something that has some meaning to the reader, but it's not as if you're referring to this value anywhere. You're not saying name doesn't matter dot whatever, you can't use that. We're gonna see later that in this mapped type, we're able to use this. So giving it a name and making that name descriptive is a little bit more important."
          },
          {
            "time": "[00:05:44]",
            "text": "So here we have a colon in a regular index signature, and here we have this word in. And you can think of, when I talk about looping behavior, think of this union type as what we're looping over. And think of this as your i, right? For i equals 0 and loop over this."
          },
          {
            "time": "[00:06:08]",
            "text": "Or if you're doing a for in, right, where you're like, const key in dictionary. Fruit key is first gonna be apple and then it's gonna be cherry, and we're kind of processing, at least mentally we can think of it as a loop. Now remember, this is just type information."
          },
          {
            "time": "[00:06:29]",
            "text": "So there's no code that's being run and looping. There's nowhere you could put a break point to see what's going on. But the mental model of looping will hold up here. So mapped type lets you be more constrained and specific. Index signature, by its very nature, is about defining arbitrary key value relationships, different tools for different jobs."
          },
          {
            "time": "[00:06:54]",
            "text": "One's not necessarily better than the other. But if you were to say FruitKey in string, you would now be using a mapped type that is equivalent to the index signature below. Cuz it would just iterate, it would say like for every string, every possible string, here is the way I defined my value type."
          },
          {
            "time": "[00:07:17]",
            "text": "If that statement is not proof, that statement should be proof that there is no real looping that's happening behind the scenes. Because there's no way to iterate over every possible string in JavaScript, not in a way that will perform. There's just no way, let's just say there's no way."
          },
          {
            "time": "[00:07:36]",
            "text": "It's sort of a projection but it feels like looping to us. We can think of it as looping. So the in keyword, it's a telltale sign you're dealing with a mapped type. And index signatures, you can only define them on arbitrary strings or arbitrary numbers. That's it. And look what happens if we try to be more constrained in a regular index signature."
          },
          {
            "time": "[00:08:01]",
            "text": "We're literally told that these error messages are getting better with every release, consider using a mapped object type instead. If we attempt to do the thing that mapped types are designed to do, or we're doing it the wrong way, we're told, just go make a mapped type, please."
          },
          {
            "time": "[00:08:21]",
            "text": "Cool, so that's the difference. Seems like an index signature builds on top of that concept, but it's different. So, let's make our MyRecord type just to show what that is, right? This is not generic yet. It very specifically operates on apple and cherry, and it very specifically operates on fruit."
          },
          {
            "time": "[00:08:44]",
            "text": "Let's make that a bit more generalized. So what we're gonna do is replace this fruit key thing, right? Where it says FruitKey in apple or cherry. So let's rename that to key, down here. And then we're gonna pass in this apple or cherry thing. We'll make that a type parameter here."
          },
          {
            "time": "[00:09:04]",
            "text": "We'll call it the KeyType. And that'll be the first thing. And then this thing to the right of the colon, you've got this fruit. So we wanna make that generic. We'll pull that into a type parameter as well. So that's all we're doing. And by the way, this is from an experienced practitioner of TypeScript."
          },
          {
            "time": "[00:09:25]",
            "text": "This is a good pattern to follow, implement the non-abstract thing, and then start pulling things out to make it parameterized. It's a good way to make sure that you at least can affirm that continues to work with the use case you care about. So now we'll end up with something like this."
          },
          {
            "time": "[00:09:47]",
            "text": "It's much more generalized where we can specify here that we can pass in something like apple or cherry, right? Pass that in as strings. Kind of like those will be the names of the properties. This will be the values, the value of the property. And then it's almost like we're looping over everything in the key type we passed in."
          },
          {
            "time": "[00:10:13]",
            "text": "First apple, then cherry, and then we're giving this type. We're giving it a value type on the other side. Now, this is already built into TypeScript, but now you understand how it works hopefully. So it's called Record. And I want you to look at these side by side and see that aside from this, the names of these properties, which I've tried to be just a bit more descriptive than single letters."
          },
          {
            "time": "[00:10:44]",
            "text": "We had the same form here, with one exception, and that's like this keyof any. But down here, you can see that like, these are the types of keys that JavaScript allows. You can have numbers, symbols or strings, and that's it. So I've just said, okay, well, strings, this is most of the stuff I care to work with here has property keys that are strings."
          },
          {
            "time": "[00:11:08]",
            "text": "So that's a difference in the constraint, but doesn't make things fundamentally different. And then we have key in, some type that we passed in. So this is property key in K, well, there it is. And then there's the second type of param, and there it is. And here's our second type of param, and there it is."
          },
          {
            "time": "[00:11:29]",
            "text": "So really, what we're able to do with this mapped type is build up an object with a set of known keys that have a consistent value type. That's the first use case for this. Now, why might you care about this? Well, sometimes you want to maybe have a bunch of form fields and they each have sort of a value and whether they're validated or not."
          },
          {
            "time": "[00:12:05]",
            "text": "It's great to have a nice dictionary like this, especially if you're pre-creating one and you know exactly what you expect to be there. I'm blurring the line here between a record and a dictionary. But this is a quick and easy way to go ahead and create one. I would say this is a subtype of a dictionary."
          },
          {
            "time": "[00:12:28]",
            "text": "A dictionary is flexible in that you can have arbitrary keys and this has specific keys. So this is just a more specific thing than a dictionary."
          }
        ]
      },
      {
        "sessionTitle": "12-advanced-mapped-types.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Now let's combine this knowledge with what we just covered in the previous chapter, and that is an indexed access type. So what I've done here, and I apologize that the tooltip is kind of adding a big gap in the code, but this is just one type here, right?"
          },
          {
            "time": "[00:00:23]",
            "text": "What we're doing here is we wanna grab a portion of the window API as in the global that's available in a browser. And when do I do this? Well, especially if I'm writing code and I expect to make my tests nice and easy through dependency injection, I kinda want to limit myself to accessing only certain things on Window."
          },
          {
            "time": "[00:00:54]",
            "text": "So that I make sure that if I have to stub them in tests, or maybe if this is a single page app that I have to server render, well, there in the node world I might have to stub like polyfill some Windowish things so that the thing renders properly."
          },
          {
            "time": "[00:01:12]",
            "text": "But I wanna give myself sort of a explicit boundary so I know whenever I cross it. I can show you after we go through this a more real world example involving Chrome extensions and their Chrome extension API's. So great. So we have, we gonna call this part of Window and what we want is to grab only, we want something that looks like Window but it only has a couple things that can be found."
          },
          {
            "time": "[00:01:46]",
            "text": "So we're saying we're looping over these three things. So it's sort of almost like four each of these three, key is gonna be these sort of one at a time. And now we're using an indexed access type, right? So key is first gonna be document. So we're using Window[document], and we're gonna get this document type."
          },
          {
            "time": "[00:02:11]",
            "text": "And then the same thing for navigator, and then the same thing for set timeout, right? Here's the callback, and then here's the timeout number, and then here are the the arguments that are passed to the function. People, this is a rarely used aspect of set timeout. But ultimately, we get a subset of Windows, we get a portion of it, only these keys that we're interested in."
          },
          {
            "time": "[00:02:42]",
            "text": "So again we're gonna make this a little bit more generalized by pulling hard coded things out into typeparams. So the first thing we'll pull out is, we wanna pull out the keys, right? So that's this list of things here. So now we've got like Key in Keys, and that's a typeparam up here."
          },
          {
            "time": "[00:03:05]",
            "text": "And note that we're saying, Keys extends Key of window. Why do I want this, well pop out to the playground just so we can see it for ourselves. What if I did this? I would wanna be told, sorry, it's a pipe. I would wanna be told that zzz it's not a thing that could be found on Window, it's not found on Key of Window, Right?"
          },
          {
            "time": "[00:03:36]",
            "text": "A deliberate spelling error. If I took this away. Well the error would pop up in a different place. But now I'm being told hey, hey, hey, you can't just use Key as an index access type here, how do I know that that stuff's gonna be found on Window?"
          },
          {
            "time": "[00:03:56]",
            "text": "You could say hey it's a string, but so the first error is Keys, it could be a promise it could be a function, there's no constraint on Keys. I can't use that in a match type cuz can only use things that are like property keys, right? This is a core constraint of map types."
          },
          {
            "time": "[00:04:15]",
            "text": "It's about a property Key and looping over them. So even if I solve that by saying, It's a string, now this piece is gonna say, well, how do I know that these are things that I can get off of Window. It could be an arbitrary string. So that's why we have this in place just kinda makes everything work."
          },
          {
            "time": "[00:04:38]",
            "text": "It's not only a valid property key but it's the subset of all allowable property keys in JavaScript that will work with Window. And now, theme coming back, right? The error is popping up at the location where I apply my fix because I have misspelled this, and now things start to pass."
          },
          {
            "time": "[00:05:00]",
            "text": "So that's why you can see kinda how if we relax this, things will start to get angry in various places. This has to be a valid property key and hen this has to be a valid property key for Window. But we can get the same result out now, right?"
          },
          {
            "time": "[00:05:26]",
            "text": "So we had part of Window, this was hard coded for these three properties. So we made something here called PickWindowProperties, that's the more generalized thing, and then we can leverage that. So this is the general solution up here. We can get our specific solution back by saying, I wanna pick things off of Window, and here are the names of the properties that I wish to pick."
          },
          {
            "time": "[00:05:53]",
            "text": "Let's generalize it one step further by abstracting Window away. So we're gonna get rid of this and pull it out to a typeparam. So what we've done here, instead of calling it pickWindowProperties, we're just calling it PickProperties. And just as before we have these Keys that come in, I've actually moved it to the second type parameter, up here was the first, right?"
          },
          {
            "time": "[00:06:18]",
            "text": "I mean, it was the only one but it's in the second position now. So we have a valueType and then we have Keys, where these are Keys that are found on this valueType. And I'm using this map type here. So previously we were seeing what Window[Key], and now we're seeing ValueType[Key]."
          },
          {
            "time": "[00:06:42]",
            "text": "And we're still able to get our specific result here. Because we're parsing in Window, this is the thing we're plucking properties off of, and these are the names of the things that we're kinda peeling off. Let's open this in the playground. So I don't wanna talk about why I ordered these typeparams in this way."
          },
          {
            "time": "[00:07:11]",
            "text": "If I tried to reverse them, I might run into a problem, actually does this work now? That would be pretty cool. Wow they fixed this. All right, well, you'll still see stuff written the other way and I can kinda explain the rationale behind it. Just poking at it making sure, something's not right here."
          },
          {
            "time": "[00:07:39]",
            "text": "Let's see, I need the comma and then I think it'll work. Yep, okay, so it seems like this has been relaxed. But previously, you kinda had to state upfront. If I wanted to use ValueType in an argument, we first had to state the typeparam has to exist first, and then we can refer to it as a constraint for another typeparam."
          },
          {
            "time": "[00:08:07]",
            "text": "But it appears that recently they've relaxed this, which is kind of cool. That would let us build this API signature the way that we want, and in this case, just in terms of how you could read this out loud, I kinda like like this better. So I want to pick the properties document, navigators, setTimeout, setInterval from Window."
          },
          {
            "time": "[00:08:30]",
            "text": "And I like that rather than saying I want to pick the following things from Window, here are the properties that I want. You have both options available to you now. All right, Tristin asks a good question, in fact you've asked it twice and you've been very patient. So mapped types do they extend from dictionary, and since mapped types are a subset of a dictionary that extends word is still strange to me."
          },
          {
            "time": "[00:09:03]",
            "text": "So I would encourage you to think about this in terms of set theory. So if you imagine all of the dictionaries that could be in the universe. So things like this, right? All of these with all the possible property keys and all the possible ValueTypes. Some of them, [LAUGH] Some of them will be full of stuff, some of them will only have a couple property Keys."
          },
          {
            "time": "[00:09:41]",
            "text": "When we talk about something that is more constrained than this, more specific than this, we would say that it extends from this. So when we talk about mapped types kind of extend from their dictionary equivalents, you can think of it as, Dictionaries are more flexible than mapped types."
          },
          {
            "time": "[00:10:09]",
            "text": "So if I had, Or well, say this is a dictionary, Of dates, So it starts at empty. And then this will be, A index signature. And this is gonna require that I do a new date. Start of week is a new date. And I'll get rid of this little side panel here."
          },
          {
            "time": "[00:11:04]",
            "text": "Okay, so just looking at this code here, I would say that this dictionary is more flexible and more general than this type here, why? This has no opinion about which Keys dates are stored under. This one does have an opinion. So if I change these to let declarations, This is gonna be a problem."
          },
          {
            "time": "[00:11:36]",
            "text": "Because we can't, when we say I have a slot that's designed for a record, what guarantee do we have that end of week and start of week are here? We don't have that guarantee. Whereas in the other direction, Totally fine, why? The dictionary is ready to handle start of week, end of week, start of year, end of year, whatever you want."
          },
          {
            "time": "[00:12:03]",
            "text": "So that's, we see a Key insight here that records, these records are more specific than dictionaries. And when we talk about this extends word that's used in type parameter constraints, and in these conditional type conditions, the meaning of extends is, Something like this. We're saying is T, are all values that we could possibly have for T, to all of those satisfy what is described by date."
          },
          {
            "time": "[00:12:48]",
            "text": "And date could have many others that don't satisfy T, but does everything in the set that could be a possible T? Does all of that fit into date? So really we're saying, is T a specialized flavor of date? Is it a more specific version of date? It's a really tricky conceptual thing to get over, so I would encourage you if you're still having trouble with this, please ask more questions."
          },
          {
            "time": "[00:13:16]",
            "text": "Please keep kind of poking at this because it's one of these big lightbulbs that when it turns on, things become much more clear pretty broadly across the language. So now that we've generalized this let's look at what we have. We have a mapped type where we take two typeparams here, right?"
          },
          {
            "time": "[00:13:35]",
            "text": "So we take a value that we're plucking things off of this previously was Window. And then we have some union type potentially, that is one or more Keys that are found on this ValueType. And we're iterating over those Keys, and we're plucking the values off and this is what we get."
          }
        ]
      },
      {
        "sessionTitle": "13-pick-mapping-modifiers.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Well, we have arrived at another built- in type that TypeScript includes, and that is Pick. So if we look at the built in pick up here, and the pick properties that we made, they're basically the same type parameter names aside. ValueType is going to be the T, as you can see it here and you can see here,ValueType is here, and here or also, there's a Keyof T and a Keyof ValueType, and then here we're creating over the keys."
          },
          {
            "time": "[00:00:36]",
            "text": "So that's how pick works. It like where for record, we just needed the map type. Here we're using this indexed access type to grab something off of something else, if that makes sense. We're using that square bracket notation. We're saying, here's document, give me document, right? Record if we look at it one more time, it was just a consistent thing we were always placing there, like, it's always going to be the same."
          },
          {
            "time": "[00:01:15]",
            "text": "Whereas here we're kind of like Were using a different key. And so as a result, what comes out like these are obviously different types. Document, navigator, set timeout. That's what this index access type gives us when used with a map type. Let's talk about mapping modifiers. These are just kind of something potentially to memorize or just remember that it exists, but not not an incredibly abstract concept."
          },
          {
            "time": "[00:01:46]",
            "text": "So, the way to think about this is, as we loop over in our map type, as we loop over all the keys, we have the option to determine whether the ValueType should be read only or optional. There are two independent things. You can be read only and optional or you can be non optional and writable like they're totally independent."
          },
          {
            "time": "[00:02:15]",
            "text": "So, you're gonna see that we will find a question mark in some of these code example and the word read only. So here, this is a built in type. We're going straight to the built in types here because these are kind of less interesting to build up. But this is the key."
          },
          {
            "time": "[00:02:33]",
            "text": "This is the thing that makes partial different from pick. While there are a couple things, first off. Pick, lets see you specify which keys you would like. Here, we're iterating over all the keys in type T. And over here, we're saying the value may or may not be there."
          },
          {
            "time": "[00:03:02]",
            "text": "So that's partial, and this is the opposite of partial. The only thing that changes is we have a minus sign. It's almost like we're removing the optionalness as we loop over. This is a very weird thing like, a rare thing to for you to put into your own types."
          },
          {
            "time": "[00:03:19]",
            "text": "But that's how this works, right? It's just that and then read only here. So this would, it doesn't really freeze the object. Just remember that TypeScript disappears as part of your build process. And so at runtime like this might actually be a writable thing. But this would type check it."
          },
          {
            "time": "[00:03:42]",
            "text": "So create a version of something that is read only. Maybe it's an options, object that you're passing to function or some object you're passing in a function. You want to make sure that you don't modify it, like mutate the thing that you were passed, you might make it read only so that when you receive it, you'll be called out."
          },
          {
            "time": "[00:04:02]",
            "text": "If you ever try to mess with something that really should live in your stack, right? Now there's no built in type for removal of read only you could implement it like this, but is not necessarily a good idea. It's probably if someone made something read only, might want to figure out what that reason is they probably don't want it messed with."
          },
          {
            "time": "[00:04:27]",
            "text": "But just showing you that there is continuity here in terms of question mark and read only they both work with this minus sign. Just know that the positioning of these. So this is fairly easy to remember because it's the same location of that question marked as optional class fields or optional object literal properties."
          },
          {
            "time": "[00:04:51]",
            "text": "And read only that's always to the left cuz it's kind of like where you would put an access modifier keyword in a class field or a method it's like public read only function,."
          }
        ]
      },
      {
        "sessionTitle": "14-template-literal-types-key-mapping.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Template literal types. Not deserving enough of its own section I don't think, but a kind of a cool thing. It's a recent addition to TypeScript. So as of the time of filming this course 4.3 is the most recent TypeScript release. So template literal types have not been around for all that long."
          },
          {
            "time": "[00:00:26]",
            "text": "But I would like to show them to you because especially around data layer stuff they are really, really promising. They look like a great way to make highly reusable things. So we're going to experiment with them here. I have first, a type that I'm calling ArtFeatures, things that could appear in a painting, and then I have colors."
          },
          {
            "time": "[00:00:56]",
            "text": "So using the same syntax that you're used to using for ES template literals, by that I mean the backtick strings where you can interpolate non-string values into a template string. We can create what's called a template literal type. And what we're seeing here, so first, let's look at the syntax."
          },
          {
            "time": "[00:01:20]",
            "text": "We've got the backticks here. We have the dollar sign single brace, we're used to seeing that, right? And what we get, it's sort of every combination of color and paintable art feature. So we've got a darkSienna_cabin, darkSienna_tree, darkSienna_sunset, and now we're going to sapGreen_cabin. And it keeps going and going and going."
          },
          {
            "time": "[00:01:45]",
            "text": "When I showed this to my wife, she said that looks like a factorial. That will tell you how many of these you're going to get, right? It's every possible combination, how many unique combinations you'll get. But these are not good, in terms of, sorry, these are not idiomatic JavaScript method names, right?"
          },
          {
            "time": "[00:02:11]",
            "text": "I'm calling this art method names and look at those types, we don't use snake case, right? Not in JavaScript, I mean you totally could. The language supports it, but it's much more conventional to use camelCase. So how would we accomplish this? Well, you have a couple little special things, special transformers of these elements within your template literal type that would let you do something like this."
          },
          {
            "time": "[00:02:42]",
            "text": "Capitalize colors and we've removed the underscore but look at the d in darkSienna. Despite up here it being lowercase, right, the first letter's been capitalized and so we can get some nice method names here. Not a coincidence by the way, the feature set was built such that you could have lowercased property names and then maybe have getters and setters."
          },
          {
            "time": "[00:03:08]",
            "text": "And you want when people are using your code to be able to use these as things that feel like they were painstakingly implemented one at a time when really, it's just sort of an a times b. And here is the format of the string that I want. So why am I talking about this in a chapter of this course called mapped types?"
          },
          {
            "time": "[00:03:33]",
            "text": "Well, let's bring it back to mapped types. So what we can do here, some people call this key mapping. And effectively if we go back to our analogy of array.map, when you use array,map, you are converting the values of array A to array B, right? You're just converting the values."
          },
          {
            "time": "[00:03:56]",
            "text": "This lets us manipulate the keys as we're making that transformation. Let's see what happens, right? So here's the mapped type, right? I'm saying I'm iterating over each key and by the way, let me introduce this before [LAUGH] we go too deep in here. Let's say that this is just some piece of data, a record that I persist to an API somewhere."
          },
          {
            "time": "[00:04:23]",
            "text": "I've got an array of numbers, I've got an array of strings, and then this flags thing is a record of Booleans. So I'm gonna pop out into the TypeScript playground, we can play with this. Data state.so we've got digits, which is a number array, here's flags. So I've got dark mode and mobile, those are each a Boolean, maybe little user preferences that someone could turn those on and off, right?"
          },
          {
            "time": "[00:05:01]",
            "text": "Here I'm just being yelled at because I'm using this before it's been assigned. But it's equivalent to, Equivalent to something like that. We already talked about record but just bringing us home there. So what this lets us do is we're iterating over all of the keys in this data state interface, right?"
          },
          {
            "time": "[00:05:31]",
            "text": "So that's gonna be first digits, then names then flags, and then we're using this as keyword, as is how this remapping can happen. And we're adding the word set in front of it and capitalizing, so we get a little method here that's called setDigits, setFlags and we can pass these things in."
          },
          {
            "time": "[00:05:52]",
            "text": "So if you've written data layer code where you have a bunch of Boolean properties where it's is, is dark mode, is user opt into beta. Well, you could see how you can now in a very generalized way derive some controlled accessors for those kinds of things. Maybe you would use object.defined property to dynamically build something and then be able to represent the types accurately."
          },
          {
            "time": "[00:06:29]",
            "text": "Let me show you a library where I would hope one day they'd use something like this to define types. This is my favorite library for colorizing CLI stuff in JavaScript. And basically, to make this string blue with a red background, you do .blue, and then look at this, bgRed."
          },
          {
            "time": "[00:06:55]",
            "text": "So every colors available as a foreground or background. And now instead of explicitly saying we've got the red and then we've got here's the red and then here's the bgRed. But now you could define this template type that would just add bg capitalized, the R in red boom, and now you can make a really nice API."
          },
          {
            "time": "[00:07:17]",
            "text": "And this library is a pleasure to use, it's very easily proves that you can build beautiful and highly ergonomic APIs. Not rest APIs but functional APIs using this kind of technique. And look, we're now back to catching spelling errors again, we get true type checking here, because I left the E off of mobile and TypeScripts figured that out."
          }
        ]
      },
      {
        "sessionTitle": "15-filtering-out-properties.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Finally, the last sub part of mapped types that I'd like to talk about is, how do we filter properties out? So, we've already seen how we have some control over what is included via filtering the property key, right? So we used extract before, and we can actually, this is pretty cool."
          },
          {
            "time": "[00:00:26]",
            "text": "We can use a template literal type, almost like a query tool here to say, show me those keys of document that begin with the word query. That's pretty cool, right? It's almost like a find the substring like a regular expression, right? Which of these keys begins with query because it's any string that begins with query."
          },
          {
            "time": "[00:00:56]",
            "text": "That's what we're matching against. So we get all these QueryCommandEnabled, querySelector, querySelectorAll, etc. So those are the keys of interest and we can produce a filtered version of this document type. Meaning we only get those properties that are specified by the keys of our choosing, because that's what we're iterating over, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "We're saying K is each of these 1, 2, 3, 4, 5, 6, 7 things, right, to each of these seven things. For each of them, we'll go look at the document, get the value type, and that's what we're gonna have there. So this is one mechanism of filtering, if the key is the determining factor, but what if we want to filter based on the value?"
          },
          {
            "time": "[00:01:46]",
            "text": "For example, what if we wanted the things on the document object that are functions who return either an element or an element list, right? And I'm kinda thinking about querySelector and querySelectorAll, just things that we use for retrieving or creating DOM nodes. Now, in advance, I couldn't tell you which keys, I mean, I can tell you querySelector, querySelectorAll, are gonna be included."
          },
          {
            "time": "[00:02:14]",
            "text": "But I can't tell you which things those would be, right? So we're gonna need to think about how to approach this. And first, we're gonna go down the wrong road. So I wanna be very clear. I'm showing you something that doesn't work, but I think it's a useful midpoint as we approach a better solution."
          },
          {
            "time": "[00:02:37]",
            "text": "So first we're going to use never, we're gonna use a flawed approach. Here's a disclaimer, don't copy and paste this code into your app, please. We're gonna use a flawed approach and use a conditional type with a mapped type, In order to do this filtering, so I'm gonna read this to you in pieces."
          },
          {
            "time": "[00:03:00]",
            "text": "So we're iterating over all of the keys of document and we're performing a test. What's the test? What's our condition, is the value type for a given property key. It doesn't extend. Right, is it at least a function with an arbitrary number of arguments that returns either an element or an array of elements."
          },
          {
            "time": "[00:03:29]",
            "text": "This condition is the right one for sure. This will be represented in our good solution in a moment. So we're comparing this to see if it matches what we're looking for. And if it does, we let it pass through Document [K], right? And if it doesn't, we say, never, hoping it will disappear."
          },
          {
            "time": "[00:03:53]",
            "text": "But it doesn't, as you can see up here, we end up with every single property that is on document including 235 that have been suppressed. And although the things that match, I mean they're still usable, right? We don't say never hear. It's totally usable. Although that still works, it's not really gonna help us when it comes to autocompletes."
          },
          {
            "time": "[00:04:22]",
            "text": "We're gonna go here and we'll say, okay, let's see what subset of things I have available. That's a never these are all nevers, it's just a bunch of noise, a bunch of garbage in here. AppendChild, is that one of them. So that one didn't get zeroed out. But these gotten zeroed out, it's just a bunch of junk in here."
          },
          {
            "time": "[00:04:42]",
            "text": "It's not giving me good feedback as to what I can successfully use. So, hopefully we all agree, undesirable result. How can we make this better? A better approach is gonna involve filtering those keys first. And then once we have the set of keys that match our condition which is gonna be a value based condition."
          },
          {
            "time": "[00:05:12]",
            "text": "Then we'll be in a position where we can get something that looks more cleaned up. And I first want you to witness that this works and we're gonna peel it all back, and build up to it slowly. So when I say that this works, first, there aren't over 200 things here and the things that are here, I can't spot any nevers on my screen."
          },
          {
            "time": "[00:05:40]",
            "text": "So let's compare, there's seven more and up here there were 235 more. So it seems it's much more filtered down. And I'm gonna also sanity test and say, well, adopt node, create element, querySelector, do these things, do they feel like they're for DOM query, or DOM element creation?"
          },
          {
            "time": "[00:06:02]",
            "text": "Yes, just on a conceptual level these seem like what I was looking for. And then finally down here, this was one of the things I selected. So, I'm gonna kick out to the TypeScript Playground. And this is the kinda thing I would encourage you to pop this open on your own machines and follow along with me."
          },
          {
            "time": "[00:06:25]",
            "text": "Because what you're about to see is somebody who's familiar with working with these kinda types, me. You're gonna see how I deal with this thing up here, which is nutty and complicated, and hard to debug. And you're going to see how I make progress towards getting it to work."
          },
          {
            "time": "[00:06:53]",
            "text": "Because as, if you've been playing with this throughout the course, there's no debugger for types. This is not really code that runs, you're just defining constraints. So when things get complicated, and this is the equivalent of having many things on the same line of code, right? Where it's just doing a lot, one higher order function that does everything."
          },
          {
            "time": "[00:07:15]",
            "text": "It's really challenging to troubleshoot. So you're gonna see how I peel this back and how I can start with breaking this up into simple small things. And layer my way up into the thing that eventually is going to work. Okay, so I'm gonna actually come and add our solution and create a copy of it."
          },
          {
            "time": "[00:07:40]",
            "text": "So the approach that we wanna take here is, we want to select those keys, whose value type is what I'm looking for, right? So, we wanna go and find query selector and identify that is what we want. Because document.query selector is matching the condition that we're filtering for."
          },
          {
            "time": "[00:08:09]",
            "text": "We're not just picking it because of its name we're picking it because it has a value. That is what we're looking for. And that value is this. And I'm actually gonna deviate from our written solution there for a second just to add some more verbose, a greater explicit set of information here."
          },
          {
            "time": "[00:08:33]",
            "text": "So we'll just call this, ElementFunction, Element, and it's this, right? Just so we can refer to it by name and we get some of that punctuation out of our way. So we can take ElementFunction, we'll put it here, cuz that was working, cool. So FilteredKeys, I'm actually gonna get rid of this for now."
          },
          {
            "time": "[00:09:09]",
            "text": "All right, so let's look at this here. So we're taking in a type, right? The fact that we see keyof T, here and T[P], this is gonna be the thing we're iterating over. So let's call it, We'll call it ToFilter, right? We're filtering this thing. And then you will call this, Condition, something like condition, right?"
          },
          {
            "time": "[00:09:50]",
            "text": "It's the type that represents what we're trying to match. So we're going to loop over all of the keys. And then this is our little i in our for loop, right? For each key, this is our parameter, see that parameter in the tooltip? P for parameter. We're gonna go and grab the value type out of whatever we're filtering from."
          },
          {
            "time": "[00:10:20]",
            "text": "We're going to check it against the condition, right? Is the value type assignable to whatever we passed in? It's gonna be this, right? Is it a function that returns an element or an array of elements? And if so, this is weird, we've never seen this before. We saw a whole bunch of code that would do this, Right, we're like, did it match the condition?"
          },
          {
            "time": "[00:10:47]",
            "text": "Let it pass through. No, that's not what we're doing. If it works, if it passes the condition, we're sending the parameter through. This is the key, not the value, otherwise, never. So look at what we get out here. And let me make a smaller type so we can see this more easily."
          },
          {
            "time": "[00:11:10]",
            "text": "So we've got this, and we'll call this RelevantColorKeys. And we're going to filter for, Actually those should be numbers, right? Just let's keep it consistent with way I've treated colors throughout the day. Look, green number, save, so FilteredKeys. So we've got this color, that's what we're filtering over."
          },
          {
            "time": "[00:11:43]",
            "text": "And let's just make sure that everything passes straight through the way it should. I mean, I expect this to of course work, great. So everything passes through when I remove that condition. And then if this extends this condition, I should see P, what if we did this? You know what, I'm also gonna comment out."
          },
          {
            "time": "[00:12:15]",
            "text": "No, I have no idea why this would interfere with anything. So, okay, so we're back on track here. Now I can explain what's going on here pretty easily now. So, we're iterating over all properties of Color, right? We're looking at red, we're looking at green, we're looking at blue, and we're comparing them against number."
          },
          {
            "time": "[00:12:41]",
            "text": "We're comparing the value types against number, right? So this is number, this is gonna be here. This will be red, and then this here, it'll end up being a number. So if we were to do this, string, string for red, And then string for blue, now we can see that our RelevantColorKeys."
          },
          {
            "time": "[00:13:06]",
            "text": "So green is gonna kind of pass through. And then look everything else turns to a never because they don't match. Now, what we want are the property keys. Right, so we're still getting this object type out, we want the property keys. Well, we can take advantage of the fact that an indexed access type, we can send, we can sort of project something through an index access type."
          },
          {
            "time": "[00:13:33]",
            "text": "So I get this object type out. What if I did this? I just get green. So, it's almost like I'm starting with this and then I'm saying, okay, if I pass in the key of, right, it's just gonna be never, or green, or never. And remember, whenever we or with never, the never disappears."
          },
          {
            "time": "[00:14:14]",
            "text": "Nevers disappear when you or with them. So if we just simply say keyof Color, we're basically saying, I'm gonna transform all of the keys of color, a union type of all of the keys of color. And I'm gonna project them through this. And I'll get a union type of all of the values, but not all the values of color, cuz we've sort of modified it a bit here."
          },
          {
            "time": "[00:14:40]",
            "text": "We'll get all of the values of this, in a union type, never, or green, or never. And that's why we get just green. Now, we can actually move this up here and say keyof ToFilter, And it'll still be green. So now if we uncomment this and these, I think there may be one last thing we have to do, and there is."
          },
          {
            "time": "[00:15:15]",
            "text": "So our last problem to solve here, we've hit this before when using index access types. And basically it's saying that, look, I see you have this thing here. It's all of these keys, but they've passed through a couple things by this point. How do I know they're still key of document?"
          },
          {
            "time": "[00:15:36]",
            "text": "If you're gonna reach into document and access, if you're gonna use this thing here, how do I know that that's gonna work out? Well, the way we handled that before, was we said, hey, look, if you don't trust me, I mean, I know if we look at the keys of document and we look at what I have, they overlap completely."
          },
          {
            "time": "[00:16:00]",
            "text": "Meaning, Everything I have is included in the set of possible keys. So I'm happy to do this. I know it's a no up, but if it makes you comfortable, all the better. And now we are, I believe, should be where we need to be. Key of document, yep, and there it works."
          },
          {
            "time": "[00:16:23]",
            "text": "There's our query selector, returns an HTML input element. And look at that, this is just what we wanted. It's like a subset of document that only relates to DOM manipulation. So imagine now if you have a React app and you've ever done server side rendering, you know that sometimes you have to do some node stuff maybe you register a service worker, or some code runs and it's like, you tried to reach into window and it's not there."
          },
          {
            "time": "[00:16:51]",
            "text": "Well, this would let you kind of put some confines around that API that you're not supposed to be accessing if you're trying to serve or render your React app. Another example, here it is, so I built a Chrome extension recently. And when I'm defining the parts of the extension API that I wish to talk to, I make sure that, I don't want to reach in and touch too much."
          },
          {
            "time": "[00:17:22]",
            "text": "Because although I can use a lot of things on the Chrome extension API, depending on what permissions my extension is asked for, things will error or they won't, right? Unless I have the user's permission to access their location data, I can't do that. This lets me put boundaries around what's gonna be presented to me in autocompletes, right?"
          },
          {
            "time": "[00:17:48]",
            "text": "Where I only want to see this stuff showing up to me. And if I need some other part of the API, well, I'd have to come back here and I'd have to add it. And that'll be the trigger for me to say, when I ask for permission from users, and in a Chrome extension that's gonna be here."
          },
          {
            "time": "[00:18:09]",
            "text": "When I say, I need to be able to access the active tab and the tabs thing, right, all these permissions, that'll be my signal. I'm changing the boundaries, because I set up this nice sort of confinement around what I was building. And furthermore, I think here, so when I have to stub out parts of the Chrome API, I only have to deal with those pieces that I've said I'm going to access."
          },
          {
            "time": "[00:18:44]",
            "text": "So when I'm stubbing things out, I know, look, I only need this ad listener thing. Here on this type I've said, look, I only have these properties on there. I plucked these things off and I only wanna see that subset of things showing up. Well, now I have this type safety that tells me whenever I go out of bounds, right?"
          },
          {
            "time": "[00:19:05]",
            "text": "I have this partial Chrome API instead of the full blown thing that will show me everything and who knows what you have to stub there? It kind of depends on where you're writing your code. So that's a practical use case. I'm going to write up the types for a little mini data layer using a variety of the concepts that we've seen so far."
          },
          {
            "time": "[00:19:35]",
            "text": "But I do want you to celebrate one thing at this moment. And that is, that this type here, this FilteredKeys thing and the stuff you saw here, if we go back to the very beginning of the course, we had a slide on the beginning of the course where we set this out as our goal."
          },
          {
            "time": "[00:20:05]",
            "text": "And we've now accomplished it. And the way we do it is just sort of piecing it together, chunk by chunk by chunk, and sort of expanding it out so that we're not maybe not trying to do so much on one line. But then when we get it right, we can put it all back together."
          },
          {
            "time": "[00:20:21]",
            "text": "So hopefully we're feeling a little bit more comfortable at taking complicated things like this and sort of slicing them up a little bit."
          }
        ]
      },
      {
        "sessionTitle": "16-typing-a-data-layer.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> As a final kinda capstone to intermediate TypeScript, we're going to do a little bit of a practical exercise and that is to make a well typed data layer or a data store using the concepts that we've learned in the class today. So, and I'm just in the playground here, and you could copy this code if you like."
          },
          {
            "time": "[00:00:26]",
            "text": "But all I've got is three classes, one is called book, one is called movie, one's called song. And I've just chosen a different meaningful property, which we'll turn into a class field for each of these different classes. So if we did b is new book, we'd have to give it an author, maybe I'm the author."
          },
          {
            "time": "[00:00:50]",
            "text": "And we can see that b.authored it gives us this type back, and that's because we're using these nice little shorthand param properties, maybe you heard us talk about this in TypeScript fundamentals. So, ultimately, what I want is an API that looks kind of like this. I wanna be able to create a new store, this is like a data store, that's what I mean by store."
          },
          {
            "time": "[00:01:17]",
            "text": "And then I wanna be able to do something like store.get('book'), and this should return a book. And I wanna be able to do getAll, and this should return an array of books. And maybe create and this should take an arb if it's a book. Hopefully we get the idea here."
          },
          {
            "time": "[00:01:43]",
            "text": "We want a kind of a nice little crud, some portion of a crud like data store that gives me some good types when I retrieve things, and it gives me some type safety when I'm trying to work with things, trying to modify them. So let's actually, I created a book here, Let's pass that in, let's use this as kind of a little test case, right?"
          },
          {
            "time": "[00:02:15]",
            "text": "And let's see if we can do this one, we'll say update, and this is gonna be kind of a patch, where I'm gonna pass some incomplete subset of fields here, maybe I'm just editing the title or something, call it a partial. So this would be a book ID."
          },
          {
            "time": "[00:02:42]",
            "text": "And then, Something like that. So we want create and update and then get a collection, and we want good type safety around this. And none of this works yet, so we're gonna have to make it work. So, clearly, we're gonna need these methods here, right? The getAll, create, and update."
          },
          {
            "time": "[00:03:19]",
            "text": "So now the methods exist but they don't take anything, they don't take the right types of things. And they all return void right now, so we need to do some work. Now I do notice that we've got book, book, book, book, we're referring to kind of a record type by name."
          },
          {
            "time": "[00:03:36]",
            "text": "So what I'm gonna do here is create a map of my records, and by map I just made a type that gives me keys and values. We'll call this EntityMap, since we've talked about the word record before in a different context, and I don't want to overload it."
          },
          {
            "time": "[00:04:06]",
            "text": "Great, so we've got movie, book, and song. The keys are the names I'm gonna use to refer to this kind of entity, and then these are the follow on classes and, sorry, they will be interfaces, because they're in the type position. I mean, we're defining them as classes but they will be the interface part of it, meaning the type of an instance of these classes."
          },
          {
            "time": "[00:04:33]",
            "text": "So in all of these methods here, I could say, kind, by the way, if you ever see kind in TypeScript code, it's because we don't wanna write the word type. That's a special thing, that's like a type alias. Kind is a good alternative to use. So, and this will be, A key of EntityMap, great."
          },
          {
            "time": "[00:04:58]",
            "text": "So now this book thing is gonna be happy. Now I actually want this to be generic, right? So we'll say k for kind. And the reason is, I need to create a relationship between things. So if you remember back to the TypeScript fundamentals, when we talked about generics and type params."
          },
          {
            "time": "[00:05:28]",
            "text": "The whole point of this is we're defining some parameter that describes a linkage between things. So, in the case of get, the relationship is I'm asking for a book, and let's say we provide an ID. And I'm gonna return a book, or maybe like a promise that resolves to a book."
          },
          {
            "time": "[00:05:54]",
            "text": "Let's pretend this is all synchronous for now, you can make it async by just making all these promises instead. But we're gonna return EntityMap[k], this is an indexed access type here, right? We're saying, project the word book through this EntityMap. All right, here's book, grab the value, bring it back."
          },
          {
            "time": "[00:06:18]",
            "text": "And so over here, look at our return type, when we use this string book here, we get a book back. Watch this, when we use movie, check that out, we're getting a movie back. So depending on that word that we're using, we get the right type of entity returned to us."
          },
          {
            "time": "[00:06:42]",
            "text": "Now, we can do the same thing with the collection, it should be very similar. But let's say we don't need an ID here, since we're getting them all, and I'm just gonna put square brackets after this. And let's see what's happening here, getAll('book'), we get an array of books."
          },
          {
            "time": "[00:06:59]",
            "text": "So this is a great use of generics, a great use of an index access type. Create, so here, we want to take an object to create, right? And this is gonna be an EntityMap[k], and this will be a void. So here, if we were to say, I'm creating a book, and in here we get author, right, get some validation."
          },
          {
            "time": "[00:07:31]",
            "text": "If we gonna change this word to movie or to song, song wants artist, From Mark G's new album, right? So, we get that nice linkage between the first argument, which is a literal type, it's a statement of which record we're operating on, and that gives us some really great control over the second argument."
          },
          {
            "time": "[00:08:00]",
            "text": "What about update? So we can actually just borrow this from the create, and we will say to update, or actually we need an ID here, cuz we're referring to an individual record. So we need an ID because we're referring to an individual record, and the only thing we're gonna change is we'll say partial."
          },
          {
            "time": "[00:08:25]",
            "text": "So if you remember what partial is, if we look at the type, it's gonna loop over all of the properties in whatever it's given and make the value type optional. So this means that if we had, let's say, books have a title, In addition to an author, so this would let us say I'm gonna update this book, and I could just do the author, or actually, I could do nothing at all, this is sort of a no update."
          },
          {
            "time": "[00:09:00]",
            "text": "But we get some validation, but we may just have a piece, like I'm just editing one field, right? Whereas up here, if we said book, We need an author, And a title. Something like that. Now we could, implementing these, I would leave as an exercise to you. That's not about the types, that's about the JavaScript, the actual code that you would run."
          },
          {
            "time": "[00:09:38]",
            "text": "So, what we've used here are, within partial, right, we've used a map to type, we've used this little modifier here, we've used an indexed access type. This mapping here is really nice and important, and everything's sort of flowing through that. So this interface ends up being really important because everything sort of threads through it."
          },
          {
            "time": "[00:10:01]",
            "text": "Now, what if we had each of these types of records in its own file? I mean, this is common, right? Where if we have models for data, we have a JavaScript module that is dedicated for book and for movie. Well, watch this. And then delete this, everything's gonna start failing at the bottom, cuz it's an empty interface, right?"
          },
          {
            "time": "[00:10:32]",
            "text": "So key of that empty interface, there's like, nothing's gonna make it happy, and in fact, the key of an empty interface is never. So a no string will make it happy, but we'll get back there, no cause for alarm. So we would still need EntityMap to exist. I'm just gonna create a line here representing different modules, and you'll have to take my word for it that this will work across multiple files."
          },
          {
            "time": "[00:11:00]",
            "text": "So let's imagine that these are all different files, we could do this. We're gonna take advantage of the fact that interfaces are open. I see some head nods, people know where I'm going with this. So, if you maybe have some kind of library or framework that you're using that has like code generation, where it builds starting point files for you, all you need is to have this."
          },
          {
            "time": "[00:11:34]",
            "text": "This is part of your code gen, this little thing. So each record type we have here, a movie, a song, a book, they're all sorta adding themselves to this EntityMap. It's almost like they're registering themselves with this central thing. And it turns out everything ends up being added here and our code starts working again."
          },
          {
            "time": "[00:11:59]",
            "text": "I need a title here, A History of TypeScript, I can't help myself. So, basically, we get the same autocomplete that we had before. If it works. There we go, book, movie, and song, right? So, this has the same effect as if we defined that one interface upfront. So you can have your code split up across many, many different modules."
          },
          {
            "time": "[00:12:31]",
            "text": "You get to group each concern according to movie, and song, and book, right? According to what you're modeling, instead of saying, all right, here's where we maintain all the types, and here's where we maintain the actual code that runs. That to me is the wrong splitting point, I like being able to go to this one file and it's all here, everything having to do with this is here."
          },
          {
            "time": "[00:13:01]",
            "text": "And this shows us that this EntityMap thing and interfaces in general are kind of this cross cutting thing that, You can use to sort of make horizontal things across your app. Meaning, we can refer to this now and it relates to all of the different types of records we could work with, not just one thing in one module."
          },
          {
            "time": "[00:13:28]",
            "text": "Now typically, these will be in separate files, we can kinda simulate that. And we're gonna do this with what's called a module declaration. This is as if, so make TypeScript think that this lives in a library called fem-data. All right, this is actually gonna still work, because we've got these EntityMap things here."
          },
          {
            "time": "[00:13:59]",
            "text": "Sorry, we've got the individual interface declarations for each record, but let's copy this over. Let's see how this works. Cool, now EntityMap is not gonna be accessible here, maybe we can do this. [SOUND] Import, this may be beyond what the, May be beyond what the playground can handle."
          },
          {
            "time": "[00:14:43]",
            "text": "Actually, we may be getting the right auto complete behavior here, let's check one more time. Nope, it's all disappeared. So, beyond the bounds of what can be done in the playground, but this is exactly what you would want if you were breaking things up across many JavaScript modules."
          },
          {
            "time": "[00:15:06]",
            "text": "So you could say, you would define this here where this interface actually exists, some ts file. And then here you could say location/of/entity-map, right? Just like it's a local file of some sort. And that'll make sure that you're modifying the EntityMap that's in that other file. You're augmenting that interface rather than an EntityMap that's in this one module, if that makes sense."
          },
          {
            "time": "[00:15:39]",
            "text": "It's a really powerful pattern that scales nicely, because you can imagine as you add and remove different modules and things, this list of things you could retrieve from the database grows. You don't want one central collision point where they're just tons of git conflicts there all the time."
          },
          {
            "time": "[00:16:00]",
            "text": "This makes it so everything sort of has its own place with one central location of registry."
          }
        ]
      },
      {
        "sessionTitle": "17-wrapping-up.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Just to recap, we begin by setting some goals and talking about how this course is designed to help you understand tricky type information and to give you tips and tricks that you can put right into your app. Copy paste code out of this course, and it'll save you major headache."
          },
          {
            "time": "[00:00:18]",
            "text": "We talked a little bit about how different kinds of declarations stack on top of each other and came to the realization that classes are actually two things stacked on top of each other. It's the factory and it's the instance, right? We talked a bit about modules and CJS interop one of the trickier things where frankly, I have helped a TC 39 members, the people who are on the JavaScript standards body."
          },
          {
            "time": "[00:00:43]",
            "text": "They've had trouble with this and I've had to walk them through this the same way I walked you through it. So don't feel bad if if you get stuck there, and it's a little mysterious. We extracted type information from values using type queries, like type of, then we moved on to conditional types."
          },
          {
            "time": "[00:01:03]",
            "text": "And the built in type script utility types extract and exclude, which are just conditional types behind the scenes. And we saw how having one branch of your condition resolve out to never, that allows you to do some really interesting things. We introduced the infer keyword and we built a utility type to extract an argument out of a constructor."
          },
          {
            "time": "[00:01:31]",
            "text": "And we looked at the example of something like a Webpack config where it's a meaningful type that adds a lot of value to you. But if you didn't have access to it directly, you could kind of suck it up with a vacuum and put it where you wanna put it and refer to it just as if it were an export interface."
          },
          {
            "time": "[00:01:50]",
            "text": "Index access types, this was just a little square bracket notation for grabbing like a sub part of a type. And then finally, this was the big thing we were sort of working our way up to mapped types and that's the thing that looks like an index signature. But we can imagine like we have a lot more control, hopefully you see now where we can loop over all of the keys and a type or all of some other key, right?"
          },
          {
            "time": "[00:02:16]",
            "text": "Any union type that is based off of allowable property keys. And we can combine this with index access types, with conditional types, with those template literal types. And in a very powerful way transform one piece of type information to another. So I hope by the end of this you feel more confident working with type information how to pick it apart."
          },
          {
            "time": "[00:02:42]",
            "text": "You know how to debug it a little bit. And hopefully this will set you on a great path for your continued learning around TypeScript."
          }
        ]
      },
      {
        "sessionTitle": "2-modules-cjs-setup.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Next let's talk about modules and interrupt between a modern TypeScript code base and common JS libraries. Node still uses common JS as its defaults module format although modernization efforts are underway, it'll be a long time before we can forget about this older way of writing JavaScript code."
          },
          {
            "time": "[00:00:24]",
            "text": "This is one of the trickiest aspects of getting dependencies to work nicely with your own code. And I have helped seasoned experts overcome the stumbling blocks I'm about to show you. So this is a lot of tips and tricks. They're valuable even for you experienced TypeScript practitioners. The reason we even need to talk about this is because until 2015, there was no standardized module format for JavaScript projects."
          },
          {
            "time": "[00:00:54]",
            "text": "As a result, several community based solutions emerged. We have CommonJS which was popular in the node community, AMD and UMD and these were more popular for browser based apps. Because of all the bundling technology we use for browser based apps, these two types of modules AMD and UMD have sort of gone away, right?"
          },
          {
            "time": "[00:01:21]",
            "text": "Very few people write code like that, although sometimes we have these as a compiled target we don't really see that code. Common JS has stuck around and it's largely as I said, because of node, right. Node still consumes common JS libraries. And the core libraries of node are written in this format, so we need to know how to consume them."
          },
          {
            "time": "[00:01:47]",
            "text": "It's important to understand that I'm assuming and I encourage you to only write ES modules these days. You should be writing your own new code, using the new standard. Because that's a good way for you to be forward compatible, right? That your code will have a longer shelf life."
          },
          {
            "time": "[00:02:09]",
            "text": "First, everything you're used to seeing around model imports and exports in the Java script world, also works for TypeScript. So here are a bunch of examples. We can go through them very quickly. But they all work in TypeScript and JavaScript alike. So we've got multiple named imports. We have a default import, a named export a default export, these are re-exports, right?"
          },
          {
            "time": "[00:02:37]",
            "text": "We're sort of passing lemon and lime which originate in citrus, into our module and then export them out as if they're our named exports. All of this works in TypeScript. Although it is not super common in JavaScript projects, you're going to see things like this a lot in the TypeScript world, because often this is the solution to common JS entrop."
          },
          {
            "time": "[00:03:06]",
            "text": "So we see up here you have this module called berries. We're getting strawberry and raspberry from it. This would let you get a name space with all of the different berries hanging off of it. There's even a capability to alias a name space re-export, which is something TypeScript does today, and something JavaScript has just added to their draft specification for the language for the year 2021."
          },
          {
            "time": "[00:03:33]",
            "text": "So soon you will start to see this as a feature that you can use broadly across JavaScript. Great so that's stuff that works in JavaScript, also works in TypeScript let's talk about the more interesting thing. What are the special import concerns, you need to know about, as you take on authoring a library or an app in TypeScript?"
          },
          {
            "time": "[00:03:57]",
            "text": "Well first, if you're writing code that looks like this, or if If you're looking to write typed code that does the same thing as this, often you can just use this namespace import, right. So when we say I'm gonna grab this namespace fs from this module, if you've ever used this fs module which is one of nodes core modules, it's just a collection of functions hanging off of this fs thing."
          },
          {
            "time": "[00:04:23]",
            "text": "There's like read file sync, right file sync, read JSON, write JSON and the fs is just sort of a way to hold them all together. And we can import it just like this. Or you could import using a named imports like specific things from fs. Almost all common JS interrupt can be handled in this way."
          },
          {
            "time": "[00:04:48]",
            "text": "But there's one case that will really throw you for a loop if you encounter it and that's the case where whatever the module is exporting as its single export, it is not something that looks like a namespace. So let's look at this case here, where we have a function and effectively in our common JS code, we would see something like this, right?"
          },
          {
            "time": "[00:05:15]",
            "text": "module.exports equal In this whole function. Now we can't represent a function as a namespace, and by the way this is the equivalent code in TypeScript to accomplish this here. So if we try to consume it in this way, we're going to get an error message. And this says that if we wish to use ACMA script, imports and exports with this module, we have to turn a compiler flag on called esModuleInterop."
          },
          {
            "time": "[00:05:45]",
            "text": "And this error message is telling the truth. But what it's not telling us, is that there's an alternate solution to this problem and that is, for us to use an import that is not aligned with the ACMA script standard. And this will save us from having to turn this flag on."
          },
          {
            "time": "[00:06:04]",
            "text": "Why would I want to leave this flag off? Well, this is what I call a viral option. So viral options like es module and allowsSyntheticDefaultImports, if those are necessary, if you have to turn those on in order to make your types work, everyone who consumes your types will also have to turn them on."
          },
          {
            "time": "[00:06:28]",
            "text": "So particularly when I'm writing library code, I jumped through some serious hoops to make sure that I leave these off. And that means that if you're using one of my libraries, it's your decision whether you want to enable these or not. I don't want to force that decision on everyone who uses my code."
          },
          {
            "time": "[00:06:48]",
            "text": "So I call these viral options because when one library enables them, anyone who consumes it also has to turn it on. Thankfully, we have another solution to this problem, right. And that's the non ECMO script import. Here is how it works. So we still have this code here remains the same as when we last saw it."
          },
          {
            "time": "[00:07:10]",
            "text": "But here is the key thing, the key idea. This looks kind of like a common JS Import. But one words different, right? We're used to saying seeing const createbanana = require(\" /fruits'), but we see import instead of const. This is what makes it kind of a unique thing, right?"
          },
          {
            "time": "[00:07:32]",
            "text": "It's the imports used to be this way in very old versions of TypeScript, and you can still use them. And you can see the type information still comes along for the ride here. So given that in this situation we have to choose between a bunch of non ideal possibilities either forcing consumers of our code to turn some compiler option on, or doing this, I would sooner do this because I like the idea as a library author, I think it's part of my job to like absorb some of that pain for downstream consumers of my code."
          },
          {
            "time": "[00:08:09]",
            "text": "So I will almost always do something like this compared to forcing people to change their compiler settings. If we look at what this code compiles out to, thankfully, it's exactly what we would want. We can see module.exports = createbanana. And if we look up, that's what we were trying to accomplish here."
          },
          {
            "time": "[00:08:36]",
            "text": "And here, we can see that this is required, just the way we would hope to see common Jas code, if we have written it in regular JavaScript, right. It's just consuming the entire module as a single thing, invoking it directly because it's a function, we're good to go."
          },
          {
            "time": "[00:08:58]",
            "text": "Just on the topic of making sure your types don't require special compiler options, a quick reminder that VS code will download type information in the background as it sees users consuming a library. And there's a possibility that even if they're not depending on your library's types like directly, they'll start to see some autocomplete information in their authoring environment."
          },
          {
            "time": "[00:09:26]",
            "text": "So it's important especially if you're doing open source work, it's important to be good citizen. Make sure that if you publish types, those types of work. And make sure that you don't spread those viral options, and put that burden on your consumers cuz it may be a very tricky thing for them to straighten out, if they start to see red squiggles under their code cuz TypeScript is unhappy."
          },
          {
            "time": "[00:09:52]",
            "text": "Finally, I wanna talk about importing things that are not JavaScript modules. So if anyone in the class uses web pack or parcel or snow pack, anything like that, the way these bundlers work, is your JavaScript modules occasionally will point to non JavaScript things, that need to sort of be packaged in the same layer of assets as their respective JavaScript modules."
          },
          {
            "time": "[00:10:22]",
            "text": "So here let's imagine we have a react component that needs an image file, well, you could import an image like this. Here's a link to the Webpack documentation where I copied this line from. Now TypeScript is not happy with this by default. It's saying, I can't find a module named file.png, and that's because there is no TypeScript module called file.png, not in this environment."
          },
          {
            "time": "[00:10:50]",
            "text": "So we need some way to tell TypeScript that whenever we import a png file, it should be regarded as a JavaScript module with a default export, that is of type string. This can be accomplished if you create a file called global.d.ts, and you're gonna wanna create something called a module declaration."
          },
          {
            "time": "[00:11:13]",
            "text": "So in plain language, this could be taken to mean, I hereby state that a module exists and the name of that module is some arbitrary text followed by .png. And the default export of this module is going to be a value whose type is string. As a result of having this little piece of type information, elsewhere in your project, you're gonna see that this exact same line that was failing before, it's now not only error free, but we can see that the value of this IMG thing, it is of type string, which is great, that's ripe that's ready to put into an image tag source equals this, right?"
          }
        ]
      },
      {
        "sessionTitle": "3-type-queries.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Type queries allow us to obtain a type from a value. And there are two new keywords I want to introduce, which fit into the category of type queries. Those are keyof and typeof. So first, we're going to look at keyof. keyof allows us to obtain all of the keys of an interface or object type of some sort."
          },
          {
            "time": "[00:00:30]",
            "text": "So here, note that we're looking at a type alias, right? And if we hover over Date here, you see obviously the word interface Date. That's an indication that we're working with this as a type. And we're using this keyof operator, and then we're getting something here, it says DatePropertyNames."
          },
          {
            "time": "[00:00:50]",
            "text": "We can't really see much more about this. Now, in JavaScript, we can have property keys that are strings or numbers or rarely symbols is a separate type symbol. So not all keys are strings. But if we wanted to take this thing that we have here and say, I wanna see the keys that are only strings, only those keys that are also a string, we could use the intersection type operator."
          },
          {
            "time": "[00:01:22]",
            "text": "Remember, if we think about the Venn diagram, the intersection type operator will help us to select only those things that are in the overlap portion of the Venn diagram, right? We're saying you must be a key of date and you also must be a string. And if you meet condition one and condition two, then you're part of this new type."
          },
          {
            "time": "[00:01:46]",
            "text": "If you think about geometry, and I'm sort of revealing my educational background here. I'm a mechanical engineer by education. I think of this kind of like a dot product in that, if you remember that you can kind of define vectors as some portion in the x direction and some portion in the y direction."
          },
          {
            "time": "[00:02:05]",
            "text": "You're kind of getting the part of a type that aligns with some other type, kind of like a dot product. That's useful enough to me that I want all of the other sort of visual learners to think of it that way. So it's the sub-part of keyof Date that is also included with string."
          },
          {
            "time": "[00:02:30]",
            "text": "So here we've got the same line that we had above. In our second line, we're saying intersect this with string, and look what we get. We get all of the property names of date that are also string. We've got toDateString, toLocaleTimeString, getFullYear, 33 more, right? It's even truncating this tooltip."
          },
          {
            "time": "[00:02:56]",
            "text": "There's a lot going on here. So remember, we're still working with types, but what we've created here is a union type, right? This is the or concept of all of the different property names, which could include methods or fields that we could find on date. We've obtained type information here."
          },
          {
            "time": "[00:03:17]",
            "text": "So if we wanted to get the other things that are left over, apparently there's this Symbol.toPrimitive thing. And you can read more about that here, but that's why this didn't show us a list of strings. There's actually one symbol in there and it's for converting a date to either a number or a string."
          },
          {
            "time": "[00:03:38]",
            "text": "And there's a footnote if you wanna play with that, if you're curious and wanna pull that thread. So that's keyof. It's gonna be really important later in the course, keyof. typeof, so this is a much more direct type query in that we're literally saying, I have a value and I wish to get the type that describes this value."
          },
          {
            "time": "[00:04:03]",
            "text": "So here's a little bit of sample code. I've made sort of a non-trivial value here just to sort of make things interesting. We have a fetch which returns a promise that resolves to a response, right? Look at that return type, they're promise, and then generic over response. And then here, we've created a second promise that resolves to a string."
          },
          {
            "time": "[00:04:28]",
            "text": "Promise.all, it takes an array of things. Any of those that are promise-ish, it'll wait for those. So if we await this, look at that tooltip, it's a tuple containing a response and a string. But let's pretend that this was much more complicated. We don't have a nice type that describes this."
          },
          {
            "time": "[00:04:49]",
            "text": "So if we wanted to obtain that type, all we'd need to do is grab this, right? This is our value. See the word const in the tooltip? We're using this typeof operator, or this keyword rather. And then we can create a type alias that describes what this thing is."
          },
          {
            "time": "[00:05:10]",
            "text": "You may be wondering like, where might I use this? Well, what if you're consuming a library that exposes some things to you, some values? But they don't give you the type information for these things directly as an interface or as a type alias that you could independently import and export."
          },
          {
            "time": "[00:05:31]",
            "text": "But if you wanted to make a function that takes the return value of something else or a function. What if this were a webpack config, a really complicated, big, big object with lots of stuff on it? If you wanted to make a function that takes a webpack config as an argument, this would be a way where you could say, hey, look, I have this thing."
          },
          {
            "time": "[00:05:50]",
            "text": "Maybe it came out of a function as a return value. And now I can have a type for it, and I can use that type for something else. It's great for sort of threading concepts through and making sure you're still referring to the original source of truth. I don't have a tuple written in this piece of code at all."
          },
          {
            "time": "[00:06:07]",
            "text": "I mean, unless you would argue that this is a tuple, but certainly not a tuple type. This is a value, right? It's the thing passed into Promise.all. But I am very much referring to the type information for resolve, for fetch, for Promise.all. That's all baked in to this Response, string."
          },
          {
            "time": "[00:06:29]",
            "text": "So if these were to ever change, if I upgrade my typescript version, for example, everything will flow through very nicely. I'm still just pointing to one single source of truth. I'm just sort of giving it a name so I can hold on to it with this type query."
          },
          {
            "time": "[00:06:44]",
            "text": "So typeof is also useful for obtaining the static side of a class. By static side, we mean like the factory, right? It's the ability to create new fruit in this case and any static methods that are on this class. So if we look at the tooltips below here, we haven't written the word typeof, but we can see it appearing to us."
          },
          {
            "time": "[00:07:11]",
            "text": "If we store as a variable a copy of this Fruit class, not an instance, we can see the type of this variable is typeof Fruit. And then if we create an instance, we can see that the type is just Fruit. So if you wanted to see the static stuff available on a class and you wanted a type for that, remember, if we just use Fruit in the value position as we are here, we're referring to the constructor, right, the class, not an instance."
          },
          {
            "time": "[00:07:48]",
            "text": "And then if we look at what its type is, now we have a way of getting access to it using this type query."
          }
        ]
      },
      {
        "sessionTitle": "4-conditional-types.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types are kind of a ternary operator, but for type information. In fact, they use exactly the same syntax. And in this chapter, we're gonna look into these things. And we're gonna work up our way to what's coming next in the chapter after this, where we will see that there are some utility types that become possible once we introduce this concept of conditional types."
          },
          {
            "time": "[00:00:33]",
            "text": "Utility types are just, they're things that come with TypeScript for free, that are so broadly useful, that they're just included with TypeScript itself. It's kind of a little standard library. So first, let's talk about ternary operators as they pertain to values. You're used to seeing this in JavaScript already in all likelihood."
          },
          {
            "time": "[00:00:57]",
            "text": "So, it's just if, then, else logic and ternary, of course, just means having three parts. And we have our three parts here, right? So, if we have a value, we could say x is negative only if it is less than 0, right? So if it's greater than or equal to 0, it is non-negative, otherwise, it's negative."
          },
          {
            "time": "[00:01:25]",
            "text": "And there are three parts here. There's a condition to evaluate an expression to use if that condition evaluates to true. And then the expression to evaluate if that condition evaluates to false. All of this is gonna serve you well as we start talking about the equivalent in the types world."
          },
          {
            "time": "[00:01:46]",
            "text": "Let's look at the equivalent in the world of types. We have two appliances here that are used for cooking. We've got a grill and an oven. And they have no common shared method names. So we would say there's not very much overlap between these two things, between grill and oven."
          },
          {
            "time": "[00:02:04]",
            "text": "But that's what we're defining here. And then we can define a type that conditionally turns into either a grill or an oven. And we're gonna unpack this syntax piece by piece in just a moment. But for now, I just want you to observe the result. And the result is, remember, this is just a literal type."
          },
          {
            "time": "[00:02:28]",
            "text": "It's not a value. It's a specific string type, a string that only matches one particular thing. So if we say this is a cooking device of type grill, we get a grill out. If we say it's a cooking device of type oven, we get an oven out. And we also see the very familiar ternary operator at work here."
          },
          {
            "time": "[00:02:56]",
            "text": "And this is a condition. This is what to use if the condition evaluates to true and this if false. So if we strip everything back, we can see the pieces of interest, right? Those three parts. And it works exactly the same way. So we can kind of map it out in this way."
          },
          {
            "time": "[00:03:18]",
            "text": "If we've had a condition, expression if true, expression is false, they're just type expressions, they're not value expressions. And frankly, these two pieces here are not interesting, you could put whatever type you want there. This condition is kind of interesting. So, you can see that we're using the extends keyword here."
          },
          {
            "time": "[00:03:37]",
            "text": "And we've used it in a couple places. So if you took the fundamental course, we used extends to describe constraints for type parameters. A way of saying I take type T, and T must be at least this type. It at least must be an object that has an ID property on it, or it must be at least a string."
          },
          {
            "time": "[00:04:00]",
            "text": "Could be more than a string, but I want, I need to be able to assume that I can treat it as string and as a minimum requirement. Well, in this context, the word means the same thing. We're saying that, T must be at least this type. It's not an equality check."
          },
          {
            "time": "[00:04:23]",
            "text": "I think of it more like a greater than equals comparison. You are at least of this type. And this is the only tool we have as of today's version of TypeScript for expressing conditions. We can only use this extends word."
          }
        ]
      },
      {
        "sessionTitle": "5-conditional-types-practice.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So, quick little exercise here, with our understanding of how extends works. I want us to look at this list of eight examples, and tell me whether you think this will evaluate to true or false. So, just take a moment and look at these eight things, and we'll reveal the answers in a moment."
          },
          {
            "time": "[00:00:26]",
            "text": ">> Don't peak down here, this is where the answers are. Don't cheat yourself out of the learning experience here. But just think through these eight situations and see if you can figure out what's true and what's not. We're gonna go over the answers to this eight question quiz."
          },
          {
            "time": "[00:00:46]",
            "text": "And in doing so, we're gonna learn a little bit more about how this extends keyword works. So, we're gonna open up our spoiler warning. And so, as everywhere else in this course, these little code snippets, they're coming like directly from TypeScript compiler output. So you know I'm not lying to you."
          },
          {
            "time": "[00:01:09]",
            "text": "This is compiler results we're seeing as answers. So first, 64 extends number, that is true. And the way I encourage you to think about this, if you watch the TS fundamentals course, we likened types to kinda set theory, where we could say this type here, it's like any number you want, as long as it's 64."
          },
          {
            "time": "[00:01:37]",
            "text": "And over here, it's any number you want. So, the extends keyword, it's kinds like asking a question, does everything on the left fit within the set on the right? So, is the set 64 allowed within the set of all numbers, it is true. And here, we can see that the reverse is not true, why?"
          },
          {
            "time": "[00:02:03]",
            "text": "This number set here, that's gonna include the number 63, which is not in the set that only includes 64. So, this is just way too general. It includes things that won't make this type happy. So, number does not extend 64. Applying that same technique, we're seeing if the set of all possible string arrays fits within the set of all possible values that could ever exist in JavaScript, seems true."
          },
          {
            "time": "[00:02:39]",
            "text": "Within everything we could create in JavaScript, of course, we can include all string arrays. In chat says, I thought the inverse. I know man, that's why we're going over this. Like, this is a common misconception and I had to wrestle with this exact same thing. So, the slow and steady approach here is, well, it took for me to learn this."
          },
          {
            "time": "[00:03:03]",
            "text": "So, that's why I'm passing it on to the class. So, yeah, the set of strings is included in the set of any possible allowed values. And the set of all string arrays is also included in the set of all possible arrays. This type on the right includes arrays of numbers, arrays of Boolean, arrays of promises, right, and arrays of strings."
          },
          {
            "time": "[00:03:27]",
            "text": "So, there we go. This one's interesting. I bet a lot of people got this wrong. I bet a lot of people got this wrong. Because when you take things out to the infinities, right, to the infinitesimally strict and the infinitesimally not strict, it's very confusing to think about this, and it's tempting to stop applying the mental model."
          },
          {
            "time": "[00:03:53]",
            "text": "I bet a lot of people got this one right up here, and if you got them reversed, that's fine, right? That just means you didn't understand which direction extends was operating in. But I suspect if you mirror your answers, you might have had inconsistent results between this and this."
          },
          {
            "time": "[00:04:14]",
            "text": "Well, let's apply our same logic here. Never, the set of all values that can make never happy, empty set. Does everything that is included in an empty set fit in the set of all possible JavaScript values? Yes, of course. If we had to write a for loop to verify this condition for answer number five, we would never even loop over anything, right?"
          },
          {
            "time": "[00:04:41]",
            "text": "There's nothing to check. And we kind of default to true. It's like, do you have room in your house for everything that's inside this empty box? Sure, [LAUGH] then yeah, there's nothing in there. We have room, that's the way to think about this. Here, this is another kind of interesting edge case, does the set of everything include the set of everything?"
          },
          {
            "time": "[00:05:09]",
            "text": "Sure, kind of with the reflexive property, this would better be true. Getting a little bit more complicated here and thinking now in terms of the type for a class constructor like a factory versus an instance. So, we've got first, the instance case, right? That's the interface called date."
          },
          {
            "time": "[00:05:31]",
            "text": "Does this include the set of all things that can be used with the new keyword? That's what this type means. Are you a newable, sometimes people use this newable word, right? So, an instance of date is not newable but if we put this type of keyword in front of it, and we get the type of the factory for dates, it turns out that that is newable."
          },
          {
            "time": "[00:06:06]",
            "text": "Does anyone have any questions about these? So, raise your hand or type y in the chat if you've got at least one of these wrong, and now you kind of understand a little bit more about how extends works, after thinking through it again. So, Dimitri asked the question, the modern set theory has some limitations for case six."
          },
          {
            "time": "[00:06:28]",
            "text": "We don't understand why exactly, maybe I could learn a little bit more about that. What I do think is if we just say, does everything in box A fit inside something designed for B? And in this case, we're sort of moving everything over like by definition, like the set of all strings is included in the set of all strings, right?"
          },
          {
            "time": "[00:06:53]",
            "text": "So, Christoph, you make a good point. And if you're watching this course now, you were thinking that extends sort of operated in the reverse direction. You might have thought about it as like, does the thing on the left, is that the larger of the two sets, and then this is the smaller of the two sets?"
          },
          {
            "time": "[00:07:15]",
            "text": "It's actually the opposite. Remember, extends is about getting more and more specific. If you have a base class and you make a sub class, and then another sub class, you're adding more properties, right? If we started out with any, we have the set of all possible things that you could create in the JavaScript universe."
          },
          {
            "time": "[00:07:39]",
            "text": "And then, we'll start saying well, all right, let's make it more specific. Let's just talk about arrays. All right, let's talk about just arrays that only contain strings. Well, every time you make one of those statements and you're saying, let's make this more specific, let's define more type information, let's add more constraints, you're narrowing, and narrowing, and narrowing and you're making drilling down."
          },
          {
            "time": "[00:08:06]",
            "text": "And there are fewer and fewer things in your set. So when we say it's 64, it's almost like a weird way to say it, but the 64 have a base class of number. Kind of a base type of number like, if we widen it out, would we end up with a number?"
          },
          {
            "time": "[00:08:29]",
            "text": "Like if we made string array more general, would we arrive at all possible arrays, right? Well, making it more general, let's allow non-strings to be included. And then we could say, maybe it doesn't have to be a array, more general still. So, let's start zooming out. These are great questions, and this is one of the best things I can do with this the short time we have together, to help you get over these hurdles."
          },
          {
            "time": "[00:08:57]",
            "text": "Let's put this conditional type concept to work. And we're going to look at an example and build our way up to some of the standard utility types, that are included with the TypeScript programming language."
          }
        ]
      },
      {
        "sessionTitle": "6-extract-exclude.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Extract and exclude, these utility types which are included as part of TypeScript, they're used to obtain some sub part of a type, either through specifying what you're looking for, or what you're not looking for. Extract is about defining what you're looking for and you get that piece."
          },
          {
            "time": "[00:00:24]",
            "text": "Exclude is about describing what you want to leave behind, and you kind of get everything else. So these, behind the scenes, just use a conditional type. So we'll be able to put this concept we just learned into action now. So let's say we have a type that looks like this."
          },
          {
            "time": "[00:00:44]",
            "text": "So we have favorite colors, and we have a bunch of colors that are listed, right? So think of this, if we were in CSS and we were using the color or background color property, you can write out the word red. Or you can define colors like hash, F00."
          },
          {
            "time": "[00:01:05]",
            "text": "Or you could say RGB parentheses 255. You could specify your decimal values for each of those eight bit color slots. So we're allowing all of that here. So we kind of have a mix, right? We have strings, we have a three part tuple. And then we have an object with properties red, green and blue."
          },
          {
            "time": "[00:01:28]",
            "text": "So if we wanted to obtain only the subset of what's described by this type, that is also a string, we could use extract in this way. If we scroll to the right, you can see that we get just the strings. The tuple is not there, the object is not there."
          },
          {
            "time": "[00:01:52]",
            "text": "We could do the same thing by changing this second thing, the second type that we pass to extract. And now what we're saying is within favorite colors, give me whatever sub part of this type has a property called red, whose type is a number. We don't need to specify this whole thing here."
          },
          {
            "time": "[00:02:21]",
            "text": "Remember, it's not an exact match. This is a minimum requirement. So let's pop this example out into the playground, and let's say, what if we did this? Let's add an alpha channel, right? We could, well, this is not gonna be because it overlaps so much with the other type."
          },
          {
            "time": "[00:02:44]",
            "text": "Let's say I'm just gonna do this. I just don't want one to be strictly a superset of the other. I want them to have some overlap where we can see an interesting thing. So if we look at object colors, now look, we selected both of those, if you see in the tooltip."
          },
          {
            "time": "[00:03:02]",
            "text": "The object that has green and blue written as words versus their first letter. So it's almost like a query searching for things that might contain a substring of, here's a fragment, you'll find me the whole thing. You can think of it kind of that way, at least when we're using it in this context."
          },
          {
            "time": "[00:03:21]",
            "text": "This is where we're doing the searching. Make that a little bigger. This is where we're doing the searching. And then this is the clue, right? This is the fragment to use as the basis for the search. That would be a perfectly valid way to think about this. And of course, with tuple colors, I'm just gonna pop back here."
          },
          {
            "time": "[00:03:44]",
            "text": "We could search so the result we get, of course is number, number, number. Let's try some other things here. What if we just search for things like a tuple of length 1, we get a never, not found, right? That's what it is in this case. It's like I examined everything, and here's the set I found, developer, it's an empty set, sorry."
          },
          {
            "time": "[00:04:09]",
            "text": "But if we did this, what if it's a wider type, a more general type that still kind of matches what we're looking for. Hey, there we go. Yeah, an array of numbers that is exactly three slots. Sure, I mean, it is an array of numbers. It's a very special array of numbers, it's specific, but we can search for something that is more general."
          },
          {
            "time": "[00:04:38]",
            "text": "In the same way that up here, right, we're searching for any object that has a property red whose value is a number. And we were picking up more than one thing. So you search with something that's more general and the matches will be at that level of specificity, or even more specific, right?"
          },
          {
            "time": "[00:04:59]",
            "text": "We're searching for any number arrays. And if we had, let's say we allowed an alpha channel here, maybe this one might work in a more interesting way. So now we'll get both. We'll get the three place tuple and the four place tuple. Why? They're both different kinds of number arrays."
          },
          {
            "time": "[00:05:17]",
            "text": "So one of the key insights I wanna make sure you walk away with, how to think of this specific versus general. What's this extends keyword all about? And this is really important in terms of making sense of what we're looking at here. Yeah, so in plain language, what this type is all about, we're extracting the subset of favorite colors that is assignable to string."
          },
          {
            "time": "[00:05:43]",
            "text": "That's specifically this thing up here, right, where we're grabbing the subset that is assignable to a type Exclude is the opposite of extract. And it's useful if you can very easily define what you wish to leave behind. So it's the same exact example, I've just changed the word extract to exclude, and here we're saying, show me all."
          },
          {
            "time": "[00:06:16]",
            "text": "Show me everything that doesn't match string. Show me everything that doesn't match string. So we get our array of numbers and we get our object. Those are the non string parts of favorite colors. So, how does it work? Here are the definitions of these two types. This is pulled straight out of the TypeScript source code, and it's very, very similar to what we were working with before."
          },
          {
            "time": "[00:06:47]",
            "text": "So in plain language, here's what's happening. We have a type T, this is a type parameter, and it's what we're operating on. In this case up here, we used favorite colors, right? It's this mixed bag. It's the haystack in which we're searching for a needle. And then we have typed U, U describes what we're searching for."
          },
          {
            "time": "[00:07:12]",
            "text": "So you can think of this almost like we look at all the different parts of type T, especially if it is a union type with this whole operator here. We're gonna look at each piece of it and we're going to see which of those pieces extend from you."
          },
          {
            "time": "[00:07:34]",
            "text": "Which of them match U or are even more specific than U but still match the minimum requirement of U? If this turns out to be true in the exclude case, we leave it out. We leave out whatever matches, otherwise we let it pass through. And this is the only difference between the two."
          },
          {
            "time": "[00:07:58]",
            "text": "It's never colon T versus T colon never. It's just the inverse condition, right? So this is a good example of how you might use conditional types."
          }
        ]
      },
      {
        "sessionTitle": "7-type-q-a.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> First, I'd like to address some questions that I see in chat. So Dimitri asks, would it be correct to say that if I say that generics used are used more often when we write libraries. So Dimitri asks, are generics more appropriate to use in libraries versus app code?"
          },
          {
            "time": "[00:00:25]",
            "text": "I don't really think that it hinges on whether your code is library or app related. For example, I know of many apps that have use of generics in their data layer where they might have some concept of record type. Maybe if they're hitting like a SQL database, they have a primary key that's always ID, and they want some predictable pathway for going to fetch some information using generics and app code."
          },
          {
            "time": "[00:00:58]",
            "text": "In that area it's quite common. I would say the more reusable, the more reusability is a concern, the more you're gonna want to Leverages generics for that purpose. Yeah, libraries tend to get reused quite often. But it's not limited to libraries for sure. Leslie asks, I feel like generics can easily see him so complex because everyone's using random non-expressive letters."
          },
          {
            "time": "[00:01:31]",
            "text": "To represent types, is that considered the standard? There is no standard, I would say it's the norm to use these capital letters starting with T, but that is a leftover remnant from the C++ days. Sort of started in C++ with template classes, and then made its way into generics and Java and C-sharp."
          },
          {
            "time": "[00:01:54]",
            "text": "And now it's sort of this pattern that everyone who's used this concept before in other languages, they're used to doing it that way. I do 100% agree with you though. That, we don't like single letter variable names for values. Why are we cool with single letter names for types?"
          },
          {
            "time": "[00:02:13]",
            "text": "That's a very fair point. The good news is there's nothing that stops you from giving these more meaningful names, although you're going to come across a lot of code that just sort of has these very abstract letters. That make it difficult to sort of read the code, and understand what the intent of the developer was."
          },
          {
            "time": "[00:02:32]",
            "text": "That's a totally fair point."
          },
          {
            "time": "[00:02:32]",
            "text": ">> We see here like we use this extractor type, special type from the library, is this equivalent to the end operator? We use the model at the beginning with the key off date we combined and to extract on it the case on it, is extract basically doing the same thing or is there a difference?"
          },
          {
            "time": "[00:02:55]",
            "text": ">> That is a very, good point. So, there, I'm not sure if there are a 100% the same, but it's true that. The, it's true that the intersection type operator, that end type does accomplish things that are also possible using this syntax, with this arrangement of things. Now, I think you might get some side effects."
          },
          {
            "time": "[00:03:31]",
            "text": "But like in some cases, I'm reluctant to say that it will always work. But that's a very, very good point you bring up. I think, logically it makes a lot of sense. You're trying to get, the portion of one type that also is assignable to another type it would seem that's what we're dealing with."
          },
          {
            "time": "[00:03:54]",
            "text": "I just don't want to unfirmed say, yes they're absolutely the same thing. But they seem like there could be. This obviously you can't do with the end and the or would not give it to you either. Does that make sense?"
          },
          {
            "time": "[00:03:54]",
            "text": ">> Yes."
          },
          {
            "time": "[00:03:54]",
            "text": ">> So this exclude is sort of like the end to end it's useful to have a generic that will do that for you."
          },
          {
            "time": "[00:04:20]",
            "text": "And by the way, you're also going to see that there are things in fact, we're about to talk about the infer keyword. There are things that make it beneficial to use type params and to use a generic for extraction of some subpart of a type from another type."
          },
          {
            "time": "[00:04:45]",
            "text": "So I think you'll see a rationale for why it makes sense to do this shortly."
          }
        ]
      },
      {
        "sessionTitle": "8-inference-with-conditional-types.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> Conditional types have a special tool called the infer keyword, which can be used to extract some sub part of one type from another type. And it's not a coincidence that in the same release of TypeScript where we got conditional types. We also got this infer keyword you might feel, especially once you get used to using infer, you might feel that conditional types are sort of a very weak feature of the language."
          },
          {
            "time": "[00:00:36]",
            "text": "Without this infer keyword, it's almost like this. This is a necessary part of the story and they go hand in hand with conditional types. This infer keyword can only be used within the condition expression of a conditional type it can be used anywhere else in any kind of type expression."
          },
          {
            "time": "[00:00:58]",
            "text": "So, what we're gonna do since it's kind of an abstract concept, we're going to walk through a situation where we find that. The thing infer does for us is conspicuously missing from the language won't go up to a problem that only this new language feature could solve. And that'll help us understand how it ties into the practicalities of what we're trying to build in our In our real world apps."
          },
          {
            "time": "[00:01:28]",
            "text": "So, let's say that we have a class that takes a really complicated options object. And we'll say that it's called WebpackCompiler. And this is actually a subset of the Webpack configuration object. You don't need to remember all this, the whole point of having types is you want autocompletes here, right?"
          },
          {
            "time": "[00:01:48]",
            "text": "Cuz it's very, very flexible, like you can do a lot of different things here. But let's imagine that in the source code that we're consuming, it looks just like this, where we do not have an interface or a type alias that defines this. We only have it explicitly specified as the type of the one argument passed to the constructor, and then let's say in our own code, we want something like this where we define a configuration."
          },
          {
            "time": "[00:02:22]",
            "text": "We attempt to compile and then if something goes wrong, we log an error message out. And the configuration is part of that error message. Maybe this code is run on a machine that we don't have direct access to. And it's important that we be able in logs to see that."
          },
          {
            "time": "[00:02:42]",
            "text": "Like if it's a GitHub action, for example, we want to be able to see in the logs like this was a failure here was the config. I can copy this and I could run it. So I simply mean to convince you that This is something you might actually do, right?"
          },
          {
            "time": "[00:02:57]",
            "text": "And unfortunately, we have a spelling error here. We've said watch instead of wutch, and we get no type checking help with this spelling error. Why? Well, let's look at the type of this configure object. It's not anything that looks connected to the Webpack config. It's just an object that has two properties on it."
          },
          {
            "time": "[00:03:21]",
            "text": "We're just getting straight up inference here, based on the value or we're setting CFG to and we're passing it In the WebpackCompiler and nothing's objecting there why almost everything on this options object is optional, and we have an entry. That'll work. And the other property will just be disregarded."
          },
          {
            "time": "[00:03:46]",
            "text": "So, we want TypeScript to be able to help us out here. But we can't do this right now. Like if there was something else to import, maybe we could import it, we could use a type annotation here, and then it would start to catch our error. But as I said before, in this case, like all we have is, there's this class that I'm using and has a constructor."
          },
          {
            "time": "[00:04:10]",
            "text": "And the first argument of the constructor wants this thing. So we want to basically pull this type out somehow get a handle on it locally in our app code or our library code, we want to be able to give it a name and refer to it and use it as the type for variables."
          },
          {
            "time": "[00:04:29]",
            "text": "As if we just obtained it as an interface. So this is our goal. We want something like that. Something named that we can refer to, we just gotta get a handle on it first. And the infer keyword is what's going to let us do this. So it lets us abstract some piece of a type from a larger type."
          },
          {
            "time": "[00:04:55]",
            "text": "And before we go back to our Webpack example, which is very complicated, just the nature of that type is complicated. I want to work on an example that has the same approximate structure meaning it still is a one argument constructor. And we still want to obtain this thing, but all of the other noises is out and I think that if we solve this problem, we will also solve the same problem in the WebpackCompiler example."
          },
          {
            "time": "[00:05:26]",
            "text": "So we want to design some sort of type that takes fruit stand or some variant of it as a type parameter. And it emits array of strings. Right like, here's a class. Give me the first argument that the compiler or that the constructor receives. So this is actually the answer here and it looks quite complicated."
          },
          {
            "time": "[00:05:53]",
            "text": "We're going to pick it apart. You will understand every little piece of this syntax, but first I want you to accept that it works. So we've got this, this is sort of the answer here. We've got this fruit stand thing. And we've got like constructor Arg we pass in type of FruitStand."
          },
          {
            "time": "[00:06:14]",
            "text": "And what do we get out? The first argument that the constructor takes. Here's our WebpackCompiler example. We pass in type of that, and we get out. That's the type that we wanted this whole time. We wanted to sort of, grab that first argument, give it a name and we could Give this a name like this with the type alias, we could call it WebpackCompiler options if we want to."
          },
          {
            "time": "[00:06:39]",
            "text": "So this appears to work, it does work. Let's pick apart what all this stuff means here. So first we're just gonna build it up piece by piece. First we have a type alias and we're calling it constructor Arg. It takes a single type parameter, which we're calling C."
          },
          {
            "time": "[00:07:02]",
            "text": "It's gonna be C for class. Next, we want to create a conditional type and, we're gonna be analyzing the static side of a class, which is that's why up here, we're using type of right. That's to get the type of the class, not a type of the instance."
          },
          {
            "time": "[00:07:27]",
            "text": "And we want, To match that against something like this, right, this again is our any constructor type, right? This is this represents anything in JavaScript that is newable regardless of how many arguments it may take, regardless of what it instantiates. If you want to know more specific newable."
          },
          {
            "time": "[00:07:50]",
            "text": "You might put something over here, like any constructor that makes dates. Well, that's gonna be the date constructor. So, we started with this. So all we've added is the condition portion of what will become a conditional type. So this is we've already learned about this right we have our type puram."
          },
          {
            "time": "[00:08:11]",
            "text": "We're testing whether the type that C represents is included in the set that this represents. So is C in the set of all things that are newable. Now, we're about to make a little change that will make this a more specific type. But we want to collect that first constructor argument that this is where the infer keyword enters into the story."
          },
          {
            "time": "[00:08:36]",
            "text": "So we're going to change from accepting any arbitrary list of arguments to accepting a first argument which must be there and we're adding something here it looks like it's a new type parameter kind of, it doesn't it's not going to end up having to be part of our type parameter list."
          },
          {
            "time": "[00:08:57]",
            "text": "But typically we still use title case for this, right? And infer is to the left of it. So you can think of this almost like it's like a vacuum the end of a vacuum, right? We're gonna suck up whatever's here and call it A and after a we're prepared to have zero or more other arguments."
          },
          {
            "time": "[00:09:22]",
            "text": "We don't really care about those. But to maintain the flexibility of this thing that we're building will tolerate other arguments. You don't have to give us exactly a one argument instructor. Are our constructor we just want the first argument of any constructor. Now, the more keen eyed of you may notice, this is actually we've made this type more specific."
          },
          {
            "time": "[00:09:47]",
            "text": "So if we let me get both of these on the screen here, this type matches any newable, including zero argument constructors. This, you're gonna have to have one argument, right? This has to be present. I'm okay with that in this situation because the whole point is we're trying to obtain that."
          },
          {
            "time": "[00:10:09]",
            "text": "So if it sort of Nevers out, right, it sort of grounds out in the case where we use it with zero argument constructors like. I would say that it's a sign of misuse anyway, and that would be a reasonable result. There was nothing to obtain, so never. Right."
          },
          {
            "time": "[00:10:27]",
            "text": "So this is our condition here and now all that's left is for us to fill in what are we emit? What type do we evaluate out to if the condition It's true. And what do we evaluate out to if it's false. So in the case where our condition evaluates to true, we're able to use this type A, just as if it were a type parameter."
          },
          {
            "time": "[00:10:55]",
            "text": "So you can think of this kind of like it's in scope, right? You could use a here or you could use it here. But it's not just a placeholder like a label just so we can give this thing a name. So when people read our code, they can understand what's going on."
          },
          {
            "time": "[00:11:11]",
            "text": "We suck this up with our vacuum, and we can put it out here. Right? So we're saying if C, is a newable. Suck up that first argument that's passed to the constructor and give me its type. Now we need to put something here. And a good way to think about how we handle the other case, right the case where we turn up with nothing."
          },
          {
            "time": "[00:11:41]",
            "text": "We want to make sure that if we use this with a union type, with the or type It kind of disappears. And what I mean by that is whatever type we end up with here, right? Like if we evaluate out to this case, let's say that's x. I want wanna make sure that when we we evaluate an expression like this, we end up with just a string or number it kinda just, it's like multiplying by one, like just an identity thing where it's sort of like vanishes."
          },
          {
            "time": "[00:12:13]",
            "text": "That'll ensure that we're not adding noise whenever this type sort of plays with other types. So we can try that with any and look what happens when we do union any it swallows everything. Union any always swallows everything. The way I think about this, it's like if you send your friend to go to the grocery store."
          },
          {
            "time": "[00:12:43]",
            "text": "You're saying pick up three organic eggs, and 25 grams of some spice. And also get me everything in the store please. Well, you could have just led with that right? You could have just said, give me everything in the store. That's why this swallows everything. It's kind of like multiplying by zero in some way, in that if this is found in a union type, if you ever see this, it just makes the whole rest of the union type pointless because it's just going to evaluate out to any."
          },
          {
            "time": "[00:13:21]",
            "text": "So not only is this the wrong answer, this is not what we desire. It's like the exact opposite of what we desire. We want something that disappears, not something that dominates over and kind of takes over. The whole type. So if this gives us the exact opposite of what we're looking for, it makes sense to me to try the opposite of any, right?"
          },
          {
            "time": "[00:13:43]",
            "text": "So we're going to try this with never, and we in fact do get what we want. So when you're making these conditional types, in the case where something didn't match and you kind of just want to like escape out let's just like forget about it. Often you're just gonna want to admit and never type."
          },
          {
            "time": "[00:14:01]",
            "text": "Because that well, when used in a union type like this it will just disappear. No noise, so let's apply that to our constructor, our extractor, and we can see this is the answer. This is what we ended up with. So just again, to recap, it's a generic type that takes a type parameter C, we look at sea and we see If it's a newable, and if that newable takes at least one argument, we have a match."
          },
          {
            "time": "[00:14:42]",
            "text": "And in the event that we have a match, we're going to use our infer keyword which is like a vacuum. We're gonna suck up whatever's in that first argument, and we're going to put it in a box called A. And then, in the event that we had a match, we will always enter this branch."
          },
          {
            "time": "[00:15:03]",
            "text": "So you're always going to enter this branch, which is why you're gonna wanna use eight here. Often down here, you could put another ternary operator, you could chain these together. And you could say, well if it's a one argument constructor, we do this. Maybe if it's a two argument constructor, we build a tuple with the two things."
          },
          {
            "time": "[00:15:23]",
            "text": "You can sort of chain these together. It's normal by the way to see this chaining because, unlike in the value based JavaScript world, there is no more verbose and explicit equivalent to the ternary operator. We can't like expand this out into if then else. I know that some people don't like nested ternary is for that reason."
          },
          {
            "time": "[00:15:44]",
            "text": "So finally let's look at at the result here. So no matter what we use this type with, we can see that we get the result we're looking for. We get the first argument the constructor takes. So you can create a new date like literally new date. You can pass it a string, a date as a string, a number, which is like milliseconds since the epoch."
          },
          {
            "time": "[00:16:12]",
            "text": "And then you could create a date from another date here is the resolve and reject. you're used to seeing in a promise constructor. Here's our Webpack config. So now we have this ability to using infer, to suck up a part of a type and to obtain it and to create maybe a local reference to it in some way, taking this all the way to the finish line."
          },
          {
            "time": "[00:16:39]",
            "text": "If we go back to our first example, our motivating use case where we had the spelling error, and instead of just creating this object with inference taking care of the typing, we add this here we give it an explicit type annotation. As we've done right up here, we can see that not only do we get an error where we hoped we would get an error."
          },
          {
            "time": "[00:17:06]",
            "text": "TypeScript is found that there is a watch property and the word we used is pretty close to watch. So maybe it's a spelling error. Even guessing that it might be just a spelling mistake. So there you go. This is a great use of the infer keyword. And I use it all the time for this exact use case."
          },
          {
            "time": "[00:17:33]",
            "text": "Where I'm consuming some code and I wish I could obtain this type maybe because just for logging reasons or something, I want to like create the things that I'm passing into the function. First, log that out and then pass it in. And this is a great way even if those entities those types are not available for direct import by whoever made the library."
          },
          {
            "time": "[00:17:58]",
            "text": "That doesn't hold you back, you can still do this. So, be caution that I want to give you is in a very large app, be careful that you don't do this too too much, because it's not simple for the type checker to evaluate. And if you end up with with too much of this kind of behavior here too many conditional types, too much infer you can end up slowing down your the speed of your type of heads."
          },
          {
            "time": "[00:18:34]",
            "text": "Now that's not I would say only worried about this if you start experiencing that problem. It's not the kind of thing where, you want to make sure you avoid the problem so that you don't get out of control in the first place. Really, if you're looking to improve your performance, just make sure If you're not making like overusing this this feature of the language."
          },
          {
            "time": "[00:18:57]",
            "text": "But totally fair to use totally, the only tool for the job in many cases."
          }
        ]
      },
      {
        "sessionTitle": "9-inference-q-a.txt",
        "timeFrames": [
          {
            "time": "[00:00:00]",
            "text": ">> So Frank asks, this was a few minutes ago. So we made this type ConstructorArg, right, that was kind of what we ended up with, this was the last thing that we worked on in the previous chapter. Does the TypeScript team plan to make this a standard type, it seems pretty useful, same with JSON value in the last workshop."
          },
          {
            "time": "[00:00:26]",
            "text": "Yeah, this is a good point, and what I will say is that the bar is pretty high for including something in TypeScript itself. So we have, for example, Extract and Exclude, these are core types that are already in TypeScript. What I will say is there's nothing stopping you from writing your own types as a little library and importing that in the projects that you care about."
          },
          {
            "time": "[00:00:57]",
            "text": "For example, if I go to github.com/mike-north, how do I spell my name again? [LAUGH] Mike-north/types, you can see I have a little git repo here that is types, interfaces, and classes that I often use. And look, there's ConstructorArgs, so I bring this package into a variety of things that I work on."
          },
          {
            "time": "[00:01:26]",
            "text": "And some of these have made it into the language already, like at the time I wrote this library there was no required and there was no make everything optional, but I made my own. And as a result they're still here and that's fine, I'm not under pressure to get rid of these because these don't add to asset size, right, they just compile straight out, it's an identical type to what they have built."
          },
          {
            "time": "[00:01:57]",
            "text": "If we click that you can see that, well, we'll look more into this but It's just type information in a little JavaScript library. And if you would look at what happens with this kind of library when it's all bundled up, with one tiny exception here, so I create something called a deferred which is actually a class, right, so this isn't purely type information, a lot of this library is, right."
          },
          {
            "time": "[00:02:22]",
            "text": "But here, this is kinda like an inverted promise where whoever is holding the promise, they get to call resolve or reject from the outside, so it's gonna add a tiny little bit of asset size but nothing to be concerned about. So that's how I would answer this question, as you find things that are useful package them up and make them into little libraries that you can consume."
          },
          {
            "time": "[00:02:52]",
            "text": "I have one called JSON-typescript, and if we look at what this library contains it's very, very similar to what we built in the fundamentals class, right, this is an old school way that involves types and interfaces so this is compatible with TypeScript 2.8 even. I'm doing the same thing that we did in the fundamentals class, so all I have to do is install this package in a project and I can import stuff from it just as if it were a little library."
          },
          {
            "time": "[00:03:22]",
            "text": "If you wanna know how to set these kinds of libraries up robustly, and by that I mean if we look at this mike-north/types thing and the CI pipeline I have going here, I believe I'm testing against multiple nodes, like multiple versions of Node JS and multiple versions of the TypeScript compiler."
          },
          {
            "time": "[00:03:44]",
            "text": "And this means that as new dependencies are added, if you have dependencies here you're making sure that everything still continues to work in a very complete way. So this would be like I would be flattered and proud if you were to copy the infrastructure here and to use this for your own types, right, you just take everything in this source folder and modify it or add to it as you see fit."
          },
          {
            "time": "[00:04:12]",
            "text": "And feel free to open pull requests into mine if you think mine's useful and you wanna build on that instead, but this is sort of my own little mini standard library if you will. So we have three things ahead of us. Two more chapters in the website, and then I'm going to try to put everything kind of together in accomplishing a non-trivial task in the TypeScript playground, and that's gonna be building a little mini data layer."
          },
          {
            "time": "[00:04:40]",
            "text": "Because when we have different types of records, we have a lot of well structured type information and it's a place where we can take advantage of some of the things we've learned for high code reuse. So that's what we have ahead of us."
          }
        ]
      }
    ]
  }
]